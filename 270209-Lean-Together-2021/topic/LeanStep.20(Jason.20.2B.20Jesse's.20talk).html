---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/index.html">Lean Together 2021</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html">LeanStep (Jason + Jesse's talk)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221753066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221753066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221753066">(Jan 06 2021 at 10:37)</a>:</h4>
<p>This stuff is amazing. Jesse showed me a <code>gpt</code>-generated proof of a lemma in the Witt vector project. It's not extremely deep, but it's certainly not a <code>refl</code> lemma either. I'm impressed.</p>
<p>One challenge for ATP's (I think Brian Conrad said this at some point) is: can they prove <code>infinitude_of_primes</code> without human input.<br>
How does <code>gpt</code> fair on that one? You have this tricky step where you have to cook up a prime number that is sufficiently big, and you basically have to come up with the <code>n! + 1</code> trick out of thin air. Does it go anywhere?</p>
<p>And if you give it the <code>p := min_fac (n! + 1)</code>. Can it take it from there?</p>



<a name="221758101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221758101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221758101">(Jan 06 2021 at 11:42)</a>:</h4>
<p>With the data it was trained on it is highly unlikely, even with a lot of search I think. But eventually, the hope is that as we build up <em>a lot</em> of synthetic data by sampling proofs (with a fair amount of search) and training on that signal, the model will get a chance to build such intuitions. It also obviously depends on the type of statements we use for that.</p>



<a name="221758180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221758180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221758180">(Jan 06 2021 at 11:43)</a>:</h4>
<p>In the meantime, also I think there's a ton of value in having a system that can assist humans in a productive way, and what we have today is not far from it. If you really only have to provide these insights to formalize <code>infinitude_of_primes</code>, then it's probably going to make working with Lean much easier for a whole lot of people?</p>



<a name="221758734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221758734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221758734">(Jan 06 2021 at 11:50)</a>:</h4>
<p>Right, I think the more useful metric for the short term is not really "how many top-level theorems does <code>gpt</code> prove" but more like how much shorter can proofs become if you try to prove every goal using <code>gpt</code> (especially the goals created by <code>have</code>s, or side conditions to lemmas for <code>rw</code>, or <code>calc</code> steps, etc.)</p>



<a name="221759243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221759243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221759243">(Jan 06 2021 at 11:57)</a>:</h4>
<p>Sure, I definitely think that this can be very useful before we get <code>infinitude_of_primes_without_human_input</code>.</p>



<a name="221759272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221759272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221759272">(Jan 06 2021 at 11:57)</a>:</h4>
<p>But I also think it's a nice benchmark. It will certainly turn some heads.</p>



<a name="221759429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221759429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221759429">(Jan 06 2021 at 11:59)</a>:</h4>
<p>Agreed <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="221762239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221762239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> matt rice <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221762239">(Jan 06 2021 at 12:38)</a>:</h4>
<p>when we say shorter proofs here, I took this to mean actual length of the text of the proof, and not e.g. size of the terms evaluated, correct?</p>



<a name="221770431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221770431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221770431">(Jan 06 2021 at 14:08)</a>:</h4>
<p>To put infinitude of primes in context, I think that theorem would have gotten Euclid (or whoever actually came up with it) the Fields medal of the time.  Until that point (in my revisionist history) the way one proves that a set is infinite is to find a generator for the set.  This instead is a proof where one shows that if there is a last element then a contradiction happens if you pick a very creative number.  The thing that is going to be hardest to teach AI is to come up with creative solutions to problems.  It might figure out (or have built in) proof-by-contradiction and that if a set isn't infinite then there is a finite set of numbers that whose product is a number.  But to know that it needs to take that product and subtract one.  That is human reasoning at its finest.  (Also, most humans mathematicians are taught that proof, so it is unclear how many of them would be able to come up with it on their own.)</p>



<a name="221770604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221770604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221770604">(Jan 06 2021 at 14:10)</a>:</h4>
<p>I very much agree with your final observation. <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span></p>



<a name="221796119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221796119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221796119">(Jan 06 2021 at 17:29)</a>:</h4>
<p>The problem of course is that mathematicians are taught it and they think it's brilliant but 5 years later they think it's trivial and have forgotten the brilliance of the idea; by that point it seems difficult to persuade them that actually is difficult.</p>



<a name="221971207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221971207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221971207">(Jan 07 2021 at 17:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> During Jason's talk, you asked about how <code>gpt</code> performs on <code>analysis</code> proofs --- indeed, analysis was the largest module (23K LOC) with the largest disparity in favor of the Transformer models from our evaluation. Here are the <code>analysis</code> proofs it found. We get some repeated tactic applications because the model is not conditioned on the previous tactic states, only the current one, but many of the proofs are nontrivial and diverge from their <code>mathlib</code> counterparts. </p>
<p><a href="/user_uploads/3121/a_x3XSKBLrunFzbAfmo2mLEZ/gpt_analysis.txt">gpt_analysis.txt</a> </p>
<p>some samples:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">norm_le_zero_iff</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">},</span> <span class="bp">‚à•</span><span class="n">g</span><span class="bp">‚à•</span> <span class="bp">‚â§</span> <span class="mi">0</span> <span class="bp">‚Üî</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">intros</span><span class="o">,</span>
   <span class="n">simpa</span> <span class="o">[</span><span class="n">le_antisymm_iff</span><span class="o">,</span> <span class="n">norm_nonneg</span><span class="o">]</span> <span class="n">using</span> <span class="bp">@</span><span class="n">norm_eq_zero</span> <span class="n">Œ±</span> <span class="n">_</span> <span class="n">g</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">asymptotics.is_O_with.add</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">}</span> <span class="o">{</span><span class="n">E'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_6</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">has_norm</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_4</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">E'</span><span class="o">]</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Œ±</span><span class="o">}</span> <span class="o">{</span><span class="n">c‚ÇÅ</span> <span class="n">c‚ÇÇ</span> <span class="o">:</span> <span class="n">‚Ñù</span><span class="o">}</span> <span class="o">{</span><span class="n">f‚ÇÅ</span> <span class="n">f‚ÇÇ</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">E'</span><span class="o">},</span> <span class="n">is_O_with</span> <span class="n">c‚ÇÅ</span> <span class="n">f‚ÇÅ</span> <span class="n">g</span> <span class="n">l</span> <span class="bp">‚Üí</span> <span class="n">is_O_with</span> <span class="n">c‚ÇÇ</span> <span class="n">f‚ÇÇ</span> <span class="n">g</span> <span class="n">l</span> <span class="bp">‚Üí</span> <span class="n">is_O_with</span> <span class="o">(</span><span class="n">c‚ÇÅ</span> <span class="bp">+</span> <span class="n">c‚ÇÇ</span><span class="o">)</span> <span class="o">(</span><span class="bp">Œª</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">),</span> <span class="n">f‚ÇÅ</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f‚ÇÇ</span> <span class="n">x</span><span class="o">)</span> <span class="n">g</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">intros</span><span class="o">,</span>
   <span class="n">filter_upwards</span> <span class="o">[</span><span class="n">h‚ÇÅ</span><span class="o">,</span> <span class="n">h‚ÇÇ</span><span class="o">],</span>
   <span class="n">intros</span> <span class="n">x</span> <span class="n">hx‚ÇÅ</span> <span class="n">hx‚ÇÇ</span><span class="o">,</span>
   <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">norm_add_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
   <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">add_le_add</span> <span class="n">hx‚ÇÅ</span> <span class="n">hx‚ÇÇ</span><span class="o">),</span>
   <span class="n">rw</span> <span class="n">add_mul</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">differentiable_on_const_add_iff</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="bp">ùïú</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">nondiscrete_normed_field</span> <span class="bp">ùïú</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="bp">ùïú</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_4</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_5</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="bp">ùïú</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">‚Üí</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="n">differentiable_on</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">Œª</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="n">s</span> <span class="bp">‚Üî</span> <span class="n">differentiable_on</span> <span class="bp">ùïú</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
   <span class="n">intros</span> <span class="n">E</span> <span class="n">unique_diff_on_univ</span><span class="o">,</span>
   <span class="n">intros</span><span class="o">,</span>
   <span class="n">simp</span> <span class="o">[</span><span class="n">differentiable_on</span><span class="o">,</span> <span class="n">differentiable_within_at_univ</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221972620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221972620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221972620">(Jan 07 2021 at 17:28)</a>:</h4>
<p>Fun observation: in the first example above, it used <code>@norm_eq_zero</code> with the correct number of arguments (and even the "dreadful <code>@ _</code> idiom"), but the string <code>@norm_eq_zero</code> never appears in <code>mathlib</code> (commit <code>33483a3d</code>).</p>



<a name="221975770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221975770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221975770">(Jan 07 2021 at 17:49)</a>:</h4>
<p>Thanks for this information! I am excited about the potential for gpt for interactive use. I know when/how to use intro and cases, so, for me, the real win is when we have a tool that suggests theorems and rewrite rules. So here are some useful queries for the model:</p>
<ul>
<li>If I were to use simp or rw right now, what additional rewrite rules do you think I should add?</li>
<li>If I were to use apply or refine or exact within the next three or four steps, what is your best guess as to the theorem I would use?</li>
</ul>



<a name="221975946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221975946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221975946">(Jan 07 2021 at 17:50)</a>:</h4>
<p>Yes, this is was also my remark during the talk.</p>



<a name="221976425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221976425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221976425">(Jan 07 2021 at 17:54)</a>:</h4>
<p>I guess another useful query:</p>
<ul>
<li>If I were to use <code>cases</code> or <code>rcases</code> on something other than a hypothesis, what would it be?</li>
</ul>



<a name="221978483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221978483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221978483">(Jan 07 2021 at 18:07)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>. Anything that can be prompted by a prefix of the full completion will work as expected. So as an example we can create a specialized tactic <code>gptf-rw</code> that will "force" the use of <code>rw</code> as a tactic and the model will gadly complete the steps. For <code>cases</code> or <code>rcases</code> we can do the same. There is no trivial way to specify (do not use the hypotheses) but we can query the model and filter out the response to achieve that goal.</p>



<a name="221978501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221978501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221978501">(Jan 07 2021 at 18:07)</a>:</h4>
<p>Does that make sense?</p>



<a name="221978611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221978611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221978611">(Jan 07 2021 at 18:08)</a>:</h4>
<p>This is great feedback (thanks <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> and <span class="user-mention" data-user-id="110031">@Patrick Massot</span>) we commit to working on exactly that in the coming weeks and will circle back once we have something working.</p>



<a name="221978687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221978687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221978687">(Jan 07 2021 at 18:09)</a>:</h4>
<p>The main blocker right now is one commit to the lean repository, after that we'll be able to share the system with a broader set of people very easily cc <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span></p>



<a name="221979155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221979155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221979155">(Jan 07 2021 at 18:12)</a>:</h4>
<p>is there a PR you're referring to?</p>



<a name="221979296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221979296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221979296">(Jan 07 2021 at 18:13)</a>:</h4>
<p>Yes, Jesse's lean-tpe branch here: <a href="https://github.com/jesse-michael-han/lean/tree/lean-tpe">https://github.com/jesse-michael-han/lean/tree/lean-tpe</a></p>



<a name="221979321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/221979321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#221979321">(Jan 07 2021 at 18:13)</a>:</h4>
<p>But it needs clean-up I believe :)</p>



<a name="222087717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222087717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222087717">(Jan 08 2021 at 15:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/270209-Lean-Together.202021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk)/near/221979155">said</a>:</p>
<blockquote>
<p>is there a PR you're referring to?</p>
</blockquote>
<p>all the changes have been incorporated into <a href="https://github.com/leanprover-community/lean/pull/510">this PR</a> by <span class="user-mention" data-user-id="121918">@Edward Ayers</span></p>



<a name="222184727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222184727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222184727">(Jan 09 2021 at 19:12)</a>:</h4>
<p>Was late in watching this talk. Am I right in saying that the gpt tactic is just producing a string and doesn't by design know how to produce a string that is syntactically correct, so if it does produce meaningful strings it's because it "learnt" to do that and not because it's been programmed to do so?</p>



<a name="222185142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222185142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222185142">(Jan 09 2021 at 19:22)</a>:</h4>
<p>Yes that is correct.  It ‚Äúlearnt‚Äù in the sense of machine learning what a valid tactic string looks like. It uses a string-to-string machine learning algorithm called a Transformer that is often used for natural language where there is no formal grammar.</p>



<a name="222185372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222185372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222185372">(Jan 09 2021 at 19:28)</a>:</h4>
<p>If you are curious, both of these threads have some discussion on transformers, including the GPT transformer. <a class="stream-topic" data-stream-id="219941" href="/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Papers.20on.20Neural.20Conjecturing">#Machine Learning for Theorem Proving &gt; Papers on Neural Conjecturing</a> and <a class="stream-topic" data-stream-id="219941" href="/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/GPT-f.20paper">#Machine Learning for Theorem Proving &gt; GPT-f paper</a>.</p>



<a name="222269108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222269108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222269108">(Jan 11 2021 at 08:15)</a>:</h4>
<p>in a very fuzzy nonrigorous way, I suspect that a lot of the "power" of the gpt is spent on learning the lean syntax, and if there were some way to integrate a tree search that knew about valid lean syntax with an AI model doing AI things, it would be more effective</p>



<a name="222269131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222269131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222269131">(Jan 11 2021 at 08:15)</a>:</h4>
<p>like you can teach a gpt to play chess but it isn't as good as the monte carlo based ones</p>



<a name="222269823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222269823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222269823">(Jan 11 2021 at 08:24)</a>:</h4>
<p>If you would print chess moves in regular chess notation, one move per line. Is it possible to "measure" how much "power" gpt spends on figuring out the syntax?</p>



<a name="222279277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222279277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> EricGT <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222279277">(Jan 11 2021 at 10:19)</a>:</h4>
<p>FYI - I have not used anything from this site but do keep it on reference for future needs. The site <a href="https://huggingface.co/">https://huggingface.co/</a> is about solving NLP. They have models using GPT. I found one when searching for chess: <a href="https://huggingface.co/shtoshni/gpt2-chess-uci">https://huggingface.co/shtoshni/gpt2-chess-uci</a> . Take all of this with a grain of salt.</p>



<a name="222294692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222294692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222294692">(Jan 11 2021 at 13:11)</a>:</h4>
<p><span class="user-mention" data-user-id="238605">@Kevin Lacker</span> in the current result we don't have any tree-search as explained during the talk. But we're working on adding that which should give an healthy boost. Only the valid tactics would be kept as is the case in the original GPT-f paper. Interestingly, in AlphaGo MCTS was almost exclusively used to train the value function (the policy network was probably not even needed as the "valid" action space in each board state is fairly limited). In formal maths we have the increased difficulty that the action space even limited to "valid" steps is enumerable, so we need a strong enough policy to productively expand each node. But same as is the case for games, lot of the "proving power" will probably come from a trained value function, which does not even exist yet in the Lean setup.</p>



<a name="222294715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222294715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222294715">(Jan 11 2021 at 13:12)</a>:</h4>
<p>All in all, completely agreed with your statement, just wanted to provide a bit of additional context.</p>



<a name="222325583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222325583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222325583">(Jan 11 2021 at 17:02)</a>:</h4>
<p>how would you train a value function? the value is something like, the value for lemma X is an estimate of whether proving lemma X would be helpful in concluding theorem Y?</p>



<a name="222326003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222326003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222326003">(Jan 11 2021 at 17:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/270209-Lean-Together.202021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk)/near/222325583">said</a>:</p>
<blockquote>
<p>how would you train a value function? the value is something like, the value for lemma X is an estimate of whether proving lemma X would be helpful in concluding theorem Y?</p>
</blockquote>
<p><span class="user-mention" data-user-id="238605">@Kevin Lacker</span> You should check out the GPT-f paper, or the discussion at <a class="stream-topic" data-stream-id="219941" href="/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/GPT-f.20paper">#Machine Learning for Theorem Proving &gt; GPT-f paper</a>.  But some simple approach (not too different from AlphaGo is to train a binary classifier to say if the model's tree search is able to find a proof at a particular goal state which came up during some sort of iterative training (expert iteration or RL).  (For transformer models you can use tricks for binary classification as done in the GPT-f paper.)</p>



<a name="222326192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222326192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222326192">(Jan 11 2021 at 17:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/270209-Lean-Together.202021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk)/near/222269823">said</a>:</p>
<blockquote>
<p>If you would print chess moves in regular chess notation, one move per line. Is it possible to "measure" how much "power" gpt spends on figuring out the syntax?</p>
</blockquote>
<p>I only tried playing chess against GPT-3, so I don't have any fancy analysis, but "syntax" was probably the wrong thing for me to say. GPT-3 playing chess will almost always say moves that are the correct syntax, but sometimes it will make illegal moves, like it will try to move its pawn from e2 to e4 but it already moved that pawn earlier and it "forgot". I am sure you could make a better one by training solely on chess games but imo this sort of failure hints that the GPT architecture is doing some work to detect legal moves that could just be done by hard-coding them</p>



<a name="222326874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222326874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222326874">(Jan 11 2021 at 17:11)</a>:</h4>
<p>Thanks for the anecdote</p>



<a name="222328673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222328673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222328673">(Jan 11 2021 at 17:24)</a>:</h4>
<p>As for the syntax discussion, my thinking on this has evolved over time.  It is certainly true that a model could be given what is called an "inductive bias" forcing it to give correct syntax.  The HOList models have a stronger inductive bias for example.  Also, even with transformer models there are ways to supply tree position encodings rather than text position encoding However there are some considerations:</p>
<ol>
<li>It is a lot easier to use a text model like a transformer, since one doesn't have to engineering what formal syntax looks like.  For example, if our tool we presented last week used the HOList technology, it would be a lot more engineering to make a DSL for tactics (and even more so for Lean since Lean needs term and name parameters way more than HOL Light tactics, and HOList doesn't handle those well).</li>
<li>There is an economy of scale thing going on.  OpenAI and other companies (like HuggingFace) have a lot of infrastructure around pertained text models since (1) they are easy to pre-train (you basically dump a large part of the internet into the model) and (2) they are extremely flexible.  This makes it easy to create a new model for some esoteric purpose like theorem proving or symbolic mathematics.  Someone could take time to gather lots of tree structured data for a tree position transformer, but this would take a lot of curation work.  (Also, it would be a lot of work to parse lean text into a syntax tree, especially with Lean's change-as-you-go parser.)</li>
<li>It provides flexibility.  We are not using low level formal lean syntax, but high level pretty printed and human written syntax.  This is shorter and easier to fit into our model.  This is easy with a text transformer since it doesn't need to know the exact syntax used.</li>
<li>Transformers can also learn unspoken syntax rules, such as good variable names and common ways to write code.  The output looks more human like than if it just outputted an AST.</li>
</ol>



<a name="222328910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222328910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222328910">(Jan 11 2021 at 17:26)</a>:</h4>
<p>As for chess, note, this sort of unbiased approach is also used for chess with MuZero.  (They use conv nets instead of transformers, but the idea is similar.)  One doesn't need to program in the rules of chess to the model.  Instead the model observes human games enough to learn the action space, and then improves its understanding via RL.  It is interesting that illegal moves and really dumb moves basically look the same to the model.  I think in that paper, they argue this even helps learning in the long run.</p>



<a name="222329316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222329316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222329316">(Jan 11 2021 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/270209-Lean-Together.202021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk)/near/222269108">said</a>:</p>
<blockquote>
<p>in a very fuzzy nonrigorous way, I suspect that a lot of the "power" of the gpt is spent on learning the lean syntax, and if there were some way to integrate a tree search that knew about valid lean syntax with an AI model doing AI things, it would be more effective</p>
</blockquote>
<p>It's well known that transformers will tend to produce syntactically correct outputs if trained sufficiently, to the point that structured decoding is not really needed.</p>
<p>When it comes to neural theorem proving using <code>gptf</code>, there are two search procedures: a search for a candidate sequence of tokens by the decoding procedure wrapping the transformer, and a search for candidate proof by the tree search which wraps the decoding procedure wrapping the transformer. The outer search already knows about valid Lean tactics, but the inner search over sequences of tokens does not know about Lean syntax. One can certainly try making this inner search Lean-syntax-aware and having it mask out invalid tokens during decoding. This can improve the predictions returned by the inner search. In practice, however, the model usually predicts valid Lean syntax (interactive tactic invocations in <code>mathlib</code> tend to not have very complicated parse trees) and most failures occur in the outer search, when the tactic execution fails to make progress. Currently, I don't think we would see much benefit from such domain-specific engineering in the decoding process.</p>
<p>If we were to ask much more of the transformer, say predicting entire <em>proof terms</em> instead of tactic steps, then we might see more benefits from structured decoding.</p>



<a name="222795973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222795973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222795973">(Jan 14 2021 at 22:40)</a>:</h4>
<p>MuZero does know about the tree structure of the chess game, though, it isn't just reading in a sequence of chess moves and putting it into a GPT</p>



<a name="222796145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222796145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222796145">(Jan 14 2021 at 22:42)</a>:</h4>
<p>"tree search" isn't quite the right way to describe a theorem prover, though, a set of possible proofs really maps to a DAG rather than the way a set of possible chess games maps to a tree and that seems like a big difference</p>



<a name="222796410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222796410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222796410">(Jan 14 2021 at 22:45)</a>:</h4>
<p>Board games are also DAGs, but tree search is still the term usually used.</p>



<a name="222797054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222797054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222797054">(Jan 14 2021 at 22:51)</a>:</h4>
<p>Lean GPT-f is also not currently outputting more than one tactic at a time, so it isn‚Äôt that different from outputting a chess move.  A complete proof, sequence of tactics comes from a tree search.</p>



<a name="222798359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/LeanStep%20%28Jason%20%2B%20Jesse%27s%20talk%29/near/222798359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/LeanStep.20(Jason.20.2B.20Jesse's.20talk).html#222798359">(Jan 14 2021 at 23:04)</a>:</h4>
<p>But to be clear, there are many differences between Muzero and GPT-f.  The only point I wanted to make is that technically muzero also (like GPT-f) doesn‚Äôt know what a valid move is a priori.  It has to be learned.  (One not small difference also is that muzero is constrained to output 64x64 possible moves (many not valid) while GPT-f can output any text string.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
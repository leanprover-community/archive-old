---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/index.html">Lean Together 2021</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html">Lean 4: An overview (Leo's talk)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221551058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221551058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221551058">(Jan 04 2021 at 17:08)</a>:</h4>
<p>Leo: I tried some of the advent of code exercises in Lean4 and it was very pleasant to program in.  I really like the <code>foo (&lt;- bar)</code> notation.  It eliminates the need for a lot of monadic combinators.</p>



<a name="221551371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221551371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221551371">(Jan 04 2021 at 17:10)</a>:</h4>
<p>Question about persistent data structures: When you compare persistent data structures in C++ and Lean 4, do you use them persistently?</p>



<a name="221587056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221587056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221587056">(Jan 04 2021 at 22:01)</a>:</h4>
<p>i missed the zoom chat about porting mathlib to lean 4. did anyone conclude or plan anything, can someone share a TLDR of the conversation?</p>



<a name="221592600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221592600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221592600">(Jan 04 2021 at 22:56)</a>:</h4>
<p>I didn’t happen on Zoom in the end (I think due to time).</p>



<a name="221593063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221593063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221593063">(Jan 04 2021 at 23:00)</a>:</h4>
<blockquote>
<p>When you compare persistent data structures in C++ and Lean 4, do you use them persistently?</p>
</blockquote>
<p>No. The comparison I was referring to was on a benchmark where the tree was being used linearly.<br>
In benchmarks where persistency matter, the Lean 4 version is several orders of magnitude faster than the C++ std version since we have to keep copying the whole tree in C++.<br>
We believe the Lean and Koka implementations are faster than the C++ version because of two ingredients: "counting immutable beans" paper and mimalloc.</p>



<a name="221599713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221599713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221599713">(Jan 05 2021 at 00:27)</a>:</h4>
<p>Binary trees in the STL are known to be slow right? So Lean 4 being faster on that front isn't really surprising.</p>



<a name="221600457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221600457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221600457">(Jan 05 2021 at 00:36)</a>:</h4>
<p>It was surprising to me and my colleagues. The STL version is performing destructive updates, and our version is pure. Our version is also much faster than Haskell. It was surprising to Simon PJ. He conjectured that we would only be faster when the trees were being updated linearly. However, when we tried nonlinear benchmarks, the Lean version was even faster. <br>
BTW, when we reported our results, many were skeptical and doubted our experimental results were correct. Now, they were reproduced in Koka, this kind of doubt is gone.<br>
The Lean version is also much faster than the persistent red-black tree used in Lean 3 and implemented in C++. I implemented both versions :)</p>



<a name="221620957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221620957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221620957">(Jan 05 2021 at 08:02)</a>:</h4>
<p>To be clear, which C++ STL "tree" container are we comparing to here?</p>



<a name="221625077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221625077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221625077">(Jan 05 2021 at 09:04)</a>:</h4>
<p>set/map/multiset I guess</p>



<a name="221671275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270209-Lean%20Together%202021/topic/Lean%204%3A%20An%20overview%20%28Leo%27s%20talk%29/near/221671275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/270209-Lean-Together-2021/topic/Lean.204.3A.20An.20overview.20(Leo's.20talk).html#221671275">(Jan 05 2021 at 16:56)</a>:</h4>
<p>so if I just have an STL <code>map&lt;string, int&gt;</code> and I insert a million entries into it and do a million random reads, I should expect the equivalent to be faster in Lean 4 than in C++?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/homological.20headache.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html">homological headache</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226393769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226393769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226393769">(Feb 15 2021 at 15:01)</a>:</h4>
<p>Hmm, I can't replicate the solution that worked in the <a href="#narrow/stream/267928-condensed-mathematics/topic/bounded.20exactness/near/225605844">previous example</a>.<br>
Here are two rather minimal examples that explain the problem.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.homology.chain_complex</span>
<span class="kn">import</span> <span class="n">algebra.category.Group</span>
<span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">cochain_complex</span> <span class="n">AddCommGroup</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">section</span>

<span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">int_magic</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="o">(</span><span class="n">assumption</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.interactive.ring1</span> <span class="n">none</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.interactive.refl</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span>
   <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>

<span class="kd">end</span>

<span class="sd">/-- Convenience definition:</span>
<span class="sd">The identity morphism of an object in the system of complexes</span>
<span class="sd">when it is given by different indices that are not</span>
<span class="sd">definitionally equal. -/</span>
<span class="kd">def</span> <span class="n">congr_hom</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C.X</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.X</span> <span class="n">j</span> <span class="o">:=</span>
<span class="n">eq_to_hom</span> <span class="bp">$</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span> <span class="o">}</span>

<span class="sd">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>
<span class="kd">def</span> <span class="n">differential</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C.X</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.X</span> <span class="n">j</span> <span class="o">:=</span>
<span class="n">C.d</span> <span class="n">i</span> <span class="bp">≫</span> <span class="n">congr_hom</span> <span class="n">C</span> <span class="n">hij</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`</span><span class="n">d</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">differential</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">int_magic</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">differential_rfl</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">differential</span> <span class="n">C</span> <span class="n">i</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">rfl</span> <span class="bp">=</span> <span class="n">C.d</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">d_comp_d</span> <span class="o">{</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i₁</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">i₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">i₂</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">i₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₁</span> <span class="bp">⟶</span> <span class="n">C.X</span> <span class="n">i₂</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₂</span> <span class="bp">⟶</span> <span class="n">C.X</span> <span class="n">i₃</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">subst</span> <span class="n">i₃</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">differential_rfl</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">homological_complex.d_squared</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">d_d</span> <span class="o">{</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i₁</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">i₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">i₂</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">i₃</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₁</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">differential</span> <span class="n">C</span> <span class="n">i₂</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">int_magic</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₃</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">show</span> <span class="o">((</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₁</span> <span class="bp">⟶</span> <span class="n">C.X</span> <span class="n">i₂</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i₂</span> <span class="bp">⟶</span> <span class="n">C.X</span> <span class="n">i₃</span><span class="o">))</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">d_comp_d</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
  <span class="c1">-- rw sub_add_cancel at h,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
  <span class="c1">-- rw add_sub_cancel at h,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226394200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226394200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226394200">(Feb 15 2021 at 15:04)</a>:</h4>
<p>I don't care so much about how we invoke automation, as long as it works <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span> </p>
<ol>
<li>The above approach hides an automatic tactic call behind <code>notation `d` </code>. Downside: the notation will not be used in the goal view.</li>
<li>Use <code>auto_param</code>. But this doesn't work with bundled morphisms.</li>
<li>Use <code>fact (i + 1 = j)</code>. I fear that this might not scale when it comes to chaining equalities together using transitivity.</li>
</ol>



<a name="226394237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226394237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226394237">(Feb 15 2021 at 15:05)</a>:</h4>
<p>But the problem outlined above is orthogonal to these 3 approaches.</p>



<a name="226395548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226395548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226395548">(Feb 15 2021 at 15:16)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Have you thought about trying tricks similar to the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">test</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">congr_hom</span> <span class="n">C</span> <span class="o">(</span><span class="kd">by</span> <span class="n">int_magic</span><span class="o">)</span> <span class="n">x</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">cond</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">true</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">,</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">cond</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">cond_w</span><span class="o">,</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226395584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226395584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226395584">(Feb 15 2021 at 15:16)</a>:</h4>
<p>I don't know if this would be helpful at all.</p>



<a name="226395808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226395808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226395808">(Feb 15 2021 at 15:18)</a>:</h4>
<p>I would like to hide <code>congr_hom</code> as much as possible behind a basic API. Otherwise we'll end up with many silly proof steps, saying that the norm of <code>congr_hom x</code> is the same as the norm of <code>x</code>, etc... etc...</p>



<a name="226395893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226395893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226395893">(Feb 15 2021 at 15:19)</a>:</h4>
<p>I imagine we can solve these issues with some carefully chosen simp lemmas</p>



<a name="226396239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226396239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226396239">(Feb 15 2021 at 15:21)</a>:</h4>
<p>You can take a look at <code>system_of_complexes.lean</code> on the <code>wip_dtt</code> branch... it didn't look pleasant to me.</p>



<a name="226399165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226399165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226399165">(Feb 15 2021 at 15:47)</a>:</h4>
<p>There was the other proposal to use a massive direct sum, and define <code>d</code> on that. But I don't see how that will play nicely with either categorical language, where you don't have elements (so how do you define a complex in the first place? as something isomorphic to a massive direct sum?) or with elements (how do you move from <code>x : C i</code> to the massive direct sum? will we have canonical inclusion maps before every other element?).<br>
Still, if someone wants to try a test of this, and it works well, then I'll shut up <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> <span aria-label="speak no evil" class="emoji emoji-1f64a" role="img" title="speak no evil">:speak_no_evil:</span></p>



<a name="226407344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226407344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226407344">(Feb 15 2021 at 16:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
    <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span> <span class="o">},</span> <span class="n">clear</span> <span class="n">hx</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">x</span> <span class="n">rfl</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226407466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226407466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226407466">(Feb 15 2021 at 16:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
    <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span> <span class="o">},</span> <span class="n">clear</span> <span class="n">hx</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">x</span> <span class="n">hij</span> <span class="n">hx</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hij'</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">eq_sub_of_add_eq</span> <span class="n">hij</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">hij'</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226407538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226407538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226407538">(Feb 15 2021 at 16:54)</a>:</h4>
<p>Everything is easy if the hypothesis is stated in the type-theoretically correct way -- there are no fancy tricks here.</p>



<a name="226407628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226407628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226407628">(Feb 15 2021 at 16:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
    <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.X</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
</code></pre></div>
<p>This is great because we're quantifying over <code>i</code> and <code>j</code>, and all our dependent types (<code>C.X i</code> and <code>C.X j</code>) can be specialised to the case in hand.</p>



<a name="226410237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410237">(Feb 15 2021 at 17:21)</a>:</h4>
<p>On the other hand, it means that we'll always be writing <code>(hij : i + 1 = j)</code> all over the place. It would be great if some tactic could remove that need.</p>



<a name="226410517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410517">(Feb 15 2021 at 17:24)</a>:</h4>
<p>I like this solution, it puts the <code>i+1=j</code> proof into a subgoal where it can be proved by any means necessary</p>



<a name="226410747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410747">(Feb 15 2021 at 17:26)</a>:</h4>
<p>Writing nontrivial terms in rigid positions in a dependent type seems to be a recurring source of problems</p>



<a name="226410777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410777">(Feb 15 2021 at 17:26)</a>:</h4>
<p>Crazy idea: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">def</span> <span class="n">complex</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">C</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">⥤</span> <span class="n">AddCommGroup</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">),</span> <span class="n">C.map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">}</span>
</code></pre></div>



<a name="226410837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410837">(Feb 15 2021 at 17:27)</a>:</h4>
<p>It'll be fun explaining that to the normal people</p>



<a name="226410960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410960">(Feb 15 2021 at 17:28)</a>:</h4>
<p>I guess that is of no relevance -- my students don't yet know what the actual definition of <code>is_compact</code> is and yet they can still prove things by finding finite subcovers of open covers</p>



<a name="226410968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410968">(Feb 15 2021 at 17:28)</a>:</h4>
<p>What's it supposed to look like? That seems like a pretty normal definition</p>



<a name="226410999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226410999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226410999">(Feb 15 2021 at 17:28)</a>:</h4>
<p>d^2=0</p>



<a name="226411058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226411058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226411058">(Feb 15 2021 at 17:29)</a>:</h4>
<p>I mean, like that exact string of characters. It's like a set phrase.</p>



<a name="226411102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226411102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226411102">(Feb 15 2021 at 17:29)</a>:</h4>
<p>aha, I see now, I like this crazy idea</p>



<a name="226411315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226411315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226411315">(Feb 15 2021 at 17:31)</a>:</h4>
<p>I have no idea how to search for d^2=0 on mathoverflow but I am convinced it will be everywhere.</p>



<a name="226411341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226411341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226411341">(Feb 15 2021 at 17:31)</a>:</h4>
<p>I wonder how common it is to have this whole functor available instead of d</p>



<a name="226411511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226411511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226411511">(Feb 15 2021 at 17:32)</a>:</h4>
<p>It's the fact that mathematicians constantly abuse this d notation to mean "all the maps" which makes me open to the idea of the direct sum approach, where one really does have one map d, from the direct sum (or disjoint union, depending on which category you're taking the coproduct in).</p>



<a name="226414266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226414266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226414266">(Feb 15 2021 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226411315">said</a>:</p>
<blockquote>
<p>I have no idea how to search for d^2=0 on mathoverflow but I am convinced it will be everywhere.</p>
</blockquote>
<p>Not MO but <a href="https://approach0.xyz/search/?q=%24d%5E2%3D0%24&amp;p=1">https://approach0.xyz/search/?q=%24d%5E2%3D0%24&amp;p=1</a></p>



<a name="226416217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416217">(Feb 15 2021 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226411511">said</a>:</p>
<blockquote>
<p>It's the fact that mathematicians constantly abuse this d notation to mean "all the maps" which makes me open to the idea of the direct sum approach, where one really does have one map d, from the direct sum (or disjoint union, depending on which category you're taking the coproduct in).</p>
</blockquote>
<p>But I don't see how to write this down in lean, in such a way that you can do complexes of objects in an arbitrary (abelian) category, and at the same time make is useful when trying to apply <code>d</code> to elements of a module in some concrete complex.</p>



<a name="226416252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416252">(Feb 15 2021 at 18:18)</a>:</h4>
<p>How do you express that the big complex-object is the direct sum of the constituent objects?</p>



<a name="226416289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416289">(Feb 15 2021 at 18:19)</a>:</h4>
<p>Given any suitable definition of the <code>d</code> function, it's possible to construct a functor like <span class="user-mention silent" data-user-id="243562">Adam Topaz</span> 's version, and as long as you don't need to reduce it you can just work from that</p>



<a name="226416367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416367">(Feb 15 2021 at 18:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226410777">said</a>:</p>
<blockquote>
<p>Crazy idea: </p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">def</span> <span class="n">complex</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">C</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">⥤</span> <span class="n">AddCommGroup</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">),</span> <span class="n">C.map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Would this solve the issue that we have in the example from the first post? Of does this just mean that we should never ever talk about <code>d</code>, and always use <code>hom_of_le</code> instead? Doesn't sound like it will be very readable... <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="226416422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416422">(Feb 15 2021 at 18:21)</a>:</h4>
<p>I think you can wrap that behind a definition of type <code>\all i j : int, C i -&gt; C j</code></p>



<a name="226416529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416529">(Feb 15 2021 at 18:22)</a>:</h4>
<p>Such a map only exists for i&lt;=j, right? The situation is C i -&gt; C (i + 1) -&gt; C (i + 2) -&gt; ...</p>



<a name="226416532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416532">(Feb 15 2021 at 18:22)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I'm playing with this idea now. And the answer seems to be no, still getting the same issue :-/</p>



<a name="226416556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416556">(Feb 15 2021 at 18:22)</a>:</h4>
<p>ah yeah, it would be <code>\all i j, i &lt;= j -&gt; C i -&gt; C j</code></p>



<a name="226416601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416601">(Feb 15 2021 at 18:23)</a>:</h4>
<p>and I guess the last arrow is a hom of some kind</p>



<a name="226416616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416616">(Feb 15 2021 at 18:23)</a>:</h4>
<p>I guess the category of finite abelian groups is a perfectly good abelian category which doesn't have infinite direct sums.</p>



<a name="226416688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416688">(Feb 15 2021 at 18:24)</a>:</h4>
<p>Is it possible / desirable to totalize here? C j is an abelian group so you've got the zero morphism</p>



<a name="226416713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416713">(Feb 15 2021 at 18:24)</a>:</h4>
<p>yeah, there are zero morphisms in an arbitrary abelian category too</p>



<a name="226416930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226416930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226416930">(Feb 15 2021 at 18:28)</a>:</h4>
<p>leading to the less well known identity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d^{-1}=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>



<a name="226417340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417340">(Feb 15 2021 at 18:32)</a>:</h4>
<p>But even if you totalize... does this mean we should just put type ascriptions every where? And give up on the idea that <code>d</code> is a degree 1 map?</p>



<a name="226417420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417420">(Feb 15 2021 at 18:33)</a>:</h4>
<p>So you have <code>d : C i -&gt; C j</code> for all <code>i</code> and <code>j</code>. And</p>
<ol>
<li>if <code>j = i</code>, then <code>d = id</code></li>
<li>if <code>j = i</code>, then <code>d = </code> "the <em>actual</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>"</li>
<li>otherwise, <code>d = 0</code></li>
</ol>



<a name="226417552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417552">(Feb 15 2021 at 18:35)</a>:</h4>
<p><del>And so there will be a simp lemma that says that <code>d</code> composed with <code>d</code> is <code>d</code></del> (This is false, the right hand side could be <code>id</code> while the left hand side is <code>d &gt;&gt; 0</code>). And</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">d_eq_zero</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">\</span><span class="n">le</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C</span> <span class="n">i</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="226417649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417649">(Feb 15 2021 at 18:36)</a>:</h4>
<p>I was just hoping that lean would be able to infer the type of <code>d x</code> from the type of <code>x</code>... but I guess that's asking for lots of pain, at least in lean3.</p>



<a name="226417688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417688">(Feb 15 2021 at 18:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.homology.chain_complex</span>
<span class="kn">import</span> <span class="n">algebra.category.Group</span>

<span class="kn">open</span> <span class="n">category_theory</span> <span class="n">AddCommGroup.colimits</span>

<span class="kd">def</span> <span class="n">mk_graded</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">AddCommGroup</span><span class="o">)</span> <span class="o">:</span> <span class="n">AddCommGroup</span> <span class="o">:=</span> <span class="n">AddCommGroup.colimits.colimit</span> <span class="o">(</span><span class="n">discrete.functor</span> <span class="n">F</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">ι</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">AddCommGroup</span><span class="o">}</span> <span class="o">:</span> <span class="n">F</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">mk_graded</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">cocone_morphism</span> <span class="o">(</span><span class="n">discrete.functor</span> <span class="n">F</span><span class="o">)</span> <span class="n">i</span>

<span class="kd">structure</span> <span class="n">complex</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">AddCommGroup</span><span class="o">)</span>
<span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">mk_graded</span> <span class="n">F</span> <span class="bp">⟶</span> <span class="n">mk_graded</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">d_graded</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">F</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">ι</span> <span class="bp">≫</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">ι</span><span class="o">)</span>
<span class="o">(</span><span class="n">d_squared</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">≫</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="226417730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417730">(Feb 15 2021 at 18:37)</a>:</h4>
<p>In case anyone wants to play with a totalized version</p>



<a name="226417947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226417947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226417947">(Feb 15 2021 at 18:39)</a>:</h4>
<p>But there are two downsides, afaik (sorry for being critical, without having a better solution):</p>
<ol>
<li><code>mk_graded</code> might not fit into your category (e.g. complexes of findim vector spaces)</li>
<li>if I have a concrete example of a complex, then I will have some <code>x : F i</code>, and if I want to do a bit of homological algebra, then those <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span> maps will be all over the place</li>
</ol>



<a name="226418044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418044">(Feb 15 2021 at 18:41)</a>:</h4>
<p>Yeah, I agree. But I still think it's worth some experimentation</p>



<a name="226418144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418144">(Feb 15 2021 at 18:42)</a>:</h4>
<blockquote>
<p>those <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span> maps will be all over the place</p>
</blockquote>
<p>I don't think this is a major problem; it's kind of like working with integer expressions involving nats with <code>\u a + \u b - 1 = \u c</code></p>



<a name="226418277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418277">(Feb 15 2021 at 18:43)</a>:</h4>
<p>Regarding 1, is it possible to take a synthetic colimit here, putting you in a completion of the original category? Like a sigma</p>



<a name="226418339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418339">(Feb 15 2021 at 18:44)</a>:</h4>
<p>Yeah, that's what I'm thinking too.</p>



<a name="226418352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418352">(Feb 15 2021 at 18:44)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> 's work on ind completions would help here.</p>



<a name="226418732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418732">(Feb 15 2021 at 18:50)</a>:</h4>
<p>Yeah you can take the synthetic colimit if it's a filtered colimit, but there's already the free cocompletion in mathlib</p>



<a name="226418825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418825">(Feb 15 2021 at 18:50)</a>:</h4>
<p>But this comes with the caveat that the new category will be (potentially) a lot bigger than the original one - even in non-Lean maths if you take the cocompletion of a small category you end up with a large one</p>



<a name="226418880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418880">(Feb 15 2021 at 18:51)</a>:</h4>
<p>Plus the differential in the complex would become some morphism of presheaves, which might confuse even more people :)</p>



<a name="226418992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226418992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226418992">(Feb 15 2021 at 18:52)</a>:</h4>
<p>In this case you only need the completion wrt colimits of length <code>int</code></p>



<a name="226419064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419064">(Feb 15 2021 at 18:53)</a>:</h4>
<p>I still kind of think that d : C_i -&gt; C_j = 0 for i &gt; j is kind of insane. It would then not be true that for all i,j,k, d o d = d, for example. Chains seem to have been implemented as a functor from the integers (so again there are no d's if i &gt; j) and the "d = 0 if i+2&lt;=j" condition does sound like a cool way of setting it up.</p>



<a name="226419165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419165">(Feb 15 2021 at 18:54)</a>:</h4>
<blockquote>
<p>It would then not be true that for all i,j,k, d o d = d, for example.</p>
</blockquote>
<p>That was never true, because d o d = d doesn't typecheck for a lot of values of i,j,k</p>



<a name="226419198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419198">(Feb 15 2021 at 18:55)</a>:</h4>
<p>chain complexes have an "ad hoc" definition. They aren't implemented as functors. Just a collection of <code>int</code>-indexed objects with a <code>d</code> (of degree 1) between them.</p>



<a name="226419221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419221">(Feb 15 2021 at 18:55)</a>:</h4>
<p>the only difference now is that those assumptions are moving from type correctness assumptions to regular assumptions</p>



<a name="226419437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419437">(Feb 15 2021 at 18:57)</a>:</h4>
<p>it also means that you get less type inference. so statements will become a lot clunkier</p>



<a name="226419540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419540">(Feb 15 2021 at 18:58)</a>:</h4>
<p>I'm not sure the hypotheses that were being supplied are actually the ones you want though</p>



<a name="226419572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226419572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226419572">(Feb 15 2021 at 18:59)</a>:</h4>
<p>for example a type correctness hypothesis might be needlessly obtuse like <code>i+1+1 &lt;= j+1</code> while a regular hypothesis can be stated as <code>i+1 &lt;= j</code></p>



<a name="226420892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226420892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226420892">(Feb 15 2021 at 19:13)</a>:</h4>
<p>I've adapted the example to a totalized <code>d</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.category.Group</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">structure</span> <span class="n">cochain_complex</span> <span class="kd">extends</span> <span class="n">ℤ</span> <span class="bp">⥤</span> <span class="n">AddCommGroup</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_complex</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">),</span> <span class="n">map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">cochain_complex</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span>

<span class="sd">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>
<span class="kd">def</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span> <span class="k">then</span> <span class="n">C.map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">d_comp_d</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">delta</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h12</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h23</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">h12</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">h23</span><span class="o">,</span> <span class="bp">←</span> <span class="n">functor.map_comp</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">C.is_complex</span> <span class="n">i</span> <span class="n">k</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">dif_neg</span> <span class="n">h23</span><span class="o">,</span> <span class="n">rw</span> <span class="n">limits.comp_zero</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">dif_neg</span> <span class="n">h12</span><span class="o">,</span> <span class="n">rw</span> <span class="n">limits.zero_comp</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">d_d</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">show</span> <span class="o">((</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">))</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">d_comp_d</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
  <span class="c1">-- rw sub_add_cancel at h,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
  <span class="c1">-- rw add_sub_cancel at h,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226420987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226420987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226420987">(Feb 15 2021 at 19:14)</a>:</h4>
<p>But these statements are still problematic... Should they be written differently now? I don't see how.</p>



<a name="226421024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421024">(Feb 15 2021 at 19:15)</a>:</h4>
<p>Unless we use Kevin's approach again... but that also worked with the untotal <code>d</code>.</p>



<a name="226421277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421277">(Feb 15 2021 at 19:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226419198">said</a>:</p>
<blockquote>
<p>chain complexes have an "ad hoc" definition. They aren't implemented as functors. Just a collection of <code>int</code>-indexed objects with a <code>d</code> (of degree 1) between them.</p>
</blockquote>
<p>Oh sorry, I was looking at Adam's definition! I had assumed it was official in some way :-) I think that it definitely has its merits!</p>



<a name="226421495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421495">(Feb 15 2021 at 19:19)</a>:</h4>
<p>What's problematic? The <code>rw add_sub_cancel</code> lines work now</p>



<a name="226421500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421500">(Feb 15 2021 at 19:19)</a>:</h4>
<p>Sure, but we would definitely want a constructor that only needs a degree 1 map. E.g., when building a complex from a simplicial module by taking alternating sums of the degeneracy maps... you don't want to worry about arbitrary compositions at that point.</p>



<a name="226421526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421526">(Feb 15 2021 at 19:19)</a>:</h4>
<p>and you can use <code>i+2</code> instead of <code>i+1+1</code></p>



<a name="226421587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421587">(Feb 15 2021 at 19:20)</a>:</h4>
<p>aah, so why is <code>rw</code> working and <code>simp</code> failing?</p>



<a name="226421618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421618">(Feb 15 2021 at 19:20)</a>:</h4>
<p>Yeah:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">sub_add_cancel</span> <span class="n">i</span> <span class="mi">1</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">assumption</span><span class="o">,</span> <span class="c1">-- fails :(</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226421636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421636">(Feb 15 2021 at 19:20)</a>:</h4>
<p>The <code>d x = 0</code> assumption doesn't match with the <code>d x = 0</code> goal.</p>



<a name="226421712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421712">(Feb 15 2021 at 19:21)</a>:</h4>
<p>I think this would be a lot clearer (and shorter than the type ascriptions) if <code>j</code> was an explicit arg to <code>d</code></p>



<a name="226421794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421794">(Feb 15 2021 at 19:22)</a>:</h4>
<p>We might need to do that</p>



<a name="226421811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421811">(Feb 15 2021 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/homological.20headache/near/226421526">said</a>:</p>
<blockquote>
<p>and you can use <code>i+2</code> instead of <code>i+1+1</code></p>
</blockquote>
<p>this causes the fail that Adam noticed</p>



<a name="226421840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421840">(Feb 15 2021 at 19:23)</a>:</h4>
<p>I think d should take a proof that i &lt;= j. That proof which split up into cases -- nobody is going to need the j &lt; i situation ever, right?</p>



<a name="226421872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421872">(Feb 15 2021 at 19:23)</a>:</h4>
<p>that's what causes all the <code>simp</code> sadness though</p>



<a name="226421877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421877">(Feb 15 2021 at 19:23)</a>:</h4>
<p>Because it's a proof, we don't care if we have a proof of i &lt;= j + 1 - 1 or whatever</p>



<a name="226421952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421952">(Feb 15 2021 at 19:24)</a>:</h4>
<p>but if it's an arg to <code>d</code> then it ends up in statements which is why nothing rewrites properly</p>



<a name="226421975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226421975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226421975">(Feb 15 2021 at 19:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> why can't <code>angry_simp</code> just blast through those annoying badly-typed motives?</p>



<a name="226422017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422017">(Feb 15 2021 at 19:25)</a>:</h4>
<p>It will have to fix up those proof arguments... but isn't that just some <code>trans</code> or <code>subst</code>?</p>



<a name="226422161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422161">(Feb 15 2021 at 19:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.category.Group</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">structure</span> <span class="n">cochain_complex</span> <span class="kd">extends</span> <span class="n">ℤ</span> <span class="bp">⥤</span> <span class="n">AddCommGroup</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_complex</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">),</span> <span class="n">map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">cochain_complex</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span>

<span class="sd">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>
<span class="kd">def</span> <span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span> <span class="k">then</span> <span class="n">C.map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">d'</span> <span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">d</span>

<span class="kd">lemma</span> <span class="n">d_comp_d</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">delta</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h12</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h23</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">h12</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">h23</span><span class="o">,</span> <span class="bp">←</span> <span class="n">functor.map_comp</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">C.is_complex</span> <span class="n">i</span> <span class="n">k</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">dif_neg</span> <span class="n">h23</span><span class="o">,</span> <span class="n">rw</span> <span class="n">limits.comp_zero</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">dif_neg</span> <span class="n">h12</span><span class="o">,</span> <span class="n">rw</span> <span class="n">limits.zero_comp</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">d_d</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">show</span> <span class="o">((</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">))</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">d_comp_d</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">d'</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="n">d'</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="n">ring</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="bp">+</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">ring</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="bp">-</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="n">ring</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226422180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422180">(Feb 15 2021 at 19:27)</a>:</h4>
<p>simp's instead of rewrites still don't seem to work</p>



<a name="226422208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422208">(Feb 15 2021 at 19:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- `C.d` is the differential `C i ⟶ C (i+1)` for a cochain complex `C`. -/</span>
<span class="kd">def</span> <span class="n">d</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">C.obj</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span> <span class="k">then</span> <span class="n">C.map</span> <span class="o">(</span><span class="n">hom_of_le</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">d_comp_d</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">d</span> <span class="n">j</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">_</span><span class="o">)</span> <span class="bp">≫</span> <span class="n">d</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">delta</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h12</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h23</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">h12</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">h23</span><span class="o">,</span> <span class="bp">←</span> <span class="n">functor.map_comp</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">C.is_complex</span> <span class="n">i</span> <span class="n">k</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">dif_neg</span> <span class="n">h23</span><span class="o">,</span> <span class="n">rw</span> <span class="n">limits.comp_zero</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">dif_neg</span> <span class="n">h12</span><span class="o">,</span> <span class="n">rw</span> <span class="n">limits.zero_comp</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">d_d</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="n">k</span> <span class="o">(</span><span class="n">d</span> <span class="n">j</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">show</span> <span class="o">(</span><span class="n">d</span> <span class="n">j</span> <span class="bp">≫</span> <span class="n">d</span> <span class="n">k</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">d_comp_d</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">_</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">d</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">_</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">sub_add_cancel</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226422432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422432">(Feb 15 2021 at 19:30)</a>:</h4>
<p>The statements are indeed a lot shorter, and <code>simp</code> doesn't work because it involves uniformly rewriting in places where <code>simp</code> can't reach because of dependencies (the <code>rwa</code> is actually changing the type of the equality)</p>



<a name="226422488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422488">(Feb 15 2021 at 19:31)</a>:</h4>
<p><code>rw</code> is too stupid to question whether the rewrite is going to work, it just yolo's and reports <code>motive is not type correct</code> if it turns out not to work</p>



<a name="226422520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422520">(Feb 15 2021 at 19:31)</a>:</h4>
<p>I want <code>yolo_simp</code></p>



<a name="226422616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422616">(Feb 15 2021 at 19:32)</a>:</h4>
<p>Are there theoretical obstructions to its existence? Or could a carefully crafted <code>dtt_simp</code> make life easier, without resigning to a bunch of ad hoc hacks?</p>



<a name="226422691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422691">(Feb 15 2021 at 19:33)</a>:</h4>
<p>well the disadvantage of the yolo approach is that you can end up getting tripped up by occurrences of the pattern where it would be best not to touch, like inside proof arguments in the statement</p>



<a name="226422778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422778">(Feb 15 2021 at 19:34)</a>:</h4>
<p>A usable but kind of ugly solution would be to specify exactly which occurrences you want to replace</p>



<a name="226422881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226422881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226422881">(Feb 15 2021 at 19:35)</a>:</h4>
<p>and that still might not work with situations like the rewrite you sent me</p>
<blockquote>
<p>Is the issue that <code>(is_weak_bounded_exact._proof_2 (i + 1))</code> is only a proof of <code>i + 1 - 1 + 1 = i + 1</code> and not a proof of <code>i + 1 = i + 1</code>?</p>
</blockquote>



<a name="226423039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423039">(Feb 15 2021 at 19:37)</a>:</h4>
<p>As for dtt_simp, things get pretty hairy once you have heterogeneous equality. I think there is a way to do this but it requires pathovers, which we don't have in mathlib</p>



<a name="226423059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423059">(Feb 15 2021 at 19:38)</a>:</h4>
<p>But those kind of proofs should be fixable, right? By doing some transitivity of equality.</p>



<a name="226423159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423159">(Feb 15 2021 at 19:38)</a>:</h4>
<p>Yes, the solution is to replace the proof <code>is_weak_bounded_exact._proof_2 (i + 1)</code> with <code>congr_arg (+1) h</code> where <code>h : i + 1 - 1 = 1</code> is the lemma you are rewriting with</p>



<a name="226423177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423177">(Feb 15 2021 at 19:39)</a>:</h4>
<p>and then replace <code>h</code> with <code>rfl</code> along with everything else</p>



<a name="226423204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423204">(Feb 15 2021 at 19:39)</a>:</h4>
<p>but doing that in a <code>rw</code> line with no hairy middle steps is a challenge</p>



<a name="226423296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423296">(Feb 15 2021 at 19:40)</a>:</h4>
<p>Here's the "generalize" approach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">d</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C.obj</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">ring</span> <span class="o">},</span> <span class="n">clear</span> <span class="n">hx</span> <span class="n">x</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226423309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423309">(Feb 15 2021 at 19:40)</a>:</h4>
<p>The <code>generalize_proofs</code> tactic may come in useful here, it will hoist these lemmas into the context where you can replace them in a more targeted way</p>



<a name="226423554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226423554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226423554">(Feb 15 2021 at 19:42)</a>:</h4>
<p>The suffices line is morally equivalent to the motive that <code>rw</code> is cooking up - the trick is to generalize the right things in the context and it's easy but verbose for a human and hard for a tactic that doesn't know what you are trying to do</p>



<a name="226424363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226424363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226424363">(Feb 15 2021 at 19:51)</a>:</h4>
<p>Sorry for a (very likely) useless suggestion, but is <a href="https://www.cl.cam.ac.uk/~jdy22/papers/frex-indexing-modulo-equations-with-free-extensions.pdf">https://www.cl.cam.ac.uk/~jdy22/papers/frex-indexing-modulo-equations-with-free-extensions.pdf</a> useful for the index computations? I guess it at least provides funny terms such as "slime avoidance" and "fording"</p>



<a name="226425603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226425603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226425603">(Feb 15 2021 at 20:08)</a>:</h4>
<p>It certainly looks relevant... but I don't know enough type theory lingo to see how to apply it in the context at hand</p>



<a name="226460167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226460167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226460167">(Feb 16 2021 at 00:53)</a>:</h4>
<p>Looks like I missed some fun. :-) I've played with this <code>ℤ ⥤ V</code> with <code>C.map (hom_of_le _) = 0</code> a few times previously. It's a fun definition, and if it actually helped I'm sure we could persuade people that it wasn't insane...</p>



<a name="226460247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226460247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226460247">(Feb 16 2021 at 00:55)</a>:</h4>
<p>But I'm not sure that you get anything from this definition that you don't get just by being careful to insert lots of <code>eq_to_hom</code>s.</p>



<a name="226461360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226461360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226461360">(Feb 16 2021 at 01:19)</a>:</h4>
<p>I think the statements are generally shorter, and you don't have proofs in the statements which causes most of the problem in proofs</p>



<a name="226463949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226463949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226463949">(Feb 16 2021 at 02:11)</a>:</h4>
<p>I guess what I meant was that you still frequently need to move between <code>C.X i</code> and <code>C.X j</code> when you know <code>i = j</code>, you just have an extra way to do this: <code>C.map (hom_of_le (le_of_eq h))</code>, in addition to the general purpose <code>eq_to_hom (congr_arg C.X h)</code>.</p>



<a name="226950877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226950877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226950877">(Feb 19 2021 at 11:28)</a>:</h4>
<p>I experimented with yet another definition of a complex, that seems to specialise reasonably to <code>int</code> indexed (co)chain complexes, and to <code>nat</code> indexed chain complexes.</p>
<p>It is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">hc</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">X</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">X</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">d_squared'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">a</span><span class="o">),</span> <span class="n">d</span> <span class="n">n</span> <span class="bp">≫</span> <span class="n">tra</span> <span class="n">X</span> <span class="n">h</span> <span class="bp">≫</span> <span class="n">d</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">.</span> <span class="n">d_squared_tac</span><span class="o">)</span>
</code></pre></div>
<p>Here:</p>
<ul>
<li>there are _two_ parameters <code>a b</code> in the definition, which controls where the differential goes. <ul>
<li>for <code>int</code> indexed chain complexes you want <code>a=0, b=-1</code>.</li>
<li>for <code>int</code> indexed cochain complexes you want <code>a=0, b=1</code>.</li>
<li>for <code>nat</code> indexed chain complexes you want <code>a=1, b=0</code>.</li>
</ul>
</li>
<li><code>tra X h</code> is just defined as <code>eq_to_hom (congr_arg X h)</code>, i.e. it's transport through a type family, as a morphism in the category</li>
<li><code>d_squared_tac</code> is <code>`[{ intros n m h, simp at h, try { subst h }, obviously }]</code>.</li>
</ul>
<p>You can see in <code>https://github.com/leanprover-community/mathlib/blob/hexp/src/algebra/homology/chain_complex_2.lean</code> that at least building the equivalence of categories to cochain complexes, or the equivalence to <code>nat</code>-indexed chain complexes as proposed in <a href="https://github.com/leanprover-community/mathlib/issues/6260">#6260</a>, is _relatively_ painless -- <code>d_squared_tac</code> works when you want it to, and <code>tidy</code> manages all the proofs.</p>
<p>Of course, just proving equivalences between definitions is far from enough evidence that this is usable.</p>



<a name="226950966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226950966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226950966">(Feb 19 2021 at 11:30)</a>:</h4>
<p>I was pretty happy in in <a href="https://github.com/leanprover-community/mathlib/issues/6308">#6308</a> that the <code>nat</code> indexed chain complexes of <a href="https://github.com/leanprover-community/mathlib/issues/6260">#6260</a> worked smoothly for defining the Moore complex. So that is some evidence that that definition is usable. I may try redoing the Moore complex using this definition, to see how it goes.</p>



<a name="226951109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226951109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226951109">(Feb 19 2021 at 11:32)</a>:</h4>
<p>The other obvious tests are:</p>
<ul>
<li>adapt the existing <code>algebra/homology/homology.lean</code></li>
<li>write some other equivalences (e.g. coming from an additive automorphism of the indexing monoid <code>N</code>)</li>
<li>show that given an inclusion of monoids, the chain complexes on the small monoid are equivalent to chain complexes indexed by the big monoid, supported on the small monoid</li>
</ul>



<a name="226951194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226951194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226951194">(Feb 19 2021 at 11:32)</a>:</h4>
<p>These aren't the most exciting tests to carry out... So I'm happy to hear feedback or take directions. :-)</p>



<a name="226951254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226951254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226951254">(Feb 19 2021 at 11:33)</a>:</h4>
<p>I'd also like to test out the <code>ℕ ⥤ V</code> approach, of course.</p>



<a name="226951574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226951574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226951574">(Feb 19 2021 at 11:36)</a>:</h4>
<p>Another test is to switch (a branch of) <code>lean-liquid</code> over to your mathlib branch, and rewrite the homological algebra that we've done so far, in terms of this new definition.</p>



<a name="226951970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/226951970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#226951970">(Feb 19 2021 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> did some homological algebra in Lean 2 using a <code>succ_structure</code> for a base.</p>



<a name="227107359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/227107359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#227107359">(Feb 20 2021 at 18:02)</a>:</h4>
<p>Yeah, in Lean 2 I defined <a href="https://github.com/leanprover/lean2/blob/master/hott/homotopy/chain_complex.hlean#L8-L12">chain complexes</a> indexed by a "successor structure" which is just any type equipped with an endofunction, called the successor. It worked nicely, especially when dealing with chain complexes that have some vague periodicity. For example, the long exact sequence of homotopy groups was indexed by <code>nat x fin 3</code>, since every three indices you go up one dimension.</p>
<p>Scott's <code>add_comm_monoid</code> also works for this, and has the advantage that it works well with cochain complexes defined over <code>nat</code> (in my definition this didn't work great, since it would contain one extra map: <code>... &lt;- X 2 &lt;- X 1 &lt;- X 0 &lt;- X (pred 0)</code>)</p>
<p>I also defined <a href="https://github.com/cmu-phil/Spectral/blob/master/algebra/graded.hlean#L17-L34">graded objects</a>. The linked comment describes two design decisions that are worth considering, though I'm not sure if they would be right for mathlib ((1) looks strange, and (2) might not be a problem if tidy can deal with all the transports.</p>



<a name="227108053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/227108053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#227108053">(Feb 20 2021 at 18:14)</a>:</h4>
<p>So far, we've been running headfirst into the wall that (2) describes <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span></p>



<a name="227108086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/227108086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#227108086">(Feb 20 2021 at 18:15)</a>:</h4>
<p>So I'm inclined to define <code>d</code> as something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">d</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="n">i</span> <span class="bp">-&gt;</span> <span class="n">X</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="o">(</span><span class="n">actual</span> <span class="kd">def</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="227108184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/227108184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#227108184">(Feb 20 2021 at 18:16)</a>:</h4>
<p>Note that <code>d &gt;&gt; d = 0</code> will then hold without proof obligations. For other lemmas/facts we might want to have an auto param that automatically discharges the <code>i + 1 = j</code>-type goals</p>



<a name="227108189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/homological%20headache/near/227108189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/homological.20headache.html#227108189">(Feb 20 2021 at 18:16)</a>:</h4>
<p>probably a combi of <code>ring</code> and maybe <code>linarith</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
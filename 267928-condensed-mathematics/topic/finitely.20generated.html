---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/finitely.20generated.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html">finitely generated</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227615836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227615836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227615836">(Feb 24 2021 at 15:30)</a>:</h4>
<p>A little project: develop some API for <code>module.finite</code>. Mathlib knows the definition.</p>
<ul>
<li>Do we also want a predicate for finitely generated (mul/add) groups? And glue with the module version in the additive case?</li>
<li>Do we care about the noncommutative case?</li>
</ul>
<p>For LTE we will need</p>
<ul>
<li>finite direct sums of fin.gen modules (or add_groups) are fin.gen</li>
<li>an add_subgroup of a fin.gen add_group is again finitely generated</li>
</ul>



<a name="227647195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227647195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227647195">(Feb 24 2021 at 18:23)</a>:</h4>
<p>Which proof of the third bullet point do you have in mind that would use commutativity?  Finitely generated modules are definitely also studied in the noncommutative setting.</p>



<a name="227648538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227648538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227648538">(Feb 24 2021 at 18:31)</a>:</h4>
<p>I didn't think carefully at all about the noncommutative case. There are actually two kinds of noncommutativity here. The base ring, in the module case, but also the group itself in the case of fin.gen. groups.</p>



<a name="227839900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227839900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227839900">(Feb 25 2021 at 21:13)</a>:</h4>
<p>Re LTE needs: when Mario did Noetherian modules years ago I'm pretty sure he did that a submodule of a Noetherian module was Noetherian. Do we have finite direct sums? This feels like one of those things where there are about four ways of formalising it.</p>



<a name="227840221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227840221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227840221">(Feb 25 2021 at 21:16)</a>:</h4>
<p>I have no idea what's there... <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span></p>



<a name="227841390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227841390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227841390">(Feb 25 2021 at 21:23)</a>:</h4>
<p>For <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-modules we have the <code>is_noetherian</code> predicate, a proof that a f.g. module over a Noetherian ring is Noetherian, a submodule of a Noetherian module is Noetherian, and a Noetherian module is finitely-generated. That gives us the second bullet point for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-modules, but then there's the usual song and dance to translate this into questions about abelian groups.</p>



<a name="227841833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227841833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227841833">(Feb 25 2021 at 21:27)</a>:</h4>
<p>How do you want to do this? Define <code>add_comm_group.fg</code> or resist doing this?</p>



<a name="227846168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227846168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227846168">(Feb 25 2021 at 21:58)</a>:</h4>
<p>Aah, I see you ask the same question! I don't see why we shouldn't have <code>is_fg</code> a predicate on <code>add_comm_group</code>, it could maybe be a class but maybe not, I think there's some lemma that Z-module structure on an add_comm_group is unique so there shouldn't be problems just pulling results over. The third bullet point is certainly fine in the case where the ring is noncommutative. I think finitely generated groups are a different thing to this.</p>



<a name="227847062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227847062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227847062">(Feb 25 2021 at 22:04)</a>:</h4>
<p>I am playing with finitely generated modules to develop the API for finitely presented morphisms, so I can very well work on finitely generated groups... but as usual I leave the design decisions to you the experts <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="227852399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227852399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227852399">(Feb 25 2021 at 22:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>
<span class="kn">import</span> <span class="n">linear_algebra</span>
<span class="kn">import</span> <span class="n">group_theory.subgroup</span>
<span class="kn">import</span> <span class="n">data.finset.basic</span>
<span class="kn">import</span> <span class="n">order.galois_connection</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_top</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">g</span> <span class="n">f</span><span class="o">)</span>

<span class="kn">include</span> <span class="n">gi</span>
<span class="kd">def</span> <span class="n">is_fg</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">g</span> <span class="n">F</span> <span class="bp">=</span> <span class="bp">⊤</span>

<span class="kd">def</span> <span class="n">group.is_fg</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span> <span class="n">is_fg</span> <span class="o">(</span><span class="n">subgroup.gi</span> <span class="n">G</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">module.is_fg</span> <span class="o">(</span><span class="n">A</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span> <span class="n">is_fg</span> <span class="o">(</span><span class="n">submodule.gi</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span>

<span class="c1">-- etc...</span>
</code></pre></div>



<a name="227870704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227870704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227870704">(Feb 26 2021 at 01:58)</a>:</h4>
<p>FWIW, a subwidget being fg is should be equivalent to <code>complete_lattice.is_compact_element</code></p>



<a name="227870739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227870739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227870739">(Feb 26 2021 at 01:59)</a>:</h4>
<p>We should prove some theorems about that and galois insertions that connect this to the above definition of <code>is_fg</code></p>



<a name="227885350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227885350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227885350">(Feb 26 2021 at 05:40)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> I like that idea of generalisation. A good API for compact elements can probably be easily specialised to different forms of <code>is_fg</code>. Thanks for the suggestion</p>



<a name="227886286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/finitely%20generated/near/227886286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/finitely.20generated.html#227886286">(Feb 26 2021 at 05:58)</a>:</h4>
<p>The theory I've had in mind for a while but haven't fully put into practice is classifying all of these examples of galois insertions as "finitary" or "algebraic" (terms usually used for closure operators, but Galois insertions are basically the same). That should be enough specificity to prove that being the closure of a finset is equivalent to being a compact element (as well as lots of other good things, this is nearly the definition of matroids/pregeometries).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
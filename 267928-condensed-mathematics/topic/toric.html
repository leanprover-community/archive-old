---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/toric.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html">toric</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="228149534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/228149534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#228149534">(Feb 28 2021 at 19:03)</a>:</h4>
<p>An update from the <code>toric</code> branch.</p>
<p>I just pushed the latest version of <code>toric</code>: it has several <code>sorries</code>, but compiles. It also contains a full proof that the dual set of a ℤ-basis in a ℤ-lattice is pointed (i.e. intersects a hyperplane in just the origin). There is also a lemma that says that dual sets are (anti-)monotone, so it should be easy to show that the dual set of any set that contains a basis is pointed.</p>
<p>This is for ℤ-modules with a basis, which seem to work very well as a replacement to torsion free, finitely generated modules.  There is no finite generation assumption, but there is the requirement of having a basis.</p>
<p>I would like this to work with fewer assumptions, but this is where I am at the moment. The good thing is that I think that this should work equally well over ℚ or ℝ, which should be the cases of interest for the applications to the liquid project!</p>



<a name="228149649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/228149649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#228149649">(Feb 28 2021 at 19:04)</a>:</h4>
<p>There is still work to do to prove that saturated submonoids are finitely generated, but I consider it progress!</p>



<a name="229443460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/229443460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#229443460">(Mar 09 2021 at 09:03)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> did a massive amount of work here, and it has just been merged into <code>master</code></p>



<a name="229443505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/229443505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#229443505">(Mar 09 2021 at 09:03)</a>:</h4>
<p>Be sure to <code>git pull</code> before working on master</p>



<a name="232486406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232486406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232486406">(Mar 30 2021 at 19:50)</a>:</h4>
<p>I pushed a few more additions to the <code>toric</code> branch: it is not yet ready for unguided <code>sorry</code>-proving, but it is getting there!</p>



<a name="232486542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232486542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232486542">(Mar 30 2021 at 19:50)</a>:</h4>
<p>I work more on it this week and hopefully soon I will be able to have <code>sorry</code>s that can be proven with minimal insider knowledge.</p>



<a name="232498344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232498344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232498344">(Mar 30 2021 at 21:07)</a>:</h4>
<p>I would like to help with Gordan's lemma! Do you think  it's better to wait to have some more readable <code>sorry</code> or should I try to read the code now?</p>



<a name="232542162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232542162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232542162">(Mar 31 2021 at 06:22)</a>:</h4>
<p>I was thinking that the statement of Gordan's lemma should end up in some of the <code>toric</code> file, and that it gets simply quoted in <code>lem97</code>. I think this would make it easier to adapt the form you'll prove to the one that I'm using. Do you agree? And, if yes, where would you suggest that I insert it?</p>



<a name="232548042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548042">(Mar 31 2021 at 07:35)</a>:</h4>
<p>Dear All,</p>
<p>I am very happy about the interest in Gordan's lemma!  Part of the problem is that, while I write the steps in the proof, I confront myself with issues in the formalization and decide to change the approach.  If you are willing to write a proof and then having to adapt it to a (hopefully slightly) different context, then feel free to remove <code>sorry</code>s from the file <code>toric/towards_Gordan.lean</code> (this is the <code>toric</code> folder in the <code>toric</code> branch).</p>
<p>However, I have had to change the setup a couple of times, since I was not able to make a few of the initial approaches work.  This is quite possibly due to my own inability to use Lean, though!</p>
<p>I am trying to document <code>towards_Gordan.lean</code> in a systematic way, so that it should be easy to follow what the steps do, how they fit in the general proof and what are the important assumptions.  If you can prove a lemma "close" to one of the stated ones, that might also be very useful!</p>



<a name="232548304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548304">(Mar 31 2021 at 07:37)</a>:</h4>
<p>And do you think <code>towards_Gordan</code> will eventually become <code>Gordan</code> (i.e. : I can insert the statement there and refer to it) or do you plan to have two files?</p>



<a name="232548310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548310">(Mar 31 2021 at 07:38)</a>:</h4>
<p>Filippo, I am now upgrading my branch to the current <code>master</code>.  I will check the exact statement of Lemma 9.7 and will see how to fit it with what I have.</p>



<a name="232548416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548416">(Mar 31 2021 at 07:39)</a>:</h4>
<p>Thanks, at any rate I find it most reasonable to put what I use in the <code>toric</code> directory, and that I quote it from there. If the statement you end up with is not exactly the one I am using, we can write the bridge between the two there more easily, I guess.</p>



<a name="232548529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548529">(Mar 31 2021 at 07:40)</a>:</h4>
<p>Yes, at this stage, I am trying to get <em>some</em> Gordan-like statement proven.  Once that is done, I am hoping that merging the proven one with the one that you used should be a simple matter.</p>



<a name="232548579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548579">(Mar 31 2021 at 07:40)</a>:</h4>
<p>The statement I am using is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">explicit_gordan</span> <span class="o">(</span><span class="n">h</span><span class="bp">Λ</span> <span class="o">:</span> <span class="n">finite_free</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">explicit_dual_set</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="232548643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548643">(Mar 31 2021 at 07:41)</a>:</h4>
<p>where</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">explicit_dual_set</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">Λ</span> <span class="bp">→+</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">(</span><span class="n">l</span> <span class="n">i</span><span class="o">)},</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">le_rfl</span><span class="o">,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_nonneg</span> <span class="o">(</span><span class="n">hx</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="n">i</span><span class="o">),</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">i</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid_hom.nat_smul_apply</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nsmul_nonneg</span> <span class="o">(</span><span class="n">hx</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="232548740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548740">(Mar 31 2021 at 07:42)</a>:</h4>
<p>Also, it does make sense to have the statement of Gordan's lemma in the <code>toric</code> folder.</p>
<p>I am building the <code>toric</code> branch now, with the <code>master</code> that I just merged.</p>



<a name="232548928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232548928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232548928">(Mar 31 2021 at 07:44)</a>:</h4>
<p>Ok, I have not yet fixed the <code>nat_submodule</code> issue, but, apart from that, I am getting close to having the function <code>l</code> appearing in <code>explicit_dual_set</code> defined.</p>



<a name="232549075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232549075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232549075">(Mar 31 2021 at 07:46)</a>:</h4>
<p>Ok, <code>master</code> merged with no issues into <code>toric</code>, <code>leanproject build</code> also only warned me about <code>sorry</code>s and I pushed again to the <code>toric</code> branch.  There are no changes from what I pushed yesterday, except that it is now up to date with <code>master</code>.</p>



<a name="232549836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232549836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232549836">(Mar 31 2021 at 07:53)</a>:</h4>
<p>... and CI is also happy with the branch!  I also noticed a sign error in a doc-string and pushed the fix.  This is just a change in a comment, so there should be no CI issues.</p>



<a name="232550272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232550272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232550272">(Mar 31 2021 at 07:57)</a>:</h4>
<p>I will try to read what you have done in the next days, so please don't hesitate to leave a lot of small <code>sorry</code> (even inside proofs!)... killing them is my favorite  way of getting used to new stuff <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="232550720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232550720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232550720">(Mar 31 2021 at 08:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/232548740">said</a>:</p>
<blockquote>
<p>Also, it does make sense to have the statement of Gordan's lemma in the <code>toric</code> folder.</p>
<p>I am building the <code>toric</code> branch now, with the <code>master</code> that I just merged.</p>
</blockquote>
<p>Ok, are you going to put it somewhere and <code>push</code> to <code>master</code>? In that way, I can adapt my branch and when I'll <code>push</code> to <code>master</code> that part will be solid.</p>



<a name="232550766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232550766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232550766">(Mar 31 2021 at 08:01)</a>:</h4>
<p>Riccardo, If you stick to the file <code>towards_Gordan</code>, the <code>sorry</code>s there should be provable (at least, this is my intention!).  If you stray to a different file, you should also try to figure out if the statement is actually correct, since the <code>sorry</code>s outside of <code>towards_Gordan</code> are more of a playground, than actual steps in the formalization.</p>



<a name="232550970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232550970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232550970">(Mar 31 2021 at 08:03)</a>:</h4>
<p>I will have a look at <code>towards_Gordan</code>, thank you!</p>



<a name="232551919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232551919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232551919">(Mar 31 2021 at 08:12)</a>:</h4>
<p>Filippo, maybe the best thing would be to simply move the file <code>lem97.lean</code> into the <code>toric</code> folder, just to sort lemmas by "semantic similarity".  I still feel that I would like to have the option of tweaking the actual statement of Gordan's lemma to adapt it to what I feel is easier to formalize first, and worry about how to link it to what you have been using later.  I really think that the glue should be some simple juggling with finite sets and coercions.</p>



<a name="232552318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232552318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232552318">(Mar 31 2021 at 08:15)</a>:</h4>
<p>I agree, that it's best to formalize the statement that "falls out of all the preliminary work" and worry about the glue later.</p>



<a name="232552400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232552400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232552400">(Mar 31 2021 at 08:16)</a>:</h4>
<p>You want to keep the coe-juggling in a small place. It shouldn't infect the rest of the story (-;</p>



<a name="232552696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232552696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232552696">(Mar 31 2021 at 08:20)</a>:</h4>
<p>Oh I certainly agree it will be easy. OK, I will move<code>lem97 </code> in the <code>toric</code> folder leaving the <code>explicit_gordan</code> sorried. I'll be happy to come and help for the bridge once and if it will be needed. <span aria-label="bridge" class="emoji emoji-1f309" role="img" title="bridge">:bridge:</span></p>



<a name="232553712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232553712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232553712">(Mar 31 2021 at 08:29)</a>:</h4>
<p>What is the math proof of Gordan's lemma that you are trying to formalize? The wikipedia one is nice but leaves most of the work implicit in using duality of cones. Is there a good complete textbook account of duality of (rational) cones that you follow?</p>



<a name="232555538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232555538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232555538">(Mar 31 2021 at 08:46)</a>:</h4>
<p>I have patched together a proof, following partly the outline in Wikipedia.</p>
<p>Quickly, here is my strategy.</p>
<p>I have already proved a bunch of infrastructure to work with cones and duals, so that should be (mostly) in place.</p>
<ul>
<li>Reduce to the case in which the dual is confined in an octant.  This is achieved by making sure that the set of which you are taking the dual contains a basis.</li>
<li>Prove that the "extremal rays" are indexes by (some) subsets of the set of which you are taking the dual.  This is mostly a matter of making the definition of  "extremal rays" and "1-dimensional subcone" match up.</li>
<li>Once you have finitely many extremal rays, what is left is a form of saturation.  This will be filled in by taking linear combinations of the extremal rays with rational coefficients in [0,1] and intersecting with the lattice.   Here, the main finiteness condition will follow from intersecting a (pre-)compact set with a discrete one.</li>
</ul>



<a name="232555653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232555653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232555653">(Mar 31 2021 at 08:47)</a>:</h4>
<p>From a formalization point of view, I am trying to make the transitions between linear combinations with coefficients in ℕ, ℤ, ℚ or ℝ be as smooth as possible, since they all play some partial role in the argument.</p>



<a name="232555876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232555876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232555876">(Mar 31 2021 at 08:49)</a>:</h4>
<p>While this feels to be within my "formalization grasp", I also find it challenging!</p>



<a name="232559966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232559966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232559966">(Mar 31 2021 at 09:22)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>  OK, sounds great!</p>



<a name="232665829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232665829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232665829">(Mar 31 2021 at 21:11)</a>:</h4>
<p>I have proved <code>reduction_to_lattice</code> here<br>
<a href="https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean</a><br>
There is something I don't understand in the proof: I have the impression that the hypothesis I called <code>goal</code> is exactly what we want to prove, but <code>exact goal</code> doesn't work.  If you try to play with it it's very easy to get to a point where you need to prove <code>foo</code> and you have <code>foo</code> in the local context, but there should be some problem with possibly different <code>ℤ</code>-actions. If someone wants to play with it feel free to modify it... at the moment it is very ugly.</p>



<a name="232666610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232666610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232666610">(Mar 31 2021 at 21:17)</a>:</h4>
<p>Perhaps you've tried it already, but in that situation I often use <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#convert">tactic#convert</a> to show what Lean is having trouble with.</p>



<a name="232667154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232667154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232667154">(Mar 31 2021 at 21:21)</a>:</h4>
<p>I did it, in line <code>80</code>. The goal becomes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">g</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">b</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">g</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">b</span> <span class="n">i</span>
</code></pre></div>
<p>After <code>ext i</code> the goal becomes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">b</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">b</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>I proved this by induction on <code>g i</code>, that is an integer. The proof worked because essentially <code>zero_smul</code> <code>add_smul</code>,<code>sub_smul</code> and <code>one_smul</code> work for any <code>•</code>, but I don't know how to do it better.</p>



<a name="232667384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232667384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232667384">(Mar 31 2021 at 21:23)</a>:</h4>
<p>Ah, sorry, I hadn't looked at the proof yet!</p>



<a name="232667626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232667626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232667626">(Mar 31 2021 at 21:25)</a>:</h4>
<p>It must have something to to with coercion from <code>Λ₁</code> to submodules of <code>V</code>, or something like that.</p>



<a name="232667669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232667669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232667669">(Mar 31 2021 at 21:25)</a>:</h4>
<p>Hmm, is it something that <code>norm_cast</code> should be helping with?</p>



<a name="232667789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232667789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232667789">(Mar 31 2021 at 21:26)</a>:</h4>
<p>Let me see</p>



<a name="232669041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232669041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232669041">(Mar 31 2021 at 21:36)</a>:</h4>
<p>Hmm, it does something, but it doesn't really change the proof</p>



<a name="232670232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232670232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232670232">(Mar 31 2021 at 21:46)</a>:</h4>
<p>Ah! A combination of <code>norm_cast</code> and <code>congr</code> simplified the proof quite a lot</p>



<a name="232676329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232676329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232676329">(Mar 31 2021 at 22:36)</a>:</h4>
<p>The proof is now reasonably small, even if there still is something I don't understand completely. If  it's OK for <span class="user-mention" data-user-id="321459">@Damiano Testa</span> I will push it into <code>toric</code>.</p>



<a name="232697816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232697816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232697816">(Apr 01 2021 at 03:19)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> thank you very much for your help!</p>
<p>Feel free to push your proof to <code>toric</code>!</p>
<p>I have not looked at it, but I suspect that the issues that you mention have to do with Lean finding it tricky to convert between \Z and \Q.</p>
<p>In any case, any proof is the same as any other proof in Lean!</p>



<a name="232702284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232702284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232702284">(Apr 01 2021 at 04:27)</a>:</h4>
<p>Ok, I took a look at this and I could golf it slightly, mostly by extracting a part of the proof to something more general:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- general fact, also asked in mathlib</span>
<span class="kd">lemma</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="n">M</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">R</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hinj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">))</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">li</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">S</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linear_independent</span> <span class="n">R</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">linear_independent_iff'.mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">g</span> <span class="n">hg</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">hinj</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">ring_hom.map_zero</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
  <span class="n">refine</span> <span class="o">(((</span><span class="bp">@</span><span class="n">linear_independent_iff'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">li</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">algebra_map_smul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hg</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- marginally shorter proof</span>
<span class="kd">lemma</span> <span class="n">reduction_to_lattice</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℚ</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">vn</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s.restrict_scalars</span> <span class="n">ℤ</span> <span class="bp">⊓</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">)),</span>
  <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">vn</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">submodule.exists_is_basis_of_le_span</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">ℤ</span> <span class="n">v</span><span class="o">)</span> <span class="n">inf_le_right</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">hb.2</span><span class="o">⟩⟩,</span>
    <span class="n">replace</span> <span class="n">hb</span> <span class="o">:=</span> <span class="n">hb.1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">linear_independent_iff'</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">t</span> <span class="n">g</span> <span class="n">hg</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="n">t</span> <span class="n">g</span> <span class="n">_</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hg</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">erw</span> <span class="o">[</span><span class="n">submodule.coe_smul_of_tower</span><span class="o">,</span> <span class="n">submodule.coe_smul_of_tower</span><span class="o">,</span> <span class="n">algebra_map_smul</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="n">_</span> <span class="n">bv.1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">ab</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232702419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232702419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232702419">(Apr 01 2021 at 04:29)</a>:</h4>
<p>It may be that the main weirdness in the proof is that <code>is_scalar_tower ℤ ℚ V</code> and the coercion from ℤ to ℚ do not recognize each other.... maybe.</p>



<a name="232704801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232704801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232704801">(Apr 01 2021 at 05:04)</a>:</h4>
<p>I think that sometimes you can <code>have aux : int.module \Z = ring.to_module \Z</code> (or something like that). The proof of that <code>have</code> will be <code>subsingleton.elim</code>. And after that, you can <code>rw aux</code> so that all the scalar multiplications are now really the same.</p>



<a name="232704829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232704829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232704829">(Apr 01 2021 at 05:04)</a>:</h4>
<p>But I agree that this is an annoying side effect of (conf)using abelian groups and Z-modules.</p>



<a name="232705139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705139">(Apr 01 2021 at 05:08)</a>:</h4>
<p>Ok, analyzing this further, in the <code>erw</code> step there are two <code>submodule.coe_smul_of_tower</code>: the first one, changes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">b</span> <span class="n">i</span><span class="o">)</span> <span class="c1">--&gt; g i • ↑(b i)</span>
</code></pre></div>
<p>but the second one, changes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">b</span> <span class="n">i</span><span class="o">)</span> <span class="c1">--&gt; ⇑(algebra_map ℤ ℤ) (g i) • ↑(b i)</span>
</code></pre></div>
<p>maybe this is the issue?</p>



<a name="232705328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705328">(Apr 01 2021 at 05:11)</a>:</h4>
<p>Can this boil down to the non-defeq diamond of the Z-module over itself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">add_comm_group.int_module.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_add_comm_group</span> <span class="n">_</span> <span class="n">int.ring</span><span class="o">)</span> <span class="bp">=</span>
  <span class="bp">@</span><span class="n">semiring.to_semimodule.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">int</span> <span class="n">int.comm_ring</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- unfortunately not rfl right now</span>
</code></pre></div>



<a name="232705406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705406">(Apr 01 2021 at 05:12)</a>:</h4>
<p>Johan, I am trying with your suggestion, but I might be missing an import, since Lean does recognize neither <code>int.module</code> nor <code>ring.to_module</code>!</p>



<a name="232705446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705446">(Apr 01 2021 at 05:13)</a>:</h4>
<p>Yakov, it may be, but I am really not sure what is going on...  Even with the widgets, the pieces of the terms look identical quite a long way down.</p>



<a name="232705492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705492">(Apr 01 2021 at 05:14)</a>:</h4>
<p>Can you try <code>int_module</code> and <code>semiring.to_semimodule</code> instead?</p>



<a name="232705531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705531">(Apr 01 2021 at 05:14)</a>:</h4>
<p>with <code>int_module</code> I still get <code>unknown identifier 'int_module'</code>.</p>



<a name="232705561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705561">(Apr 01 2021 at 05:15)</a>:</h4>
<p>(however, lean recognized <code>semiring.to_semimodule</code>)</p>



<a name="232705658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705658">(Apr 01 2021 at 05:16)</a>:</h4>
<p><code>@add_comm_group.int_module \Z (by apply_instance)</code></p>



<a name="232705782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705782">(Apr 01 2021 at 05:18)</a>:</h4>
<p>Lean considers this a valid statement:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">aux</span> <span class="o">:</span> <span class="bp">@</span><span class="n">add_comm_group.int_module</span> <span class="n">ℤ</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="bp">=</span> <span class="n">semiring.to_semimodule</span><span class="o">,</span>
<span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>



<a name="232705810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705810">(Apr 01 2021 at 05:19)</a>:</h4>
<p><del>But I am not sure how to use it afterwards (nor how to prove it).</del></p>
<p>Johan did say how to prove it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">aux</span> <span class="o">:</span> <span class="bp">@</span><span class="n">add_comm_group.int_module</span> <span class="n">ℤ</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="bp">=</span> <span class="n">semiring.to_semimodule</span> <span class="o">:=</span>
<span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
</code></pre></div>



<a name="232705976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232705976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232705976">(Apr 01 2021 at 05:21)</a>:</h4>
<p>When you get to your seemingly identical goal, <code>convert rfl</code> should work now, hopefully with <code>convert</code> pulling in this hypothesis. Or try <code>simp_rw aux</code> as Johan suggested above.</p>



<a name="232706063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232706063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232706063">(Apr 01 2021 at 05:23)</a>:</h4>
<p>In several files on polyhedral lattices, I disabled the <code>add_comm_group.int_module</code> instance at the top of the file, forcing Lean (and myself) to work explicitly with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-modules.</p>



<a name="232706146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232706146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232706146">(Apr 01 2021 at 05:25)</a>:</h4>
<p>I tried <code>simp_rw at *</code> at each line in the proof, followed by <code>assumption</code>, <code>solve_by_elim</code> or <code>exact ...</code> and it did not seem to work.  I will try with <code>convert rfl</code> now!</p>



<a name="232706282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232706282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232706282">(Apr 01 2021 at 05:27)</a>:</h4>
<p><code>convert rfl</code> either leaves the goal unchanged (at least in the infoview, I did not check if it changed some parts of the terms that is not "just visible"), or it introduces a <code>has_lift_t.lift</code>.</p>



<a name="232706453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232706453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232706453">(Apr 01 2021 at 05:30)</a>:</h4>
<p>I just read Johan's freestyle post: I guess that I am doing the exact opposite here... <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="232706772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232706772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232706772">(Apr 01 2021 at 05:34)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>  do you have this on a branch? I'll take a look</p>



<a name="232707466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232707466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232707466">(Apr 01 2021 at 05:46)</a>:</h4>
<p>If I understand correctly, the issue is the error at this lemma and proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">reduction_to_lattice</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">vn</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s.restrict_scalars</span> <span class="n">ℤ</span> <span class="bp">⊓</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">)),</span>
  <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">vn</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">hind</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">ℤ</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">replace</span> <span class="n">bv</span> <span class="o">:=</span> <span class="n">bv.1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">linear_independent_iff'</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">bv</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">s</span> <span class="n">g</span> <span class="n">hg</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">((</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">gsmul_eq_smul</span><span class="o">,</span> <span class="n">gsmul_eq_smul_cast</span> <span class="n">_</span> <span class="n">_</span><span class="o">]</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">hg'</span> <span class="o">:</span> <span class="n">s.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">))</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">H</span><span class="o">,</span> <span class="n">hg</span><span class="o">]},</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">bv</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="n">hg'</span> <span class="n">i</span> <span class="n">hi</span> <span class="o">},</span>
  <span class="c1">--The RHS seems to be the statement we want, but some work is needed</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">submodule.exists_is_basis_of_le_span</span> <span class="n">hind</span> <span class="n">inf_le_right</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">hb.2</span><span class="o">⟩⟩,</span>
  <span class="n">replace</span> <span class="n">hb</span> <span class="o">:=</span> <span class="n">hb.1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hb</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232707602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232707602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232707602">(Apr 01 2021 at 05:48)</a>:</h4>
<p>Sorry, having breakfast!</p>
<p>Yakov, that is the <del>alto</del> error [weird autocorrect], though!</p>



<a name="232710892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232710892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232710892">(Apr 01 2021 at 06:37)</a>:</h4>
<p>The issue isn't in the <code>int_module</code> but rather <code>int.semiring</code> vs </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>            <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℤ</span>
               <span class="o">(</span><span class="bp">@</span><span class="n">domain.to_ring</span> <span class="n">ℤ</span>
                  <span class="o">(</span><span class="bp">@</span><span class="n">integral_domain.to_domain</span> <span class="n">ℤ</span>
                     <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring.to_integral_domain</span> <span class="n">ℤ</span> <span class="n">int.linear_ordered_comm_ring</span><span class="o">))))</span>
</code></pre></div>
<p>and related</p>



<a name="232711164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711164">(Apr 01 2021 at 06:41)</a>:</h4>
<p>Doing <code>local attribute [-instance] int.semiring int.ring int.comm_semiring</code> results in the following diamond as an issue:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>           <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℤ</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">domain.to_ring</span> <span class="n">ℤ</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">integral_domain.to_domain</span> <span class="n">ℤ</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring.to_integral_domain</span> <span class="n">ℤ</span> <span class="n">int.linear_ordered_comm_ring</span><span class="o">))))</span>
</code></pre></div>
<p>vs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>           <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℤ</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">ordered_ring.to_ring</span> <span class="n">ℤ</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_ring.to_ordered_ring</span> <span class="n">ℤ</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring.to_linear_ordered_ring</span> <span class="n">ℤ</span> <span class="n">int.linear_ordered_comm_ring</span><span class="o">))))</span>
</code></pre></div>



<a name="232711165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711165">(Apr 01 2021 at 06:41)</a>:</h4>
<p>Ok, this is now not so much about this special case, but in general, does it mean that there is a missing instance somewhere?  A missing proof?  What constitutes a "good, structural way" of fixing these issues?</p>



<a name="232711340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711340">(Apr 01 2021 at 06:44)</a>:</h4>
<p>So, should Lean be forbidden to use that <code>int</code> is an integral domain?</p>



<a name="232711350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711350">(Apr 01 2021 at 06:44)</a>:</h4>
<p>Although in a mathlib repo I have, it seems</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℤ</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">domain.to_ring</span> <span class="n">ℤ</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">integral_domain.to_domain</span> <span class="n">ℤ</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring.to_integral_domain</span> <span class="n">ℤ</span> <span class="n">int.linear_ordered_comm_ring</span><span class="o">))))</span> <span class="bp">=</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">ℤ</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">ordered_ring.to_ring</span> <span class="n">ℤ</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_ring.to_ordered_ring</span> <span class="n">ℤ</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">linear_ordered_comm_ring.to_linear_ordered_ring</span> <span class="n">ℤ</span> <span class="n">int.linear_ordered_comm_ring</span><span class="o">))))</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>works fine</p>



<a name="232711487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711487">(Apr 01 2021 at 06:46)</a>:</h4>
<p>I copy pasted your <code>example</code> in the file that I have with the convoluted proof and Lean accepts it there as well.</p>



<a name="232711504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711504">(Apr 01 2021 at 06:47)</a>:</h4>
<p>OK so one can see the issue earlier in the gordon lemma proof</p>



<a name="232711518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711518">(Apr 01 2021 at 06:47)</a>:</h4>
<p>Consider this tactic step:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">refine</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">hb.2</span><span class="o">⟩⟩,</span>
</code></pre></div>



<a name="232711537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711537">(Apr 01 2021 at 06:47)</a>:</h4>
<p>Switching it to just</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">refine</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
</code></pre></div>



<a name="232711558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711558">(Apr 01 2021 at 06:47)</a>:</h4>
<p>We can see a difference between the hypothesis <code>hb</code> and the goal</p>



<a name="232711562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711562">(Apr 01 2021 at 06:47)</a>:</h4>
<p><a href="/user_uploads/3121/CyPZVBVaJjs-c6jK-ttWOaq5/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/CyPZVBVaJjs-c6jK-ttWOaq5/image.png" title="image.png"><img src="/user_uploads/3121/CyPZVBVaJjs-c6jK-ttWOaq5/image.png"></a></div>



<a name="232711613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711613">(Apr 01 2021 at 06:48)</a>:</h4>
<p><a href="/user_uploads/3121/mTA0--7o4mxWRMkiy9YUI-Zc/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/mTA0--7o4mxWRMkiy9YUI-Zc/image.png" title="image.png"><img src="/user_uploads/3121/mTA0--7o4mxWRMkiy9YUI-Zc/image.png"></a></div>



<a name="232711651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711651">(Apr 01 2021 at 06:48)</a>:</h4>
<p>I see: <code>ordered_ring</code> vs <code>domain</code>.</p>



<a name="232711683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711683">(Apr 01 2021 at 06:49)</a>:</h4>
<p>Right. So why is it unhappy? And, even though it is unhappy, is there a way to get the <code>exists_is_basis_of_le_span</code> to use the "correct" <code>ring</code> as a workaround?</p>



<a name="232711688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711688">(Apr 01 2021 at 06:49)</a>:</h4>
<p>It is funny, but in the other stuff that I was doing in a similar vein, I had separate assumptions:</p>
<ul>
<li>one to work with <code>regular</code> elements (close to integrality conditions) and</li>
<li>one with non-negative stuff (close to orders).</li>
</ul>
<p>I am impressed that Lean picks up on this also in this case!</p>



<a name="232711769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711769">(Apr 01 2021 at 06:50)</a>:</h4>
<p>One issue with <code>exists_is_basis_of_le_span</code> as it is right now is there is a free metavariable</p>



<a name="232711808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711808">(Apr 01 2021 at 06:51)</a>:</h4>
<p>So, are you suggesting that an <code>@</code> and underscore-fest might solve this?</p>



<a name="232711815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711815">(Apr 01 2021 at 06:51)</a>:</h4>
<p>Specifically, which <code>submodule \Z V</code> is on the left of the <code>\inf</code>.</p>



<a name="232711818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711818">(Apr 01 2021 at 06:51)</a>:</h4>
<p>Could be? I'm not sure yet.</p>



<a name="232711906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711906">(Apr 01 2021 at 06:53)</a>:</h4>
<p>Let me try to work this out.</p>



<a name="232711964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232711964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232711964">(Apr 01 2021 at 06:54)</a>:</h4>
<p>(Just an observation -- you found the source of the integral_domain: it is the assumption coming from <code>exists_is_basis_of_le_span</code>!)</p>



<a name="232712217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712217">(Apr 01 2021 at 06:57)</a>:</h4>
<p>I am tempted to say that it is this one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">submodule.restrict_scalars</span> <span class="n">ℤ</span> <span class="n">s</span>
</code></pre></div>



<a name="232712272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712272">(Apr 01 2021 at 06:58)</a>:</h4>
<p>What about that submodule?</p>



<a name="232712296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712296">(Apr 01 2021 at 06:58)</a>:</h4>
<p>I think that this is the submodule that is implicit, no?</p>



<a name="232712317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712317">(Apr 01 2021 at 06:59)</a>:</h4>
<p>Yes, that's right. I'm just trying to slay little things that might get in the way, process of elimination</p>



<a name="232712536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712536">(Apr 01 2021 at 07:01)</a>:</h4>
<p>There is indeed a hidden goal, after the <code>obtain</code> step: there are three goals after it, but only two need to be proven, since one disappears.  I think that it disappears when Lean realizes that the module is what I wrote above.  At least, this is my interpretation!</p>



<a name="232712663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712663">(Apr 01 2021 at 07:02)</a>:</h4>
<p>Yes, agreed. I am still not sure why the <code>integral_domain &gt; domain &gt; ring &lt; comm_ring &lt; integral_domain</code> diamond seems to be getting in the way</p>



<a name="232712695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232712695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232712695">(Apr 01 2021 at 07:03)</a>:</h4>
<p>(that is, even after getting rid of the other ring instances)</p>



<a name="232714180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714180">(Apr 01 2021 at 07:18)</a>:</h4>
<p>I see that you are playing with more or less what I did yesterday (with a far better understanding  :)<br>
I don't know if this is relevant, but my first attempt to prove the proposition was to start like this (before realizing there is <code>submodule.exists_is_basis_of_le_span</code>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">reduction_to_lattice</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">vn</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s.restrict_scalars</span> <span class="n">ℤ</span> <span class="bp">⊓</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">)),</span>
  <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">vn</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">w</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">Λ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="n">submodule.subset_span</span> <span class="o">(</span><span class="n">set.mem_range_self</span> <span class="n">_</span><span class="o">)⟩,</span>
  <span class="k">have</span> <span class="n">hind</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">ℤ</span> <span class="n">w</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">--this is OK</span>
  <span class="k">have</span> <span class="n">hbasis</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">is_basis_span</span> <span class="n">hind</span><span class="o">,</span> <span class="c1">--this is not OK</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232714235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714235">(Apr 01 2021 at 07:19)</a>:</h4>
<p>Actually, the proof feels like it could be simply:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">convert</span> <span class="n">submodule.exists_is_basis_of_le_span</span>
    <span class="o">((</span><span class="kd">by</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="n">_</span> <span class="n">bv.1</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">ab</span> <span class="o">}))</span> <span class="o">(</span><span class="bp">@</span><span class="n">inf_le_right</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">submodule.restrict_scalars</span> <span class="n">ℤ</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
</code></pre></div>



<a name="232714344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714344">(Apr 01 2021 at 07:20)</a>:</h4>
<p>So my idea was to prove that <code>Λ</code> is free, the basis should of course be <code>w</code>. Now, proving that <code>w</code> is linear independent is easy... but I wasn't able to prove that it is a spanning set, and if you try you see immediately what goes wrong.</p>



<a name="232714384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714384">(Apr 01 2021 at 07:21)</a>:</h4>
<p>since the resulting goal of this looks like the equality of two "identical" terms: the only apparent difference seems to be the choice of symbol for the <code>exists</code> variable.</p>



<a name="232714612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714612">(Apr 01 2021 at 07:23)</a>:</h4>
<p>Ah there is another difference</p>



<a name="232714615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714615">(Apr 01 2021 at 07:23)</a>:</h4>
<p>This is all very weird and I am getting the impression that the difficulty is generated by working with "explicit" types, like ℤ and ℚ.</p>



<a name="232714617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714617">(Apr 01 2021 at 07:23)</a>:</h4>
<p>Not sure if it is a meaningful one</p>



<a name="232714683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232714683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232714683">(Apr 01 2021 at 07:24)</a>:</h4>
<p><code>submodule.has_inf</code> vs <code>semilattice_inf.to_has_inf (submodule ℤ V)</code></p>



<a name="232715158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232715158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232715158">(Apr 01 2021 at 07:29)</a>:</h4>
<p>Those are also <code>rfl</code> =/</p>



<a name="232715405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232715405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232715405">(Apr 01 2021 at 07:31)</a>:</h4>
<p>Hmm, I have a feeling that these "just work" since they are contained in the part that "disappears" in the proof.  I take this to mean that Lean correctly understand what we are saying and moves on, right?</p>



<a name="232716190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232716190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232716190">(Apr 01 2021 at 07:39)</a>:</h4>
<p>Do you have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> of what goes wrong, hopefully just mathlib dependent but otherwise I'll clone LTE?</p>



<a name="232716515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232716515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232716515">(Apr 01 2021 at 07:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.free_module</span>

<span class="kd">lemma</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="n">M</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">R</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hinj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">))</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">li</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">S</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linear_independent</span> <span class="n">R</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">linear_independent_iff'.mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">g</span> <span class="n">hg</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">hinj</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">ring_hom.map_zero</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
  <span class="n">refine</span> <span class="o">(((</span><span class="bp">@</span><span class="n">linear_independent_iff'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">li</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">algebra_map_smul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hg</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℚ</span> <span class="n">v</span><span class="o">)</span>
<span class="kn">include</span> <span class="n">bv</span>
<span class="kd">lemma</span> <span class="n">reduction_to_lattice</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">vn</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s.restrict_scalars</span> <span class="n">ℤ</span> <span class="bp">⊓</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">)),</span>
  <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">vn</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">submodule.exists_is_basis_of_le_span</span>
    <span class="o">((</span><span class="kd">by</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="n">_</span> <span class="n">bv.1</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">ab</span> <span class="o">}))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">inf_le_right</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">submodule.restrict_scalars</span> <span class="n">ℤ</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">hb</span> <span class="c1">-- :C</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232716614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232716614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232716614">(Apr 01 2021 at 07:43)</a>:</h4>
<p>Alternatively, you could also hope to finish the proof earlier:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">reduction_to_lattice</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℚ</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">vn</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s.restrict_scalars</span> <span class="n">ℤ</span> <span class="bp">⊓</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">)),</span>
  <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">vn</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">submodule.exists_is_basis_of_le_span</span>
    <span class="o">((</span><span class="kd">by</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="n">_</span> <span class="n">bv.1</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">ab</span> <span class="o">}))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">inf_le_right</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">submodule.restrict_scalars</span> <span class="n">ℤ</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refl</span><span class="o">,</span> <span class="c1">-- does not work</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232716807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232716807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232716807">(Apr 01 2021 at 07:45)</a>:</h4>
<p>Thanks!</p>



<a name="232717218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232717218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232717218">(Apr 01 2021 at 07:49)</a>:</h4>
<p>First comment: it's probably coming from <code>add_comm_group.int_module</code>, which is not defeq to other int actions. Indeed, if you disable it with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">add_comm_group.int_module</span>
</code></pre></div>
<p>at the start of your mwe, then Lean does not understand the statement of the second lemma any more. So it has to be used somewehere.</p>



<a name="232720785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232720785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232720785">(Apr 01 2021 at 08:24)</a>:</h4>
<p>Here is a working proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.free_module</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">add_comm_group.int_module</span>

<span class="kd">lemma</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="o">{</span><span class="n">R</span> <span class="n">S</span> <span class="n">M</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">R</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hinj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">S</span><span class="o">))</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">li</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">S</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linear_independent</span> <span class="n">R</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">linear_independent_iff'.mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">g</span> <span class="n">hg</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">hinj</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">ring_hom.map_zero</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
  <span class="n">refine</span> <span class="o">(((</span><span class="bp">@</span><span class="n">linear_independent_iff'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">li</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">algebra_map_smul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hg</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">ℤ</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℚ</span> <span class="n">v</span><span class="o">)</span>
<span class="kn">include</span> <span class="n">bv</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">lemma</span> <span class="n">reduction_to_lattice</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℚ</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">vn</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s.restrict_scalars</span> <span class="n">ℤ</span> <span class="bp">⊓</span> <span class="n">submodule.span</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">v</span><span class="o">)),</span>
  <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">vn</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">A</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ab</span><span class="o">,</span> <span class="n">int.cast_inj.mp</span> <span class="n">ab</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">algebra_map.injective.linear_independent</span> <span class="n">A</span> <span class="n">bv.1</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">submodule.exists_is_basis_of_le_span</span> <span class="n">B</span> <span class="o">(</span><span class="bp">@</span><span class="n">inf_le_right</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">submodule.restrict_scalars</span> <span class="n">ℤ</span> <span class="n">s</span><span class="o">)</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">convert</span> <span class="n">hb</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I disabled <code>add_comm_group.int_module</code>, and instead assumed <code>[semimodule ℤ V] 
[is_scalar_tower ℤ ℚ V]</code> to make sure that we did not use the bad int module structure, and instead used a generic one.</p>
<p><em>But</em>: the proof is way too slow (62s on my computer), so this is not acceptable.</p>



<a name="232721106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232721106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232721106">(Apr 01 2021 at 08:27)</a>:</h4>
<p>Thanks Sébastien!  This is looking much better (albeit slow) now!</p>
<p>While we are at it, I wanted your <code>A</code> statement to be already in mathlib, but I could not find it: is it hiding in there somewhere?</p>
<p>[Also, on my computer the proof is so slow that it times out...]</p>



<a name="232722152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232722152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232722152">(Apr 01 2021 at 08:37)</a>:</h4>
<p>Yes, the proof is clearly wrong now. I'm not able to find the culprit for now, sorry...</p>



<a name="232722898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232722898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232722898">(Apr 01 2021 at 08:44)</a>:</h4>
<p>Even <code>convert hb using 1</code> takes time (essentially the same amount of time as far as I can see).</p>



<a name="232723948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232723948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232723948">(Apr 01 2021 at 08:55)</a>:</h4>
<p>Minimal diamond:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.free_module</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">algebra.id</span> <span class="n">ℤ</span> <span class="bp">=</span> <span class="n">algebra_int</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
</code></pre></div>
<p>both instances are registered in mathlib.</p>



<a name="232724109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232724109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232724109">(Apr 01 2021 at 08:56)</a>:</h4>
<p>I tried turning <code>-instance algebra_int</code> off but that hadn't helped in my experiments.</p>



<a name="232724877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232724877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232724877">(Apr 01 2021 at 09:03)</a>:</h4>
<p>We need a better way to deal with these "initial objects"</p>



<a name="232724878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232724878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232724878">(Apr 01 2021 at 09:03)</a>:</h4>
<p>The thing is that these instances are used in other files when defining various objects, so it is already too late. Maybe changing <code>algebra.id</code> to something nicer would help (expanding the fields instead of relying on an abstract construction).</p>



<a name="232796868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232796868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232796868">(Apr 01 2021 at 17:47)</a>:</h4>
<p>I played a little bit more with this. My conclusion is that "Yury's rule of thumb" for decidable instances should also apply in this situation. We need to find a better name for this rule, but it amounts to: "in a context where there is a subsingleton with data, and several natural instances of it which are not defeq, then mention the instance explicitly in theorems that use it".</p>
<p>As <span class="user-mention" data-user-id="310045">@Eric Wieser</span>  has pointed out several times, we are exactly in this situation here. For instance, if <code>E</code> and <code>F</code> are two <code>add_comm_group</code>, then they are both <code>ℤ</code>-modules, and then you get two non-defeq <code>ℤ</code> module instances on <code>E x F</code>, the one coming from the <code>add_comm_group</code> instance and the one coming from the module product instance. And there is no way to make these defeq. </p>
<p>A solution is to <em>not</em> register <code>add_comm_group.nat_semimodule</code> as a global instance, and only use it when needed in proofs, and use suitable typeclass assumptions in statements. (Or register it as a global instance, but only once we are sure that it's not used in statements, and only to make it available for proofs -- this could probably be enforced by a linter). I had a go at refactoring mathlib along these lines, to see how things go. The good news is that, with this refactor, the above problem in this thread completely disappears, i.e., no need for <code>convert</code> or whatever. And a few proofs that were painful because of instance mismatch become smoother. The bad news is that I'm not done fixing it, because there are many places where the previous instance is used. My work in progress is in the branch <a href="https://github.com/leanprover-community/mathlib/tree/gsmul_instance">branch#gsmul_instance</a>, if anyone wants to have a look/fix a few proofs.</p>



<a name="232799711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232799711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232799711">(Apr 01 2021 at 18:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> thanks a lot for all your debugging, and your efforts for refactoring!</p>



<a name="232799796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232799796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232799796">(Apr 01 2021 at 18:06)</a>:</h4>
<p>I'm coming around to these ideas of disabling these global instances</p>



<a name="232800113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232800113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232800113">(Apr 01 2021 at 18:09)</a>:</h4>
<p>Sébastien, thank you so much for looking into this!  I am only superficially following the discussion, but I find it interesting to see how much I am used to abuse notations and definitions and how Lean picks up on it!</p>



<a name="232804481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232804481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232804481">(Apr 01 2021 at 18:38)</a>:</h4>
<p>Another option would be to use <code>gsmul</code> and <code>nsmul</code> in lemma statements, and convert to smul and back inside the lemma</p>



<a name="232804824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232804824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232804824">(Apr 01 2021 at 18:41)</a>:</h4>
<p>The problem with <code>gsmul</code> and <code>nsmul</code> is that all the linear algebra lemmas do not apply (for instance, when you want to use the fact that a linear map satisfies <code>f (c • v) = c • f v</code>, this won't work out of the box for <code>gsmul</code>). So they are really a pain to use together with linear algebra.</p>



<a name="232808302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232808302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232808302">(Apr 01 2021 at 19:04)</a>:</h4>
<p>Somehow, in LTE we're in this weird limbo, where we use additive group homomorphisms, but also scalar multiplication.</p>



<a name="232808436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232808436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232808436">(Apr 01 2021 at 19:05)</a>:</h4>
<p>And one of my reasons is extremely mundane: the notation for scalar multiplication is just nicer than <code>gsmul/nsmul</code>. And at the same time the notation for group homs looks better than that for linear maps (especially if you are just working with <code>Z</code>-modules anyway).</p>



<a name="232821738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232821738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232821738">(Apr 01 2021 at 20:41)</a>:</h4>
<p>I've uploaded here<br>
<a href="https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/towards_Gordan.lean</a><br>
a proof of <code>pre_generators_finite</code>. I am little tired to golf it, but as usual if someone wants to play with it no problem.</p>
<p>The idea of the proof is very simple: the function <code>i</code> takes a pre_generator <code>g</code> and sends it to the set <code>t</code> of the definition. Since <code>t ⊆ s</code> and <code>s</code> is finite, it is enough to prove that <code>i</code> is injective. The mathematical proof is between the lines <code>197</code> and <code>218</code>. The rest of the proof is me fighting against <code>classical.some</code> and the fact that to use <code>fintype.of_injective</code> the codomain of <code>i</code> must be <code>set s</code>, but morally the "true" codomain, where it's easier to work, is <code>set M</code>.</p>



<a name="232822045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232822045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232822045">(Apr 01 2021 at 20:43)</a>:</h4>
<p>Note that here the problem is my inexperience, Lean seems innocent.</p>



<a name="232827797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232827797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232827797">(Apr 01 2021 at 21:29)</a>:</h4>
<p>What I am still confused/surprised about is that surely all of these issues were experienced by people using Coq or Agda or UniMath or whatever?</p>



<a name="232831639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232831639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232831639">(Apr 01 2021 at 22:04)</a>:</h4>
<p>Do you have to say fintype? Or can you just prove set.finite pre_generators f s when set.finite s?</p>



<a name="232831674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232831674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232831674">(Apr 01 2021 at 22:05)</a>:</h4>
<p>Because you get noncomputable fintype from set.finite anyway</p>



<a name="232831696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232831696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232831696">(Apr 01 2021 at 22:05)</a>:</h4>
<p>And then you don't have to juggle sort coercions</p>



<a name="232832298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232832298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232832298">(Apr 01 2021 at 22:11)</a>:</h4>
<p>I don't know, <span class="user-mention" data-user-id="321459">@Damiano Testa</span> wrote the statement and I didn't want to modify it... my current goal is just to get familiar with convex geometry in Lean</p>



<a name="232859264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232859264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232859264">(Apr 02 2021 at 04:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/232831639">said</a>:</p>
<blockquote>
<p>Do you have to say fintype? Or can you just prove set.finite pre_generators f s when set.finite s?</p>
</blockquote>
<p>That sounds like it might help. (But I haven't looked at the code yet.)</p>



<a name="232862020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232862020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232862020">(Apr 02 2021 at 05:23)</a>:</h4>
<p>I have not finished writing a full proof, so the stuff in <code>towards_Gordan</code> is still subject to change.  However, I try to give indications of what is important in each statement in the doc-strings above each lemma.  If a change in an assumption makes the proof simpler, and leaves the statement "essentially the same", feel free to go for it!</p>
<p>Some of these statements might have to be changed anyways, since I decided to go for a full <code>sorry</code>-explosion, rather than figuring out what the best way of doing things is step-by-step.</p>



<a name="232862109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232862109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232862109">(Apr 02 2021 at 05:24)</a>:</h4>
<p>What I do try, though, is to make the statements "true": hopefully this also makes them provable!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="232864238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232864238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232864238">(Apr 02 2021 at 06:02)</a>:</h4>
<p>Also, the reason I used <code>fintype</code> is because I read somewhere that <code>fintype</code>s were easier than <code>finset</code>s.  If <code>set.finite</code> is even easier, then I would probably change finiteness assumptions everywhere to <code>set.finite</code>!</p>



<a name="232864792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232864792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232864792">(Apr 02 2021 at 06:11)</a>:</h4>
<p>My understanding is that the power of <code>finset</code> and <code>fintype</code> is their computability. If you're going to already mark it as <code>noncomputable</code>, then you can make your statements be about <code>set.finite</code> because of <a href="https://leanprover-community.github.io/mathlib_docs/find/set.finite.fintype">docs#set.finite.fintype</a>, which will give you a noncomputable fintype anyway</p>



<a name="232864857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232864857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232864857">(Apr 02 2021 at 06:12)</a>:</h4>
<p>Because <code>set.finite s</code> is just <code>nonempty (fintype s)</code></p>



<a name="232865213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232865213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232865213">(Apr 02 2021 at 06:18)</a>:</h4>
<p>Ok, from <code>nonempty (fintype s)</code> I would deduce that <code>s</code> is going to be <code>non-empty</code>?  I am not sure if I like this: I am usually careful about including the empty set in my statements, excluding it only when the statement is false for the empty set.  The possibility of having an empty set is often simplifying for proofs.</p>



<a name="232865247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232865247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232865247">(Apr 02 2021 at 06:19)</a>:</h4>
<p>Ah, maybe the <code>nonempty</code> is simply the assertion that there is a <code>fintype</code> structure on <code>s</code>, possibly with <code>s</code> being the empty <code>finset</code>?</p>



<a name="232865643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232865643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232865643">(Apr 02 2021 at 06:24)</a>:</h4>
<p>You don't have to unfold what <code>set.finite</code> is to prove things about it, which is what's nice. I don't know if the relevant lemmas get easier to prove in that API. But I'd think anything that can be proven about fintype implying fintype should be easier across set.finite, and if it isn't, then that's missing API.</p>



<a name="232866132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866132">(Apr 02 2021 at 06:33)</a>:</h4>
<p>Ok, I will try to replace <code>fintype</code> with <code>set.finite</code>!</p>



<a name="232866472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866472">(Apr 02 2021 at 06:38)</a>:</h4>
<p>So, the expectation is that this statement</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fg_with_basis</span> <span class="o">(</span><span class="n">vm</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_full_on</span> <span class="n">f</span> <span class="n">v</span> <span class="n">vm</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">vm</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">N</span><span class="o">,</span> <span class="n">set.finite</span> <span class="n">g</span> <span class="bp">∧</span> <span class="n">dual_set</span> <span class="n">nat_submodule</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">submodule.span</span> <span class="n">ℕ</span> <span class="n">g</span> <span class="o">:=</span>
</code></pre></div>
<p>should be easier than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fg_with_basis</span> <span class="o">(</span><span class="n">vm</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_full_on</span> <span class="n">f</span> <span class="n">v</span> <span class="n">vm</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">vm</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">N</span><span class="o">,</span> <span class="n">dual_set</span> <span class="n">nat_submodule</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">submodule.span</span> <span class="n">ℕ</span> <span class="n">g</span> <span class="o">:=</span>
</code></pre></div>
<p>right?  (The only intended difference is in the properties of the asserted existence of <code>g</code>.)</p>



<a name="232866508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866508">(Apr 02 2021 at 06:39)</a>:</h4>
<p>Yeah, possibly</p>



<a name="232866533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866533">(Apr 02 2021 at 06:40)</a>:</h4>
<p>Ok, I pushed the change.</p>
<p>Thanks!</p>



<a name="232866605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866605">(Apr 02 2021 at 06:40)</a>:</h4>
<p>As long as it is not likely harder, I am happy to go with whatever!</p>



<a name="232866614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866614">(Apr 02 2021 at 06:40)</a>:</h4>
<p>And something like this (if one really wanted to refactor the lemma):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pre_generators_finite</span> <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">pre_generators</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
</code></pre></div>



<a name="232866664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866664">(Apr 02 2021 at 06:41)</a>:</h4>
<p>Ah, I used</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pre_generators_finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">fs</span> <span class="o">:</span> <span class="n">set.finite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">set.finite</span> <span class="o">(</span><span class="n">pre_generators</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>which should simply be your version, without taking advantage of dot-notation, right? <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="232866723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866723">(Apr 02 2021 at 06:42)</a>:</h4>
<p>(There is an <code>include bv</code> in the file that I am using.)</p>



<a name="232866737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866737">(Apr 02 2021 at 06:42)</a>:</h4>
<p>Yeah. For example, this is the goal after these steps</p>



<a name="232866753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866753">(Apr 02 2021 at 06:43)</a>:</h4>
<p>(However, I suspect that <code>bv</code> plays no role in the proof.)</p>



<a name="232866779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866779">(Apr 02 2021 at 06:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pre_generators_finite</span> <span class="o">(</span><span class="n">bv</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">ℤ</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">pre_generators</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">pre_generators</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">submodule.ext'_iff</span><span class="o">,</span> <span class="n">set.ext_iff</span><span class="o">,</span> <span class="n">submodule.mem_coe</span><span class="o">,</span> <span class="n">mem_dual_set</span><span class="o">],</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  {c : N |</span>
<span class="cm">    (∀ (m : M), m ∈ s → ⇑(⇑f m) c ∈ nat_submodule) ∧</span>
<span class="cm">    ∃ (t : set M) (H : t ⊆ s), ∀ (x : N),</span>
<span class="cm">      (∀ (m : M), m ∈ {1, -1} • t → ⇑(⇑f m) x ∈ nat_submodule) ↔ x ∈ submodule.span ℕ {c}}.finite</span>
<span class="cm">  -/</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232866864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866864">(Apr 02 2021 at 06:44)</a>:</h4>
<p>In my version, the <code>simp_rw submodule.ext'_iff</code> does not work:</p>



<a name="232866870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866870">(Apr 02 2021 at 06:45)</a>:</h4>
<p>Then you can use things like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">refine</span> <span class="n">set.finite.subset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.inter_subset_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
</code></pre></div>
<p>to prove finiteness solely on the right hand side of the condition, if that is sufficient</p>



<a name="232866890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866890">(Apr 02 2021 at 06:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">simplification</span> <span class="kd">lemma</span> <span class="bp">'</span><span class="n">submodule.ext'_iff'</span> <span class="o">(</span><span class="n">use</span> <span class="n">command</span> <span class="bp">'</span><span class="kd">set_option</span> <span class="n">trace.simp_lemmas</span> <span class="n">true'</span> <span class="n">for</span> <span class="n">more</span> <span class="n">details</span><span class="o">)</span>
</code></pre></div>



<a name="232866926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866926">(Apr 02 2021 at 06:45)</a>:</h4>
<p>which branch are you on?</p>



<a name="232866973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232866973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232866973">(Apr 02 2021 at 06:46)</a>:</h4>
<p>I am on <code>toric</code>, the one that I just pushed.</p>



<a name="232867343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232867343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232867343">(Apr 02 2021 at 06:51)</a>:</h4>
<p>Ok, looking at the proof that Riccardo wrote, I think that it should make use of <code>is_cyclic</code>.  This probably means that I should change the definition of pre_generators.  This will probably make the coercion to type of a set simpler, by going via a subtype instead.</p>



<a name="232867419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232867419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232867419">(Apr 02 2021 at 06:52)</a>:</h4>
<p>However, I will not have time to do this before Monday: I have some non-Lean Easter plans!</p>



<a name="232867450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232867450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232867450">(Apr 02 2021 at 06:53)</a>:</h4>
<p>Thank you all for your feedback: I really have the impression that we are making good progress on Gordan's lemma!</p>



<a name="232867684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232867684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232867684">(Apr 02 2021 at 06:57)</a>:</h4>
<p>The <code>ext'_iff</code> lemma is now a part of <code>set_like</code> after a refactor</p>



<a name="232867785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232867785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232867785">(Apr 02 2021 at 06:59)</a>:</h4>
<p>Now it would be <code>  simp_rw [@set_like.ext_iff (submodule ℕ N) N]</code></p>



<a name="232872035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232872035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232872035">(Apr 02 2021 at 07:58)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> If you happy with <code>set.finite</code> I can do it.</p>



<a name="232872088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232872088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232872088">(Apr 02 2021 at 07:59)</a>:</h4>
<p>BTW I use <code>bv</code> to prove that <code>M</code> is torsion free.</p>



<a name="232877508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232877508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232877508">(Apr 02 2021 at 09:07)</a>:</h4>
<p>I think that the version that I pushed to <code>toric</code> has <code>set.finite</code> and also your proof of the reduction to Z.</p>
<p>I need to think about <code>bv</code>: I did not think that it was needed, but it is an important assumption for the final result anyway!</p>



<a name="232878718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232878718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232878718">(Apr 02 2021 at 09:22)</a>:</h4>
<p>My mathematical proof is the following: I have to prove that a pre_generator <code>g</code> is determined by the subset <code>t</code> of the definition. If <code>g₁</code> and <code>g₂</code> are associated to the same subset, then <code>submodule.span ℕ {g₁} = submodule.span ℕ {g₂}</code>, by definition. So there are <code>a b : ℕ</code> such that <code>g₁ = a • g₂</code> and <code>g₂ = b • g₁</code> so <code>g₁ = a • b • g₁ = (a * b) • g₁</code>.  Now I want <code>a * b = 1</code> (or <code>g₁ = 0</code>), and here is where I used torsion freeness.</p>



<a name="232885298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232885298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232885298">(Apr 02 2021 at 10:43)</a>:</h4>
<p>I pushed to <code>toric</code> the new proof of <code>pre_generators_finite</code>. It is indeed better then before. For some reason I am not able to define <code>i</code> using <code>if</code> <code>then</code> <code>else</code> and so I did it in tactic mode.</p>



<a name="232903782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232903782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232903782">(Apr 02 2021 at 14:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/232796868">said</a>:</p>
<blockquote>
<p>A solution is to <em>not</em> register <code>add_comm_group.nat_semimodule</code> as a global instance, and only use it when needed in proofs, and use suitable typeclass assumptions in statements. (Or register it as a global instance, but only once we are sure that it's not used in statements, and only to make it available for proofs -- this could probably be enforced by a linter). I had a go at refactoring mathlib along these lines, to see how things go. The good news is that, with this refactor, the above problem in this thread completely disappears, i.e., no need for <code>convert</code> or whatever. And a few proofs that were painful because of instance mismatch become smoother. The bad news is that I'm not done fixing it, because there are many places where the previous instance is used. My work in progress is in the branch <a href="https://github.com/leanprover-community/mathlib/tree/gsmul_instance">branch#gsmul_instance</a>, if anyone wants to have a look/fix a few proofs.</p>
</blockquote>
<p>I have worked a bit more on this. Now, I am stuck in Witt vectors, where there is a tactic to be adjusted and I don't know anything about tactics. Or maybe set a global instance for all these files. An expert look would be most welcome :-)</p>



<a name="232909098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232909098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232909098">(Apr 02 2021 at 15:04)</a>:</h4>
<p>Never mind, problem solved :-)</p>



<a name="232936857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232936857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232936857">(Apr 02 2021 at 18:46)</a>:</h4>
<p>Wow, I'm glad it is already solved! Otherwise, I would certainly have tried to help.</p>



<a name="232936884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232936884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232936884">(Apr 02 2021 at 18:46)</a>:</h4>
<p>I feel somewhat responsible for maintaining Witt vectors (-;</p>



<a name="232944375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232944375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232944375">(Apr 02 2021 at 19:57)</a>:</h4>
<p>Riccardo, this is also more or less what I had in mind and it is certain sufficient for the application to Gordan's lemma.  You could probably get away without <code>bv</code>, observing that a cyclic <code>nat</code> module has finitely many generators (1, if it is infinite and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi (n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> if it has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> elements).  However, it might be better to observe that there are finitely many subsets that produce a cyclic module and bypass the second issue altogether!</p>



<a name="232944412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232944412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232944412">(Apr 02 2021 at 19:57)</a>:</h4>
<p>Well, not everything is solved in the Witt vectors part yet, which is probably the most painful part for now :-) I wanted to see how much work it would be to make the change, and it is much more than I expected -- which is a sign that mathlib is now pretty big, in fact big enough that such refactors become nontrivial.</p>



<a name="232983465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232983465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232983465">(Apr 03 2021 at 05:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> I think I figured out how to fix the tactic in Witt vectors</p>



<a name="232983476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232983476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232983476">(Apr 03 2021 at 05:44)</a>:</h4>
<p>You need an extra <code>intro</code> to take care of the <code>algebra</code> instance.</p>



<a name="232984204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232984204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232984204">(Apr 03 2021 at 06:01)</a>:</h4>
<p>I've pushed a bunch of fixes. We need to add an instance <code>algebra int (zmod n)</code>. I haven't done that yet, but it should fix the remaining problems (I hope!)</p>



<a name="232984519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/232984519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#232984519">(Apr 03 2021 at 06:08)</a>:</h4>
<p>Pushed that instance for <code>zmod</code>, let's see what CI thinks of it.</p>



<a name="233966679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233966679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233966679">(Apr 10 2021 at 15:58)</a>:</h4>
<p>OK I am trying to get on top of this Gordan's Lemma thing. As far as I can see, in <code>master</code> we have a file <code>toric/lem97.lean</code> which contains a complete proof of Lemma 9.7 of <code>analytic.pdf</code> modulo </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">explicit_gordan</span> <span class="o">(</span><span class="n">h</span><span class="bp">Λ</span> <span class="o">:</span> <span class="n">finite_free</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">Λ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">explicit_dual_set</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>Here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span> is a finite free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module, and<code>explicit_dual_set l</code> is the sub-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>-module of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Λ</mi><mo>∗</mo></msup><mo>:</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Λ</mi><mo separator="true">,</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda^*:=Hom(\Lambda,\Z)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord">Λ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mclose">)</span></span></span></span> consisting of things which pair to something non-negative with the image of <code>l</code>; the claim is that it's finitely-generated as an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>-module. Clearly <code>explicit_gordan</code> is what we should be aiming for.</p>
<p>I've been trying to make some sense of the <code>toric</code> branch, which right now contains quite a lot of what seems to me to be dead code and commented code. I've made a couple of recent commits to this branch adding some docstrings, although right now it seems to me like the branch is more like an experimental playground rather than something which will ultimately be merged into <code>master</code> -- which is fine, we have branches of mathlib which are like this, and when stuff is working then it gets migrated into new branches which get PR'ed. I'm kind of guessing that this is the plan here too.</p>
<p>What I cannot extract from this branch right now is where we are going. I talked to Damiano yesterday and my understanding is that the formalisation of the proof of Gordan's Lemma is going on in the file <code>toric.towards_Gordan</code> on the <code>toric</code> branch. I note with a little concern that it's not actually proving the precise statement which we need in <code>lem97</code> though, and sometimes glue is harder than you think. But my main concern is that I cannot see the wood for the trees right now and if I don't know what we're formalising then it's hard to jump in.</p>
<p>So I propose making a mini-blueprint to explain where we're going. There are a whole bunch of comments in <code>toric.towards_Gordan</code> which Damiano said might help but right now they're not enough for me (I don't know much at all about toric geometry though).</p>
<p>I have uploaded a file <code>toric/gordan_blueprint.tex</code> to the <code>toric</code> branch, which right now is a bunch of questions about stuff on the <code>toric</code> branch and nowhere near a mathematical proof. If someone (<span class="user-mention" data-user-id="321459">@Damiano Testa</span> or <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> or <span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span>  -- you seem to be the active contributors to this branch) can perhaps turn this tex sketch into a mathematical proof -- forget the formalisation for now -- then we can perhaps decide how best to formalise it. Is there a proof you guys have in mind?</p>



<a name="233967233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233967233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233967233">(Apr 10 2021 at 16:06)</a>:</h4>
<p>I've just googled around a bit. Is the idea that we're formalising the "topological proof" in <a href="https://en.wikipedia.org/wiki/Gordan%27s_lemma">Wikipedia</a>?</p>



<a name="233969467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233969467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233969467">(Apr 10 2021 at 16:44)</a>:</h4>
<p>I'm not entirely sure I understand the Wikipedia proof right now. Is it using some result of the form "double dual of a fg cone (:= <code>nnreal</code>-submodule) in a real vector space is itself? Or maybe "dual of an fg cone is fg"? Are these things obvious?</p>



<a name="233969559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233969559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233969559">(Apr 10 2021 at 16:45)</a>:</h4>
<p>Dear Kevin,</p>
<p>thank you very much for your effort!  I am not sure that I will have time to work on this right now, but I will take a serious look next week.</p>
<p>I have been making PRs to mathlib as I was going along, to move the more "stable" part.  For this reason, the stuff left in <code>toric</code> is less coherent.  I have started making the file <code>towards_Gordan</code> with the idea of making it a path towards a proof of Gordan's lemma, but I feel that it became "public"  a little too early.</p>
<p>I have had conversations with Johan about the "glue" and he also agreed that what will come out of the <code>toric</code> branch should be easily converted to what is the explicit Gordan statement.  I was trying to prepare the <code>towards_Gordan</code> file to a level that was usable to someone who did not know the proof of Gordan's lemma, but, given Kevin's unsuccessful effort, I am not done doing it!</p>



<a name="233969661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233969661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233969661">(Apr 10 2021 at 16:46)</a>:</h4>
<p>Yes, the proof that I am formalising is close to the topological proof in wikipedia.  I gave a <em>very</em> rough outline of the main steps in a conversation with Peter, let me fetch it!</p>



<a name="233969715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233969715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233969715">(Apr 10 2021 at 16:47)</a>:</h4>
<p>This is an outline:</p>
<p><a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/232555538">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/toric/near/232555538</a></p>



<a name="233970180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970180">(Apr 10 2021 at 16:54)</a>:</h4>
<p>What is an "octant" and what is an "extremal ray"?</p>



<a name="233970236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970236">(Apr 10 2021 at 16:54)</a>:</h4>
<p>"Octant" (in a vector space/Z-module) is the set of all vectors with non-negative coordinates, with respect to a basis.</p>



<a name="233970315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970315">(Apr 10 2021 at 16:56)</a>:</h4>
<p>In the Lean formalization is what I would have called <code>pointed</code>, except that you noticed that the definition was not correct.  Luckily, I had not started using this.  The good thing about "octants" (or <code>nat</code>-submodules of octants), is that they have finitely many extremal rays. (Which I am now going to define.)</p>



<a name="233970390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970390">(Apr 10 2021 at 16:56)</a>:</h4>
<p>An extremal ray is a one-dimensional subcone of a cone with the property that is <code>c d</code> are in the cone and <code>c + d</code> is in the extremal ray, then <code>c</code> and <code>d</code> are actually already in the extremal ray.</p>



<a name="233970477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970477">(Apr 10 2021 at 16:58)</a>:</h4>
<p>In intuitive terms, extremal rays are the "edges" of the cone.</p>
<p>What should be proved is that the elements of the cone are in the convex hull of the extremal rays... up to saturation.  Thus, we should prove that there are finitely many extremal rays <em>and</em> that the saturation only adds finitely many more elements.</p>



<a name="233970530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970530">(Apr 10 2021 at 16:59)</a>:</h4>
<p>Finite generation of extremal rays follows from the fact that extremal rays are correspond to what is called, I think, pre_generators in <code>toric</code> (the relationship between extremal rays and pre_generators needs to be proven).</p>



<a name="233970547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970547">(Apr 10 2021 at 16:59)</a>:</h4>
<p>(pre_generators being finite is "easy" and, if I remember correctly, already proven, in some form.)</p>



<a name="233970709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970709">(Apr 10 2021 at 17:01)</a>:</h4>
<p>Finiteness of saturating elements is the "topological part of the proof: once you have the finitely many generators extremal rays, you are missing the elements inside the cone that are convex combinations of the generators of the extremal rays with non-negative and bounded above real coefficients.</p>



<a name="233970798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233970798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233970798">(Apr 10 2021 at 17:02)</a>:</h4>
<p>Thus, these "new" elements are contained in a compact set (the real combinations) and in a discrete subset (they are in the integral subcone).  Hence there are only finitely many of them.</p>



<a name="233971491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971491">(Apr 10 2021 at 17:13)</a>:</h4>
<p>I'm still trying to get all this stuff straight.</p>
<p>It seems to me that sometimes people talk about real vector spaces and sometimes free Z-modules. As far as I can see we dont need real anything, we can stick to vector spaces over the rationals.</p>
<p>You say that <code>pointed</code> is supposed to be an octant, but you proved that {0} was pointed and in your definition an octant in a real vector space will always be a manifold with dimension the same as that of the underlying space. </p>
<p>Is your definition of extremal ray for Q-vector spaces or Z-modules? What is a "cone"? Are you using the word to mean both a f.g. Q_+-submodule of a Q-module and a f.g. N-submodule of a Z-module? I'm sorry for all the questions, I really think we need to be very precise about these things though. If sub-N-modules of Z-modules can be cones, are they all saturated or not?</p>
<p>"What should be proved is that the elements of the cone are in the convex hull of the extremal rays.." -- I don't even know now whether you're over Q or over Z.</p>
<p>Can you be more precise about all of this? I am still struggling to understand the precise definitions of everything.</p>



<a name="233971581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971581">(Apr 10 2021 at 17:14)</a>:</h4>
<p>Can we prefix everything with Q- or Z-? Are Z-cones by definition finitely generated? Are they saturated?</p>



<a name="233971614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971614">(Apr 10 2021 at 17:15)</a>:</h4>
<p>Ok, the reason I was being a little sloppy is that we definitely need to have these notions interacting nicely with <code>nat</code>- <code>int</code>- <code>rat</code>- and (to a <em>much</em> lesser extent) <code>real</code>.</p>



<a name="233971635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971635">(Apr 10 2021 at 17:15)</a>:</h4>
<p>Let me answer more in detail your questions.</p>



<a name="233971777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971777">(Apr 10 2021 at 17:17)</a>:</h4>
<p>First, "octant" is what I said before its Lean formalisation.  As you remark, is always "of the top dimension".  Cones inside an octant, though, need not have that dimension: as you say, <code>0</code> is a cone inside any octant and is therefore pointed.</p>



<a name="233971866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971866">(Apr 10 2021 at 17:18)</a>:</h4>
<p>The Lean formalization of <code>pointed</code> is more general.  Since I want to be able to convert between various coefficients, let me give a few types, with their standard interpretation.</p>



<a name="233971908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971908">(Apr 10 2021 at 17:19)</a>:</h4>
<p>There are three main "coefficient" types: <code>N</code>, <code>Z</code>, <code>Q</code>.  I will let you guess what they are in the standard application.</p>



<a name="233971934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233971934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233971934">(Apr 10 2021 at 17:19)</a>:</h4>
<p>The only tricky one is that, at one point, we will want to allow <code>Q</code> to be the reals, but for the most part (and, really, even in the last step) we can always get away with the rationals.</p>



<a name="233972111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972111">(Apr 10 2021 at 17:22)</a>:</h4>
<p>The three types <code>N</code>, <code>Z</code> and <code>Q</code> are ordered semirings, they form a <code>scalar_tower</code> of <code>algebra</code>s, the elements of <code>N</code> are "nonnegative" in <code>Q</code> and you can also assume that <code>algebra_map R S</code> is injective (cf <code>is_inj_nonneg</code>).</p>



<a name="233972181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972181">(Apr 10 2021 at 17:22)</a>:</h4>
<p>Cones, refers to a <code>submodule.span N s</code>, where <code>s</code> is a subset of a <code>Q</code>-module.</p>



<a name="233972366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972366">(Apr 10 2021 at 17:25)</a>:</h4>
<p>Extremal rays are one-dimensional subcones of a <code>pointed</code> cone (not really sure whether we want the definition to also apply to non-pointed stuff).  Thus, we reduce from a general cone (which could be the <code>nat</code>-span of <code>1, -1</code> inside <code>rat</code>, i.e. <em>not</em> a <code>pointed</code> cone), to a <code>pointed</code> cone, by "splitting in halfs and combining".</p>



<a name="233972432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972432">(Apr 10 2021 at 17:26)</a>:</h4>
<p>Before I describe this process more in detail, let me explain how you "construct" cones.</p>



<a name="233972447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972447">(Apr 10 2021 at 17:26)</a>:</h4>
<p>This is via the <code>dual_set</code> process.</p>



<a name="233972575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972575">(Apr 10 2021 at 17:28)</a>:</h4>
<p>For duals, the setup is that there are two <code>Q</code>-modules <code>M</code> and <code>N</code> and a bilinear <code>pairing</code>, typically denoted by <code>f</code>, mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">M \times N \to Q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span></span></span></span>.</p>



<a name="233972754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972754">(Apr 10 2021 at 17:31)</a>:</h4>
<p>A <code>dual_set</code> is "essentially" a cone: given a subset <code>s</code> of <code>M</code>, the corresponding <code>dual_set</code> is the set of all elements of <code>N</code> that have non-negative pairing with <code>s</code>.</p>



<a name="233972825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972825">(Apr 10 2021 at 17:32)</a>:</h4>
<p>A <code>dual_set</code> is automatically an <code>N</code>-submodule and it is also automatically saturated.</p>



<a name="233972853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233972853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233972853">(Apr 10 2021 at 17:32)</a>:</h4>
<p>Thus, the statement of Gordan's lemma (if I have not missed anything) is as follows:</p>



<a name="233973358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973358">(Apr 10 2021 at 17:40)</a>:</h4>
<p>(I noticed now the clash in notation <code>N</code> refers to the natural numbers look-alike as well as the <code>Q</code>-module: I will try to use latex font <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> for the module.)</p>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> be <code>Q</code>-modules, <em>with a fixed finite basis</em>.  The basis is important, since we are going to talk about "integral" (resp. "non-negative") elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> and  and they are the <code>Z</code>- (resp. <code>N</code>-)linear combinations of the elements of the basis.</p>
<p>Assume that the pairing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111111111111111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"></mspace><mi>M</mi><mo>×</mo><mi>N</mi><mo>→</mo><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">f \colon M \times N \to \mathbb{Q}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span> is "perfect" (what we really want is that every element of the linear dual of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is represented by pairing with some element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>).</p>
<p>Start with a finite set <code>s</code> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>.<br>
The <code>dual_set</code> of <code>s</code> is an <code>N</code>-submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>.  The "integer" elements of this submodule admit a finite generating set, of course as an <code>N</code>-module, which is the only thing that type-checks.</p>



<a name="233973401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973401">(Apr 10 2021 at 17:41)</a>:</h4>
<p>I hope that this clarifies a bit more your doubts.  I might have missed some further confusion: please, ask again, if there are unclear points!!</p>



<a name="233973602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973602">(Apr 10 2021 at 17:44)</a>:</h4>
<p>Ah, there was the issue of finite generation of cones: they need not be, and we are exactly trying to prove that <em>some</em> cones are finitely generated.</p>
<p>Also, cones are <code>N</code>-spans of stuff: they might be <code>Z</code>-spans, for instance if you use a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo></mrow><annotation encoding="application/x-tex">\pm</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">±</span></span></span></span>-symmetric generating set, but they need not be.</p>



<a name="233973612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973612">(Apr 10 2021 at 17:44)</a>:</h4>
<p>Cones need not be saturated, but the ones that arise from <code>dual_set</code> automatically are.</p>



<a name="233973674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973674">(Apr 10 2021 at 17:45)</a>:</h4>
<p>Also, cones with finitely many extremal rays <em>need not</em> be finitely generated: this is why the fact that the ones arising as <code>dual_set</code> are <em>automatically saturated</em> is important.</p>



<a name="233973821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973821">(Apr 10 2021 at 17:47)</a>:</h4>
<p>Finally, a comment about the reals: the whole proof can take place with rational coefficients.  The only "real" input is in proving that the set of integral vectors inside the span of finitely many vectors with coefficients in <code>[0, 1]</code> is finite.  The "easy" way is to use real coefficients, the set of linear combinations is compact, the set of integer vectors is discrete, hence the intersection is finite.</p>



<a name="233973883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233973883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233973883">(Apr 10 2021 at 17:48)</a>:</h4>
<p>Of course, you do not "need" real combinations, but it is convenient to have them.  Thus, working with a more "generic" type of coefficients is probably a better idea.</p>



<a name="233974146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233974146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233974146">(Apr 10 2021 at 17:53)</a>:</h4>
<blockquote>
<p>"What should be proved is that the elements of the cone are in the convex hull of the extremal rays.." -- I don't even know now whether you're over Q or over Z.</p>
</blockquote>
<p>In the "maths world" we should prove that the elements of the <code>dual_set</code> that happen to have integer coordinates are non-negative rational linear combinations of elements of the extremal rays.  Of course, such combinations will <em>not</em> all be integrals, but some will and all those that are rationals we want to take.  Once we have this "non-negative rational generating set" for our dual cone, we start worrying about generating over the naturals.  For that, we use the integral generators of the extremal rays as a first guess.  These are finitely many, by some result that is "almost" formalized.  Now the issue is just one of saturation: every integral element of the cone has a positive natural multiple that is a natural-linear combination of these generators of the extremal rays.  Thus, we want to "divide" by these multiples.</p>



<a name="233974461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233974461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233974461">(Apr 10 2021 at 17:59)</a>:</h4>
<p>An example to keep in mind is the cone generated by <code>(1,0), (1,2)</code>.  The background basis is the standard one <code>(1,0), (0,1)</code>: integral refers to integral linear combinations of these last two elements.</p>
<p>The extremal rays are the non-negative (rational or natural, not especially important) multiples of the two given vectors <code>(1,0), (1,2)</code>.</p>
<p>The non-negative rational linear combinations of the vectors <code>(1,0), (1,2)</code> contain the integer vector <code>(1,1)</code>.  However, all natural (or even integer) linear combinations of <code>(1,0), (1,2)</code> have <em>even</em> second coordinate and will therefore not equal <code>(1,1)</code>: there is a hole. </p>
<p>However, <code>2(1, 1) = (1,0) + (1,2)</code> <em>is</em> a non-negative integral combination of <code>(1,0), (1,2)</code>.  We need to saturate.  In this case, it is enough to simply add this vector, to the set of generators of the extremal rays.</p>
<p>In general, we need to show that there are only finitely many holes that we need to take care of, and, after we add them, every remaining integer vector in the cone is also a non-negative integer combination of our finite set.</p>



<a name="233974845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233974845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233974845">(Apr 10 2021 at 18:04)</a>:</h4>
<p>I have not really been working on anything related to Gordan's lemma, only the use of it to derive <code>Lemma 9.7</code>. I see Damiano jumped in, and he certainly has more to say.</p>



<a name="233974862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233974862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233974862">(Apr 10 2021 at 18:05)</a>:</h4>
<p>(deleted)</p>



<a name="233992737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233992737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233992737">(Apr 10 2021 at 22:00)</a>:</h4>
<p>I still don't see the proof we're trying to formalise.  You say "we should prove that the elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mo>∨</mo></msup></mrow><annotation encoding="application/x-tex">S^\vee</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∨</span></span></span></span></span></span></span></span></span></span></span> (in the notation of my TeX file) are nonnegative rational linear combinations of elements of the extremal rays" -- but do you know or have a reference for the maths proof of this?</p>



<a name="233992883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233992883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233992883">(Apr 10 2021 at 22:03)</a>:</h4>
<p>I know all about the example you mention, I already put it in the TeX file. I am hoping that the TeX file can become a document which a mathematician can read, ie which I can read. Right now i can't understand the topological proof in Wikipedia and i can't see a proof in this thread or in the TeX file.</p>



<a name="233992948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233992948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233992948">(Apr 10 2021 at 22:04)</a>:</h4>
<p>My issue with the Wikipedia proof is that it seems to be assuming things about cones which i don't know.</p>



<a name="233993154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/233993154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#233993154">(Apr 10 2021 at 22:07)</a>:</h4>
<p>I don't know where the u_i are coming from in the Wikipedia proof and i don't see where (or if) they're showing up in your proof</p>



<a name="234015981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234015981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234015981">(Apr 11 2021 at 04:56)</a>:</h4>
<p>Dear Kevin,</p>
<p>I am really sorry: I realise that I made the folder <code>toric</code> available too soon.  I did not formalise all the statements that I mentioned above: they have to be formalised, of course, but I have not done it yet.</p>
<p>In particular, as you noticed, the statement that a pointed, closed convex cone is the convex hull of its extremal rays is still far from being formalised.  The "pointer" to this is in the now flawed file <code>dual_extremal_API</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--  The rays of the dual of the set `s` are the duals of the subsets of `s` that happen to be</span>
<span class="sd">cyclic. -/</span>
<span class="kd">def</span> <span class="n">dual_set_rays</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="bp">|</span> <span class="n">r.is_cyclic</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="n">s'</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">f.dual_set</span> <span class="n">P₀</span> <span class="n">s'</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">  We may need extra assumptions for this. -/</span>
<span class="sd">/--  The link between the rays of the dual and the extremal rays of the dual should be the</span>
<span class="sd">crucial finiteness step: if `s` is finite, there are only finitely many `dual_set_rays`, since</span>
<span class="sd">there are at most as many as there are subsets of `s`.  If the extremal rays generate</span>
<span class="sd">dual of `s`, then we are in a good position to prove Gordan's lemma! -/</span>
<span class="kd">lemma</span> <span class="n">dual_set_rays_eq_extremal_rays</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.dual_set_rays</span> <span class="n">P₀</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f.dual_set</span> <span class="n">P₀</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">extremal_rays</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="234016301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234016301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234016301">(Apr 11 2021 at 05:02)</a>:</h4>
<p>This lemma, or a provable version of it, gives the conversion between <code>extremal_rays</code> and <code>dual_set_rays</code>.</p>
<p>I should also at least state that a cone is the span of its <code>extremal_rays</code>, but I have not done this.  Part of the reason is that I would have liked there to be more API available, to make sure that I had not made silly mistakes in the definitions before, and I only wanted to build these lemmas on more solid foundations.</p>
<p>At the moment, I have actually proven too few lemmas about these definitions to be sure that I have not made a mistake.  And, as you pointed out, I <em>have</em> made mistakes!</p>



<a name="234033539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234033539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234033539">(Apr 11 2021 at 10:17)</a>:</h4>
<p>Note that I pushed Damiano a bit to merge <code>toric</code> into master. I think it makes it more visible. I'm sorry for the confusion it created.</p>



<a name="234034307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234034307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234034307">(Apr 11 2021 at 10:30)</a>:</h4>
<p>I am going to write a more complete mathematical version of the proof, which is what I think that Kevin wanted all along: hopefully this will clear out most of the doubts!</p>



<a name="234035056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234035056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234035056">(Apr 11 2021 at 10:42)</a>:</h4>
<p>We're talking privately, trying to put together a mathematical proof, so we can actually understand the magnitude of the task. It seems that the proof Damiano is suggesting right now needs stuff like the Hahn-Banach theorem, the Krein-Milman theorem etc. I am not yet convinced that this is the proof we should be formalising.</p>



<a name="234035081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234035081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234035081">(Apr 11 2021 at 10:43)</a>:</h4>
<p>I think the next step is to establish full details of a mathematical proof, before we can even think about formalising anything.</p>



<a name="234058299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234058299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234058299">(Apr 11 2021 at 16:26)</a>:</h4>
<p>I pushed a slightly more complete version of the Algebraic Wikipedia proof, expanding on what Kevin had written.</p>
<p>I would be happy to hear any comments, try to answer any questions, and clarify any hazy points, if I can!</p>



<a name="234058337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234058337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234058337">(Apr 11 2021 at 16:27)</a>:</h4>
<p>You can find the "algebraic blueprint" in the <code>toric</code> branch, in <code>src/toric/gordan_algebraic_blueprint.tex</code>.</p>



<a name="234058365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234058365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234058365">(Apr 11 2021 at 16:27)</a>:</h4>
<p><del>Ah, I forgot to update the pdf file: is there a way of doing it remotely, or should I push a compiled pdf version of the tex file?</del><br>
I also pushed a version with the pdf file.</p>



<a name="234069614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234069614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234069614">(Apr 11 2021 at 19:30)</a>:</h4>
<p>I am late to the party , I didn't had time this weekend. I didn't work a lot on this, I just killed two random sorry  that seemed doable, without any global strategy. In any case now that my refactoring project is done I can help. I will try to have a close look at the blueprint tomorrow.</p>



<a name="234102197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234102197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234102197">(Apr 12 2021 at 04:35)</a>:</h4>
<p>I pushed a newer version of the <code>algebraic</code> blueprint to the <code>toric</code> branch.  There are no substantial changes, I simply tried to streamline the proof a little bit, and, hopefully, clarified it!</p>



<a name="234102289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234102289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234102289">(Apr 12 2021 at 04:36)</a>:</h4>
<p>Comments are welcome!</p>



<a name="234170339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234170339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234170339">(Apr 12 2021 at 14:38)</a>:</h4>
<p>In the proof of Lemma 3, "...dual  of  a finite subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\ker \varphi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">φ</span></span></span></span>..." should be "...dual  of  a finite subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>φ</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(\ker \varphi)^\ast</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">φ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>...", right?</p>



<a name="234175446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234175446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234175446">(Apr 12 2021 at 15:04)</a>:</h4>
<p>Also, is it clear that "the dual of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\ker \varphi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">φ</span></span></span></span> is the quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Λ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Lambda^\ast</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> by the saturation of the additive subgroup generated by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">φ</span></span></span></span>"?</p>



<a name="234176408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234176408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234176408">(Apr 12 2021 at 15:09)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathrm{ker}\varphi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span></span><span class="mord mathnormal">φ</span></span></span></span> is a saturated submodule, and so a direct factor; hence dualization behaves well</p>



<a name="234176985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234176985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234176985">(Apr 12 2021 at 15:12)</a>:</h4>
<p>Does mathlib have the classification of f.g. modules over PIDs? I guess this is what's eventually used here...</p>



<a name="234177127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234177127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234177127">(Apr 12 2021 at 15:13)</a>:</h4>
<p>Nope, not yet, unfortunately <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="234177148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234177148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234177148">(Apr 12 2021 at 15:13)</a>:</h4>
<p>Not quite, but we know f.g. + torsion-free =&gt; free (and hence f.g. implies free + f.g. torsion); what we don't have right now is classification of f.g. torsion modules. I think what we have should be enough.</p>



<a name="234177174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234177174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234177174">(Apr 12 2021 at 15:14)</a>:</h4>
<p>Or at least that a f.g. torsion free is free</p>



<a name="234177233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234177233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234177233">(Apr 12 2021 at 15:14)</a>:</h4>
<p>I think Patrick finished this recently.</p>



<a name="234178083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234178083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234178083">(Apr 12 2021 at 15:18)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.exists_is_basis">docs#submodule.exists_is_basis</a>. Everything here seems to be torsionfree, so it should be enough</p>



<a name="234178224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234178224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234178224">(Apr 12 2021 at 15:19)</a>:</h4>
<p>Nice!</p>



<a name="234179127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234179127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234179127">(Apr 12 2021 at 15:24)</a>:</h4>
<p>Wait, is this what you want? Seems to me that you want to see that the quotient by <code>ker phi</code> is free.</p>



<a name="234181147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234181147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234181147">(Apr 12 2021 at 15:37)</a>:</h4>
<p>(note that <code>submodule.exists_is_basis</code> is true even without the finite rank assumption)</p>



<a name="234182364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234182364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234182364">(Apr 12 2021 at 15:44)</a>:</h4>
<p>You're right. I don't find that torsion free implies free, but maybe I didn't search enough</p>



<a name="234191666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234191666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234191666">(Apr 12 2021 at 16:44)</a>:</h4>
<p>This is not yet in mathlib. I started to PR preliminaries with <a href="https://github.com/leanprover-community/mathlib/issues/7037">#7037</a> and <a href="https://github.com/leanprover-community/mathlib/issues/7040">#7040</a>, and <a href="https://github.com/leanprover-community/mathlib/issues/7160">#7160</a> is currently under review. Maybe I should have done only one massive PR.</p>



<a name="234191748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234191748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234191748">(Apr 12 2021 at 16:45)</a>:</h4>
<p>If there is a urgent need I can also create a file in the liquid repository.</p>



<a name="234200645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234200645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234200645">(Apr 12 2021 at 17:45)</a>:</h4>
<p>With respect to the saturation of kernels, I think that this is already formalised.  Ot at least it is close to being formalised and might be within easy reach in the case of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>-modules.</p>



<a name="234200873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234200873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234200873">(Apr 12 2021 at 17:46)</a>:</h4>
<p>Patrick, I do not think that this is urgent.  There is some more stuff that needs doing that does not depend on this, and we can always merge your unmerged branches into <code>lean-liquid</code>.  It will probably be easy to adapt, should there be changes in the statements.</p>



<a name="234201288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234201288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234201288">(Apr 12 2021 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I corrected some mini typos in the blueprint.</p>
<p>What is the status of Theorem 2 in Lean? If not already done it seems a good subproject, that can be done independently of Gordan's lemma</p>



<a name="234201634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234201634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234201634">(Apr 12 2021 at 17:52)</a>:</h4>
<p>I will take a look now: I have been out all day and have a few things to catch up, so I may be a little slow in replying!</p>



<a name="234202067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234202067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234202067">(Apr 12 2021 at 17:54)</a>:</h4>
<p>Riccardo, I do not know how much of Theorem 2 is already in mathlib.  However, it will likely need some API developed around it.</p>



<a name="234202120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234202120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234202120">(Apr 12 2021 at 17:55)</a>:</h4>
<p>Here is what I would ideally hope that the API would be able to do:</p>



<a name="234202160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234202160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234202160">(Apr 12 2021 at 17:55)</a>:</h4>
<p>We already have <code>monoid_algebra</code>with an API</p>



<a name="234202388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234202388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234202388">(Apr 12 2021 at 17:56)</a>:</h4>
<p>The ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>M</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[M]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">]</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>-graded, and later we will want to do a Noetherian induction on the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-graded ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.  It would be <em>awesome</em> if we could use a common API for dealing with <em>graded</em> rings/algebra, where the grading is by a more or less arbitrary (abelian) group, additive of multiplicative.</p>



<a name="234202611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234202611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234202611">(Apr 12 2021 at 17:58)</a>:</h4>
<p>Ok, <code>monoid_algebra</code> could work, though I have not worked with it.  Most of the arguments involve decomposing a non-necessarily homogeneous element, into its homogeneous components.  It would be great if the API could make it easy to do this.</p>



<a name="234202653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234202653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234202653">(Apr 12 2021 at 17:58)</a>:</h4>
<p>Possibly in the form of an induction principle or something analogous-</p>



<a name="234203184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234203184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234203184">(Apr 12 2021 at 18:01)</a>:</h4>
<p>I have no idea about graded stuff in mathlib, but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>M</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[M]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">]</span></span></span></span> is in mathlib, and I don't see any problem to state Theorem 2, exactly as in the blueprint (so we don't need any graded ring).</p>



<a name="234203406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234203406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234203406">(Apr 12 2021 at 18:02)</a>:</h4>
<p>I mean, if we want to follow the algebraic proof there are no doubts that Theorem 2 is needed, exactly as it is in the blueprint, right?</p>



<a name="234204217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234204217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234204217">(Apr 12 2021 at 18:07)</a>:</h4>
<p>Yes, the point of the blueprint is that it is supposed to be spelling out exactly what we need to prove precisely the sorried statement in <code>toric.lem97</code>.</p>



<a name="234204569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234204569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234204569">(Apr 12 2021 at 18:09)</a>:</h4>
<p>I need to worry about other things today and tomorrow, but on Wednesday I will get back to this, and in my mind what we need to do with this proof is to pull out more sublemmas, because I think the main argument is too long to be formalised painlessly in Lean -- we will get to that stage where it takes 10 seconds to write every line and this is no fun at all. Right now the two things I can see that we can pull off are Theorem 2, which is already pulled off, and the statement that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span> is a finite free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module then it has a well-defined rank <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(\Lambda)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord">Λ</span><span class="mclose">)</span></span></span></span>, and the theorem that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi mathvariant="normal">Λ</mi><mo>→</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\phi:\Lambda\to\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is non-zero then the kernel of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> is also a finite free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-module, with strictly smaller rank.</p>



<a name="234205002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234205002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234205002">(Apr 12 2021 at 18:12)</a>:</h4>
<p>I completely agree that we need to find as much subgoals as possible. I can work on theorem 2</p>



<a name="234205044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234205044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234205044">(Apr 12 2021 at 18:12)</a>:</h4>
<p>Even using this last result in the main proof will be delicate, because the kernel of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> is a submodule, which we then promote to a module <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Λ</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\Lambda'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, and we will have to move <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>:</mo><mo>=</mo><mi>S</mi><mo>∩</mo><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_0:=S\cap ker(\phi)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span></span></span></span> into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Λ</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\Lambda'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, prove finitely-generated there by induction, and then move the finite generation back to the submodule. This is just the sort of nonsense which is going to make the proof slightly delicate to formalise, but we have seen this kind of argument time and time again and we know it's possible. There is a risk it will make it long though, which is why I think we need to get as much stuff out of the main inductive step as we can.</p>



<a name="234205100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234205100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234205100">(Apr 12 2021 at 18:13)</a>:</h4>
<p>A formal proof of theorem 2 would be very helpful! Thanks!</p>



<a name="234205973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234205973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234205973">(Apr 12 2021 at 18:18)</a>:</h4>
<p>I am also very much hoping that we can extract this argument about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> being finitely-generated over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as a separate lemma, but one will have to be very careful here that the lemma one extracts will actually be applicable in the case that one needs. I would advocate a "top-down" approach here -- this is not particularly fashionable amongst the CS crowd (they are paranoid people) but Johan and I and Patrick and many other mathematicians have been using this approach for a while and as far as I can see it works fine. What I mean here is: just take that sorried Gordan's Lemma in <code>toric.lem97</code> and start to prove it, but sorry <em>everything</em> along the way. For example, say that a free module has a rank, but sorry the definition. Claim that the submodule, when promoted to a module, is free of smaller rank, and sorry the proof. Then write down the grading, prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a subring, sorry the proof it's finitely-generated over the base field, sorry the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, now see if you can use results in the library to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over the base field and check that you can now finish the proof with Theorem 2 (i.e. check that your choice of precise formalisation of Theorem 2 suffices to finish the job).</p>



<a name="234206716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234206716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234206716">(Apr 12 2021 at 18:23)</a>:</h4>
<p>This top-down approach now gives us a whole bunch of sorries (and already what I have said above might expand out into quite a long proof as well). Now we have to decide how to fill in those sorries, and the idea is to try and fill them in with new lemmas rather than solving these goals within this proof we've just written. Then one has to think about precisely the statement of the formalisation of the missing pieces, but because we have this top-down sorried proof, one can take one of the missing pieces (for example some statement that for a Z-graded Noetherian ring, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>), attempt to formalise the statement, and before one even begins to prove it one can check to see if the statement is in the correct form to make it easy to fill in the sorry in the main proof. If it turns out that this makes the main proof even bigger, because there are issues switching from subtypes to types or problems checking that one grading matches with another, or problems because it turns out that there are two different notions of grading, then this is an indication that the formalised statement you have chosen might not be the best one. This way the top-down proof guides us and shows us how to formalise the intermediate statements, meaning that the end result won't have one horrible 300-line argument in it but will instead be a bunch of smaller results which it will be possible to glue together relatively painlessly.</p>



<a name="234207207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207207">(Apr 12 2021 at 18:26)</a>:</h4>
<p>So in fact Riccardo, one answer to your "theorem 2 is needed, exactly as it is in the blueprint" would be this: the blueprint states a mathematical theorem, not a formal Lean theorem. It might be best to start with the big prize, namely the precise sorried statement in the <code>lem97</code> file, and work down from there. You might find for example that ultimately we do not want a statement about <code>monoid_algebra R M</code>, but a statement about a ring which is canonically isomorphic to <code>monoid_algebra R M</code>. If you've gone ahead and formalised Theorem 2 but just for the "concrete" model of <code>monoid_algebra R M</code> in mathlib then you might find that your lemma will not "fill in the hole" that we need it to fill in. So I think that before anything is formalised, now we think we have a mathematical proof, it might be worth starting on the top-down approach.</p>



<a name="234207208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207208">(Apr 12 2021 at 18:27)</a>:</h4>
<p>I must be missing something.... what's theorem 2?</p>



<a name="234207244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207244">(Apr 12 2021 at 18:27)</a>:</h4>
<p>It's in a pdf on the toric branch</p>



<a name="234207256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207256">(Apr 12 2021 at 18:27)</a>:</h4>
<p>Ah ok</p>



<a name="234207301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207301">(Apr 12 2021 at 18:27)</a>:</h4>
<p>(I thought it was theorem n.2 from the blueprint for some value of n...)</p>



<a name="234207302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207302">(Apr 12 2021 at 18:27)</a>:</h4>
<p>It's in <code>src/toric/gordan_algebraic_blueprint.tex</code>.</p>



<a name="234207404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207404">(Apr 12 2021 at 18:28)</a>:</h4>
<p>This is a mini-blueprint for Gordan's Lemma, because we realised that it was more complicated than we originally thought.</p>



<a name="234207484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207484">(Apr 12 2021 at 18:28)</a>:</h4>
<p>It could easily be put into the lean-liquid blueprint, but it will not be difficult to do this later.</p>



<a name="234207972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234207972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234207972">(Apr 12 2021 at 18:32)</a>:</h4>
<p>It says that, for a commutative monoid <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and a nontrivial ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>M</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[M]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">]</span></span></span></span> is finitely generated (as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra) if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is finitely generated as a monoid.</p>



<a name="234208084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234208084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234208084">(Apr 12 2021 at 18:32)</a>:</h4>
<p>Yeah I'm looking at it now...</p>



<a name="234208122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234208122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234208122">(Apr 12 2021 at 18:32)</a>:</h4>
<p>Oh this should totally be doable with current mathlib</p>



<a name="234208233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234208233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234208233">(Apr 12 2021 at 18:33)</a>:</h4>
<p>That's why I am asking if we're sure it is the theorem we need <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="234209829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234209829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234209829">(Apr 12 2021 at 18:44)</a>:</h4>
<p>Yes I'm sure it's doable, but the big question is precisely how to formalise it. This is why I am suggesting that now we think we have a maths proof which should be possible to formalise reasonably (although I have not checked Damiano's argument about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> being finitely-generated over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> yet -- please someone else feel free to do this so we've had more than one pair of eyes on it!) the next step should be to start at the top and replace the one sorry in <code>lem97</code> with a bunch of sorries, thus showing us precisely the form of the sublemmas which we will need. As I've already said, I am concerned that if we prove a result about <code>monoid_algebra</code> then this will not be applicable in the situation we're interested in, and the actual result we need might be a result about an algebra which satisfies the universal property of <code>monoid_algebra</code>. Whether it is easiest to prove <code>monoid_algebra</code> first and deduce the result for the ring isomorphic to <code>monoid_algebra</code> afterwards, or whether it's easier to work with the universal property directly, is something I am not yet clear on. However there is often more than one universal property! We need something which is not too hard to check in the application, but furthermore strong enough to relatively painlessly come up with a unique isomorphism to the concrete <code>monoid_algebra</code> if we decide to formalise the theorem using this concrete model. This is precisely the mistake we made with the first schemes formalisation you see -- we proved a very messy result which involved several rings of the form <code>localisation R S</code> and then we needed to apply it to rings which had the universal property of <code>localisation R S</code> but were not definitionally equal to it, and I had to spend about a week developing tools for diagram chasing along morphisms coming from universal properties and it was no fun at all.</p>



<a name="234210340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234210340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234210340">(Apr 12 2021 at 18:48)</a>:</h4>
<p>If this is helpful, I think that I can extract smaller lemmas from the mathematical proof.</p>



<a name="234210489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234210489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234210489">(Apr 12 2021 at 18:49)</a>:</h4>
<p>Would this be useful?  There are several results that are mentioned as "mathematical one-liners" that I imagine would expand quite a bit when formalized.  If this is helpful, I can start expanding the mathematical proof, by fracturing it more.</p>



<a name="234210554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234210554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234210554">(Apr 12 2021 at 18:49)</a>:</h4>
<p>Also, I would very much welcome someone else looking at the proof!</p>



<a name="234214731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234214731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234214731">(Apr 12 2021 at 19:18)</a>:</h4>
<p>We recently got <a href="https://leanprover-community.github.io/mathlib_docs/find/is_free_group">docs#is_free_group</a></p>



<a name="234214764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234214764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234214764">(Apr 12 2021 at 19:18)</a>:</h4>
<p>I feel like we should add similar classes for all such free constructions (including the monoid algebra)</p>



<a name="234214828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234214828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234214828">(Apr 12 2021 at 19:19)</a>:</h4>
<p>(note the universe restrictions in the definition BTW, along with <a href="https://leanprover-community.github.io/mathlib_docs/find/is_free_group.unique_lift">docs#is_free_group.unique_lift</a> )</p>



<a name="234297514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234297514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234297514">(Apr 13 2021 at 09:54)</a>:</h4>
<p>I started writing at least the statement of theorem 2,  to check if there are results we are missing to prove it, in this form or another.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.monoid_algebra</span>
<span class="kn">import</span> <span class="n">ring_theory.finiteness</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">algebra</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">monoid_alg_ft_iff</span> <span class="o">:</span> <span class="n">finite_type</span> <span class="n">R</span> <span class="o">(</span><span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℕ</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Does someone see a way to use <code> [comm_monoid M]</code> instead of <code> [add_comm_monoid M]</code>? It seems much more natural to me, but then I don't know how to say <code>(⊤ : submodule ℕ M).fg </code>, since a multiplicative monoid is not a <code>ℕ</code>-semimodule, and all the theory of finitely generated stuff in mathlib is for subsemimodules.</p>



<a name="234297918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234297918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234297918">(Apr 13 2021 at 09:57)</a>:</h4>
<p>Hmm, I can use <code>additive M</code>but maybe this will introduce other problems in the proof.</p>



<a name="234298963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234298963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234298963">(Apr 13 2021 at 10:05)</a>:</h4>
<p>If we don't have stuff about finitely generated submonoids, then I don't think we can use multiplicative notation</p>



<a name="234298987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234298987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234298987">(Apr 13 2021 at 10:05)</a>:</h4>
<p>Unless you want to do another huge refactor of mathlib (-;</p>



<a name="234299569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234299569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234299569">(Apr 13 2021 at 10:10)</a>:</h4>
<p>No thanks <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="234316775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234316775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234316775">(Apr 13 2021 at 12:37)</a>:</h4>
<p>I am experimenting a little bit, but maybe the following statement is more reasonable</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">monoid_alg_ft_iff</span> <span class="o">:</span> <span class="n">finite_type</span> <span class="n">R</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span>
  <span class="bp">∃</span> <span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">M</span><span class="o">,</span> <span class="n">submonoid.closure</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
</code></pre></div>



<a name="234317300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234317300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234317300">(Apr 13 2021 at 12:40)</a>:</h4>
<p>I guess that works. But you run the risk that you will have to develop an API for <code>submonoid.fg</code> on the fly.</p>



<a name="234320705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234320705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234320705">(Apr 13 2021 at 13:04)</a>:</h4>
<p>Ok the big work thing I had to do is over and I will be looking at this starting in about an hour. Did anyone begin to flesh out the proof of the sorry in lem97? If not I'll start there. It's time we got Gordan out of the way.</p>



<a name="234328485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234328485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234328485">(Apr 13 2021 at 13:51)</a>:</h4>
<p>I have not looked at the proof of explicit_gordan, but I still think that having graded rings/algebras could be useful for the proof.  At least some primitive form of it.</p>



<a name="234331002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331002">(Apr 13 2021 at 14:05)</a>:</h4>
<p>Yes we absolutely need an API for graded rings here, for example you use all over the place the fact that if A is graded by a cancellative monoid M and if i+j=k is an identity in M and a_i * r = a_k in A with a_i in A_i etc then there's some a_j with a_i * a_j = a_k. We don't want to have to stop what we're doing to justify this sort of stuff. What is the status of M-gradings on A, M a commutative monoid and A a commutative ring? This sounds like something fun to make</p>



<a name="234331187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331187">(Apr 13 2021 at 14:06)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="310045">@Eric Wieser</span> has/had some PRs on gradings on <code>direct_sum _</code>. But we don't have general gradings on general rings, afaik</p>



<a name="234331224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331224">(Apr 13 2021 at 14:07)</a>:</h4>
<p>I agree that it would be fun to make, but I do not know what is available.</p>



<a name="234331416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331416">(Apr 13 2021 at 14:08)</a>:</h4>
<p>My thinking was that a "grading on a ring" is just an isomorphism to a direct sum of submonoids</p>



<a name="234331470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331470">(Apr 13 2021 at 14:08)</a>:</h4>
<p>I remember Eric had something about nat gradings (and I even remember arguing that nat gradings were the place to start) but we need int gradings</p>



<a name="234331603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331603">(Apr 13 2021 at 14:09)</a>:</h4>
<p>and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>-gradings, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an add_monoid, while we are at it?</p>



<a name="234331893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234331893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234331893">(Apr 13 2021 at 14:10)</a>:</h4>
<p>I am pushing for this, since two proofs in the blueprint would benefit from being able to use gradings: the one about the equivalence of fg for an add_monoid and the monoid_algebra, and the one about the Z-gradings</p>



<a name="234332234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234332234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234332234">(Apr 13 2021 at 14:12)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/direct_sum.ring">docs#direct_sum.ring</a> has gradings <del>of</del> by an arbitrary <code>add_monoid</code></p>



<a name="234333154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234333154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234333154">(Apr 13 2021 at 14:18)</a>:</h4>
<p>What we're missing is something like the statement</p>
<blockquote>
<p><code>A : ι → monoid R</code> is a gradation of a ring <code>R</code> if <code>complete_lattice.independent (set.range A)</code> and there is a ring_equiv from <code>R</code> to <code>⨁ i, A i</code> whose inverse is roughly <code>direct_sum.to_monoid (λ i, add_submonoid.inclusion $ le_supr A i)</code></p>
</blockquote>



<a name="234334064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234334064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234334064">(Apr 13 2021 at 14:23)</a>:</h4>
<p>I think that the two main properties that should be easily accessible are that</p>
<ul>
<li>every element of the graded ring is a finite sum of homogeneous elements</li>
<li>product of homogeneous elements is homogeneous of degree the sum of the degrees.</li>
</ul>
<p>I imagine that this should form part of the definitions, but I have been wrong about such things in the past!</p>
<p>Having this to hand already goes quite a long way into the proof of the first lemma about monoid generation.</p>
<p>If it is not already in mathlib, it would also be good to extract a lemma that says that if a ring is generated by some set <code>s</code> and some other set <code>t</code> generates the generators, then <code>t</code> also generates.</p>



<a name="234336132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234336132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234336132">(Apr 13 2021 at 14:33)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> what we need right now I think is something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.subring</span>
<span class="kn">import</span> <span class="n">data.finsupp</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">structure</span> <span class="n">grading</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">graded_piece</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span>
<span class="o">(</span><span class="n">independent</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">span</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>
<p>and also a variant for <code>add_comm_monoid</code> (in fact in our application we only need <code>add_comm_monoid</code>). Do we have anything like this? We don't need to build the ring we have it already, we want to impose the grading a posteriori.</p>



<a name="234336514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234336514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234336514">(Apr 13 2021 at 14:35)</a>:</h4>
<p>Kevin, maybe this is implicit, but don't we also want that multiplication between homogeneous pieces maps to the right homogeneous piece?</p>



<a name="234336551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234336551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234336551">(Apr 13 2021 at 14:35)</a>:</h4>
<p>Is it not a requirement for the graded pieces to be closed under addition?</p>



<a name="234336761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234336761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234336761">(Apr 13 2021 at 14:36)</a>:</h4>
<p>hmm :-)</p>



<a name="234337409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234337409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234337409">(Apr 13 2021 at 14:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">grading</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">graded_piece</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">add_subgroup</span> <span class="n">R</span><span class="o">)</span>
<span class="o">(</span><span class="n">grading_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span>
  <span class="n">r</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span>
<span class="o">(</span><span class="n">independent</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">span</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>
<p>?</p>



<a name="234337570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234337570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234337570">(Apr 13 2021 at 14:40)</a>:</h4>
<p>My attempt at my quoted description above is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.complete_lattice</span>
<span class="kn">import</span> <span class="n">algebra.direct_sum_graded</span>
<span class="kn">import</span> <span class="n">algebra.direct_sum</span>

<span class="n">open_locale</span> <span class="n">direct_sum</span>

<span class="kd">def</span> <span class="n">is_gradation</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">add_submonoid</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">complete_lattice.independent</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="bp">∃</span> <span class="n">hone</span> <span class="n">hmul</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">inst</span> <span class="o">:=</span> <span class="n">direct_sum.gmonoid.of_add_submonoids</span> <span class="n">A</span> <span class="n">hone</span> <span class="n">hmul</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">exactI</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">≃+*</span> <span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">),</span>
      <span class="c1">-- this let is here to help the elaborator</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→+</span> <span class="bp">↥</span><span class="o">(</span><span class="bp">⨆</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
        <span class="n">direct_sum.to_add_monoid</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="o">(</span><span class="n">add_submonoid.inclusion</span> <span class="o">(</span><span class="n">le_supr</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">_</span><span class="o">))</span> <span class="k">in</span>
      <span class="n">e.symm.to_add_equiv.to_add_monoid_hom</span> <span class="bp">=</span> <span class="o">(</span><span class="n">add_submonoid.subtype</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span>
</code></pre></div>



<a name="234337704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234337704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234337704">(Apr 13 2021 at 14:41)</a>:</h4>
<p>If the semiring mafia get to this definition then the graded pieces will end up being add_submonoids, but I suspect one can prove they're subgroups from the other axioms if R has subtraction.</p>



<a name="234337864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234337864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234337864">(Apr 13 2021 at 14:42)</a>:</h4>
<p>re syntax error: just end with <code>:= sorry</code></p>



<a name="234337906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234337906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234337906">(Apr 13 2021 at 14:42)</a>:</h4>
<p>Yeah, I worked that out eventually, but what I actually meant was <code>: Prop :=</code></p>



<a name="234337919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234337919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234337919">(Apr 13 2021 at 14:42)</a>:</h4>
<p>... unless of course, the grading does not respect multiplication by <code>-1</code>, if it can! <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="234338296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234338296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234338296">(Apr 13 2021 at 14:44)</a>:</h4>
<p>Damiano, the trick is that if r is in R_m then you write -r as a linear combination of stuff in graded pieces</p>



<a name="234338556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234338556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234338556">(Apr 13 2021 at 14:46)</a>:</h4>
<p>Kevin, is your <code>independent</code> equivalent to <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.indepedent">docs#complete_lattice.indepedent</a>?</p>



<a name="234338630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234338630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234338630">(Apr 13 2021 at 14:46)</a>:</h4>
<p>Ah, I see that now the graded pieces are <code>add_subgroup</code>s: I had missed that!</p>



<a name="234338776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234338776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234338776">(Apr 13 2021 at 14:47)</a>:</h4>
<p>so, yes, of course, the piece that contains <code>1</code> also contains <code>-1</code>!</p>



<a name="234339004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339004">(Apr 13 2021 at 14:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/234338556">said</a>:</p>
<blockquote>
<p>Kevin, is your <code>independent</code> equivalent to <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.independent">docs#complete_lattice.independent</a>?</p>
</blockquote>
<p>Yes.</p>



<a name="234339140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339140">(Apr 13 2021 at 14:49)</a>:</h4>
<p>... and is that easy to prove?</p>



<a name="234339155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339155">(Apr 13 2021 at 14:49)</a>:</h4>
<p>Oh -- at least in the add_subgroup case.</p>



<a name="234339244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339244">(Apr 13 2021 at 14:50)</a>:</h4>
<p>In the add_subgroup case it's easy to prove on paper. Is that what you're asking?</p>



<a name="234339323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339323">(Apr 13 2021 at 14:50)</a>:</h4>
<p>Actually, does it automatically follow that <code>1</code> is homogeneous?  In my mind, I always think that the elements of degree <code>0</code> form a subring: they are clearly a subgroup that is closed under multiplication, but do they have a <code>1</code>?  Is the one of this piece the same as the <code>1</code> of the whole ring?</p>



<a name="234339418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339418">(Apr 13 2021 at 14:51)</a>:</h4>
<p>I've just realized - your version is multiplicatively graded, but <code>direct_sum.ring</code> is additively graded</p>



<a name="234339420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339420">(Apr 13 2021 at 14:51)</a>:</h4>
<p>for safe measure, should we add the axiom that the degree <code>0</code> piece is a subring?</p>



<a name="234339738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339738">(Apr 13 2021 at 14:53)</a>:</h4>
<p>I only care about the case of an <code>add_comm_monoid</code> grading, I went with <code>comm_monoid</code> believing that I could perhaps use <code>to_additive</code> to generate the API for the <code>add_comm_monoid</code> variant (I'm assuming it ignores rings)</p>



<a name="234339862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234339862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234339862">(Apr 13 2021 at 14:53)</a>:</h4>
<p>I was scared of that parenthesized assumption so decided to just focus on the additive case</p>



<a name="234340070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234340070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234340070">(Apr 13 2021 at 14:54)</a>:</h4>
<p>I guess it won't touch the rings but it could well touch the <code>add_subgroup R</code>'s :-/</p>



<a name="234340513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234340513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234340513">(Apr 13 2021 at 14:56)</a>:</h4>
<p>Here's how to mesh Kevin's definition with my direct_sum stuff:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.direct_sum_graded</span>

<span class="n">open_locale</span> <span class="n">direct_sum</span>

<span class="c1">-- modified for additive grading, and a `one` axiom</span>
<span class="kd">structure</span> <span class="n">add_grading</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">graded_piece</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">add_subgroup</span> <span class="n">R</span><span class="o">)</span>
<span class="o">(</span><span class="n">grading_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">grading_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span>
  <span class="n">r</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))</span>
<span class="o">(</span><span class="n">independent</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">span</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">add_grading</span> <span class="n">M</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">g.graded_piece</span> <span class="n">i</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">grading.gmonoid</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">add_grading</span> <span class="n">M</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">direct_sum.gmonoid</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">g.graded_piece</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">direct_sum.gmonoid.of_add_subgroups</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">g.graded_piece</span> <span class="n">i</span><span class="o">)</span> <span class="n">g.grading_one</span> <span class="n">g.grading_mul</span>
</code></pre></div>



<a name="234340585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234340585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234340585">(Apr 13 2021 at 14:56)</a>:</h4>
<p>The reason my <code>independent</code> is the same as <code>complete_lattice.independent</code> is that Sups in the lattice of add_submonids is "add_submonoid generated by", and this is the same as "finite sums of elements in the union". Is that enough of a clue Eric or are you asking for something more formal?</p>



<a name="234340677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234340677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234340677">(Apr 13 2021 at 14:57)</a>:</h4>
<p>My question was less "why is that true" and more "how painful will it be to convince lean that is true"</p>



<a name="234341191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234341191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234341191">(Apr 13 2021 at 14:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/234339420">said</a>:</p>
<blockquote>
<p>for safe measure, should we add the axiom that the degree <code>0</code> piece is a subring?</p>
</blockquote>
<p>This is proven by <a href="https://github.com/leanprover-community/mathlib/issues/6851">#6851</a> using the existing axioms</p>



<a name="234341524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234341524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234341524">(Apr 13 2021 at 15:00)</a>:</h4>
<p>Oh OK. Yeah it might be a bit painful -- we saw this recently with Patrick's challenge the other day. To say "this subgroup A_0 of A has trivial intersection with the subgroup generated by these subgroups A_1, A_2, A_3, ..." is the same as to say "if I have f : nat -&gt;_0 A with f(i) in A_i and the sum of the f(i) is zero, then f(0) must be 0", because f(0) is in both A_0 and the subgroup generated by the A_i for a &gt;= 1 which contains f(1)+f(2)+.... = -f(0). This is why I'm a bit worried about submonoids.</p>



<a name="234341991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234341991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234341991">(Apr 13 2021 at 15:01)</a>:</h4>
<p>I think pretending the semiring mafia will never arrive and using subgroup instead of submonoid is an acceptable approach here</p>



<a name="234343575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234343575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234343575">(Apr 13 2021 at 15:06)</a>:</h4>
<p>But as a wannabe member of the constructivist cartel, I feel like your definition should provide <code>span</code> constructively as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">span</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span> <span class="bp">//</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">graded_piece</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span><span class="o">})</span>
</code></pre></div>
<p>or better</p>



<a name="234344064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234344064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234344064">(Apr 13 2021 at 15:08)</a>:</h4>
<p>Eric, thanks!  I am not able to follow quickly your argument, but it is great that the units line up!</p>



<a name="234344806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234344806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234344806">(Apr 13 2021 at 15:11)</a>:</h4>
<p>By "units" you mean <code>1</code> or "pieces of code from Eric and Kevin"?</p>



<a name="234345603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234345603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234345603">(Apr 13 2021 at 15:14)</a>:</h4>
<p>Eric, I meant the elements <code>1</code> in <code>R</code> and the element <code>1</code> in <code>graded_piece (0 : M)</code>.</p>



<a name="234348192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234348192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234348192">(Apr 13 2021 at 15:28)</a>:</h4>
<p>Note that even without the <code>(1 : R)</code> axiom you can still create an instance of <a href="https://leanprover-community.github.io/mathlib_docs/find/direct_sum.ghas_mul">docs#direct_sum.ghas_mul</a>, which shortly after <a href="https://github.com/leanprover-community/mathlib/issues/6786">#6786</a>  will result in a <code>non_unital_semiring</code> structure on <code>add_grading M R</code></p>



<a name="234349273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234349273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234349273">(Apr 13 2021 at 15:34)</a>:</h4>
<p>Ok, I am happy with that, thanks!  Also, I wanted to make sure that we <em>did not</em> face non-unital rings (even in the degree <code>0</code> graded_piece`), hence my questions!  I would not want to demote these graded rings to graded rngs!</p>



<a name="234362297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234362297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234362297">(Apr 13 2021 at 16:52)</a>:</h4>
<p>Aargh <code>complete_lattice.independent</code> is a statement about subsets and we have a map from a monoid, so for example if the monoid is nontrivial and the map sends every element of the monoid to the same nonzero <code>add_subgroup</code> then they won't be independent in the sense I wrote (and that we need) but they'll be independent in the sense that the range of the function has size 1.</p>



<a name="234362991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234362991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234362991">(Apr 13 2021 at 16:56)</a>:</h4>
<p>Oh, nice catch</p>



<a name="234363022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234363022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234363022">(Apr 13 2021 at 16:57)</a>:</h4>
<p>Just make the function<code>graded_piece</code>  injective?</p>



<a name="234363288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234363288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234363288">(Apr 13 2021 at 16:58)</a>:</h4>
<p>As sanity check I proved the easy implication of theorem 2 of the blueprint, here<br>
<a href="https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean</a></p>



<a name="234363320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234363320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234363320">(Apr 13 2021 at 16:59)</a>:</h4>
<p>Perhaps restating <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.independent">docs#complete_lattice.independent</a> in terms of an indexed collection is a good idea anyway though</p>



<a name="234363421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234363421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234363421">(Apr 13 2021 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/234363320">said</a>:</p>
<blockquote>
<p>Perhaps restating <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.independent">docs#complete_lattice.independent</a> in terms of an indexed collection is a good idea anyway though</p>
</blockquote>
<p>How big of a refactor would this be?</p>



<a name="234363559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234363559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234363559">(Apr 13 2021 at 17:00)</a>:</h4>
<p>BTW, the algebraic geometer in me wants a grading to be a coaction by the coordinate ring of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83889em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">G</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> or something. (not a serious suggestion.)</p>



<a name="234363978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234363978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234363978">(Apr 13 2021 at 17:02)</a>:</h4>
<p>I've no idea how big that refactor would be, but I don't think <code>complete_lattice.independent</code> is used in all that many places yet</p>



<a name="234364021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234364021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234364021">(Apr 13 2021 at 17:02)</a>:</h4>
<p>Mainly just <a href="https://leanprover-community.github.io/mathlib_docs/order/compactly_generated.html">https://leanprover-community.github.io/mathlib_docs/order/compactly_generated.html</a> I think</p>



<a name="234364670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234364670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234364670">(Apr 13 2021 at 17:06)</a>:</h4>
<p>I think the toric people want Z gradings, the projective scheme people want N gradings and in this proof we also want gradings by an arbitrary monoid</p>



<a name="234365090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234365090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234365090">(Apr 13 2021 at 17:09)</a>:</h4>
<p><code>span</code> is just a statement about a Sup</p>



<a name="234365411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234365411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234365411">(Apr 13 2021 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/234364670">said</a>:</p>
<blockquote>
<p>I think the toric people want Z gradings, the projective scheme people want N gradings and in this proof we also want gradings by an arbitrary monoid</p>
</blockquote>
<p>IIRC a grading by a monoid M on an <code>R</code>-algebra is "the same" as a coaction of <code>R[M]</code>?</p>



<a name="234365530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234365530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234365530">(Apr 13 2021 at 17:11)</a>:</h4>
<p>Although this point of view would be hard to formalize for noncommutative monoids (since it involves a tensor product of bialgebras)</p>



<a name="234365532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234365532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234365532">(Apr 13 2021 at 17:11)</a>:</h4>
<p>Aha, this is some monoid scheme maybe</p>



<a name="234365676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234365676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234365676">(Apr 13 2021 at 17:12)</a>:</h4>
<p>Do people grade with noncommutative monoids ever? <span class="user-mention" data-user-id="317890">@Julian Külshammer</span> ?</p>



<a name="234366053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234366053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234366053">(Apr 13 2021 at 17:15)</a>:</h4>
<p>So in terms of lattices this map from a monoid is like a basis -- the Sup of everything is top, and the inf of (one piece) and (the Sup of all the other pieces) is zero. Is that a thing in lattices with a Sup?</p>



<a name="234366147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234366147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234366147">(Apr 13 2021 at 17:15)</a>:</h4>
<blockquote>
<p>Do people grade with noncommutative monoids ever? </p>
</blockquote>
<p>Based on what I found for <a href="https://leanprover-community.github.io/mathlib_docs/find/direct_sum.semiring">docs#direct_sum.semiring</a> (as opposed to <a href="https://leanprover-community.github.io/mathlib_docs/find/direct_sum.comm_semiring">docs#direct_sum.comm_semiring</a>), if your ring is not commutative then you don't need your index set to be either.<br>
Not that that answers the question of whether its useful, just that its easy to generalize to.</p>



<a name="234366392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234366392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234366392">(Apr 13 2021 at 17:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/234366053">said</a>:</p>
<blockquote>
<p>So in terms of lattices this map from a monoid is like a basis -- the Sup of everything is top, and the inf of (one piece) and (the Sup of all the other pieces) is zero. Is that a thing in lattices with a Sup?</p>
</blockquote>
<p>This sounds like some general notion of independence that comes up in matroid theory.</p>



<a name="234366654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234366654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234366654">(Apr 13 2021 at 17:18)</a>:</h4>
<p>Maybe this should move to #maths, this feels much more mathlibby than liquidy</p>



<a name="234375218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234375218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234375218">(Apr 13 2021 at 18:14)</a>:</h4>
<p>I have looked a bit into your discussion, seeing that you're going to attack Gordan. I won't be of great help with the grading mafia but I'd be help to adapt the current proof of <code>lem97</code> to a new statement of <code>explicit_gordan</code>, if you come up with something different from what I used there.</p>



<a name="234375224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234375224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234375224">(Apr 13 2021 at 18:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Is the emphasis on noncommutative or on monoids? There are articles written in my area of research about gradings by non-commutative groups and one definitely wants to consider <code>\N</code>-gradings as well, so grading by possibile non-commutative monoids seems like an obvious choice for me. In most examples people compute the grading is by <code>\N^r</code> or <code>\Z^r</code> or <code>Z/2</code>, but I also don't see why it should be more difficult to formalise a grading by a noncommutative monoid than a commutative monoid. Do you have an example of a basic result which fails?</p>



<a name="234377299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234377299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234377299">(Apr 13 2021 at 18:27)</a>:</h4>
<p>There is also the case of the group algebra of a (finite) group, which is graded by the group itself.</p>



<a name="234578660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234578660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234578660">(Apr 14 2021 at 21:21)</a>:</h4>
<p>I know that we are going to change the statement like 30 times, but I was having too much fun, and here is the proof of theorem2 of the blueprint</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">monoid_alg_ft_iff_fg</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">ℕ</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span> <span class="bp">↔</span> <span class="n">finite_type</span> <span class="n">R</span> <span class="o">(</span><span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>It is in <a href="https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean">https://github.com/leanprover-community/lean-liquid/blob/riccardobrasca/src/toric/theorem2.lean</a></p>



<a name="234578943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234578943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234578943">(Apr 14 2021 at 21:23)</a>:</h4>
<p>I think this might be fine -- we might later on need to apply it to something isomorphic to an add_monoid_algebra, but in this case we just will need to prove things like if A and B are isomorphic R-algebras and A is finite type then so is B.</p>



<a name="234578988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234578988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234578988">(Apr 14 2021 at 21:23)</a>:</h4>
<p>We already have this!</p>



<a name="234579456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234579456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234579456">(Apr 14 2021 at 21:26)</a>:</h4>
<p>In which case I think you've done enough :-) I'm having a lot of fun with gradings, I have achieved far less today than I had hoped but it would still be wonderful to get Gordan done by the end of the week.</p>



<a name="234618893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234618893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234618893">(Apr 15 2021 at 05:21)</a>:</h4>
<p>Kevin, is the definition of grading that you are using the one in<br>
<a href="#narrow/stream/116395-maths/topic/Gradings.20on.20a.20ring/near/234389540">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Gradings.20on.20a.20ring/near/234389540</a></p>
<p>I would be happy to contribute!</p>



<a name="234622761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234622761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234622761">(Apr 15 2021 at 06:19)</a>:</h4>
<p>Right now the technical issue is that there are two ways of saying that R is the direct sum of R_m and these should probably be unified.</p>



<a name="234622820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234622820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234622820">(Apr 15 2021 at 06:20)</a>:</h4>
<p>Ok, if you want, I can try taking care of that.</p>



<a name="234622915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234622915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234622915">(Apr 15 2021 at 06:21)</a>:</h4>
<p>It's pretty gory. I need to do family stuff for another hour and then I'll have time for lean</p>



<a name="234632893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234632893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234632893">(Apr 15 2021 at 07:55)</a>:</h4>
<p>Ok so it looks like Sebastien is fixing the mathlib diamond so I can tell you about gradings. I was going to work on this stuff today (and tomorrow), by the way.</p>
<p>The mathlib branch <code>independent2</code> (which I'm about to PR) contains a definition of what it means for a function f:I -&gt; L (I an abstract type, L a complete lattice) to be "independent" -- it means that the inf of f(i) and (the Sup of the f(j) for j!=i) is bot. In applications, L will be the additive submonoids or subgroups of a ring or semiring, so this just says that f(i) intersect (subgroup generated by f(j) for j != i) is zero.</p>
<p>The mathlib branch <code>grading</code>contains <code>independent2</code> (I merged the independent2 branch into it, even though the independent2 branch isn't in master) and also contains a recent PR of Eric's which defines <code>add_submonoid_is_internal</code>. This is a predicate on maps f : I -&gt; add_submonoid M which says "the induced map from the direct sum of the f(i) to M is a bijection". I've been trying to work with this and it's quite tricky. You can see for example in <code>ring_theory.grading</code> that I have an unfinished proof that R[X] is graded by the naturals and it looks pretty scary to me. Right now I am wondering whether Eric's "the induced map from the direct sum is a bijection" would be easier to work with if we rewrote it in the following way. The bijection is an injection and a surjection. To say that a map from a direct sum of additive abelian submonoids of M to M is injective is, I think, the same as saying that that the function from I to the submonoids is injective as above. Conversely the claim that the map is surjective is just the statement that the Sup of the image is Top (a.k.a. "span"). So right now I was thinking of abandoning my proof and writing more API, saying that <code>direct_sum.add_submonoid_is_internal graded_piece</code> is equivalent to <code>independent</code> + <code>span</code>. </p>
<p>So right now as you can see it's all in quite a state, but I still feel confident that doing these examples (polynomials are graded by nat, monoid algebras are graded by the monoid) are the test cases which need to work before we can start on Gordan -- you can think of them as practice, if you like.</p>



<a name="234633558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234633558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234633558">(Apr 15 2021 at 08:00)</a>:</h4>
<p>Kevin, thanks for the update!  I will try to take a look at grading on polynomials, then!</p>



<a name="234635041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234635041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234635041">(Apr 15 2021 at 08:13)</a>:</h4>
<p>The question is whether we should be continuing to battle through this proof (I think we should <em>not</em>) or whether we should prove that the bijection is an injection and a surjection, and injection is equivalent to <code>independent</code> and surjection equivalent to <code>span</code>.</p>



<a name="234635459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234635459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234635459">(Apr 15 2021 at 08:16)</a>:</h4>
<p>I'll formalise the statement of what I'm thinking of and then push to <code>grading</code>.</p>



<a name="234635570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234635570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234635570">(Apr 15 2021 at 08:17)</a>:</h4>
<p>Ok, thanks a lot!</p>



<a name="234638077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234638077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234638077">(Apr 15 2021 at 08:38)</a>:</h4>
<p>OK I pushed. In the <code>grading</code> branch of mathlib there are a bunch of sorries. My guess is that <code>direct_sum.add_submonoid_is_internal_iff_independent_and_span</code> helps (although it should be broken into two lemmas) with the examples, but I don't know for sure.</p>
<p>Unfortunately, you might have to wait for the oleans, or make them yourself (this is what I have been doing -- I do <code>leanproject get-cache --rev 07614552f6b7157fa5582a8f2a536b390715cb14</code> and then <code>lean --make src/ring_theory/grading.lean</code> on the command line and wait about 5 minutes). Alternatively you can wait a few hours and then <code>leanproject get-cache</code> should work fine.</p>



<a name="234638293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234638293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234638293">(Apr 15 2021 at 08:40)</a>:</h4>
<p>Thanks a lot, Kevin, for <code>grading</code> and for the instructions!</p>



<a name="234669386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234669386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234669386">(Apr 15 2021 at 12:55)</a>:</h4>
<p>You're describing <a href="https://github.com/leanprover-community/mathlib/tree/grading">branch#grading</a> in mathlib not lean-liquid, right?</p>



<a name="234669680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234669680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234669680">(Apr 15 2021 at 12:57)</a>:</h4>
<p>I certainly assumed so: I pulled <code>grading</code> from mathlib.</p>



<a name="234671965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234671965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234671965">(Apr 15 2021 at 13:12)</a>:</h4>
<p>For polynomials i'd expect it's far easier to directly construct the inverse mapping to show bijectivity</p>



<a name="234672276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234672276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234672276">(Apr 15 2021 at 13:14)</a>:</h4>
<p>Which is just "sum <code>direct_sum.of I ⟨monomial i (p.coeff i), sorry⟩</code> over <code>p.support</code>"</p>



<a name="234681118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234681118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234681118">(Apr 15 2021 at 14:04)</a>:</h4>
<p>Can someone put me out of my misery?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.direct_sum</span>
<span class="kn">import</span> <span class="n">data.polynomial.basic</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">def</span> <span class="n">polynomial_equiv</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≃</span>
  <span class="n">direct_sum</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_monoid_hom.mrange</span> <span class="o">(</span><span class="n">monomial</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
<span class="c1">-- error: don't know how to synthesize placeholder</span>
</code></pre></div>
<p>I can't get the equiv to typecheck :-(</p>



<a name="234681486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234681486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234681486">(Apr 15 2021 at 14:06)</a>:</h4>
<p>Oh, I've got it: RHS doesn't know which poly ring. Sorry for the noise.</p>



<a name="234689829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234689829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234689829">(Apr 15 2021 at 14:51)</a>:</h4>
<p>I am going nuts -- I have still not manage to state this equiv :-(</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.direct_sum</span>
<span class="kn">import</span> <span class="n">data.polynomial.basic</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">add_comm_monoid</span> <span class="o">((</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">direct_sum</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span><span class="o">))</span> <span class="bp">→</span>
  <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="n">direct_sum.to_add_monoid</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
      <span class="o">((</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange.subtype</span> <span class="o">:</span>
        <span class="o">((</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">→+</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)))</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  direct_sum.to_add_monoid (λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype)</span>
<span class="cm">term</span>
<span class="cm">  λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype</span>
<span class="cm">has type</span>
<span class="cm">  Π (i : ℕ), ↥((monomial i).to_add_monoid_hom.mrange) →+ polynomial R : Type</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  Π (i : ℕ), ?m_1 i →+ ?m_2 : Type (max ? ?)</span>
<span class="cm">-/</span>
</code></pre></div>
<p>What am I doing wrong?</p>



<a name="234691233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234691233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234691233">(Apr 15 2021 at 14:58)</a>:</h4>
<p>Man, the elaborator is really getting the upper hand on you today</p>



<a name="234692895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234692895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234692895">(Apr 15 2021 at 15:03)</a>:</h4>
<p>My orange bars aren't cooperating so I can't help you yet</p>



<a name="234696458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234696458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234696458">(Apr 15 2021 at 15:18)</a>:</h4>
<p>If you break it into tiny pieces it cooperates:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">monomial_add_monoid_hom</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">monomial</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom</span>

<span class="kd">def</span> <span class="n">direct_sum.submonoids_to_add_monoid</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">add_submonoid</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">))</span> <span class="bp">→+</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">direct_sum.to_add_monoid</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">direct_sum</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">monomial_add_monoid_hom</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">mrange</span><span class="o">))</span> <span class="bp">→+</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">direct_sum.submonoids_to_add_monoid</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">monomial_add_monoid_hom</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">mrange</span><span class="o">)</span>
</code></pre></div>



<a name="234696805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234696805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234696805">(Apr 15 2021 at 15:20)</a>:</h4>
<p>Ah, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">direct_sum</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">((</span><span class="n">monomial</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mrange</span><span class="o">))</span> <span class="bp">→+</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">direct_sum.to_add_monoid</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">monomial</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange.subtype</span><span class="o">)</span>
</code></pre></div>



<a name="234696968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234696968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234696968">(Apr 15 2021 at 15:21)</a>:</h4>
<p>IN fact, it's the <code>⇑</code> causing you all the pain in your example</p>



<a name="234699413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234699413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234699413">(Apr 15 2021 at 15:34)</a>:</h4>
<p>Thanks! I put the <code>⇑</code> in because it wasn't working without it (indeed what I posted doesn't work without the <code>⇑</code> either)</p>



<a name="234699722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234699722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234699722">(Apr 15 2021 at 15:35)</a>:</h4>
<p>Hmm, I see. This is supposed to be a field of an <code>equiv</code>. So I just tell it the type of the add_monoid_hom I guess.</p>



<a name="234700944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234700944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234700944">(Apr 15 2021 at 15:42)</a>:</h4>
<p>My rule of thumb is that one should not put coercion arrows in lemma statements (or function coercion). If a coercion is necessary, it should be notated using typing syntax <code>(_ : _)</code>, and if it is function coercion, just apply as normal</p>



<a name="234703814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234703814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234703814">(Apr 15 2021 at 15:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/234699413">said</a>:</p>
<blockquote>
<p>(indeed what I posted doesn't work without the <code>⇑</code> either)</p>
</blockquote>
<p>It does once you replace the <code>→</code> with <code>→+</code> I think</p>



<a name="234703860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234703860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234703860">(Apr 15 2021 at 15:59)</a>:</h4>
<p>But here's the actual problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.direct_sum</span>
<span class="kn">import</span> <span class="n">data.polynomial.basic</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">def</span> <span class="n">polynomial_equiv</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">polynomial</span> <span class="n">R</span> <span class="bp">≃</span>
  <span class="n">direct_sum</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="n">direct_sum.to_add_monoid</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
      <span class="o">((</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange.subtype</span> <span class="o">:</span>
        <span class="o">((</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">→+</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">))),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="234703958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234703958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234703958">(Apr 15 2021 at 16:00)</a>:</h4>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>type mismatch at application
  direct_sum.to_add_monoid (λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype)
term
  λ (i : ℕ), (monomial i).to_add_monoid_hom.mrange.subtype
has type
  Π (i : ℕ), ↥((monomial i).to_add_monoid_hom.mrange) →+ polynomial R : Type
but is expected to have type
  Π (i : ℕ), ?m_1 i →+ ?m_2 : Type (max ? ?)
</code></pre></div>



<a name="234704268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234704268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234704268">(Apr 15 2021 at 16:01)</a>:</h4>
<p>I got so frustrated with this that I just decided to prove the mem_supr lemmas :-)</p>



<a name="234707053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234707053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234707053">(Apr 15 2021 at 16:17)</a>:</h4>
<p>Why not define it as an add_equiv?</p>



<a name="234707216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234707216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234707216">(Apr 15 2021 at 16:18)</a>:</h4>
<p>all I want to do is to prove that a function is bijective. It seemed to me that defining it as an <code>add_equiv</code> just meant I'd have to prove more things for no reason.</p>



<a name="234708693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234708693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234708693">(Apr 15 2021 at 16:27)</a>:</h4>
<p>Here you go:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.direct_sum</span>
<span class="kn">import</span> <span class="n">data.polynomial.basic</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="n">open_locale</span> <span class="n">direct_sum</span>
<span class="kd">noncomputable theory</span>

<span class="kd">abbreviation</span> <span class="n">monomial.submonoid</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span>

<span class="kd">def</span> <span class="n">polynomial_equiv</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃+</span> <span class="n">polynomial</span> <span class="n">R</span>  <span class="o">:=</span>
<span class="o">{</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">r</span><span class="o">,</span> <span class="n">direct_sum.of</span> <span class="n">_</span> <span class="n">n</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">monomial</span> <span class="n">n</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">d</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">direct_sum.to_add_monoid</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→+</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="234708861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234708861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234708861">(Apr 15 2021 at 16:28)</a>:</h4>
<p>Thanks! I might not get back to this until tomorrow now -- right now I'm struggling with stuff like <code>∏ᶠ (i_1 : ι), ite (i_1 = i) x 1 = x</code></p>



<a name="234712946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234712946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234712946">(Apr 15 2021 at 16:52)</a>:</h4>
<p>Solved:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.direct_sum</span>
<span class="kn">import</span> <span class="n">data.polynomial.basic</span>
<span class="kn">import</span> <span class="n">data.polynomial</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="n">open_locale</span> <span class="n">direct_sum</span>
<span class="kd">noncomputable theory</span>

<span class="kd">abbreviation</span> <span class="n">monomial.submonoid</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span>

<span class="kd">abbreviation</span> <span class="n">monomial.to_submonoid</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange_restrict</span>

<span class="kd">def</span> <span class="n">polynomial_equiv</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃+</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">add_monoid_hom.to_add_equiv</span>
  <span class="o">(</span><span class="n">direct_sum.to_add_monoid</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">(</span><span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span><span class="o">)</span>
  <span class="o">(</span><span class="n">finsupp.lift_add_hom</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">(</span><span class="n">direct_sum.of</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">monomial.to_submonoid</span> <span class="n">R</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">monomial</span><span class="o">],</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="n">r</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">monomial</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">)</span>
</code></pre></div>



<a name="234713062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234713062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234713062">(Apr 15 2021 at 16:52)</a>:</h4>
<p><code>simp ..., refl</code> also known as <code>simpa</code></p>



<a name="234713100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234713100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234713100">(Apr 15 2021 at 16:52)</a>:</h4>
<p><code>simp [monomial]</code> is needed because you're not supposed to use <code>finsupp.lift_add_hom</code> on polynomials</p>



<a name="234716800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234716800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234716800">(Apr 15 2021 at 17:13)</a>:</h4>
<p>oh it doesn't compile for me :-(</p>



<a name="234718255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234718255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234718255">(Apr 15 2021 at 17:22)</a>:</h4>
<p>hmm, works on master, I'll have to merge into my branch.</p>



<a name="234719469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234719469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234719469">(Apr 15 2021 at 17:29)</a>:</h4>
<p>OK great, it works on my branch, now I have to wait for several more hours and then pay some money to download oleans :-/ (my internet is broken right now)</p>



<a name="234734236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234734236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234734236">(Apr 15 2021 at 19:06)</a>:</h4>
<p>To be honest, I do not understand the proof, but is this the same as Eric's proof, except for an <code>add_monoid_algebra</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="n">open_locale</span> <span class="n">direct_sum</span>
<span class="kd">noncomputable theory</span>

<span class="kn">section</span> <span class="n">add_monoid_algebra</span>

<span class="sd">/-- `monomial s a` is the monomial `a * X^s` -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Mm</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">finsupp.lsingle</span> <span class="n">i</span>

<span class="kd">abbreviation</span> <span class="n">monomial.submonoid</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="o">(</span><span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Mm</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange</span>

<span class="kd">abbreviation</span> <span class="n">monomial.to_submonoid</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Mm</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.mrange_restrict</span>

<span class="kd">def</span> <span class="n">polynomial_equiv</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃+</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">add_monoid_hom.to_add_equiv</span>
  <span class="o">(</span><span class="n">direct_sum.to_add_monoid</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">(</span><span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span><span class="o">)</span>
  <span class="o">(</span><span class="n">finsupp.lift_add_hom</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">(</span><span class="n">direct_sum.of</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">monomial.to_submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">Mm</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="n">r</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">Mm</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">add_monoid_algebra</span>
</code></pre></div>



<a name="234736289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234736289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234736289">(Apr 15 2021 at 19:19)</a>:</h4>
<p>Right, a monoid_algebra version is probably sensible</p>



<a name="234736357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234736357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234736357">(Apr 15 2021 at 19:19)</a>:</h4>
<p>You can use finsupp.single_add_hom instead of touching lsingle</p>



<a name="234737218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234737218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234737218">(Apr 15 2021 at 19:24)</a>:</h4>
<p>I have not managed to get <code>finsupp.single_add_hom</code> to work.</p>
<p>However, if I replace randomly <code>add_monoid_algebra</code> with <code>monoid_algebra</code>, not even everywhere, it seems to me that Lean does not complain: is this normal?</p>



<a name="234737240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234737240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234737240">(Apr 15 2021 at 19:24)</a>:</h4>
<p>Am I missing something?</p>



<a name="234738030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738030">(Apr 15 2021 at 19:29)</a>:</h4>
<p>About the <code>finsupp.single_add_hom</code>: I should change the type of <code>Mm (i : M)</code> to be <code>R →+ add_monoid_algebra R M</code>, right?</p>
<p>If I do so, though, the abbreviations are not happy afterwards...</p>



<a name="234738328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738328">(Apr 15 2021 at 19:30)</a>:</h4>
<p>I think actually we want the version relating dfinsupp and finsupp</p>



<a name="234738331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738331">(Apr 15 2021 at 19:30)</a>:</h4>
<p>Got it!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- `monomial s a` is the monomial `a * X^s` -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Mm</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">finsupp.single_add_hom</span> <span class="n">i</span>

<span class="kd">abbreviation</span> <span class="n">monomial.submonoid</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="o">(</span><span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Mm</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mrange</span>

<span class="kd">abbreviation</span> <span class="n">monomial.to_submonoid</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Mm</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">mrange_restrict</span>

<span class="kd">def</span> <span class="n">polynomial_equiv</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨁</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≃+</span> <span class="n">add_monoid_algebra</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">add_monoid_hom.to_add_equiv</span>
  <span class="o">(</span><span class="n">direct_sum.to_add_monoid</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">(</span><span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span><span class="o">)</span>
  <span class="o">(</span><span class="n">finsupp.lift_add_hom</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">(</span><span class="n">direct_sum.of</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">monomial.submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">monomial.to_submonoid</span> <span class="n">R</span> <span class="n">M</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">Mm</span><span class="o">,</span> <span class="n">set_like.coe_mk</span><span class="o">,</span> <span class="n">finsupp.lift_add_hom_apply_single</span><span class="o">,</span> <span class="n">direct_sum.to_add_monoid_of</span><span class="o">,</span>
      <span class="n">add_monoid_hom.coe_comp</span><span class="o">,</span> <span class="n">finsupp.single_add_hom_apply</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span>
      <span class="n">add_submonoid.coe_subtype</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="n">r</span> <span class="o">:</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Mm</span><span class="o">,</span> <span class="n">finsupp.lift_add_hom_apply_single</span><span class="o">,</span> <span class="n">direct_sum.to_add_monoid_of</span><span class="o">,</span>
      <span class="n">add_monoid_hom.coe_mrange_restrict</span><span class="o">,</span> <span class="n">add_monoid_hom.coe_comp</span><span class="o">,</span> <span class="n">finsupp.single_add_hom_apply</span><span class="o">,</span>
      <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">add_submonoid.coe_subtype</span><span class="o">,</span> <span class="n">add_monoid_hom.id_apply</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">)</span>
</code></pre></div>



<a name="234738479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738479">(Apr 15 2021 at 19:31)</a>:</h4>
<p>So replace <code>add_monoid_algebra</code> with <code>finsupp</code>, and <code>direct_sum</code> with <code>dfinsupp</code></p>



<a name="234738481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738481">(Apr 15 2021 at 19:32)</a>:</h4>
<p>In any case, I view this simply as a confirmation that your approach is very robust: I could adapt it to work for the (add_)monoid_graded case, from the polynomial case, without actually understanding how it was working!</p>



<a name="234738558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738558">(Apr 15 2021 at 19:32)</a>:</h4>
<p>Well those types are defeq!</p>



<a name="234738632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738632">(Apr 15 2021 at 19:32)</a>:</h4>
<p>I'll PR a dfinsupp / finsupp version tomorrow</p>



<a name="234738707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234738707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234738707">(Apr 15 2021 at 19:33)</a>:</h4>
<blockquote>
<p>Well those types are defeq!</p>
</blockquote>
<p>Aaah, that explains why Lean simply liked all of it!</p>



<a name="234739170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739170">(Apr 15 2021 at 19:35)</a>:</h4>
<p>If you're looking for practice, we probably want a linear_equiv / submodule version of that def too</p>



<a name="234739279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739279">(Apr 15 2021 at 19:36)</a>:</h4>
<p>I tried to do the replacement <code>finsupp + dfinsupp</code>, but I have failed.  It is also getting late, so I may not give it a go tonight!</p>



<a name="234739327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739327">(Apr 15 2021 at 19:36)</a>:</h4>
<p>The key trick in the proof was to phrase things in a way that ext could pick up</p>



<a name="234739366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739366">(Apr 15 2021 at 19:36)</a>:</h4>
<p>Btw, what is the <code>: 2</code> in ext?</p>



<a name="234739373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739373">(Apr 15 2021 at 19:36)</a>:</h4>
<p>Ie, by solving <code>f.comp f_inv = id</code></p>



<a name="234739396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739396">(Apr 15 2021 at 19:37)</a>:</h4>
<p>"don't expand as far as p.coeff I"</p>



<a name="234739441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739441">(Apr 15 2021 at 19:37)</a>:</h4>
<p>ah, like <code>congr' 2</code>?</p>



<a name="234739457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739457">(Apr 15 2021 at 19:37)</a>:</h4>
<p>It means "apply ext twice"</p>



<a name="234739458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739458">(Apr 15 2021 at 19:37)</a>:</h4>
<p>except with ext?</p>



<a name="234739463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234739463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234739463">(Apr 15 2021 at 19:37)</a>:</h4>
<p>Yes</p>



<a name="234741985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234741985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234741985">(Apr 15 2021 at 19:54)</a>:</h4>
<p>I squeezed the the two <code>simp</code>s to speed up the processing: there is quite a lot of lemmas that show up!</p>



<a name="234742052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234742052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234742052">(Apr 15 2021 at 19:54)</a>:</h4>
<p>Anyway, I'm off for the day!</p>
<p>Kevin and Eric, thanks a lot for gradings!</p>



<a name="234760240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234760240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234760240">(Apr 15 2021 at 21:53)</a>:</h4>
<p>These isomorphisms aren't the end of it, but they're definitely the hardest part. One also needs to check that <code>1</code> and <code>*</code> are well-behaved.</p>



<a name="234760289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234760289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234760289">(Apr 15 2021 at 21:53)</a>:</h4>
<p>For polynomials this was easy. So this looks like it's a workable definition.</p>



<a name="234813787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234813787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234813787">(Apr 16 2021 at 08:20)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7217">#7217</a></p>



<a name="234813928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234813928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234813928">(Apr 16 2021 at 08:22)</a>:</h4>
<p>Typeclass search really wasn't happy here</p>



<a name="234816948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234816948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234816948">(Apr 16 2021 at 08:46)</a>:</h4>
<p>Frustratingly <code>add_monoid_hom.range</code> and <code>add_monoid_hom.mrange</code> are not defeq as types, so probably some refactoring to do before I can get the add_comm_group version easily</p>



<a name="234825583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234825583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234825583">(Apr 16 2021 at 09:54)</a>:</h4>
<p>These two monoid <code>range</code> things can be a bit annoying to work with because the definition always involves having to prove <code>mem_top</code>. <code>set.range</code> does not have this problem.</p>



<a name="234830692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234830692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234830692">(Apr 16 2021 at 10:35)</a>:</h4>
<p>Have a look at <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.range/src">src#add_monoid_hom.range</a>, it solves that problem</p>



<a name="234830904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234830904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234830904">(Apr 16 2021 at 10:37)</a>:</h4>
<p>Once my other two cleanup PRs go though (<a href="https://github.com/leanprover-community/mathlib/issues/7218">#7218</a>, <a href="https://github.com/leanprover-community/mathlib/issues/7220">#7220</a>), I'll see what breaks if we do that everywhere</p>



<a name="234831388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234831388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234831388">(Apr 16 2021 at 10:41)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.range">docs#subgroup.range</a> ?</p>



<a name="234831684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234831684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234831684">(Apr 16 2021 at 10:44)</a>:</h4>
<p>Oops, fixed</p>



<a name="234831758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/234831758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#234831758">(Apr 16 2021 at 10:44)</a>:</h4>
<p>It uses <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.copy">docs#subgroup.copy</a> to make it definitionally useful</p>



<a name="235361769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235361769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235361769">(Apr 20 2021 at 15:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I need some API for <code>finite_free</code>. In <code>polyhedral_lattice.basic</code> you have a <code>move_this</code> section containing the definition. If I remove <code>[semimodule ℤ A]</code> from the definition (<code>A</code> is an <code>add_comm_group</code>) then the <code>combinatorial_lemma</code> file stops compiling: I get an error on line 378 with <code>rw oops</code> failing; <code>oops</code> is a proof of <code>@polyhedral_lattice.int_semimodule Λ _ = @add_comm_group.int_module Λ _</code>. If I remove the proof of <code>oops</code> and the rewrite, things work again. Is this what I'm supposed to be doing or are there reasons for me not to fiddle with this? The reason I ask is that my instinct is to set up <code>finite_free</code> for <code>comm_group</code>s as well as <code>add_comm_group</code>s and I'm not sure a <code>comm_group</code> can be a Z-module  in Lean.</p>



<a name="235363226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235363226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235363226">(Apr 20 2021 at 15:25)</a>:</h4>
<p>bleurgh I now get errors in <code>polyhedral_lattice.finsupp</code>. Maybe I'll leave this until after the int refactor, my guess is that I have clashing semimodule instances here.</p>



<a name="235391985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235391985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235391985">(Apr 20 2021 at 18:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> All of this will be solved in 1 or 2 days, when <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>'s <code>gsmul</code> PR is merged into mathlib.</p>



<a name="235392131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235392131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235392131">(Apr 20 2021 at 18:30)</a>:</h4>
<p>So I would suggest to just add <code>[semimodule int A]</code> assumptions for now, and we'll remove them in two days.</p>



<a name="235421479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235421479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235421479">(Apr 20 2021 at 21:44)</a>:</h4>
<p>The next problem I find I'm running into is that I'm reluctant to do anything involving <code>is_basis</code> now Anne has told us that they're bundling it. Right now I'm sorrying a bunch of basic algebra stuff and just trying to push on with the more serious stuff.</p>



<a name="235559500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235559500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235559500">(Apr 21 2021 at 18:32)</a>:</h4>
<p>It seems that every time I try to generalize things about <code>finsupp</code> / <code>add_monoid_algebra</code> / <code>dfinsupp</code> / <code>direct_sum</code>, it makes things harder not easier for me... After making what I thought would be some handy API in <a href="https://github.com/leanprover-community/mathlib/issues/7217">#7217</a> and <a href="https://github.com/leanprover-community/mathlib/issues/7293">#7293</a>, I had to fight an <a href="https://github.com/leanprover-community/mathlib/blob/5d206164388594cfdb0f9a6dc4fa75441cc95a30/src/algebra/direct_sum_graded_monoid_algebra.lean#L33-L37">more-awful-than-before battle</a> against the elaborator, and a <a href="https://github.com/leanprover-community/mathlib/blob/5d206164388594cfdb0f9a6dc4fa75441cc95a30/src/algebra/direct_sum_graded_monoid_algebra.lean#L65-L80">similarly awful fight with <code>ext</code></a>. In the end <a href="https://github.com/leanprover-community/mathlib/blob/5d206164388594cfdb0f9a6dc4fa75441cc95a30/src/algebra/direct_sum_graded_monoid_algebra.lean#L60-L87">I was able to construct</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- There is a ring equivalence between an `add_monoid_algebra` (e.g. a `polynomial`) and</span>
<span class="sd">the direct sum of `single_mrange k i` (e.g. the monomials of degree `i`). -/</span>
<span class="kd">def</span> <span class="n">to_direct_sum_mrange</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">k</span> <span class="n">G</span> <span class="bp">≃+*</span> <span class="bp">⨁</span> <span class="n">i</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">single_mrange</span> <span class="n">k</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">_</span>
</code></pre></div>



<a name="235560992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235560992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235560992">(Apr 21 2021 at 18:44)</a>:</h4>
<p>But these feel to me like the things we need in the API, so it's great that you're managing to do them; hopefully users can just hide behind what you're doing. The maps are nice, the proofs are hard but hopefully people will only need the maps.</p>



<a name="235561894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235561894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235561894">(Apr 21 2021 at 18:50)</a>:</h4>
<p>But even using the maps was hard</p>



<a name="235561939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235561939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235561939">(Apr 21 2021 at 18:50)</a>:</h4>
<p>See my first link</p>



<a name="235561969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235561969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235561969">(Apr 21 2021 at 18:51)</a>:</h4>
<p><code>@</code> and <code>letI</code> everywhere</p>



<a name="235564127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235564127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235564127">(Apr 21 2021 at 19:04)</a>:</h4>
<p>It's great that you are working on this! I haven't had the time, energy, and guts to work on this so far.</p>



<a name="235564205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235564205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235564205">(Apr 21 2021 at 19:05)</a>:</h4>
<p>But I'm wondering if things become easier when you try to do everything in terms of internal sums? So without <code>dfinsupp</code>.</p>



<a name="235567252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235567252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235567252">(Apr 21 2021 at 19:26)</a>:</h4>
<p>By internal sum I assume you mean some subtype of <code>finsupp</code>?</p>



<a name="235568115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235568115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235568115">(Apr 21 2021 at 19:32)</a>:</h4>
<p>Well, or maybe even submodules of <code>add_monoid_algebra</code></p>



<a name="235568171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235568171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235568171">(Apr 21 2021 at 19:32)</a>:</h4>
<p>Can we have an "intrinsic" definition of <code>graded_ring</code>?</p>



<a name="235569157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235569157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235569157">(Apr 21 2021 at 19:39)</a>:</h4>
<p>Part of the motivation here was to enable a graded ring whose components are <a href="https://leanprover-community.github.io/mathlib_docs/find/pi_tensor_product">docs#pi_tensor_product</a></p>



<a name="235569186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235569186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235569186">(Apr 21 2021 at 19:39)</a>:</h4>
<p>For which an external direct sum is easier</p>



<a name="235573148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235573148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235573148">(Apr 21 2021 at 20:07)</a>:</h4>
<p>But I suppose you can always have an internal direct sum of a sigma type</p>



<a name="235575511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235575511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235575511">(Apr 21 2021 at 20:25)</a>:</h4>
<p>Graded ring = monoid object in the category of graded abelian groups. Can we make such a definition useful?</p>



<a name="235585812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/235585812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#235585812">(Apr 21 2021 at 21:31)</a>:</h4>
<p>Probably all the problems are there already in grading abelian groups?</p>



<a name="236100660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/236100660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#236100660">(Apr 25 2021 at 23:05)</a>:</h4>
<p>Adam gave an update so I thought I'd give one too. I've had to made an API for gradings on rings and this has turned out to be delicate, just for stupid reasons: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><msub><mo>⨁</mo><mi>m</mi></msub><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R=\bigoplus_mR_m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> but the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R_m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are either additive subgroups of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> or abstract groups in their own right, so it seems that there are several ways of stating things, and I'm still not sure which is the most useful. For example I've managed to state in no fewer than four ways the fact that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">r\in R_m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then the <code>m</code>th component of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>. The main problem of course is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><msub><mo>⨁</mo><mi>m</mi></msub><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R=\bigoplus_m R_m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is not true in Lean -- instead <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>≅</mo><msub><mo>⨁</mo><mi>m</mi></msub><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R\cong \bigoplus_m R_m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and neither map is remotely close to being the identity. </p>
<p>I've reduced Gordan's Lemma (modulo some easy sorrys which I'm reluctant to fill in because <code>is_basis</code> is being refactored) to this lemma in commutative algebra that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> is Noetherian and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>-graded then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is finitely-generated over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, plus the assertion that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>:</mo><msup><mi mathvariant="double-struck">Z</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\phi:\Z^n\to\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is non-zero then the kernel is finite free of rank less than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>. The former fact will be possible but of course we'll have the usual nonsense about how <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> are subrings but we want to consider them as rings and algebras etc etc; I've struggled through stuff like this before and I'm sure it will be possible. As for the subgroups of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">Z</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Z^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>, I'm just hoping that we will have enough general machinery to make this not too hard.</p>



<a name="237213328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237213328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237213328">(May 03 2021 at 19:13)</a>:</h4>
<p>It sounds like Coq may now have enough basics on polyhedral stuff for the "convex geometry" proof of Gordan's lemma <a href="https://arxiv.org/abs/2104.15021">https://arxiv.org/abs/2104.15021</a></p>



<a name="237216077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237216077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237216077">(May 03 2021 at 19:34)</a>:</h4>
<p>Are you now following computer science and logic on arXiv? Johan, what have we done?</p>



<a name="237216900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237216900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237216900">(May 03 2021 at 19:39)</a>:</h4>
<p>No I'm not, no worries</p>



<a name="237218460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237218460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237218460">(May 03 2021 at 19:50)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> and <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> are developing a lot of convex geometry on the Discord.</p>



<a name="237218580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237218580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237218580">(May 03 2021 at 19:51)</a>:</h4>
<p>Oh hey yeah! Anything you need?</p>



<a name="237218680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237218680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237218680">(May 03 2021 at 19:52)</a>:</h4>
<p>A port of that paper would be nice <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="237221617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237221617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237221617">(May 03 2021 at 20:13)</a>:</h4>
<p>I think we might have enough convex geometry to get close to the geometry proof of Gordan's lemma since we have Krein-Milman, HB and supporting/separating hyperplane lemmas</p>



<a name="237221788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237221788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237221788">(May 03 2021 at 20:15)</a>:</h4>
<p>But from talking to <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I understand it might be better to get the algebraic proof so that the theory of graded rings gets developed better?</p>



<a name="237221870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237221870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237221870">(May 03 2021 at 20:15)</a>:</h4>
<p>Well, we should have both, so that the theory of convex polyhedra and the theory of graded rings get developed better</p>



<a name="237520723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237520723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237520723">(May 05 2021 at 16:00)</a>:</h4>
<p>I read through the paper and all of this sounds very doable and interesting! I'm already PRing exposed faces, and then Krein-Milman. We shall see how far I get on the rest.</p>



<a name="237520836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237520836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237520836">(May 05 2021 at 16:01)</a>:</h4>
<p>Ah, and Bhavik seems to be already gone proving Gordan's lemma <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="237521681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237521681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237521681">(May 05 2021 at 16:06)</a>:</h4>
<p>Yes he's live streaming the topological proof on discord right now</p>



<a name="237827386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237827386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237827386">(May 07 2021 at 14:00)</a>:</h4>
<p>If we are still interested in the algebraic proof <code>add_monoid_algebra.finite_type_iff_fg</code> is now in mathlib. I will add the easy (and I think useless for LTE) version for groups next week.</p>



<a name="237837609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237837609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237837609">(May 07 2021 at 15:05)</a>:</h4>
<p>I think the algebraic proof is still the one we are aiming for.</p>



<a name="237837878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237837878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237837878">(May 07 2021 at 15:07)</a>:</h4>
<p>Unless <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> and <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> think they can prove <code>explicit_gordan</code> before Kevin is done with grading exams, of course.</p>



<a name="237844929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237844929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237844929">(May 07 2021 at 15:48)</a>:</h4>
<p>That depends on whether Kevin finishes grading exams by Monday or not <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="237847741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237847741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237847741">(May 07 2021 at 16:05)</a>:</h4>
<p>Ha! You think you'll be done by Monday? Sounds great!</p>



<a name="237874963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237874963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237874963">(May 07 2021 at 19:09)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> just to be clear, there are several "Gordan's Lemma"s in the literature -- the one we want is much stronger than the one we were talking about recently, it needs all that matrix elimination stuff. I pointed you to precisely the lemma we needed in the LTE IIRC</p>



<a name="237879977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237879977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237879977">(May 07 2021 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/237874963">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> just to be clear, there are several "Gordan's Lemma"s in the literature -- the one we want is much stronger than the one we were talking about recently, it needs all that matrix elimination stuff. I pointed you to precisely the lemma we needed in the LTE IIRC</p>
</blockquote>
<p>In what sense is it much stronger? I think the only difference from the one we talked about (with finite intersections of rational hyperplanes) was that the version I was doing was for Z^n rather than any more general version</p>



<a name="237885805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237885805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237885805">(May 07 2021 at 20:30)</a>:</h4>
<p>Bhavik, if you can prove the version in LTE that would be absolutely fabulous. I am just pointing out that you showed me a lemma in a book and the lemma was called Gordan's Lemma but it was not what we are calling Gordan's Lemma, and what we want is what we are calling Gordan's Lemma.</p>



<a name="237886336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237886336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237886336">(May 07 2021 at 20:34)</a>:</h4>
<p>We were initially going to do the topological proof, but then I decided that the algebraic proof looked easier, so I started on this, but then internal grading turned out to be subtle (but do-able) so I'm persevering with it, but now the topological proof is looking easier again. </p>
<p>I just did <code>rw submodule.smul_mem</code> and it failed, so I did <code>rw @submodule.smul_mem [fill in all the fields]</code> and <a href="https://gist.github.com/kbuzzard/0d90aae44ce2034af134400be2065d0a">this happened</a>. Note that <code>pp.all</code> was off, I just triggered the Lean "display more information if the pretty printer says that the terms match but I know they don't".</p>



<a name="237886743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237886743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237886743">(May 07 2021 at 20:38)</a>:</h4>
<p>But my work will not be wasted because we have developed a grading API and I'm putting it through its paces (I suspect I know what I did wrong to get that error, by the way!)</p>



<a name="237901238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/237901238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#237901238">(May 07 2021 at 22:48)</a>:</h4>
<p>If I use <code>convert</code> instead of <code>refine</code> then my 2000-line-long error turns into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">grade_zero.has_scalar</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G</span><span class="bp">ᵢ</span> <span class="n">i</span><span class="o">))</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">smul_with_zero.to_has_scalar</span>
</code></pre></div>



<a name="238542922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238542922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238542922">(May 12 2021 at 20:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/toric/near/237847741">said</a>:</p>
<blockquote>
<p>Ha! You think you'll be done by Monday? Sounds great!</p>
</blockquote>
<p>A little late, but the gordan-bm branch of LTE now has an almost sorry-free proof of Gordan's lemma: the <em>only</em> sorry in the proof is showing that the dual of a finite free group is finite free; I'm pretty sure this is easy but I left it in case someone else was already doing it</p>



<a name="238543083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543083">(May 12 2021 at 20:56)</a>:</h4>
<p>This last fact is probably even in mathlib!</p>



<a name="238543123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543123">(May 12 2021 at 20:56)</a>:</h4>
<p>I think dual bases in mathlib are only for fields currently?</p>



<a name="238543178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543178">(May 12 2021 at 20:57)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/basis.dual_basis">docs#basis.dual_basis</a></p>



<a name="238543219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543219">(May 12 2021 at 20:57)</a>:</h4>
<p>Ah yeah</p>



<a name="238543234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543234">(May 12 2021 at 20:57)</a>:</h4>
<p>Right, it requires <code>K</code> to be a field whereas here it's the integers</p>



<a name="238543251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543251">(May 12 2021 at 20:57)</a>:</h4>
<p>That's a shame</p>



<a name="238543259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543259">(May 12 2021 at 20:57)</a>:</h4>
<p>I think it should mostly work for rings still</p>



<a name="238543572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543572">(May 12 2021 at 21:00)</a>:</h4>
<p>If I have time I'll try to generalize that dual basis in mathlib.</p>



<a name="238543804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238543804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238543804">(May 12 2021 at 21:01)</a>:</h4>
<p>I want to play with these bundled bases anyway</p>



<a name="238544921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238544921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238544921">(May 12 2021 at 21:08)</a>:</h4>
<p>Mathlib probably needs a good API for free modules anyway.  My plan for next week was to start working on the rank of the kernel of a non zero <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">Z</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">\mathbf{Z}^n \to \mathbf{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord mathbf">Z</span></span></span></span> and see what is missing.</p>



<a name="238546562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238546562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238546562">(May 12 2021 at 21:20)</a>:</h4>
<p>Do we even have <code>module.is_free</code> or something like that?</p>



<a name="238547009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238547009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238547009">(May 12 2021 at 21:24)</a>:</h4>
<p>I think Johan suggested to make a classe <code>finite_free</code> and build and API</p>



<a name="238547104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238547104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238547104">(May 12 2021 at 21:25)</a>:</h4>
<p>I don't think we have <code>module.is_free</code>, at least looking at how <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.basis_of_pid">docs#submodule.basis_of_pid</a> is stated</p>



<a name="238551421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238551421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238551421">(May 12 2021 at 22:03)</a>:</h4>
<p>So we have projective modules and flat modules but not free modules?? :-) PS <span class="user-mention" data-user-id="385895">@Jon Eugster</span> you might like it over here.</p>



<a name="238559645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238559645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238559645">(May 12 2021 at 23:35)</a>:</h4>
<p>FYI: The section involving <a href="https://leanprover-community.github.io/mathlib_docs/find/basis.dual_basis">docs#basis.dual_basis</a> ccompiles just fine if one replaces <code>[field K]</code> with <code>[comm_ring K]</code>, except for <a href="https://leanprover-community.github.io/mathlib_docs/find/basis.dual_dim_eq">docs#basis.dual_dim_eq</a> which relies on the definition of <code>module.rank</code> which requires a field. I guess doing this properly would require defining the rank of a module which has a basis and showing that it doesn't depend on the choice of basis, and I don't have the energy to do such a large refactor...</p>



<a name="238580949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238580949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238580949">(May 13 2021 at 04:47)</a>:</h4>
<p>I think it's a good idea to generalize all the dual basis stuff. (And just leave <code>dual_dim_eq</code> for fields, for now.)</p>



<a name="238580957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238580957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238580957">(May 13 2021 at 04:47)</a>:</h4>
<p>In a separate refactor <code>module.rank</code> can be generalized.</p>



<a name="238581045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238581045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238581045">(May 13 2021 at 04:48)</a>:</h4>
<p>Note that <span class="user-mention" data-user-id="260921">@Markus Himmel</span> added <code>invariant_basis_number</code> to mathlib some while ago, and I've already used it succesfully for some of the <code>finite_free</code> sorries in LTE.</p>



<a name="238583094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238583094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238583094">(May 13 2021 at 05:26)</a>:</h4>
<p>I'm preparing a PR generalising dual basis</p>



<a name="238585083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238585083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238585083">(May 13 2021 at 06:02)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7599">#7599</a></p>



<a name="238732178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238732178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238732178">(May 14 2021 at 08:03)</a>:</h4>
<p>It's on the merge queue, so hopefully we will have a sorry-free gordan in a couple of hours</p>



<a name="238734658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238734658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238734658">(May 14 2021 at 08:29)</a>:</h4>
<p>Well done to <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> who pushed through the topological proof in the end. So what is the current status of the proof of 9.4 of Analytic.pdf?</p>



<a name="238734681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238734681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238734681">(May 14 2021 at 08:29)</a>:</h4>
<p>Well done to <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> who pushed through the topological proof in the end. So what is the current status of the proof of 9.4 of Analytic.pdf?</p>



<a name="238734841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238734841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238734841">(May 14 2021 at 08:31)</a>:</h4>
<p>The current status is that Patrick is making good progress on 9.2.<br>
And I want to define the Cech nerves that we need for <code>col_exact</code> pretty soon. But we need to find a timeslot where Adam and me are both available. And theres something like 8 hrs of timezone difference...</p>



<a name="238734982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238734982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238734982">(May 14 2021 at 08:32)</a>:</h4>
<p>I also want to do some refactoring, to make things smoother.</p>



<a name="238735029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238735029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238735029">(May 14 2021 at 08:33)</a>:</h4>
<p>So in the end this whole formalized maths thing has some connection to reality: each time topology and algebra can both be used, the topology proof is nicer!</p>



<a name="238735034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238735034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238735034">(May 14 2021 at 08:33)</a>:</h4>
<p>For example, <code>9.2</code> is currently stated for arbitrary powers of <code>M</code>. But that is very unnatural.</p>



<a name="238735191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238735191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238735191">(May 14 2021 at 08:34)</a>:</h4>
<p>Hopefully I'll have time to work on 9.2 today. Johan, did you read <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/prop_92/concrete.lean">https://github.com/leanprover-community/lean-liquid/blob/master/src/prop_92/concrete.lean</a>?</p>



<a name="238735230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238735230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238735230">(May 14 2021 at 08:34)</a>:</h4>
<p>Reading it is not necessary, but I think you may find it interesting</p>



<a name="238735504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238735504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238735504">(May 14 2021 at 08:37)</a>:</h4>
<p>I read it a while ago. Let me have another look.</p>



<a name="238735545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238735545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238735545">(May 14 2021 at 08:37)</a>:</h4>
<p>I like the abstraction over <code>Tinv</code>. And doing the <code>T_inv _ Tinv</code> conjugation in the induction. It seems to work very well.</p>



<a name="238736123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238736123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238736123">(May 14 2021 at 08:44)</a>:</h4>
<p>Here is an example of what was slowing me down with the algebraic proof. Say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a commutative ring and then later on you come up with a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span>-grading on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, so additive subgroups <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">n\in\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">1\in R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub><msub><mi>R</mi><mi>n</mi></msub><mo>⊆</mo><msub><mi>R</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_mR_n\subseteq R_{m+n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> and such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mo>⨁</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R=\bigoplus R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (this is "=" in the obvious untrue sense). I proved that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> was Noetherian then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> was a finitely-generated <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-module generated by a finset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>⊆</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n\subseteq R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and next I want to prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{\geq0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is a finitely-generated <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-algebra, but now you have to move your finite generators of the promoted-to-type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> into the also promoted-to-a-type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{\geq0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span>, defined as the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>z</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r_z=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, and you have to move your theorem which says that an arbitrary <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">r\in R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is spanned by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to a theorem which says that the corresponding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">r\in R_{\geq0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is in the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-span of the moved <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> etc. Now I write I realise that I should write down an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">R_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-module morphism from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{\geq0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.928509em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. There were just tons of dumb things like this, as well as having to make the internal grading API from scratch, and I didn't have enough Lean time in the day to make progress at more than a snail's pace (when marking is over I should be in a much better state though). </p>
<p>We will need grading when we do <code>Proj</code> for schemes, so I've known for a while we need a good grading API, and I'm optimistic that ultimately the API I've made for internal gradings, when tidied up (my next job) will be helpful here.</p>



<a name="238749415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/toric/near/238749415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/toric.html#238749415">(May 14 2021 at 11:05)</a>:</h4>
<p>By the way I did a lazy proof that the dual is finite free by hand just to be sure that my Gordan proof worked, so it's technically already sorry free! But of course the proof that should come from your PR is much better</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
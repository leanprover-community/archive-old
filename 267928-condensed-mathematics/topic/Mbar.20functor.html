---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/Mbar.20functor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html">Mbar functor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246813559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246813559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246813559">(Jul 22 2021 at 06:37)</a>:</h4>
<p>We have currently proven a mix of thm 9.4 and 9.5. To get the actual 9.4, we need to prove it for profinite sets <code>S</code>. So far, we only have it for finite sets <code>S</code>.</p>
<p>What do we need to do:</p>
<ul>
<li>Make <code>Mbar_le</code> into a functor on finite sets.</li>
<li>For <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S = \lim_i S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> a profinite set, define <code>Mbar_le.profinite</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><mi>S</mi><msub><mo stretchy="false">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mi>i</mi></msub><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\overline{\mathcal M}_{r&#x27;}(S)_{\le c} = \lim_i \overline{\mathcal M}_{r&#x27;}(S_i)_{\le c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.295179em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.295179em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span>. This should be a functor on profinite sets. Feel free to improve the name.<ul>
<li>Add instances, so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><mi>S</mi><msub><mo stretchy="false">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\overline{\mathcal M}_{r&#x27;}(S)_{\le c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.295179em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> is a profinite set.</li>
</ul>
</li>
<li>Define <code>Mbar.profinite</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>⋃</mo><mrow><mi>c</mi><mo>≥</mo><mn>0</mn></mrow></msub><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><mi>S</mi><msub><mo stretchy="false">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\overline{\mathcal M}_{r&#x27;}(S) = \bigcup_{c \ge 0} \overline{\mathcal M}_{r&#x27;}(S)_{\le c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.278219em;vertical-align:-0.39488900000000005em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139799999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39488900000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.295179em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span>. This should be a functor on profinite sets. Feel free to improve the name.<ul>
<li>Add instances, so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\overline{\mathcal M}_{r&#x27;}(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> is a <code>profinitely_filtered_pseudo_normed_group_with_Tinv</code>.</li>
</ul>
</li>
<li>State thm 9.4 for profinite <code>S</code>, and prove it.
*</li>
</ul>



<a name="246813569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246813569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246813569">(Jul 22 2021 at 06:37)</a>:</h4>
<p>All of this can be done without needing the definition of a condensed set.</p>



<a name="246817176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246817176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246817176">(Jul 22 2021 at 07:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/Mbar.20functor/near/246813559">said</a>:</p>
<blockquote>
<ul>
<li>Make <code>Mbar_le</code> into a functor on finite sets.</li>
</ul>
</blockquote>
<p>It might be best to not touch the current definition, and instead define <code>Mbar_le.functor</code> as functor from <code>FinType</code> to <code>Profinite</code>. Evaluating it on a finite set can then be defeq to <code>Mbar_le</code>.</p>



<a name="246863724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246863724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246863724">(Jul 22 2021 at 15:34)</a>:</h4>
<p>I've started on functorializing(?) <code>Mbar</code>.</p>



<a name="246864013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246864013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246864013">(Jul 22 2021 at 15:36)</a>:</h4>
<p>I assume the following is correct (for Mbar, I'll work on <code>Mbar_le</code> next)?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given an element of `Mbar r' S` and a function `f : S → T`, this</span>
<span class="sd">  constructs an associated element of `Mbar r' T`. -/</span>
<span class="kd">def</span> <span class="n">map</span> <span class="o">:</span> <span class="n">Mbar</span> <span class="n">r'</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">Mbar</span> <span class="n">r'</span> <span class="n">T</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span><span class="o">,</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">s</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s'</span><span class="o">,</span> <span class="n">f</span> <span class="n">s'</span> <span class="bp">=</span> <span class="n">t</span><span class="o">),</span> <span class="n">F</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">coeff_zero'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">summable'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="kd">begin</span>
     <span class="bp">...</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="246865069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246865069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246865069">(Jul 22 2021 at 15:44)</a>:</h4>
<p>In the end, the functor <code>Mbar</code> on profinite sets will be defined in terms of the functor <code>Mbar_le</code> on profinite sets (see the sketch above).<br>
So I think it isn't necessary to turn <code>Mbar</code> (as we have it right now) into a functor on finite sets.</p>



<a name="246865141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246865141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246865141">(Jul 22 2021 at 15:44)</a>:</h4>
<p>We will need an iso between <code>[fintype S], (Mbar_functor r').obj S</code> and <code>Mbar r' S</code></p>



<a name="246865146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246865146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246865146">(Jul 22 2021 at 15:44)</a>:</h4>
<p>I understand, but <code>Mbar_le</code> is defined as a subset of <code>Mbar</code>.</p>



<a name="246865221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246865221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246865221">(Jul 22 2021 at 15:45)</a>:</h4>
<p>Fair enough.</p>



<a name="246865276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246865276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246865276">(Jul 22 2021 at 15:45)</a>:</h4>
<p>So now that this <code>Mbar.map</code> is defined, we just need to show that it's compatible with the filtration.</p>



<a name="246869516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246869516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246869516">(Jul 22 2021 at 16:18)</a>:</h4>
<p>Do we not have a topology on <code>Mbar</code> so that the <code>Mbar_le</code>s are subspaces?</p>



<a name="246869610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246869610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246869610">(Jul 22 2021 at 16:18)</a>:</h4>
<p>I remember we discussed this a while back, but I don't remember what the conclusion was :)</p>



<a name="246870339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246870339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246870339">(Jul 22 2021 at 16:24)</a>:</h4>
<p>You run into defeq issues.</p>



<a name="246870405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246870405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246870405">(Jul 22 2021 at 16:24)</a>:</h4>
<p>Because <code>Mbar_le</code> naturally gets a profinite topology. You can put the colimit topology on <code>Mbar</code>. But then the subspace topology on <code>Mbar_le</code> will only be propeq, not defeq to the topology you started with.</p>



<a name="246870662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246870662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246870662">(Jul 22 2021 at 16:26)</a>:</h4>
<p>Man... formalizing is hard.</p>



<a name="246879251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246879251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246879251">(Jul 22 2021 at 17:26)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean-liquid/blob/ee3d614135c82452cd37f72383ac152b2962668a/src/Mbar/Mbar_le.lean#L497">https://github.com/leanprover-community/lean-liquid/blob/ee3d614135c82452cd37f72383ac152b2962668a/src/Mbar/Mbar_le.lean#L497</a></p>



<a name="246879321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246879321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246879321">(Jul 22 2021 at 17:27)</a>:</h4>
<p>I guess to extend this to a functor on <code>Profinite</code> we can take a right Kan extension, but do we actually want to do that?</p>



<a name="246881113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246881113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246881113">(Jul 22 2021 at 17:41)</a>:</h4>
<p>I'm always feeling uneasy with Kan extensions <span aria-label="see no evil" class="emoji emoji-1f648" role="img" title="see no evil">:see_no_evil:</span> <br>
But if it is a Kan extension, then probably that is the best way to do it.</p>



<a name="246881707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246881707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246881707">(Jul 22 2021 at 17:45)</a>:</h4>
<p>By the way, is there a better way to write things like <code>∑ s in finset.univ.filter (λ s', f s' = t), F s n</code>?</p>



<a name="246884187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246884187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246884187">(Jul 22 2021 at 18:04)</a>:</h4>
<p>I've also wished for a better way, but I don't think we have it yet.</p>



<a name="246914586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246914586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246914586">(Jul 22 2021 at 22:48)</a>:</h4>
<p>We don't have <code>preimage (f : X -&gt; Y) (y : Y) : set X</code>?</p>



<a name="246914673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246914673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246914673">(Jul 22 2021 at 22:50)</a>:</h4>
<p>It would have to be a finset in this case, not a set</p>



<a name="246914906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246914906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246914906">(Jul 22 2021 at 22:53)</a>:</h4>
<p>Why wouldn't (sum s : {t}.preimage f) work, since you have a fintype?</p>



<a name="246914919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246914919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246914919">(Jul 22 2021 at 22:53)</a>:</h4>
<p>The coe sort would also be a fintype.</p>



<a name="246916168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246916168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246916168">(Jul 22 2021 at 23:09)</a>:</h4>
<p>I'm confused. What is <code>sum</code>?</p>



<a name="246916309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246916309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246916309">(Jul 22 2021 at 23:11)</a>:</h4>
<p>I don't have a unicode keyboard at the moment. I mean \sum, the sum sigma.</p>



<a name="246916360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246916360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246916360">(Jul 22 2021 at 23:11)</a>:</h4>
<p>You'd have a sum over a coesort, and you'd have a coerced s in F s n, but they would mean the same values.</p>



<a name="246917501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246917501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246917501">(Jul 22 2021 at 23:31)</a>:</h4>
<p>I still don't understand what <code>sum s : {t}.preimage f</code> is supposed to mean... This seems like it's saying that the <code>sum</code> of <code>s</code> is a term of <code>{t}.preimage f</code>. But what I want to do is to take a sum where the index varies over <code>{t}.preimage f</code>.</p>



<a name="246917750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246917750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246917750">(Jul 22 2021 at 23:35)</a>:</h4>
<p>And sure, I can take a sum over the type associated to the preimage, but I feel like this will cause more pain when compared with a slightly less than optimal notation</p>



<a name="246917960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246917960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246917960">(Jul 22 2021 at 23:39)</a>:</h4>
<p>Instead of "sigma s in filter ... ", say "sigma s : coerced ..." and rely on fintype sums. I understand the hesitancy about pain.</p>



<a name="246918052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246918052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246918052">(Jul 22 2021 at 23:40)</a>:</h4>
<p>Ah I see what you mean now. But yes, I'm afraid the pain will be worse with this, since I rely on things like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bUnion">docs#finset.sum_bUnion</a> (in the reverse direction) for a few of the proofs involved</p>



<a name="246918065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246918065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246918065">(Jul 22 2021 at 23:40)</a>:</h4>
<p>What I was saying is that "take a sum where the index varies over <code>{t}.preimage f</code>." is precisely <code>∑ s : {t}.preimage f, F s n</code></p>



<a name="246918159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246918159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246918159">(Jul 22 2021 at 23:42)</a>:</h4>
<p>Right, there are a lot of slightly incompatible forms. And it gets worse because rw isn't strong enough to rewrite around them unless you match the syntax precisely.</p>



<a name="246918182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246918182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246918182">(Jul 22 2021 at 23:43)</a>:</h4>
<p>What I really want is notation <code>∑ a in S where p a, f a</code> to mean <code>∑ a in S.filter p, f a</code>.</p>



<a name="246918542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246918542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246918542">(Jul 22 2021 at 23:49)</a>:</h4>
<p>How would you do it in the finset.univ case?</p>



<a name="246918631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246918631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246918631">(Jul 22 2021 at 23:51)</a>:</h4>
<p>Without the <code>in S</code>, but with the <code>where p a</code></p>



<a name="246923943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246923943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246923943">(Jul 23 2021 at 01:25)</a>:</h4>
<p>I guess <code>finsum</code> might be useful as well. But I haven't yet tried using it in places like this.</p>



<a name="246924168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/246924168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#246924168">(Jul 23 2021 at 01:29)</a>:</h4>
<p>Adding notation for the <code>S.filter p</code> step would make things more readable, which is good. But then we would still need a bunch of API lemmas, to make it usable.</p>



<a name="247009285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247009285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247009285">(Jul 23 2021 at 17:41)</a>:</h4>
<p>I just pushed the extension of the functor from <code>Fintype</code> to <code>Profinite</code> here:<br>
<a href="https://github.com/leanprover-community/lean-liquid/blob/284acf5fe6b2f78cecce80715b003226aff00dd7/src/Mbar/Mbar_le.lean#L515">https://github.com/leanprover-community/lean-liquid/blob/284acf5fe6b2f78cecce80715b003226aff00dd7/src/Mbar/Mbar_le.lean#L515</a></p>
<p>(and a general version here <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/Profinite/extend.lean">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/Profinite/extend.lean</a> )</p>



<a name="247009334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247009334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247009334">(Jul 23 2021 at 17:42)</a>:</h4>
<p>I used the presentation of a profinite set as a limit of its discrete quotients for this, but at some point we should probably relate this to the Kan extension.</p>



<a name="247061514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247061514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247061514">(Jul 24 2021 at 07:34)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> Thanks!</p>



<a name="247083139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247083139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247083139">(Jul 24 2021 at 16:38)</a>:</h4>
<p>Concerning <code>Mbar.profinite</code>... how should we define this? You wrote a union above, which is presumably a colimit, so a priori should involve some sheafification if we want a condensed object.</p>



<a name="247094949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247094949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247094949">(Jul 24 2021 at 21:34)</a>:</h4>
<p>filtered colimits need not be sheafified in condensed sets!</p>



<a name="247095077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247095077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247095077">(Jul 24 2021 at 21:38)</a>:</h4>
<p>Great!</p>



<a name="247226737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247226737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247226737">(Jul 26 2021 at 16:29)</a>:</h4>
<p>I've defined a thing called <code>Mbar.profinite</code> here <br>
<a href="https://github.com/leanprover-community/lean-liquid/blob/0cf5a881a1c416b3d71aeb0a9c0b1603e376c551/src/Mbar/Mbar_le.lean#L585">https://github.com/leanprover-community/lean-liquid/blob/0cf5a881a1c416b3d71aeb0a9c0b1603e376c551/src/Mbar/Mbar_le.lean#L585</a><br>
Of course there is much more to do, including proving that it's actually a sheaf ;)</p>



<a name="247226970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247226970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247226970">(Jul 26 2021 at 16:30)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> Awesome. Checking that it is a sheaf would need some stuff from the beginning of Condensed.pdf.</p>



<a name="247227005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247227005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247227005">(Jul 26 2021 at 16:31)</a>:</h4>
<p>As in, we want easier sheaf conditions, for the special setting that we're in.</p>



<a name="247227114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247227114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247227114">(Jul 26 2021 at 16:32)</a>:</h4>
<p>I've been really busy with a tonne of other stuff. And next week I'll be on holidays. (This week I have 2 more talks to give.)<br>
But I think we should copy the strategy of the first half: make a push for the statement first.</p>



<a name="247227167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247227167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247227167">(Jul 26 2021 at 16:32)</a>:</h4>
<p>And if I understand Peter's comment above, the fact that it doesn't require sheafification probably boils down to the fact that filtered colimits commute with finite limits in <code>Type*</code>,</p>



<a name="247227200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247227200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247227200">(Jul 26 2021 at 16:32)</a>:</h4>
<p>This <code>Mbar.profinite</code> is a good test case. We'll need it anyway, even though it doesn't show up in the statement.</p>



<a name="247227383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247227383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247227383">(Jul 26 2021 at 16:34)</a>:</h4>
<p>In the end, we need something that we might call <code>signed_radon_measure : CondMod(real)</code>. This beast is another of those sheafs, and its definition looks very similar to <code>Mbar.profinite</code>.</p>



<a name="247255691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247255691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247255691">(Jul 26 2021 at 20:15)</a>:</h4>
<p>You don't need condensed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span>-modules for the statement! It takes place in condensed abelian groups</p>



<a name="247262395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247262395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247262395">(Jul 26 2021 at 21:04)</a>:</h4>
<p>I realized that I misspoke above. <code>Mbar.profinite</code> is not even a presheaf on <code>Profinite</code>. I made a version called <code>Mbar.precondensed</code> here <a href="https://github.com/leanprover-community/lean-liquid/blob/50f0c86e29b0988cabee4911c026591f33de255f/src/Mbar/Mbar_le.lean#L605">https://github.com/leanprover-community/lean-liquid/blob/50f0c86e29b0988cabee4911c026591f33de255f/src/Mbar/Mbar_le.lean#L605</a> which, to every <code>S : Profinite</code> actually associates the presheaf on <code>Profinite</code> associated to <code>Mbar(S)</code>. The universes make it a bit of a mess.</p>
<p>What's happening is the following:</p>
<ol>
<li><code>Mbar_le.bifunctor</code> is the functor which to every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><msub><mi mathvariant="double-struck">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">c : \mathbb{R}_{\geq 0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.934069em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> and <code>S : Profinite</code> associates the profinite set <code>Mbar_le r' c S</code>.</li>
<li>Next, compose with the functor sending a profinite set to the representable presheaf.</li>
<li>Finally, take the colimit of these presheaves as <code>c</code> varies to obtain <code>Mbar.precondensed</code>.</li>
</ol>
<p>Note that <code>Mbar_le r' c S</code> is defined as a limit in <code>Profinite</code>, where, a priori, we should be taking a limit of presheaves on <code>Profinite</code>, but this should give the same result. <br>
Is it actually important for us to consider <code>Mbar_le r' c S</code> for profinite <code>S</code> as a condensed set?</p>



<a name="247263358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247263358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247263358">(Jul 26 2021 at 21:08)</a>:</h4>
<p>Concerning the universe issue, which is related to the discussion <a href="#narrow/stream/267928-condensed-mathematics/topic/condensed.20sets/near/245993721">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/condensed.20sets/near/245993721</a> I ended up using presheaves of the form </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">as_small.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">Profinite.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="247293703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247293703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247293703">(Jul 27 2021 at 04:41)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span>  We will need to treat <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">)</mo><mrow><mo>&gt;</mo><mi>r</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal M(S, \Z((T))_{&gt;r})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathbb">Z</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22737em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> as a condensed abelian group, at some point. But I'm not sure that we need <code>Mbar</code> as condensed something. We need <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="script">M</mi><mo stretchy="true">‾</mo></mover><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\overline{\mathcal M}_{r&#x27;}(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> for profinite <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>. But by the time we need it, we have left the condensed world behind us already.</p>



<a name="247322542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247322542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247322542">(Jul 27 2021 at 11:51)</a>:</h4>
<p>I guess the question then is still about how <span class="tex-error">$$\overline\mathcal{M}_{r'}(S)$$</span> is defined. In which category does the colimit occur?</p>



<a name="247324967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247324967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247324967">(Jul 27 2021 at 12:17)</a>:</h4>
<p>In the category of abelian groups, I think.</p>



<a name="247325025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247325025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247325025">(Jul 27 2021 at 12:17)</a>:</h4>
<p>Well, the mbar_le's are just sets.</p>



<a name="247325077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247325077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247325077">(Jul 27 2021 at 12:18)</a>:</h4>
<p>(well, Profinite sets)</p>



<a name="247325358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247325358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247325358">(Jul 27 2021 at 12:21)</a>:</h4>
<p>Ooh, right. Sorry. So it is a colimit of sets. And the result is a profinitely filtered pseudo-normed group.</p>



<a name="247325498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247325498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247325498">(Jul 27 2021 at 12:22)</a>:</h4>
<p>I see. Is it clear that this agrees with the construction coming from the condensed world if one forgets the condensed structure?</p>



<a name="247325614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247325614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247325614">(Jul 27 2021 at 12:23)</a>:</h4>
<p>In any case the thing I originally defined as <code>Mbar.profinite</code> is exactly this colimit of sets</p>



<a name="247325945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247325945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247325945">(Jul 27 2021 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/Mbar.20functor/near/247325498">said</a>:</p>
<blockquote>
<p>I see. Is it clear that this agrees with the construction coming from the condensed world if one forgets the condensed structure?</p>
</blockquote>
<p>I guess the question is to what extent taking the representable presheaf commutes with taking colimits?</p>



<a name="247326023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247326023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247326023">(Jul 27 2021 at 12:27)</a>:</h4>
<p>I think that it should be fine, because profinite sets are compact. So any map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>→</mo><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T \to \mathcal M(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> will factor via some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><mi>S</mi><msub><mo stretchy="false">)</mo><mrow><mo>≤</mo><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal M(S)_{\le c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.295179em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="247326728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247326728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247326728">(Jul 27 2021 at 12:34)</a>:</h4>
<p>That sounds right.</p>



<a name="247328227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Mbar%20functor/near/247328227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Mbar.20functor.html#247328227">(Jul 27 2021 at 12:50)</a>:</h4>
<p>Ah, I guess the general nonsense fact is that the representable (by a profinite set) condensed sets are compact objects.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
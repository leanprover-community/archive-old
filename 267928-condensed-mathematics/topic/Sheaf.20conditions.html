---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html">Sheaf conditions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257837920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257837920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257837920">(Oct 16 2021 at 15:02)</a>:</h4>
<p>I proved the sheaf condition (for condensed sets) in terms of finite products and equalizers associated to surjective maps of Profinite sets here<br>
<a href="https://github.com/leanprover-community/lean-liquid/blob/b8ebef1943604d3b8af4cb65eb9d313e15f65dcc/src/condensed/is_proetale_sheaf.lean#L351">https://github.com/leanprover-community/lean-liquid/blob/b8ebef1943604d3b8af4cb65eb9d313e15f65dcc/src/condensed/is_proetale_sheaf.lean#L351</a></p>
<p>Now the question is how to formulate the condition in terms of exteremally disconnected sets. Any ideas?</p>



<a name="257838921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257838921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257838921">(Oct 16 2021 at 15:19)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> Can you remind me why we need <code>P.is_proetale_sheaf_of_types</code>? Why can't we use the generic sheaf condition?</p>



<a name="257838975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257838975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257838975">(Oct 16 2021 at 15:20)</a>:</h4>
<p>I see that we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">is_proetale_sheaf_of_types_iff</span> <span class="o">:</span>
  <span class="n">P.is_proetale_sheaf_of_types</span> <span class="bp">↔</span> <span class="n">presieve.is_sheaf</span> <span class="n">proetale_topology</span> <span class="n">P</span> <span class="o">:=</span>
</code></pre></div>



<a name="257839029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839029">(Oct 16 2021 at 15:20)</a>:</h4>
<p>Shouldn't that RHS be the main way of talking about condensed gadgets?</p>



<a name="257839053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839053">(Oct 16 2021 at 15:21)</a>:</h4>
<p>The general sheaf condition uses coyoneda to reduce to the condition for types.</p>



<a name="257839064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839064">(Oct 16 2021 at 15:21)</a>:</h4>
<p>For types the two are equivalent</p>



<a name="257839156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839156">(Oct 16 2021 at 15:22)</a>:</h4>
<p>See <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.presheaf.is_sheaf_iff_is_sheaf_of_type">docs#category_theory.presheaf.is_sheaf_iff_is_sheaf_of_type</a></p>



<a name="257839185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839185">(Oct 16 2021 at 15:23)</a>:</h4>
<p>Isn't <code>presieve.is_sheaf</code> the thing that the rest of <code>category_theory/</code> communicates with and has API for?</p>



<a name="257839202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839202">(Oct 16 2021 at 15:23)</a>:</h4>
<p>That's why I would guess it should be the default way of talking about condensed things.</p>



<a name="257839219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839219">(Oct 16 2021 at 15:23)</a>:</h4>
<p>But maybe that's also what is already happening.</p>



<a name="257839276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839276">(Oct 16 2021 at 15:24)</a>:</h4>
<p>I'm not sure I understand what you're asking</p>



<a name="257839293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839293">(Oct 16 2021 at 15:24)</a>:</h4>
<p>The RHS of that lemma is indeed the general sheaf of types condition, but the LHS is specific for condensed sets</p>



<a name="257839325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839325">(Oct 16 2021 at 15:25)</a>:</h4>
<p>So how many ways do we now have to say: presheaf <code>X</code> is a condensed sheaf?</p>



<a name="257839334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839334">(Oct 16 2021 at 15:25)</a>:</h4>
<p>Lots <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="257839345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839345">(Oct 16 2021 at 15:25)</a>:</h4>
<p>Right. So I guess we need to assemble them in a <code>tfae</code> at some point.</p>



<a name="257839355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839355">(Oct 16 2021 at 15:26)</a>:</h4>
<p>Yeah of course</p>



<a name="257839399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839399">(Oct 16 2021 at 15:26)</a>:</h4>
<p>And then there will be the question: what is going to be <em>the</em> definition, in terms of which we build the rest of the API.</p>



<a name="257839437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839437">(Oct 16 2021 at 15:26)</a>:</h4>
<p>I somehow thought that you wanted to use <code>P.is_proetale_sheaf_of_types</code> for that. But maybe that's just wrong. In that case, please ignore everything I said.</p>



<a name="257839439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839439">(Oct 16 2021 at 15:26)</a>:</h4>
<p>Oh for that I think we should use that presieve.is_sheaf condition, since that's essentially how sheaves are defined</p>



<a name="257839454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839454">(Oct 16 2021 at 15:27)</a>:</h4>
<p>Thanks. I'm back on track.</p>



<a name="257839471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839471">(Oct 16 2021 at 15:27)</a>:</h4>
<p>Now about the extremally disconnected condition. That's p12 of Condensed.pdf, right? Just below 2.7.</p>



<a name="257839483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839483">(Oct 16 2021 at 15:27)</a>:</h4>
<p>And it's basicallly just the product condition that you phrased for Profinites.</p>



<a name="257839583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839583">(Oct 16 2021 at 15:29)</a>:</h4>
<p>And if I understand you correctly, you are asking whether we should do something like "build the category of extr.disc.s, the inclusion functor to <code>Profinite</code>, and then phrase the product condition for <code>inclusion ⋙ X</code>" ... or ... something else, like a hand-rolled Sigma-type like product condition.</p>



<a name="257839604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839604">(Oct 16 2021 at 15:29)</a>:</h4>
<p>Is that right? Or was your question something else?</p>



<a name="257839930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839930">(Oct 16 2021 at 15:34)</a>:</h4>
<p>Yup, that's right, but only when restricted to extr.disc sets</p>



<a name="257839969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257839969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257839969">(Oct 16 2021 at 15:35)</a>:</h4>
<p>The question is whether we want to actually deal with restricting and extending back to profinites all the time, or if we want to come up with a condition that works while remaining in profinite</p>



<a name="257840546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257840546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257840546">(Oct 16 2021 at 15:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/Sheaf.20conditions/near/257839583">said</a>:</p>
<blockquote>
<p>And if I understand you correctly, you are asking whether we should do something like "build the category of extr.disc.s, the inclusion functor to <code>Profinite</code>, and then phrase the product condition for <code>inclusion ⋙ X</code>" ... or ... something else, like a hand-rolled Sigma-type like product condition.</p>
</blockquote>
<p>Does this actually work? If I have some random presheaf on <code>Profinite</code> whose restriction to <code>ExtrDisc</code> satisfies the finite product condition, is it really the case that the original presheaf is a sheaf? I don't think that's right...</p>



<a name="257840687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257840687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257840687">(Oct 16 2021 at 15:46)</a>:</h4>
<p>I think a general condition in terms of ExtrDisc sets for presheaves on <code>Profinite</code> could like like this:</p>
<ol>
<li>For all profinite <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and extr.disc. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> with a surjection <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">E \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and all extr.disc <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">E&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> with a surjection to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mo>×</mo><mi>X</mi></msub><mi>E</mi></mrow><annotation encoding="application/x-tex">E \times_X E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">×</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mi>q</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X) \to eq(P(E) \to P(E&#x27;))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span> is a bijection (this is an equalizer, so there are two maps, I don't remember how to typeset that).</li>
<li>For all finite families of extr.disc. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mo>∐</mo><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mo>∏</mo><mi>i</mi></msub><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\coprod_i X_i) \to \prod_i P(X_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∐</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is a bijection.</li>
</ol>



<a name="257841164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257841164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257841164">(Oct 16 2021 at 15:54)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> I got the impression that the product condition is all you need. At least, that's how I understand the observation just after Prop 2.7.</p>



<a name="257841279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257841279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257841279">(Oct 16 2021 at 15:56)</a>:</h4>
<p>If you consider presheaves on <code>ExtrDisc</code>, yes</p>



<a name="257842100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257842100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257842100">(Oct 16 2021 at 16:07)</a>:</h4>
<p>But that's what I said, right? You restrict the presheaf <code>X</code> to a presheaf on <code>ExtrDisc</code> by composing with <code>inclusion : ExtrDisc ⥤ Profinite</code></p>



<a name="257842112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257842112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257842112">(Oct 16 2021 at 16:07)</a>:</h4>
<p>And then you impose the product condition.</p>



<a name="257842186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257842186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257842186">(Oct 16 2021 at 16:08)</a>:</h4>
<p>Ok, but there may be many presheaves <code>X</code> on <code>Profinite</code> with the same restriction to <code>ExtrDisc</code></p>



<a name="257842301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257842301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257842301">(Oct 16 2021 at 16:10)</a>:</h4>
<p>Hmm, that's a good point.</p>



<a name="257842355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257842355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257842355">(Oct 16 2021 at 16:11)</a>:</h4>
<p>If you start with a sheaf <code>X</code> on Profinite, then it's uniquely determined by the restriction to <code>ExtrDosc</code>, but that relies on that equalizer condition</p>



<a name="257847686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257847686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257847686">(Oct 16 2021 at 17:34)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> Yeah, I see it now. So I think it should be something like the two conditions you listed above.</p>



<a name="257847811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257847811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257847811">(Oct 16 2021 at 17:36)</a>:</h4>
<p>On the other hand, I don't know how important that sheaf condition is for LTE.</p>



<a name="257847867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257847867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257847867">(Oct 16 2021 at 17:37)</a>:</h4>
<p>I guess what's more important for us, is for example: <code>f : X ⟶ Y</code> is an iso iff <code>X(S) → Y(S)</code> is an iso for all <code>S : ExtrDisc</code>.</p>



<a name="257847964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257847964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257847964">(Oct 16 2021 at 17:38)</a>:</h4>
<p>And other checks that only have to be performed on <code>ExtrDisc</code>. But I don't think we'll leave the sheaf world. And the examples of condensed sets that we construct will probably not use this sheaf condition, right?</p>



<a name="257850224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257850224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257850224">(Oct 16 2021 at 18:13)</a>:</h4>
<p>We will need to do something with the sheaf condition when we want to sheafify, when we go to prove that <code>Cond Ab</code> is abelian, to prove it has enough projectives, etc.</p>



<a name="257856657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/Sheaf%20conditions/near/257856657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/Sheaf.20conditions.html#257856657">(Oct 16 2021 at 19:56)</a>:</h4>
<p>I added:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">is_proetale_sheaf_of_types_tfae</span> <span class="o">:</span>
  <span class="o">[</span> <span class="n">presieve.is_sheaf</span> <span class="n">proetale_topology</span> <span class="n">P</span>
  <span class="o">,</span> <span class="n">P.is_proetale_sheaf_of_types</span>
  <span class="o">,</span> <span class="n">P.is_proetale_sheaf_of_types_pullback</span>
  <span class="o">,</span> <span class="n">P.is_proetale_sheaf_of_types_explicit_pullback</span>
  <span class="o">,</span> <span class="n">P.finite_product_condition</span> <span class="bp">∧</span> <span class="n">P.equalizer_condition</span>
  <span class="o">]</span><span class="bp">.</span><span class="n">tfae</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html">for_mathlib/imker</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="285154855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285154855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285154855">(Jun 06 2022 at 18:55)</a>:</h4>
<p>So <code>truncation</code> has been split into <code>imker</code> and <code>truncation</code>, and I've been working on <code>imker</code> a bit today. I've abstracted out the one remaining lemma we need to make the file sorry-free:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.abelian.basic</span>
<span class="kn">import</span> <span class="n">algebra.homology.homology</span>

<span class="kn">open</span> <span class="n">category_theory</span> <span class="n">category_theory.limits</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">ùìê</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="bp">ùìê</span><span class="o">]</span> <span class="o">[</span><span class="n">abelian</span> <span class="bp">ùìê</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">homology_functor.is_iso_of_is_zero_of_is_zero_of_is_zero</span> <span class="o">{</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">complex_shape</span> <span class="n">Œπ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">Œπ</span><span class="o">}</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">c.rel</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span><span class="n">C‚ÇÅ</span> <span class="n">C‚ÇÇ</span> <span class="o">:</span> <span class="n">homological_complex</span> <span class="bp">ùìê</span> <span class="n">c</span><span class="o">}</span> <span class="o">(</span><span class="n">h1from</span> <span class="o">:</span> <span class="n">C‚ÇÅ.d_from</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2to</span> <span class="o">:</span> <span class="n">C‚ÇÇ.d_to</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h2from</span> <span class="o">:</span> <span class="n">C‚ÇÇ.d_from</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">isomap</span> <span class="o">:</span> <span class="n">cokernel</span> <span class="o">(</span><span class="n">C‚ÇÅ.d_to</span> <span class="n">j</span><span class="o">)</span> <span class="bp">‚âÖ</span> <span class="n">C‚ÇÇ.X</span> <span class="n">j</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">C‚ÇÅ</span> <span class="bp">‚ü∂</span> <span class="n">C‚ÇÇ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f.f</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">cokernel.œÄ</span> <span class="o">(</span><span class="n">C‚ÇÅ.d_to</span> <span class="n">j</span><span class="o">)</span> <span class="bp">‚â´</span> <span class="n">isomap.hom</span><span class="o">)</span> <span class="o">:</span>
<span class="n">is_iso</span> <span class="o">((</span><span class="n">homology_functor</span> <span class="bp">ùìê</span> <span class="n">c</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>I haven't started trying to prove this yet. It looks like this is pretty much the same question as one I've been struggling with for a couple of days now but it's actually a bit easier because, for example, it doesn't mention kernel_subobjects. I plan on working more on this (in fact I plan on working on it until it's done) so if anyone else wants to leap in and have a go then please let me know so we don't duplicate work. If anyone has any suggestions I'd be interested to hear them; it's getting to the point where this should be becoming easy (I hope).</p>



<a name="285156090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285156090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285156090">(Jun 06 2022 at 19:05)</a>:</h4>
<p>I guess if you specialize to <code>‚Ñ§</code>-indexed gadgets your life becomes easier.</p>



<a name="285156106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285156106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285156106">(Jun 06 2022 at 19:05)</a>:</h4>
<p>Because then you can assume that <code>d_from</code> and <code>d_to</code> are isomorphic to actual <code>d</code>s.</p>



<a name="285162418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285162418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285162418">(Jun 06 2022 at 19:54)</a>:</h4>
<p>I'm not convinced this makes things easier, because <code>d_from</code> is just a map from a thing to a thing, and <code>d</code> is just a map from a thing to a thing. Here's an example of the problems I face here: I can't rewrite.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">homology_functor.is_iso_of_is_zero_of_is_zero_of_is_zero</span> <span class="o">{</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">complex_shape</span> <span class="n">Œπ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">Œπ</span><span class="o">}</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">c.rel</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span><span class="n">C‚ÇÅ</span> <span class="n">C‚ÇÇ</span> <span class="o">:</span> <span class="n">homological_complex</span> <span class="bp">ùìê</span> <span class="n">c</span><span class="o">}</span> <span class="o">(</span><span class="n">h1from</span> <span class="o">:</span> <span class="n">C‚ÇÅ.d_from</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2to</span> <span class="o">:</span> <span class="n">C‚ÇÇ.d_to</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h2from</span> <span class="o">:</span> <span class="n">C‚ÇÇ.d_from</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">isomap</span> <span class="o">:</span> <span class="n">cokernel</span> <span class="o">(</span><span class="n">C‚ÇÅ.d_to</span> <span class="n">j</span><span class="o">)</span> <span class="bp">‚âÖ</span> <span class="n">C‚ÇÇ.X</span> <span class="n">j</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">C‚ÇÅ</span> <span class="bp">‚ü∂</span> <span class="n">C‚ÇÇ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f.f</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">cokernel.œÄ</span> <span class="o">(</span><span class="n">C‚ÇÅ.d_to</span> <span class="n">j</span><span class="o">)</span> <span class="bp">‚â´</span> <span class="n">isomap.hom</span><span class="o">)</span> <span class="o">:</span>
<span class="n">is_iso</span> <span class="o">((</span><span class="n">homology_functor</span> <span class="bp">ùìê</span> <span class="n">c</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">delta</span> <span class="n">homology.map</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">h2to</span><span class="o">,</span> <span class="c1">-- fails :-(</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm not convinced that it being <code>d</code> would make anything any different here.</p>



<a name="285162704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285162704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285162704">(Jun 06 2022 at 19:57)</a>:</h4>
<p>Basically there are four maps at play, two d_froms and two d_tos, and we explicitly have hypotheses about every one of them. It's using them which is hard. Would it be any easier if they were d's? I'm not convinced. We have <code>hij</code> so we could make <code>d_from</code> into a <code>d</code> and if you want to add a hypothesis <code>hjk : j + 1 = k</code> this is fine because it's true in the application (even though it clearly is not relevant here because both d_from maps are zero).</p>



<a name="285163254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285163254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285163254">(Jun 06 2022 at 20:00)</a>:</h4>
<p>I don't know whether it's relevant but this is one of those situations where if you put pp.all on then the size of the terms makes Mario shudder (and we're not even seeing the ten <code>...</code>s at the end)</p>



<a name="285163796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285163796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285163796">(Jun 06 2022 at 20:03)</a>:</h4>
<p>I think you are discovering more reasons why we need to refactor <code>homology</code> and give it a proper API with clearly defined API boundaries.</p>



<a name="285165611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285165611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285165611">(Jun 06 2022 at 20:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">homology_functor.is_iso_of_is_zero_of_is_zero_of_is_zero_Johan_variant</span>
  <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">‚Ñ§</span><span class="o">}</span> <span class="o">(</span><span class="n">hij</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hjk</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">k</span><span class="o">)</span>
  <span class="o">{</span><span class="n">C‚ÇÅ</span> <span class="n">C‚ÇÇ</span> <span class="o">:</span> <span class="n">homological_complex</span> <span class="bp">ùìê</span> <span class="o">(</span><span class="n">complex_shape.up</span> <span class="n">‚Ñ§</span><span class="o">)}</span> <span class="o">(</span><span class="n">h1from</span> <span class="o">:</span> <span class="n">C‚ÇÅ.d</span> <span class="n">j</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2to</span> <span class="o">:</span> <span class="n">C‚ÇÇ.d</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h2from</span> <span class="o">:</span> <span class="n">C‚ÇÇ.d</span> <span class="n">j</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">isomap</span> <span class="o">:</span> <span class="n">cokernel</span> <span class="o">(</span><span class="n">C‚ÇÅ.d</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">‚âÖ</span> <span class="n">C‚ÇÇ.X</span> <span class="n">j</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">C‚ÇÅ</span> <span class="bp">‚ü∂</span> <span class="n">C‚ÇÇ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f.f</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">cokernel.œÄ</span> <span class="o">(</span><span class="n">C‚ÇÅ.d</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">‚â´</span> <span class="n">isomap.hom</span><span class="o">)</span> <span class="o">:</span>
<span class="n">is_iso</span> <span class="o">((</span><span class="n">homology_functor</span> <span class="bp">ùìê</span> <span class="o">(</span><span class="n">complex_shape.up</span> <span class="n">‚Ñ§</span><span class="o">)</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">delta</span> <span class="n">homology.map</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span> <span class="c1">-- there are now d_to's anyway</span>
  <span class="n">simp_rw</span> <span class="n">homological_complex.d_to</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>
<p>I tried it anyway. I don't know whether I'm supposed to unfolding <code>homology.map</code> but it unfolds into <code>d_from</code> and <code>d_to</code> anyway, and I still can't rewrite. I like a challenge, I'll think about this more tomorrow.</p>



<a name="285166421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285166421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285166421">(Jun 06 2022 at 20:18)</a>:</h4>
<p>I should say that if I can rewrite then we get <code>image_to_kernel 0 (C‚ÇÇ.d_from j) _</code> and then <code>rw image_to_kernel_zero_left,</code> means we can use <code>cokernel.œÄ_zero_is_iso</code> and then cancel the isomorphism, making the question simpler.</p>



<a name="285173337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285173337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285173337">(Jun 06 2022 at 21:18)</a>:</h4>
<p>aah, progress! I can't do the rewrite because the type of the term <code>image_to_kernel f g w</code> depends on <code>f</code>. Now I think I know how to fix it. Expect more excitingly slow progress tomorrow :-)</p>



<a name="285174029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285174029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285174029">(Jun 06 2022 at 21:23)</a>:</h4>
<p>We have <code>cokernel_iso_of_eq : f = g ‚Üí (cokernel f ‚âÖ cokernel g)</code>. I'm now wondering whether we need 100 more lemmas of this form.</p>



<a name="285185738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285185738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285185738">(Jun 06 2022 at 23:21)</a>:</h4>
<p>We even have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.cokernel_iso_of_eq_hom_comp_desc">docs#category_theory.limits.cokernel_iso_of_eq_hom_comp_desc</a> -- maybe we have them all already ;-) OK I'm back on track!</p>



<a name="285220560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220560">(Jun 07 2022 at 08:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I've just written a def <code>has_homology</code> + a bunch of API.</p>



<a name="285220569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220569">(Jun 07 2022 at 08:56)</a>:</h4>
<p>I'm now trying to build LTE</p>



<a name="285220612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220612">(Jun 07 2022 at 08:57)</a>:</h4>
<p>If it all works, I hope this will allow you to monster golf your proof.</p>



<a name="285220689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220689">(Jun 07 2022 at 08:58)</a>:</h4>
<p>I haven't pushed yet, but I wanted to let you know. I've already golfed several annoying homology proofs in LTE.</p>



<a name="285220756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220756">(Jun 07 2022 at 08:58)</a>:</h4>
<p>Thanks! I need to do admin all morning but will hopefully be back to this this afternoon</p>



<a name="285220770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220770">(Jun 07 2022 at 08:58)</a>:</h4>
<p>I pushed some progress towards the imker lemma last night</p>



<a name="285220851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285220851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285220851">(Jun 07 2022 at 08:59)</a>:</h4>
<p>I have pushed to the <code>has-homology</code> branch. I need to bring my son to a friend now. Will be back soon.</p>



<a name="285228716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285228716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285228716">(Jun 07 2022 at 10:12)</a>:</h4>
<p>Ok, it compiles, merged into master and pushed.</p>



<a name="285234371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285234371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285234371">(Jun 07 2022 at 11:14)</a>:</h4>
<p>Thanks! Will look later</p>



<a name="285303863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285303863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285303863">(Jun 07 2022 at 19:40)</a>:</h4>
<p>I pushed some more API to the <code>has_homology</code> file. In particular: you related <code>has_homology</code> and <code>homology</code>; I've just related <code>has_homology.map</code> and <code>homology.map</code> and so now the problem I had (showing a <code>homology.map</code> is an isomorphism, which was going to be feasible but very slow going) can hopefully be reduced to showing that a <code>has_homology.map</code> is an isomorphism, and if we play our cards right this latter isomorphism might be the identity (as opposed to the original one, which was definitionally very very far from the identity!).</p>



<a name="285374767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285374767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285374767">(Jun 08 2022 at 11:00)</a>:</h4>
<p>OK so <code>imker</code> is sorry-free! <code>has_homology</code> was indeed the missing piece of the puzzle.</p>
<p>I have never used abelian categories before; my recent efforts in LTE are my way of learning them. On the way to filling in these <code>imker</code> sorries I had to prove about 25 really basic lemmas about abelian categories: you can see them <a href="https://github.com/leanprover-community/lean-liquid/blob/45f9358f67b17b2e1b7acd2738552df9f1728d38/src/for_mathlib/imker.lean#L159-L440">here</a>. Probably every single one of them is true for a weaker class of category. I couldn't find any of these. Does this mean that (a) I shouldn't be using these lemmas at all (i.e. I'm thinking about category theory in the wrong way), (b) these lemmas are there but I'm just not finding them or (c) this is just missing API which should be PRed to mathlib? Some stuff seemed so basic.</p>



<a name="285378324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378324">(Jun 08 2022 at 11:41)</a>:</h4>
<p>I think some of the lemmas are probably not required.<br>
When dealing with things that are limits and colimits we generally use some combination of <code>ext, dsimp, simp</code> to close such goals.<br>
For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">cokernel.desc_comp_left</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">[</span><span class="n">abelian</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">‚ü∂</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">‚ü∂</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">‚ü∂</span> <span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="bp">‚â´</span> <span class="n">e</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="bp">‚â´</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">‚Üê</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">zero_comp</span><span class="o">]))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>works. And presumably your lemma </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">cokernel.desc_spec</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">[</span><span class="n">abelian</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">‚ü∂</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">‚ü∂</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">cokernel</span> <span class="n">f</span> <span class="bp">‚ü∂</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">cokernel.œÄ</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="bp">‚Üî</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span> <span class="o">:=</span>
</code></pre></div>
<p>isn't really necessary.</p>



<a name="285378431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378431">(Jun 08 2022 at 11:42)</a>:</h4>
<p>I'm quite surprised the <code>epi_iff</code> lemmas you proved are not in mathlib.</p>



<a name="285378468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378468">(Jun 08 2022 at 11:43)</a>:</h4>
<p>If they're really missing, then those should certainly be PRed eventually.</p>



<a name="285378536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378536">(Jun 08 2022 at 11:43)</a>:</h4>
<p>They might be there; I think typeclass inference might be interfering with my search. Oh wow what is this <code>ext</code> trick??</p>



<a name="285378572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378572">(Jun 08 2022 at 11:44)</a>:</h4>
<p>These are limits and colimits, and the <code>ext</code> applies a <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.colimit.hom_ext">docs#category_theory.limits.colimit.hom_ext</a> essentially</p>



<a name="285378644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378644">(Jun 08 2022 at 11:44)</a>:</h4>
<p>If you have more complicated limits, you may need an <code>intros</code> after the ext.</p>



<a name="285378721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378721">(Jun 08 2022 at 11:45)</a>:</h4>
<p>I have no idea how to work with limits. I think this is one of the reasons I've found category theory so hard. I've only had to use kernels and cokernels so far and here there has been bespoke API which I've found very easy to use. I'll try and understand what's going on! Thanks!</p>



<a name="285378816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378816">(Jun 08 2022 at 11:46)</a>:</h4>
<p>Note that your <code>desc_spec</code> lemma is essentially a version of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_colimit.uniq">docs#category_theory.limits.is_colimit.uniq</a></p>



<a name="285378869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378869">(Jun 08 2022 at 11:47)</a>:</h4>
<p>The lemma saying something about the composition of <code>cokernel.\pi</code> with <code>cokernel.desc</code> is essentially <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_colimit.fac">docs#category_theory.limits.is_colimit.fac</a></p>



<a name="285378888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378888">(Jun 08 2022 at 11:47)</a>:</h4>
<p>The map <code>cokernel.desc</code> itself is <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_colimit.desc">docs#category_theory.limits.is_colimit.desc</a> etc.</p>



<a name="285378993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285378993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285378993">(Jun 08 2022 at 11:48)</a>:</h4>
<p>Yeah I never think about what these things "actually are", I just want the lemmas. This is really bending my idea of what <code>ext</code> means!</p>



<a name="285379098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285379098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285379098">(Jun 08 2022 at 11:49)</a>:</h4>
<p>Those are for situations where you have a <code>is_colimit C</code> for some cocone <code>C</code>. If you're dealing with the "colimit" itself (i.e. the noncomputable thing obtained by <code>exists.some</code>) then we have the associated defs/lemmas <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.colimit.hom_ext">docs#category_theory.limits.colimit.hom_ext</a> <code>docs#category_theory.limits.colimit.\iota_desc</code> (fix the unicode...) <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.colimit.desc">docs#category_theory.limits.colimit.desc</a> etc.</p>



<a name="285379105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285379105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285379105">(Jun 08 2022 at 11:49)</a>:</h4>
<p>I think you're saying that some stuff I want is special cases of statements about limits and for psychological reasons I've been avoiding thinking about things in this way; I don't ever think of a kernel as an equaliser, for example. I think of it as something with an API</p>



<a name="285379190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/imker/near/285379190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Fimker.html#285379190">(Jun 08 2022 at 11:50)</a>:</h4>
<p>And that's the right way to think of it! But you should keep in mind that the API mimics the limits api and try to use that because the simp lemmas have been set up to work well as such.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
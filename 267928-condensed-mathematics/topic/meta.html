---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/meta.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html">meta</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="243082828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243082828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Scholze <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243082828">(Jun 17 2021 at 20:51)</a>:</h4>
<p>Here's a meta question. How much would have to happen before Lean (or something similar) is able to</p>
<p>a) do such computations as yesterday, once it has been told the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> (it knows this definition since early January...);</p>
<p>b) sift through the literature to figure out that this complex in fact goes back to Eilenberg and MacLane (and has arisen repeatedly since)? Or well, at least suggest relevant references.</p>
<p>I gather b) is much much harder than a) and would definitely require significant upfront work, of "digitizing" the whole literature in the first place. I became aware of the reference because one of my PostDocs (Johannes Anschütz) was just looking at that paper of MacLane, so mentioned this to me over lunch.</p>
<p>But a) sounds more realistic to me. It feels weird that you have to code from scratch in a different language, why not simply let Lean compute some examples?</p>



<a name="243097613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243097613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243097613">(Jun 17 2021 at 23:14)</a>:</h4>
<p>(I've moved Patrick's post to the correct topic.)</p>



<a name="243098847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243098847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243098847">(Jun 17 2021 at 23:31)</a>:</h4>
<p>(a) is a significantly difficult and a lot less automatic than you think. The gap between a mathematical definition, even a "computational" one as perceived by a mathematician, to an actual program that can calculate the result, especially if it needs to be efficient and not just computable in principle, is quite large. I relied quite heavily on Johan's python program as a baseline implementation. In some cases, the naive implementation performs well enough to run on the examples that matter, in which case you might get away with just writing the program in a plausibly computable way in lean, but most of the time the mathematical description is entirely separate from the computation.</p>



<a name="243115286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243115286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243115286">(Jun 18 2021 at 04:29)</a>:</h4>
<p>Still, as far as I understand, Lean 4 might be a language in which we can do both. It might still be a separate program implementing certain definitions in a specific way to take advantage of the context (e.g., linear algebra over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathbb F_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83889em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> has a much more efficient algorithm than the general case). But it would be the same language in which you prove and compute.</p>



<a name="243115571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243115571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243115571">(Jun 18 2021 at 04:35)</a>:</h4>
<p>Let me put it like this: all the small <code>h(p,i)</code> that I computed by brute force in Sage should be computable just as well in Lean (once it becomes as fast as Lean 4 is). All that is needed for that is an implementation of Gaussian elimination (and maybe a proof that it actually is a way to compute dimensions?).<br>
But the next observation was to do a randomized computation. This was human input, so I don't think Lean will quickly come up with that idea when you just tell it "compute this".<br>
Still it is conceivable that Lean can compute <code>h(3,3)</code> and <code>h(7,2)</code> with the standard definitions and a little bit of extra code to do the randomized computation.<br>
But the computation of <code>h(2,4)</code> required a completely different implementation of linear algebra. We would have to teach Lean: hey, if you are working over a field with 2 elements, please use these faster algorithms instead of the default ones (and here's a proof that they do the right thing).</p>



<a name="243115828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243115828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243115828">(Jun 18 2021 at 04:40)</a>:</h4>
<p>that last bit isn't that unusual; in lean we would normally write the algorithm generically over (computable) fields, and for <code>h(3,3)</code> and <code>h(7,2)</code> we are using <code>zmod 3</code> and <code>zmod 7</code>, while for <code>h(2,4)</code> we are using <code>bool</code></p>



<a name="243116170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243116170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243116170">(Jun 18 2021 at 04:48)</a>:</h4>
<p>But it's not just that we use <code>bool</code>. We also cut out a lot of computations that would otherwise just be multiplying by <code>1</code> all the time.</p>



<a name="243127865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243127865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243127865">(Jun 18 2021 at 08:04)</a>:</h4>
<p>Interesting. So, if lean 3/4 were to do these computations would the result just be ,say, the rank of the subspace or would it also provide a full proof of this fact? i.e. it gives a full proof detailing each step in the Gaussian elimination? perhaps this depends on how one made lean do the computation.</p>



<a name="243129472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243129472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243129472">(Jun 18 2021 at 08:19)</a>:</h4>
<p>Yes, it depends on what you ask Lean to do. It could generate a proof along the way, but it would be a massive proof term.</p>



<a name="243131630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/meta/near/243131630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/meta.html#243131630">(Jun 18 2021 at 08:39)</a>:</h4>
<p>Yeah in these cases one maybe only wants a "quantum proof". i.e. one that only exists while the computation is running but is never observed by the user or recorded. Or you compress the proof sufficiently so that it could be stored, but that might not always be possible.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
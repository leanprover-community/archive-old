---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html">salamander/ab cat stuff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="278707349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278707349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278707349">(Apr 12 2022 at 15:12)</a>:</h4>
<p>I'm taking a break from marking and so I pulled LTE. The most noticeable thing was a new 1000 line file from Johan called <code>for_mathlib/salamander</code> which does a lot of diagram-chasology but is not quite sorry-free. I drew the diagram for the first sorry and it seems to me that the missing ingredient is that if A B C : \C^op and f: A-&gt; B and g:B-&gt;C with gf=0 then you can make a commuting square from this picture with ker(g) being the fourth vertex, the map from A to ker(g) is called something like kernel.lift and the map from ker(g) to C is 0. Now you can take the unop of this entire diagram and get a commuting square in the original abelian category C but you can also make it by hand using coker(g^unop) and cokernel.desc. What we need is that "these diagrams are the same". How is one expected to prove this? I'm reminded of what we did in version 1 of schemes where we had to prove a ton of diagrams commuted and we just bashed it all out. But is there some sort of more sophisticated approach? I'm assuming (ker g)^unop isn't <em>equal</em> to coker(g^unop) in general. In schemes we introduced an "is_localisation" predicate. Do we have an "is_cokernel" predicate here because that would be one way to proceed. Or do people have completely different ideas about how to go about this?</p>



<a name="278707624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278707624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278707624">(Apr 12 2022 at 15:14)</a>:</h4>
<p>Yeah, there are 5 annoying sorries left in that file. But once we have those filled in, we'll have a very nice atomic building block for diagram chases in double complexes.</p>



<a name="278708019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278708019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278708019">(Apr 12 2022 at 15:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <code>is_cokernel</code> is essentially <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_colimit">docs#category_theory.limits.is_colimit</a> applied to a <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.cokernel_cofork">docs#category_theory.limits.cokernel_cofork</a></p>



<a name="278708165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278708165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278708165">(Apr 12 2022 at 15:18)</a>:</h4>
<p>BTW, we should have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.cokernel_unop_op">docs#category_theory.cokernel_unop_op</a></p>



<a name="278709096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278709096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278709096">(Apr 12 2022 at 15:24)</a>:</h4>
<p>A little while ago I contemplated whether we should have (co)limits as a class, see<br>
<a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/limits.20as.20a.20class.3F/near/247014056">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/limits.20as.20a.20class.3F/near/247014056</a></p>
<p>As you can see, Bhavik wasn't a fan.</p>



<a name="278710126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278710126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278710126">(Apr 12 2022 at 15:32)</a>:</h4>
<p>nonono</p>



<a name="278710177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278710177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278710177">(Apr 12 2022 at 15:33)</a>:</h4>
<p>I guess Reid is not a fan either ;)</p>



<a name="278727625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278727625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278727625">(Apr 12 2022 at 17:47)</a>:</h4>
<p>The argument against is that it carries data but surely you can somehow bundle everything together and have a prop-valued predicate. Oh I guess the point is then that it can't be a class</p>



<a name="278728283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278728283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278728283">(Apr 12 2022 at 17:51)</a>:</h4>
<p>I don't think it's a problem for it to contain data. Yes, if we start throwing a bunch of instances of such classes in mathlib, that would be bad, but if we are conservative about what instances are declared as such, I don't think it would be a problem. </p>
<p>This <code>is_zero</code> that I suggested in the link above is a special case that was added to LTE and it works very nicely.<br>
We could add <code>is_cokernel</code> and <code>is_kernel</code> as well, and I would guess they would be just as nice to work with in practice.</p>



<a name="278728484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278728484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278728484">(Apr 12 2022 at 17:52)</a>:</h4>
<p>But as Bhavik pointed out, is_zero doesn't have any data. Somehow you have to remember the map as well as the object with is_cokernel</p>



<a name="278728719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278728719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278728719">(Apr 12 2022 at 17:53)</a>:</h4>
<p>Yeah, but that map is unique given the properties it satisfies.</p>



<a name="278732178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278732178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278732178">(Apr 12 2022 at 18:18)</a>:</h4>
<p>Here's some code for the special case of cokernels.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.abelian.basic</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">abelian</span> <span class="n">C</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">is_cokernel</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">out_param</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">))</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">π'</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">Z</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">π'</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">limits.is_colimit</span> <span class="o">(</span><span class="n">limits.cokernel_cofork.of_π</span> <span class="n">_</span> <span class="n">h1</span><span class="o">)))</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_cokernel</span> <span class="n">f</span> <span class="n">Z</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">is_cokernel.π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_cokernel</span> <span class="n">f</span> <span class="n">Z</span><span class="o">]</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="n">is_cokernel.π'</span> <span class="n">X</span>

<span class="kd">@[simp, reassoc]</span>
<span class="kd">lemma</span> <span class="n">is_cokernel.condition</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">is_cokernel.h1</span>

<span class="kd">def</span> <span class="n">is_cokernel.cofork</span> <span class="o">:</span> <span class="n">limits.cokernel_cofork</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">limits.cokernel_cofork.of_π</span> <span class="o">(</span><span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">is_cokernel.condition</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">is_cokernel.is_colimit</span> <span class="o">:</span> <span class="n">limits.is_colimit</span> <span class="o">(</span><span class="n">is_cokernel.cofork</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_cokernel.h2.some</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">is_cokernel.desc</span> <span class="o">{</span><span class="n">W</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">⟶</span> <span class="n">W</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_cokernel.is_colimit</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">desc</span> <span class="bp">$</span> <span class="n">limits.cokernel_cofork.of_π</span> <span class="n">g</span> <span class="n">w</span>

<span class="kd">@[simp, reassoc]</span>
<span class="kd">lemma</span> <span class="n">is_cokernel.fac</span> <span class="o">{</span><span class="n">W</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span> <span class="bp">≫</span> <span class="n">is_cokernel.desc</span> <span class="n">f</span> <span class="n">Z</span> <span class="n">g</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_cokernel.is_colimit</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">fac</span> <span class="o">(</span><span class="n">limits.cokernel_cofork.of_π</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">limits.walking_parallel_pair.one</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">is_cokernel.uniq</span> <span class="o">{</span><span class="n">W</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">⟶</span> <span class="n">W</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span> <span class="bp">≫</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">is_cokernel.desc</span> <span class="n">f</span> <span class="n">Z</span> <span class="n">g</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">is_cokernel.is_colimit</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">uniq</span> <span class="o">(</span><span class="n">limits.cokernel_cofork.of_π</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">(</span><span class="n">_</span><span class="bp">|</span><span class="n">_</span><span class="o">),</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">hm</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">is_cokernel.hom_ext</span> <span class="o">{</span><span class="n">W</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span> <span class="bp">≫</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span> <span class="bp">≫</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">is_cokernel.is_colimit</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">hom_ext</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">(</span><span class="n">_</span><span class="bp">|</span><span class="n">_</span><span class="o">),</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">is_cokernel.iso</span> <span class="o">(</span><span class="n">Z'</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_cokernel</span> <span class="n">f</span> <span class="n">Z'</span><span class="o">]</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">≅</span> <span class="n">Z'</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_cokernel.is_colimit</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">cocone_point_unique_up_to_iso</span> <span class="o">(</span><span class="n">is_cokernel.is_colimit</span> <span class="n">f</span> <span class="n">Z'</span><span class="o">)</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">is_cokernel.iso_hom</span> <span class="o">(</span><span class="n">Z'</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_cokernel</span> <span class="n">f</span> <span class="n">Z'</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">is_cokernel.iso</span> <span class="n">f</span> <span class="n">Z</span> <span class="n">Z'</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">=</span> <span class="n">is_cokernel.desc</span> <span class="n">f</span> <span class="n">Z</span> <span class="o">(</span><span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z'</span><span class="o">)</span> <span class="o">(</span><span class="n">is_cokernel.condition</span> <span class="n">f</span> <span class="n">Z'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">is_cokernel.iso_inv</span> <span class="o">(</span><span class="n">Z'</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">is_cokernel</span> <span class="n">f</span> <span class="n">Z'</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">is_cokernel.iso</span> <span class="n">f</span> <span class="n">Z</span> <span class="n">Z'</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">=</span> <span class="n">is_cokernel.desc</span> <span class="n">f</span> <span class="n">Z'</span> <span class="o">(</span><span class="n">is_cokernel.π</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">is_cokernel.condition</span> <span class="n">f</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>
</div></div>



<a name="278733462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278733462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278733462">(Apr 12 2022 at 18:28)</a>:</h4>
<p>Oh, and of course we can't forget</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span>
<span class="kd">instance</span> <span class="n">cokernel_is_cokernel</span> <span class="o">:</span> <span class="n">is_cokernel</span> <span class="n">f</span> <span class="o">(</span><span class="n">limits.cokernel</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">π'</span> <span class="o">:=</span> <span class="n">limits.cokernel.π</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">h1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">h2</span> <span class="o">:=</span> <span class="n">nonempty.intro</span> <span class="bp">$</span>
  <span class="o">{</span> <span class="n">desc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">limits.cokernel_cofork</span> <span class="n">_</span><span class="o">),</span> <span class="n">limits.cokernel.desc</span> <span class="n">_</span> <span class="n">S.π</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">fac'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">limits.cokernel_cofork</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">_</span><span class="bp">|</span><span class="n">_</span><span class="o">),</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">uniq'</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">rintro</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">limits.cokernel_cofork</span> <span class="n">_</span><span class="o">)</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">limits.coequalizer.hom_ext</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="n">limits.walking_parallel_pair.one</span><span class="o">,</span>
    <span class="kd">end</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>



<a name="278760760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278760760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278760760">(Apr 12 2022 at 22:12)</a>:</h4>
<p>Does this make the sorry easier? Does it really need to be a class rather than just a structure?</p>



<a name="278760775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278760775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278760775">(Apr 12 2022 at 22:13)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_localization">docs#is_localization</a></p>



<a name="278760900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278760900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278760900">(Apr 12 2022 at 22:14)</a>:</h4>
<p>That's a class but also a Prop. Can you make pi' be an input rather than a field? Could it be a predicate on the morphism rather than the object?</p>



<a name="278761596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278761596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278761596">(Apr 12 2022 at 22:22)</a>:</h4>
<p>It doesn't need to be a class. If you're happy with a structure, then you can carry around a term of type <code>limits.is_colimit (limits.cokernel_cofork.of_π _ _)</code> (that what we currently have).</p>



<a name="278762230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278762230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278762230">(Apr 12 2022 at 22:30)</a>:</h4>
<p>From a purely philosophical point of view, what do you think of when you think of a limit? Say just a product <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \times Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>.<br>
From my perspective, it's an object, say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, which is endowed with the data of two projections <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">P \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">P \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> which satisfy some axioms. Yes, the two projections <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">P \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">P \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> are additional data, and the additional axioms are propositions.</p>
<p>I think it would be nice to be able to write <code>[is_product X Y P]</code> and get <code>pi_1 : P \to X</code> and <code>pi_2 : P \to Y</code> (as well as the axioms) as part of the class..</p>



<a name="278768031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278768031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278768031">(Apr 12 2022 at 23:51)</a>:</h4>
<p>For me the salient example is a square being a pullback (or pushout), which has a pasting/cancellation property that seems more or less impossible to express in this language.</p>



<a name="278768196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/278768196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#278768196">(Apr 12 2022 at 23:53)</a>:</h4>
<p>But the same kind of issue arises even for products, e.g. a model of a Lawvere theory is a functor that preserves products and this also seems not to fit well with the <code>[is_product X Y P]</code> class</p>



<a name="281748235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/salamander/ab%20cat%20stuff/near/281748235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/salamander.2Fab.20cat.20stuff.html#281748235">(May 09 2022 at 21:27)</a>:</h4>
<p>We can probably avoid using the salamander lemma file. So there's no hurry to work on the remaining <code>sorry</code>s in <code>salamander.lean</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
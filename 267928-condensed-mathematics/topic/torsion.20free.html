---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/torsion.20free.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html">torsion free</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227615409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227615409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227615409">(Feb 24 2021 at 15:27)</a>:</h4>
<p>A little project: develop some API for <code>torsion_free</code>.<br>
If we want to do this mathlib style, then we probably need:</p>
<p>Definitions:</p>
<ul>
<li>torsion free modules <code>module.torsion_free</code>?</li>
<li>torsion free (additive) groups <code>torsion_free</code>/<code>add_torsion_free</code>?</li>
<li>(do we care about the noncommutative case?)</li>
</ul>
<p>Glue:</p>
<ul>
<li>glue between the two additive notions</li>
</ul>
<p>API:</p>
<ul>
<li>finite <code>direct_sum</code> of add_groups / modules</li>
<li>subgroups/submodules</li>
</ul>



<a name="227615535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227615535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227615535">(Feb 24 2021 at 15:28)</a>:</h4>
<p>What's the definition of torsion-free over rings with zero divisors?</p>



<a name="227615629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227615629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227615629">(Feb 24 2021 at 15:29)</a>:</h4>
<p>I guess now that we have regular elements in mathlib (right?) we can say that the module has no torsion with respect to every regular element.</p>



<a name="227616065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227616065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227616065">(Feb 24 2021 at 15:31)</a>:</h4>
<p>I think we can also choose to only develop the notion for modules. But when someone shows up and wants to apply it to a multiplicative group, we'll need to duplicate the API at that point.</p>



<a name="227616168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227616168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227616168">(Feb 24 2021 at 15:32)</a>:</h4>
<p>Maybe that's even better, because then we can crystallize the API just in the module case, and afterwards the copy-pasta should be straightforward when we want to adapt it to groups.</p>



<a name="227616438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227616438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227616438">(Feb 24 2021 at 15:34)</a>:</h4>
<p>Oh, I just noticed that <code>is_regular</code> is defined for anything with <code>has_mul</code> <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="227622307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227622307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227622307">(Feb 24 2021 at 16:04)</a>:</h4>
<p>I am not sure whether the definition of <code>is_regular</code> already applies to modules, but if it does not apply "as is", it should really be defined by saying that a scalar <code>r</code> is regular for a module <code>M</code> should mean that smultiplication by <code>r</code> is injective.</p>



<a name="227622971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227622971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227622971">(Feb 24 2021 at 16:06)</a>:</h4>
<p>For instance, I would say that <code>1 : \Z</code> is regular on <code>zmod 2</code>, but <code>2</code> is not.  I have not thought too much about the case in which the module is not faithful, though, so I am not sure whether down the line, you would like to avoid these cases...</p>



<a name="227646477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227646477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227646477">(Feb 24 2021 at 18:17)</a>:</h4>
<p>So here's a definition that works in general:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.regular</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">M</span> <span class="n">X</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">torsion_free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">is_regular</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">function.injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="227646557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227646557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227646557">(Feb 24 2021 at 18:18)</a>:</h4>
<p>But to get torsion-free groups out of this, we have to do some gymnastics:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- is this somewhere?</span>
<span class="kd">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">ℕ</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="bp">^</span><span class="n">x</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">pow_mul'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nat.pos_regular</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">is_regular</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">nat.mul_right_inj</span> <span class="n">h</span> <span class="n">at</span> <span class="n">hh</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">nat.mul_left_inj</span> <span class="n">h</span> <span class="n">at</span> <span class="n">hh</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat.succ_regular</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_regular</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.pos_regular</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">$</span> <span class="n">nat.succ_pos</span> <span class="n">_</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">cond</span> <span class="o">:</span> <span class="n">torsion_free</span> <span class="n">ℕ</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">^</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">x</span> <span class="n">hn</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span> <span class="o">{</span><span class="n">finish</span><span class="o">},</span>
  <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">cond</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">nat.succ_regular</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227649489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227649489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227649489">(Feb 24 2021 at 18:37)</a>:</h4>
<p>But for torsion-free add_groups the gymnastics should be less convoluted, right?</p>



<a name="227653058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653058">(Feb 24 2021 at 19:00)</a>:</h4>
<p>yeah, those should have an automatic instance of a mul-action by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>.</p>



<a name="227653113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653113">(Feb 24 2021 at 19:00)</a>:</h4>
<p>In the regular file there should be a lemma about nonzero elements of integral domains being regular.  I think that, with Eric's refactor, N should be an integral domain... maybe!</p>



<a name="227653178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653178">(Feb 24 2021 at 19:00)</a>:</h4>
<p>Or is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span> an integral semidomain?</p>



<a name="227653272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653272">(Feb 24 2021 at 19:01)</a>:</h4>
<p>Maybe: I'm not at my computer and cannot check...</p>



<a name="227653290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653290">(Feb 24 2021 at 19:01)</a>:</h4>
<p>(that was a joke <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> I really hope no one defines a semidomain)</p>



<a name="227653521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653521">(Feb 24 2021 at 19:03)</a>:</h4>
<p>Oh, but <code>domain</code> extends <code>ring</code> in mathlib.</p>



<a name="227653537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227653537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227653537">(Feb 24 2021 at 19:03)</a>:</h4>
<p>Certainly, an N is commutative, there is a lemma that allows you to only prove left regular.</p>



<a name="227665121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227665121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227665121">(Feb 24 2021 at 20:20)</a>:</h4>
<p>Actually, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.pos_regular</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">is_regular</span> <span class="n">m</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_regular_of_cancel_monoid_with_zero</span> <span class="n">h.ne.symm</span>
</code></pre></div>



<a name="227665950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227665950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227665950">(Feb 24 2021 at 20:25)</a>:</h4>
<p>I learned recently that <code>lt.ne'</code> is the same as <code>lt.ne.symm</code>.</p>



<a name="227667068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227667068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227667068">(Feb 24 2021 at 20:32)</a>:</h4>
<p>Thanks for the characters' saving tip!</p>



<a name="227667346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227667346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227667346">(Feb 24 2021 at 20:34)</a>:</h4>
<p>Maybe a better name for <code>is_regular_of_cancel_monoid_with_zero</code> would be <code>is_regular_of_ne_zero</code>?</p>



<a name="227668576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227668576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227668576">(Feb 24 2021 at 20:41)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I like that name! Sounds good</p>



<a name="227669795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227669795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227669795">(Feb 24 2021 at 20:48)</a>:</h4>
<p>I'll PR it tomorrow, but feel free to change it now, if you want!  I'm pretty sure no one has used the lemma yet</p>



<a name="227712526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227712526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227712526">(Feb 25 2021 at 03:27)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/6408">#6408</a></p>



<a name="227714405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227714405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227714405">(Feb 25 2021 at 04:00)</a>:</h4>
<p>Adam, the instance <code>mul_action</code> works, with the same proof, for a <code>monoid</code>.  Given an earlier discussion, maybe we should also have an instance of <code>mul_action pnat G</code>, for any semigroup <code>G</code>!  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- is this somewhere?</span>
<span class="kd">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">ℕ</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="bp">^</span><span class="n">x</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">pow_mul'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="227715377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227715377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227715377">(Feb 25 2021 at 04:17)</a>:</h4>
<p>Sounds good to me!</p>



<a name="227715388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227715388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227715388">(Feb 25 2021 at 04:17)</a>:</h4>
<p>How generally are natural-number powers defined in mathlib?</p>



<a name="227715389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227715389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227715389">(Feb 25 2021 at 04:17)</a>:</h4>
<p>We can go as general as that...</p>



<a name="227715448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227715448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227715448">(Feb 25 2021 at 04:18)</a>:</h4>
<p>I don't know how easy it would be to make the <code>to_additive</code> machine work there...</p>



<a name="227715456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227715456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227715456">(Feb 25 2021 at 04:18)</a>:</h4>
<p>(if it can be made to work at all!)</p>



<a name="227715660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227715660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227715660">(Feb 25 2021 at 04:22)</a>:</h4>
<p>yeah, the trouble is that we are switch the sides of the action</p>



<a name="227720439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227720439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227720439">(Feb 25 2021 at 05:31)</a>:</h4>
<p>Regardless of whether we use it or not, I decided to give a try to defining <code>pnat</code> powers, but I seem to be lacking good techniques to work with them: can you suggest a better proof?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">power</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">G</span> <span class="n">pnat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pow</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">g</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">n0</span><span class="o">,</span>
  <span class="n">generalize'</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n.pred</span> <span class="bp">=</span> <span class="n">np</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">n1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n.pred.succ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ_pred_eq_of_pos</span> <span class="n">n0</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hn</span> <span class="n">at</span> <span class="n">n1</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">n1</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">np</span> <span class="k">with</span> <span class="n">np</span> <span class="n">hnp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">g</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hnp</span> <span class="n">np.succ_pos</span> <span class="n">np.pred_succ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span> <span class="o">}</span>
<span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="227720499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227720499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227720499">(Feb 25 2021 at 05:32)</a>:</h4>
<p>In particular, I could not find a suitable "pnat induction" lemma in the library.</p>



<a name="227720622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227720622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227720622">(Feb 25 2021 at 05:34)</a>:</h4>
<p>Moreover, to then make it work, it seems that it should be proven for <code>{n // 0 &lt; n}</code> as well as for <code>pnat</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">hm</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">}</span>
<span class="k">#check</span> <span class="n">g</span> <span class="bp">^</span> <span class="n">n</span> <span class="c1">--works</span>
<span class="k">#check</span> <span class="o">(⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="c1">--works</span>
<span class="k">#check</span> <span class="n">g</span> <span class="bp">^</span> <span class="o">(⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">hm</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span>
<span class="c1">-- fails: `failed to synthesize type class instance for [...] ⊢ has_pow G {n // 0 &lt; n}`</span>
</code></pre></div>



<a name="227734459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227734459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227734459">(Feb 25 2021 at 08:35)</a>:</h4>
<p>I'm not sure that going as far down as semigroups is necessary, however this might just be because everyone is always happy to stop at monoids. Damiano -- nobody uses <code>pnat</code> so it doesn't surprise me that you can't find induction. Just define pnat.rec_on and make a PR, and then apply it instead. Don't forget to tag it <code>elab_as_eliminator</code> so that lean has a better chance of figuring out the so-called "motive" <code>C</code>. Maybe experimenting with semigroups will be a good excuse to make <code>pnat</code> great again</p>



<a name="227734497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227734497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227734497">(Feb 25 2021 at 08:35)</a>:</h4>
<p>Is there a strong need for <code>pnat</code> powers?</p>



<a name="227734629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227734629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227734629">(Feb 25 2021 at 08:37)</a>:</h4>
<p>You'll have problems making an API for your current  definition because you've made it in tactic mode. Try #print ing it to see what kind of a monster it is</p>



<a name="227734656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227734656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227734656">(Feb 25 2021 at 08:37)</a>:</h4>
<p>Not really, I don't see any harm in sticking to monoids</p>



<a name="227734682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227734682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227734682">(Feb 25 2021 at 08:37)</a>:</h4>
<p>The issue is that with a semigroup you don't have g^0</p>



<a name="227735709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227735709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227735709">(Feb 25 2021 at 08:48)</a>:</h4>
<p>I have no application in mind that would want an action of a <code>semigroup</code> instead of a <code>monoid</code>: in most situations that I can imagine, there is very little difficulty in extending a <code>semigroup</code> to a <code>monoid</code> by adding a "natural" identity.  Thus, for the moment, I would not go further down this road.  The above was mostly an experiment to work with <code>pnat</code>and I am glad that Kevin confirms that it is missing some functionality!</p>



<a name="227736009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227736009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227736009">(Feb 25 2021 at 08:51)</a>:</h4>
<p>Besides, I am failing to produce an element of <code>G</code> by induction.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_eliminator]</span>
<span class="kd">lemma</span> <span class="n">pnat.rec_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">n0</span><span class="o">,</span>
  <span class="n">generalize'</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n.pred</span> <span class="bp">=</span> <span class="n">np</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">n1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n.pred.succ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ_pred_eq_of_pos</span> <span class="n">n0</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hn</span> <span class="n">at</span> <span class="n">n1</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">n1</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">np</span> <span class="k">with</span> <span class="n">np</span> <span class="n">hnp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">p1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hp</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">np.succ_pos</span><span class="o">⟩</span> <span class="o">(</span><span class="n">hnp</span> <span class="n">_</span> <span class="n">np.pred_succ</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">power_Np</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">G</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pow</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">g</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">pnat.rec_on</span> <span class="n">n</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
<span class="c1">-- fails saying</span>

<span class="n">invalid</span> <span class="bp">'</span><span class="n">pnat.rec_on'</span> <span class="n">application</span><span class="o">,</span> <span class="n">elaborator</span> <span class="n">has</span> <span class="n">special</span> <span class="n">support</span> <span class="n">for</span> <span class="n">this</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">application</span>
<span class="o">(</span><span class="n">it</span> <span class="n">is</span> <span class="n">handled</span> <span class="n">as</span> <span class="n">an</span> <span class="s2">"eliminator"</span><span class="o">),</span> <span class="n">but</span> <span class="n">the</span> <span class="n">expected</span> <span class="n">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="n">G</span><span class="o">,</span>
<span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span>
<span class="bp">⊢</span> <span class="n">G</span>
<span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>Using <code>refine</code> instead of <code>apply</code> gives:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">power_Np</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">G</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pow</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">g</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">pnat.rec_on</span> <span class="n">n</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
<span class="c1">-- fails saying</span>

<span class="s2">"eliminator"</span> <span class="n">elaborator</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">the</span> <span class="n">motive</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="n">G</span><span class="o">,</span>
<span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span>
<span class="bp">⊢</span> <span class="n">G</span>
</code></pre></div>



<a name="227736732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227736732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227736732">(Feb 25 2021 at 08:59)</a>:</h4>
<p>I think <code>Sort</code> needs to be replaced by <code>Sort*</code></p>



<a name="227736756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227736756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227736756">(Feb 25 2021 at 09:00)</a>:</h4>
<p>I think <code>Sort = Prop</code></p>



<a name="227737104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227737104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227737104">(Feb 25 2021 at 09:02)</a>:</h4>
<p>And my gut feeling is that the <code>subst</code> command is inserting an <code>eq.rec</code> which might be tough to prove things about. I'm stuck away from Lean right now but I would be tempted to write this in term mode using <code>nat.rec</code> and trying to avoid a further <code>eq.rec</code></p>



<a name="227737276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227737276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227737276">(Feb 25 2021 at 09:04)</a>:</h4>
<p>Presumably there's pnat.pred to nat and a map the other way too and it's just a case of composing these with nat.rec</p>



<a name="227737353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227737353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227737353">(Feb 25 2021 at 09:05)</a>:</h4>
<p>But your eliminator problems might just be the Sort issue</p>



<a name="227742065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227742065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227742065">(Feb 25 2021 at 09:49)</a>:</h4>
<p>OK I'm at a PC, I'll give this pnat thing a go</p>



<a name="227742417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227742417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227742417">(Feb 25 2021 at 09:52)</a>:</h4>
<p>Your <code>lemma</code> should be a <code>def</code></p>



<a name="227744036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227744036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227744036">(Feb 25 2021 at 10:06)</a>:</h4>
<p>I was talking to a student, so I am now reading your comments!</p>



<a name="227745994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227745994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227745994">(Feb 25 2021 at 10:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">)</span> <span class="o">:</span> <span class="n">n.nat_pred.succ_pnat</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails :-(</span>
</code></pre></div>
<p>This is the problem. Maybe you need the <code>eq.rec</code> to get over this.</p>



<a name="227746103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227746103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227746103">(Feb 25 2021 at 10:24)</a>:</h4>
<p>I am also having a hard time working with this...</p>



<a name="227746185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227746185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227746185">(Feb 25 2021 at 10:25)</a>:</h4>
<p>the <code>subst</code> command was there, since I could not even <code>rw</code> it in the goal (which I understand I should avoid anyway, but there was already something that I found strange)</p>



<a name="227746283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227746283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227746283">(Feb 25 2021 at 10:26)</a>:</h4>
<p>This could be fixed by redefining <code>pnat</code> to be <code>nat</code>.</p>



<a name="227746403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227746403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227746403">(Feb 25 2021 at 10:27)</a>:</h4>
<p>I would like that.  In fact, I would like to define a <code>nat</code> depending on a <code>nat</code> to stand for the "naturals at least equal to _"!</p>



<a name="227746748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227746748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227746748">(Feb 25 2021 at 10:30)</a>:</h4>
<p>With the <code>Sort*</code>, the induction applied to the definition of <code>has_pow</code> and it was easy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">power_Np</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">G</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pow</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">n</span><span class="o">,</span> <span class="o">((</span><span class="n">pnat.rec_on</span> <span class="n">n</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">pm1</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">pm1</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span><span class="o">))</span> <span class="n">g</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>However, as you predicted, the lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pow_one</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">^</span> <span class="o">(⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">nat.one_pos</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
</code></pre></div>
<p>went from being <code>rfl</code> to being not soluble by me!</p>



<a name="227747145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227747145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227747145">(Feb 25 2021 at 10:34)</a>:</h4>
<p>I think that I will give up: I am not sure how to make progress on this, and I am also not in need for defining induction or powers using <code>pnat</code>.</p>



<a name="227748374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227748374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227748374">(Feb 25 2021 at 10:46)</a>:</h4>
<p>I need to stop because I am teaching in 5 hours and I've still not started on my blog post or pushed any material. Because the proof of <code>foo</code> below is not <code>rfl</code>, one has to use <code>eq.subst</code> (whose proof is just <code>eq.rec</code>) to push through this approach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pnat.basic</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="c1">-- example (n : ℕ+) : n.nat_pred.succ_pnat = n := rfl -- fails :-(</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">)</span> <span class="o">:</span> <span class="n">n.nat_pred.succ_pnat</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- now `eq.subst (foo n) : p (n.nat_pred.succ_pnat) → p n</span>

<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">pnat.rec_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">eq.subst</span> <span class="o">(</span><span class="n">foo</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">p</span> <span class="o">(</span><span class="n">succ_pnat</span> <span class="n">m</span><span class="o">))</span> <span class="n">p1</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="o">(</span><span class="n">pm</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">succ_pnat</span> <span class="n">m</span><span class="o">)),</span> <span class="o">(</span><span class="n">hp</span> <span class="o">(</span><span class="n">succ_pnat</span> <span class="n">m</span><span class="o">)</span> <span class="n">pm</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">succ_pnat</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))))</span> <span class="n">n.nat_pred</span><span class="o">)</span>
</code></pre></div>
<p>The crucial thing about <code>nat.rec</code> is that if you have <code>C0 : C 0</code> and <code>Csucc n : C n -&gt; C (n + 1)</code> and you define your function <code>f</code> with <code>nat.rec</code>, then <code>f 0 = c0</code> and <code>f (n + 1) = Csucc n (f n)</code> are both <code>rfl</code>. The <code>eq.subst</code> will mess all this up though. I think the way to proceed is not as above but instead to use <code>nat.rec</code> on <code>n.1</code>. I'll try this later on but right now I need to focus on my class.</p>



<a name="227748620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227748620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227748620">(Feb 25 2021 at 10:49)</a>:</h4>
<p>Some smart people have looked at <code>pnat</code> and the fact that nobody has defined <code>pnat.rec</code> is telling. There's the induction principle but this has fewer problems because Prop is easier to handle than Type.</p>



<a name="227748865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227748865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227748865">(Feb 25 2021 at 10:51)</a>:</h4>
<p>Here's a proof using <code>nat.rec</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">pnat.rec_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">n</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">IH</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">h</span> <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">p1</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hp</span> <span class="n">_</span> <span class="o">(</span><span class="n">IH</span> <span class="n">n.succ_pos</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227748920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227748920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227748920">(Feb 25 2021 at 10:52)</a>:</h4>
<p>(I can use tactics because I'm a professional <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> )</p>



<a name="227749337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227749337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227749337">(Feb 25 2021 at 10:56)</a>:</h4>
<p>Very nice, Mario!  Thank you!</p>



<a name="227749400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227749400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227749400">(Feb 25 2021 at 10:57)</a>:</h4>
<p>also don't forget the equation lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">pnat.rec_on_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="n">hp</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">pnat.rec_on</span> <span class="mi">1</span> <span class="n">p</span> <span class="n">p1</span> <span class="n">hp</span> <span class="bp">=</span> <span class="n">p1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">pnat.rec_on_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="n">hp</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">pnat.rec_on</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">p</span> <span class="n">p1</span> <span class="n">hp</span> <span class="bp">=</span> <span class="n">hp</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">pnat.rec_on</span> <span class="n">n</span> <span class="n">p</span> <span class="n">p1</span> <span class="n">hp</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="o">[</span><span class="n">exact</span> <span class="n">absurd</span> <span class="n">h</span> <span class="n">dec_trivial</span><span class="o">,</span> <span class="n">refl</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="227749426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227749426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227749426">(Feb 25 2021 at 10:57)</a>:</h4>
<p>Unfortunately as you can see they aren't both refl</p>



<a name="227749441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227749441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227749441">(Feb 25 2021 at 10:57)</a>:</h4>
<p>because <code>pnat</code> isn't actually an inductive type</p>



<a name="227751300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227751300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227751300">(Feb 25 2021 at 11:14)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> it doesn't matter if the proofs aren't refl -- what matters is that the proofs exist!</p>



<a name="227752338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227752338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227752338">(Feb 25 2021 at 11:24)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/6410">#6410</a> : Mario's induction for <code>pnat</code>!</p>



<a name="227753813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227753813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227753813">(Feb 25 2021 at 11:39)</a>:</h4>
<p>Note that Mario's proof did indeed do induction on <code>n : nat</code> rather than <code>n.nat_pred</code>.</p>



<a name="227754008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227754008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227754008">(Feb 25 2021 at 11:41)</a>:</h4>
<p>Yes, I thought that working with a natural number was better than working with an absurd induction step and then splitting cases, but I was wrong!</p>



<a name="227754146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227754146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227754146">(Feb 25 2021 at 11:42)</a>:</h4>
<p>This now works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">power_Np</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">G</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pow</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">pnat.rec_on</span> <span class="n">n</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">id</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">pm1</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">pm1</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span> <span class="o">}</span>
<span class="kd">end</span>
<span class="o">}</span>

<span class="kd">lemma</span> <span class="n">action_one</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">^</span> <span class="o">(⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">nat.one_pos</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">action_succ</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semigroup</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">^</span> <span class="o">(⟨</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">succ_pos</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">^</span> <span class="o">(⟨</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n.succ_pos</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="227754501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227754501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227754501">(Feb 25 2021 at 11:46)</a>:</h4>
<p>However, Lean almost immediately complains about excessive memory consumption.  This might be a consequence of having the lemma in the <code>liquid</code> project and not on the separate file <code>data/pnat/basic</code>.</p>



<a name="227756633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227756633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227756633">(Feb 25 2021 at 12:07)</a>:</h4>
<p>unlikely, that shouldn't make much difference</p>



<a name="227756688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227756688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227756688">(Feb 25 2021 at 12:08)</a>:</h4>
<p>If you modified a basic file and then went back to the liquid project then lean might be going crazy compiling mathlib in the editor</p>



<a name="227756814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227756814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227756814">(Feb 25 2021 at 12:09)</a>:</h4>
<p>Ok, I closed all tabs other than the one where I am working (which at the moment does not even depend on the <code>pnat</code> thing) and I hope that there will no longer be memory issues!</p>



<a name="227760319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227760319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227760319">(Feb 25 2021 at 12:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/torsion.20free/near/227748920">said</a>:</p>
<blockquote>
<p>(I can use tactics because I'm a professional <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> )</p>
</blockquote>
<p>Is it a good idea to use the equation compiler instead?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[recursor]</span>
<span class="kd">def</span> <span class="n">pnat.rec</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rfl.le.not_lt</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">p1</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hp</span> <span class="n">_</span> <span class="o">(</span><span class="n">pnat.rec</span> <span class="o">⟨</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n.succ_pos</span><span class="o">⟩)</span>

<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">pnat.rec_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">pnat.rec</span> <span class="n">p1</span> <span class="n">hp</span> <span class="n">n</span>
</code></pre></div>



<a name="227764959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227764959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227764959">(Feb 25 2021 at 13:18)</a>:</h4>
<p>The term you get is a bit messier, but how much this matters depends on the context. That proof there is actually using well founded recursion, so it won't compute very well</p>



<a name="227765079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227765079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227765079">(Feb 25 2021 at 13:19)</a>:</h4>
<p>you can get it to at least use bounded recursion if you do the initial cases on pnat separate from the main recursion</p>



<a name="227765436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227765436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227765436">(Feb 25 2021 at 13:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pnat.rec_aux</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">p</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rfl.le.not_lt</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">p1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hp</span> <span class="n">_</span> <span class="o">(</span><span class="n">pnat.rec_aux</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n.succ_pos</span><span class="o">)</span>

<span class="kd">@[recursor]</span>
<span class="kd">def</span> <span class="n">pnat.rec</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">pnat</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">pnat.rec_aux</span> <span class="n">p1</span> <span class="n">hp</span> <span class="n">n</span> <span class="n">h</span>
</code></pre></div>



<a name="227765652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227765652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227765652">(Feb 25 2021 at 13:23)</a>:</h4>
<p>Using tactics here makes it easier to control the exact recursion structure</p>



<a name="227836806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227836806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227836806">(Feb 25 2021 at 20:53)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I should think the proof of the pudding will be whether you can prove <code>rec_on_one</code> and <code>rec_on_succ</code>.</p>



<a name="227837036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227837036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227837036">(Feb 25 2021 at 20:54)</a>:</h4>
<p>The equation compiler almost proves them for you</p>



<a name="227837518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227837518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227837518">(Feb 25 2021 at 20:57)</a>:</h4>
<p>At least, it emits proofs of type defeq to the ones we care about</p>



<a name="227837660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/227837660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#227837660">(Feb 25 2021 at 20:58)</a>:</h4>
<p>But Mario's right about it producing an undesirably long term</p>



<a name="228067860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/228067860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#228067860">(Feb 27 2021 at 16:27)</a>:</h4>
<p>I want to revive the <code>torsion free</code> part of this thread.</p>
<p>While experimenting with the <code>toric</code> branch, it seems that assuming <code>is_basis</code> is a very good substitute for <code>torsion free</code>.</p>
<p>While this may not be a very robust or general approach, working with modules admitting a basis is actually not such a mathematically weird idea.  Of course, you would not be able to apply these statements about the rationals viewed as a module of the integers (or the naturals!), but maybe this is not what we need...</p>



<a name="229566921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229566921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229566921">(Mar 09 2021 at 22:23)</a>:</h4>
<p>I have just pushed a loooong proof that the direct sum of <code>polyhedral_lattice</code>s is torsion free, to remove one <code>sorry</code> from the <code>instance : polyhedral_lattice (⨁ i, Λ i)</code> of  <code>polyhedral_lattice.basic</code>. But something strange happens : when adding<code>import linear_algebra.direct_sum_module</code> at the beginning of the file, the code breaks on line 167 (this has nothing to do with my proof). I can't understand where this comes from, so I left my proof commented (and replaced it with a <code>sorry</code>), hoping that someone can fix the problem.</p>



<a name="229588800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229588800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229588800">(Mar 10 2021 at 01:49)</a>:</h4>
<p>It fails on the end of the namespace? <a href="https://github.com/leanprover-community/lean-liquid/blob/6de12c8fa1eefa02db4ada2babd5bbf06785de44/src/polyhedral_lattice/basic.lean#L167">https://github.com/leanprover-community/lean-liquid/blob/6de12c8fa1eefa02db4ada2babd5bbf06785de44/src/polyhedral_lattice/basic.lean#L167</a></p>



<a name="229619887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229619887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229619887">(Mar 10 2021 at 08:26)</a>:</h4>
<p>Yes, the <code>rw [hl, finset.smul_sum, ← finset.univ_sigma_univ, finset.sum_sigma],</code> on line 159 compiles well if <code>import linear_algebra.direct_sum_module</code> is not called, but when adding <code>import linear_algebra.direct_sum_module</code>, it suddenly fails.</p>



<a name="229620763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229620763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229620763">(Mar 10 2021 at 08:35)</a>:</h4>
<p>On the other hand, the <code>sorry</code>s on lines 156, 158, 164 were already there.</p>



<a name="229621028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621028">(Mar 10 2021 at 08:37)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span> what do you think, is <code>torsion_free</code> working well?</p>



<a name="229621134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621134">(Mar 10 2021 at 08:38)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> suggested that another way to say "finite free abelian group" is something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">\</span><span class="n">ex</span> <span class="o">{</span><span class="bp">\</span><span class="n">iota</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">\</span><span class="n">iota</span> <span class="bp">-&gt;</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">is_basis</span> <span class="n">int</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>



<a name="229621142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621142">(Mar 10 2021 at 08:38)</a>:</h4>
<p>Well, I think it works pretty well. I was able without too much pain to prove that the direct sum of torsion-free modules is torsion-free, basically mimicking the "natural" proof</p>



<a name="229621171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621171">(Mar 10 2021 at 08:38)</a>:</h4>
<p>And I think <span class="user-mention" data-user-id="238446">@Anne Baanen</span> was also experimenting with making this the definition of <code>free</code></p>



<a name="229621205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621205">(Mar 10 2021 at 08:38)</a>:</h4>
<p>Well, I have just worked with it yesterday, but I found the API pretty good.</p>



<a name="229621264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621264">(Mar 10 2021 at 08:39)</a>:</h4>
<p>In particular, it seems perfectly well-suited for saying what being torsion (or not) is over very general basis other than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span></p>



<a name="229621381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621381">(Mar 10 2021 at 08:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/torsion.20free/near/229621171">said</a>:</p>
<blockquote>
<p>And I think <span class="user-mention silent" data-user-id="238446">Anne Baanen</span> was also experimenting with making this the definition of <code>free</code></p>
</blockquote>
<p>But <code>free</code> and <code>torsion_free</code> are quite far apart, as notions, no?</p>



<a name="229621454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621454">(Mar 10 2021 at 08:41)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span> Yes, but for <code>polyhedral_lattice</code> we want to say "finite free abelian group"</p>



<a name="229621475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621475">(Mar 10 2021 at 08:41)</a>:</h4>
<p>And in the end I don't care how we say it. So we should pick the version that is easiest to work with</p>



<a name="229621574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229621574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229621574">(Mar 10 2021 at 08:42)</a>:</h4>
<p>So far, the definition looked good to me</p>



<a name="229622633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229622633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229622633">(Mar 10 2021 at 08:52)</a>:</h4>
<p>Filippo, I looked at your proof and I have a small streamlining of it.  However, I also get the weird issues later on, so I am hesitant to push it anywhere!  I leave it here, in case you find it useful.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">tf</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span> <span class="n">n</span> <span class="n">hnv</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">nzv_i</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">direct_sum.component</span> <span class="n">ℤ</span> <span class="n">ι</span> <span class="bp">Λ</span> <span class="n">i</span> <span class="n">v</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">not_forall</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">direct_sum.ext_iff</span> <span class="n">ℤ</span><span class="o">]</span> <span class="n">at</span> <span class="n">hv</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">tf_i</span> <span class="o">:</span> <span class="n">torsion_free</span> <span class="o">(</span><span class="bp">Λ</span> <span class="n">i</span><span class="o">),</span>
    <span class="o">{</span> <span class="k">suffices</span> <span class="n">pl_i</span> <span class="o">:</span> <span class="n">polyhedral_lattice</span> <span class="o">(</span><span class="bp">Λ</span> <span class="n">i</span><span class="o">),</span>
      <span class="n">exact</span> <span class="n">pl_i.tf</span><span class="o">,</span>
      <span class="n">apply_assumption</span> <span class="o">},</span>
    <span class="n">refine</span> <span class="n">tf_i</span> <span class="o">(</span><span class="n">direct_sum.component</span> <span class="n">ℤ</span> <span class="n">ι</span> <span class="bp">Λ</span> <span class="n">i</span> <span class="n">v</span><span class="o">)</span> <span class="n">nzv_i</span> <span class="n">n</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">linear_map.map_smul_of_tower</span><span class="o">,</span>
    <span class="n">convert</span> <span class="o">(</span><span class="n">direct_sum.ext_iff</span> <span class="n">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hnv</span> <span class="n">i</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
</code></pre></div>



<a name="229622868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229622868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229622868">(Mar 10 2021 at 08:54)</a>:</h4>
<p>Ok, thanks. I'll improve it. But do you understand the problem with <code>import</code>ing <code>direct_sum_module</code>?</p>



<a name="229623063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229623063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229623063">(Mar 10 2021 at 08:56)</a>:</h4>
<p>No, I have not looked into the <code>import</code> issue.</p>



<a name="229626941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229626941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229626941">(Mar 10 2021 at 09:28)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> May be you have an idea of this <code>import</code> issue? Also, what is your plan for this file <code>polyhedral_lattice.basis</code>, is it reasonable to continue working on this trying to "kill" some <code>sorry</code>'?</p>



<a name="229627074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627074">(Mar 10 2021 at 09:29)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span> I will take a look at the import issue now</p>



<a name="229627157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627157">(Mar 10 2021 at 09:30)</a>:</h4>
<p>At some point you were thinking about 9.7, right? If we pin down some statement of Gordan's lemma, would you like to try proving Gordan =&gt; 9.7?</p>



<a name="229627204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627204">(Mar 10 2021 at 09:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/torsion.20free/near/229627157">said</a>:</p>
<blockquote>
<p>At some point you were thinking about 9.7, right? If we pin down some statement of Gordan's lemma, would you like to try proving Gordan =&gt; 9.7?</p>
</blockquote>
<p>I had just opened the file to look into this! <span aria-label="time" class="emoji emoji-1f557" role="img" title="time">:time:</span></p>



<a name="229627252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627252">(Mar 10 2021 at 09:31)</a>:</h4>
<p>For <code>polyhedral_lattice.basis</code>, we first have to decide what is the best way for us to say "finite free abelian group". And I think the point where we want to use this most is in the proof of Gordan. So Damiano will have to tell us what he likes best (-;</p>



<a name="229627451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627451">(Mar 10 2021 at 09:33)</a>:</h4>
<p>To bisect the problem; does importing <code>linear_algebra.dfinsupp</code> instead break it too?</p>



<a name="229627519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627519">(Mar 10 2021 at 09:33)</a>:</h4>
<p>BTW: Is there already a formulation of Gordan's lemma in the library? Or is it coming with Damiano's work?</p>



<a name="229627536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627536">(Mar 10 2021 at 09:33)</a>:</h4>
<p>No, we have to do this ourselves</p>



<a name="229627550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627550">(Mar 10 2021 at 09:33)</a>:</h4>
<p>Damiano is building the machine to prove it</p>



<a name="229627593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627593">(Mar 10 2021 at 09:34)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span> shall we do a quick video call, to work out a sketch?</p>



<a name="229627671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627671">(Mar 10 2021 at 09:34)</a>:</h4>
<p>Also, the import issue doesn't show up for me</p>



<a name="229627686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229627686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229627686">(Mar 10 2021 at 09:34)</a>:</h4>
<p>I get an error on some <code>rw</code></p>



<a name="229634615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229634615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229634615">(Mar 10 2021 at 10:32)</a>:</h4>
<p>I also get an error on a <code>rw</code> further down the line.</p>



<a name="229634668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229634668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229634668">(Mar 10 2021 at 10:32)</a>:</h4>
<p>(my day today is littered with commitments ever once in a while, so my comments are scattered and I can only concentrate on small stuff!)</p>



<a name="229675175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229675175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229675175">(Mar 10 2021 at 15:01)</a>:</h4>
<p>I tried looking at the <code>import</code> issue: I could not understand why it breaks, but was able to make it progress further, a <code>simp</code> step away from <code>sorry</code> where it stopped earlier.  It is not pretty, but it seems to (partially) work and also incorporates a proof of <code>fg</code>.  Let me know what you think!</p>



<a name="229804571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229804571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229804571">(Mar 11 2021 at 07:11)</a>:</h4>
<p>What is the status here? Is this some issue with a broken proof or is the problem weirder?</p>



<a name="229813625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229813625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229813625">(Mar 11 2021 at 08:41)</a>:</h4>
<p>I do not know what the problem is.  When I looked at it, there were two relevant proofs:</p>
<ul>
<li>a complete, commented out, proof, needing some import, also commented out; and</li>
<li>an incomplete proof further down that led, with no errors, to a <code>sorry</code>.</li>
</ul>
<p>(If you look at the file, it might be easier to follow what I am saying.)</p>
<p>Adding the imports needed for the commented proof, made a <code>rw</code> step of the second proof no longer work.  With a bad trick, I was able to push the now-broken proof a couple of steps further, just until the <code>simp</code> before its ending sorry.</p>
<p>I think that this is where the situation is right now.</p>



<a name="229842906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229842906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229842906">(Mar 11 2021 at 12:54)</a>:</h4>
<p>Yes, indeed, this is the situation. It seems strange that adding an <code>import</code> breaks a <code>rw</code> proof, but may be this comes from more things having the same name? At any rate, after discussions with <span class="user-mention" data-user-id="112680">@Johan Commelin</span> , it is now probably time to wait a little bit for this file as we're waiting for a <code>PR</code> about free modules on <code>mathlib</code>, which seems on its way to be merged.</p>



<a name="229842995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229842995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229842995">(Mar 11 2021 at 12:54)</a>:</h4>
<p>On the other hand, <span class="user-mention" data-user-id="321459">@Damiano Testa</span>  I still don't find the <code>fg</code> proof, was it for the direct sum?</p>



<a name="229864230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/229864230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#229864230">(Mar 11 2021 at 15:10)</a>:</h4>
<p>Oh, I might have said <code>fg</code> for <code>tf</code>: I simply golfed your proof, whichever one if was!! <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="232742669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/232742669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#232742669">(Apr 01 2021 at 11:41)</a>:</h4>
<p>I didn't follow the discussion... to we have somewhere that free implies torsion free (yes, I mean the easy implication)?</p>



<a name="232742799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/232742799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#232742799">(Apr 01 2021 at 11:42)</a>:</h4>
<p>I think we have it somewhere: I am going to look for it, but do you need for something else or for discussion we had with Damiano? Because the situation changed a bit and became slightly out of date.</p>



<a name="232743097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/232743097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#232743097">(Apr 01 2021 at 11:45)</a>:</h4>
<p>I am trying to prove  <code>pre_generators_finite</code>. In any case if we want to play with lattices something like <code>a • x = b • x  →  a = b</code> (with <code>x</code> nonzero) seems very natural... and that is all what I need.</p>



<a name="232744383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/torsion%20free/near/232744383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/torsion.20free.html#232744383">(Apr 01 2021 at 11:57)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/is_basis.no_zero_smul_divisors">docs#is_basis.no_zero_smul_divisors</a>  that is all I need.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/index.html">condensed mathematics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html">for_mathlib/truncation.lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="284761710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284761710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284761710">(Jun 02 2022 at 15:29)</a>:</h4>
<p>I'm going to start working on this file now <span class="user-mention" data-user-id="112680">@Johan Commelin</span></p>



<a name="284773606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284773606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284773606">(Jun 02 2022 at 16:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">imker</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">cochain_complex</span> <span class="bp">ùìê</span> <span class="n">‚Ñ§</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñ§</span><span class="o">)</span> <span class="o">:</span> <span class="n">cochain_complex</span> <span class="bp">ùìê</span> <span class="n">‚Ñ§</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">-</span><span class="mi">1</span> <span class="k">then</span> <span class="n">image_subobject</span> <span class="o">(</span><span class="n">C.d_to</span> <span class="n">n</span><span class="o">)</span> <span class="k">else</span>
              <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="k">then</span> <span class="n">kernel_subobject</span> <span class="o">(</span><span class="n">C.d_from</span> <span class="n">n</span><span class="o">)</span> <span class="k">else</span>
                <span class="o">(</span><span class="n">has_zero_object.has_zero</span> <span class="bp">ùìê</span><span class="o">)</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">d</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="k">then</span> <span class="k">if</span> <span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">n</span> <span class="k">then</span> <span class="kd">by</span>
       <span class="o">{</span> <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hi</span><span class="o">,</span> <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hj</span><span class="o">,</span>
         <span class="n">rw</span> <span class="n">if_neg</span> <span class="o">(</span><span class="k">show</span> <span class="n">j</span> <span class="bp">‚â†</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">hj</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">}),</span>
         <span class="n">exact</span> <span class="n">image_to_kernel</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">homological_complex.d_to_comp_d_from</span> <span class="n">_</span> <span class="n">n</span><span class="o">)}</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">shape'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">i</span> <span class="n">j</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">‚â†</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hi</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_mpr_eq_cast</span><span class="o">,</span> <span class="n">cast_cast</span><span class="o">,</span> <span class="n">dite_eq_right_iff</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="n">add_eq_of_eq_sub</span> <span class="n">hi</span><span class="o">))</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">d_comp_d'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hi</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">dif_pos</span> <span class="o">(</span><span class="n">sub_add_cancel</span> <span class="n">n</span> <span class="mi">1</span><span class="o">),</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_ne_zero</span><span class="o">,</span> <span class="n">add_right_eq_self</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">,</span> <span class="n">comp_zero</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">zero_comp</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>There's a pretty horrible definition. Do you think I can get away with it? Maybe! I guess I'll start filling in the three sorries about <code>imker</code> and stop either if I get stuck or if someone pops up here suggesting a nicer definition. I only used <code>image_subobject</code> and <code>kernel_subobject</code> because I can then use <code>image_to_kernel</code> to define the morphism. Is there a morphism <code>(image f) -&gt; (kernel g)</code> if <code>f &gt;&gt; g = 0</code>?</p>



<a name="284773956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284773956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284773956">(Jun 02 2022 at 17:01)</a>:</h4>
<p>WARNING: subobjects are pretty painful to work with in my opiniion!</p>



<a name="284774289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284774289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284774289">(Jun 02 2022 at 17:04)</a>:</h4>
<p>Do you know how to get the map <code>image f -&gt; kernel g</code> if f &gt;&gt; g = 0?</p>



<a name="284774381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284774381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284774381">(Jun 02 2022 at 17:04)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/image_to_kernel'">docs#image_to_kernel'</a></p>



<a name="284774526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284774526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284774526">(Jun 02 2022 at 17:05)</a>:</h4>
<p>UGH but the definition of image is also terrible. IMO it should have been defined as <code>kernel (cokernel.\pi f)</code>.</p>



<a name="284774742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284774742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284774742">(Jun 02 2022 at 17:07)</a>:</h4>
<p>Ah we have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.image">docs#category_theory.abelian.image</a></p>



<a name="284774782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284774782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284774782">(Jun 02 2022 at 17:07)</a>:</h4>
<p>This is such a mess... <span aria-label="expressionless" class="emoji emoji-1f611" role="img" title="expressionless">:expressionless:</span></p>



<a name="284775271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284775271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284775271">(Jun 02 2022 at 17:11)</a>:</h4>
<p>In any case, the comparison between the two images is <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.image_iso_image">docs#category_theory.abelian.image_iso_image</a></p>



<a name="284776081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284776081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284776081">(Jun 02 2022 at 17:14)</a>:</h4>
<p>Unfortunately <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.abelian.image_to_kernel">docs#category_theory.abelian.image_to_kernel</a> doesn't exist.</p>



<a name="284868736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284868736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284868736">(Jun 03 2022 at 12:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I saw your comment</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">has_zero_object.has_zero</span> <span class="c1">-- isn't there a locale which does this??</span>
</code></pre></div>
<p>The answer should be <code>open_locale zero_object</code>.</p>



<a name="284938748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/284938748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#284938748">(Jun 03 2022 at 22:14)</a>:</h4>
<p>Thanks! I'll get back to working on this file again tomorrow, hopefully I have many hours to spend on it as I'm travelling through Europe by train all day</p>



<a name="285030556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285030556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285030556">(Jun 05 2022 at 10:53)</a>:</h4>
<p>I was rather surprised yesterday with how slow progress was. I'm still very much working on this file, I wrote hundreds of lines during many hours on several train journeys across Europe but still didn't finish the boss level of <code>imker</code>. I have reduced the boss to the final stage though. While it's fresh in my mind and before I start on an afternoon's marking, let me tell you the thing which looked easy but turned out to be long.</p>
<p>Let's say we have two maps both called <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> but I'll call them <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>, so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>‚Üí</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">g:B\to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, and let's assume <code>f &gt;&gt; g = 0</code>. I can now make two complexes. The first only has two non-zero terms, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>:</mo><mo>=</mo><mi>I</mi><mi>m</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J:=Im(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>:</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K:=ker(g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>, with the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>J</mi><mo>‚Üí</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">i:J\to K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> being the canonical inclusion coming from the assumption <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">gf=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>. The second only has one non-zero term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>:</mo><mo>=</mo><mi>K</mi><mi mathvariant="normal">/</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">H:=K/J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>, the homology of the original three-term complex. So we're flattening three terms to two to one.</p>
<p>There's a canonical map from the two-nonzero-term complex <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>‚Üí</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">J\to K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> to the one-nonzero-term complex <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> via the canonical map, and all other down maps are 0. This induces a map on cohomology from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">/</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">K/J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mi>K</mi><mi mathvariant="normal">/</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">H=K/J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> and the claim is that this is an isomorphism. So on paper it looks like there is nothing even to prove, because the map is the identity!</p>
<p>But the cohomology of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚Üí</mo><mi>H</mi><mo>‚Üí</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0\to H\to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> is not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>, it's a cokernel of an <code>image_to_kernel</code> map from some subobject to some other subobject. If you unravel the question then it becomes the following: Is the obvious map from Im(Im(f)-&gt;ker(g)) to ker(ker(g)-&gt;ker((ker(g)/Im(f))-&gt;0) an isomorphism? Of course the answer to this is going to be "yes" but it took several hours to reduce the question to this (i.e. to cut through all the other definitions and deal with d_prev v d etc), and now I am slowly reducing the question to simpler and simpler ones; I'll get there in the end.</p>
<p>Do you think I'm missing ideas, or just API? The API which I've developed to get me this far is <a href="https://github.com/leanprover-community/lean-liquid/blob/eff5279615b6d98e5151ea7f8d0438b822f39050/src/for_mathlib/truncation.lean#L141-L357">here</a> and I feel like I'm in control -- it's just a case of figuring out what I need for my next move and then proving it if it's not there. I must say that I feel far more at home manipulating abelian categories than I do with general categories, so in contrast to previous adventures I've had in category land (which I've found generally frustrating and challenging) this time I'm having a whole lot of fun. Progress is still slow but I feel like some of the stuff I'm generating might be helpful elsewhere.</p>



<a name="285030892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285030892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285030892">(Jun 05 2022 at 11:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> to construct a map to/from homology, in my opinion, the best approach is to use <a href="https://leanprover-community.github.io/mathlib_docs/find/homology.desc'">docs#homology.desc'</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/homology.lift">docs#homology.lift</a> (as I mentioned before, I find the subobjects approach to be really difficult to work with). We also have a useful isomorphism in <code>for_mathlib/homology_iso</code> which should help get rid of the annoying <code>X_next</code> and <code>X_prev</code>.</p>



<a name="285031352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285031352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285031352">(Jun 05 2022 at 11:12)</a>:</h4>
<p>Yeah I got rid of them yesterday. Right now I've not had to engage with subobjects in any way other than a superficial one, but they're looming. Right now <code>homology.map</code> is defined in terms of <code>cokernel.desc</code> so that was what I used. Perhaps what you're saying is that it would have been less pain to have worked with a different definition.</p>



<a name="285031522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285031522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285031522">(Jun 05 2022 at 11:17)</a>:</h4>
<p>Take a look at the mathlib file <code>category_theory/abelian/homology</code> near the bottom, there are several lemmas that let you rewrite <code>homology.map</code> in terms of <code>desc'</code>or <code>lift</code>.</p>



<a name="285032391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285032391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285032391">(Jun 05 2022 at 11:38)</a>:</h4>
<p>Right now I'm unsure about whether to go back to this approach or to press on with my own.</p>



<a name="285078764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285078764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285078764">(Jun 06 2022 at 06:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> FYI: I split the file into two pieces. There is now a <code>imker.lean</code>.</p>



<a name="285406391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/285406391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#285406391">(Jun 08 2022 at 15:11)</a>:</h4>
<p>I'm now working on the sorries in this file.</p>



<a name="286350209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/286350209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#286350209">(Jun 16 2022 at 13:11)</a>:</h4>
<p><code>for_mathlib/truncation.lean</code> is sorry-free! It needs a refactor.</p>



<a name="286649395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/267928-condensed%20mathematics/topic/for_mathlib/truncation.lean/near/286649395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/267928-condensed-mathematics/topic/for_mathlib.2Ftruncation.2Elean.html#286649395">(Jun 18 2022 at 12:37)</a>:</h4>
<p>Thanks so much for filling in those <code>sorry</code>s!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
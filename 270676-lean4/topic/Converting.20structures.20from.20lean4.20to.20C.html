---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html">Converting structures from lean4 to C</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="285311583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285311583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> z battleman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285311583">(Jun 07 2022 at 20:47)</a>:</h4>
<p>Hi! I'm very new to development with the ffi and I'm sturggling a bit to get footing. From what I can tell, many projects leave their types abstract and define their functions as constants that have no Lean representation and interface with c. Ideally, I would like to write a library that has a Lean representation which allows one to do proofs.</p>
<p>I tried to do this basing essentially all of the code on <a href="https://github.com/arthurpaulino/NumLean">this</a> repository, with the idea to try and get a Vector in Lean of <code>Fin m -&gt; Float</code> which has a backend in C given as a struct.  As of right now, my Lean code looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">mathVec</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">data</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">Float</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">mathVec</span> <span class="n">m</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">default</span> <span class="o">:</span> <span class="n">mathVec</span> <span class="n">m</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="mi">0</span><span class="o">⟩</span>

<span class="kn">namespace</span> <span class="n">mathVec</span>

<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">externMk</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">Float</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">mathVec</span> <span class="n">m</span>
  <span class="o">:=</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"Can't actually do this"</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">implementedBy</span> <span class="n">externMk</span><span class="o">]</span> <span class="n">mathVec.mk</span>

<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">externData</span> <span class="o">:</span> <span class="n">mathVec</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">Float</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"Can't actually do this"</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">implementedBy</span> <span class="n">externData</span><span class="o">]</span> <span class="n">mathVec.data</span>

<span class="kd">@[extern "mathVec_new"]</span>
<span class="kd">def</span> <span class="n">new</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">mathVec</span> <span class="n">m</span>
  <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">x</span><span class="o">⟩</span>

<span class="kd">@[extern "mathVec_get_val"]</span>
<span class="kd">def</span> <span class="n">get</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">mathVec</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">Fin</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">v.data</span> <span class="n">i</span>
</code></pre></div>
<p>and the underlying c is essentially the exact same as <a href="https://github.com/arthurpaulino/NumLean/blob/master/c/ffi.c">the repository from before</a> with the allocations and whatnot changed accordingly. Here is a <a href="https://pastebin.com/SuZgVJsk">pastebin</a> of it</p>
<p>This unsurprisingly doesn't immediately work out of the box becausee you never tell Lean how to take something of <code>Fin m -&gt; Float</code> and turn it into the desired struct. However, after looking at a couple of projects on github, I haven't been able to figure out how to do this. </p>
<p>Thank you so much for any advice!</p>
<p>(As a bit of an additional question, even with abstract types, it seems like somehow the inputs to the Lean functions are automatically transformed into the C struct. I think it makes a bit more sense how this might work as the names are the same, and more importantly, they are of the same type in the same order, but I would be curious to know how this worked in more detail)</p>



<a name="285320249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285320249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285320249">(Jun 07 2022 at 22:04)</a>:</h4>
<p>Generating C code with <code>lean -c</code> is very useful to figure out how to use lean objects.  Create a function that takes a function <code>f : Fin m -&gt; Float</code> and an index <code>i : Fin m</code> and returns <code>f i</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[export eval_fun]</span>
<span class="kd">def</span> <span class="n">eval_fun</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">Float</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">i</span>
</code></pre></div>
<p>Run <code>lean -c eval_fun.c eval_fun.lean</code> and the generate <code>.c</code> file contains:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">eval_fun</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_2</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_3</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_apply_1</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>This shows that to evaluate an object of type <code>Fin m -&gt; Float</code>, you should use <code>lean_apply_1</code>. Therefore the main loop to load the data on C level will look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">for</span><span class="o">(</span><span class="n">size_t</span> <span class="n">i</span><span class="bp">=</span><span class="mi">0</span><span class="bp">;</span><span class="n">i</span><span class="bp">&lt;</span><span class="n">m</span><span class="bp">;</span><span class="n">i</span><span class="bp">++</span><span class="o">){</span>
  <span class="n">lean_inc</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">v</span><span class="bp">-&gt;</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="n">lean_unbox_float</span><span class="o">(</span><span class="n">lean_apply_1</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="n">lean_usize_to_nat</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>



<a name="285320478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285320478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285320478">(Jun 07 2022 at 22:07)</a>:</h4>
<p>How did I figure out <code>lean_usize_to_nat</code>? I just created another function</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[export mk_index]</span>
<span class="kd">def</span> <span class="n">mk_index</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i.toNat</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i.toNat</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
</code></pre></div>
<p>Which generates this C code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">mk_index</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">x_2</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_3</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_usize_to_nat</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>You can see that <code>Fin m</code> and <code>Nat</code> have the same representation on C level.</p>



<a name="285320962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285320962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285320962">(Jun 07 2022 at 22:12)</a>:</h4>
<p>By inspecting some code It looks like that <code>lean_unbox_float</code> does not consume its argument. Therefore the code should look like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">for</span><span class="o">(</span><span class="n">size_t</span> <span class="n">i</span><span class="bp">=</span><span class="mi">0</span><span class="bp">;</span><span class="n">i</span><span class="bp">&lt;</span><span class="n">m</span><span class="bp">;</span><span class="n">i</span><span class="bp">++</span><span class="o">){</span>
  <span class="n">lean_inc</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">lean_object</span> <span class="bp">*</span> <span class="n">val</span> <span class="bp">=</span> <span class="n">lean_apply_1</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="n">lean_usize_to_nat</span><span class="o">(</span><span class="n">i</span><span class="o">))</span><span class="bp">;</span>
  <span class="n">v</span><span class="bp">-&gt;</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="n">lean_unbox_float</span><span class="o">(</span><span class="n">val</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">lean_dec</span><span class="o">(</span><span class="n">val</span><span class="o">)</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>I'm still unsure if I have the reference counting correct here, so someone more knowledgeable should comment on that.</p>



<a name="285321240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285321240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285321240">(Jun 07 2022 at 22:16)</a>:</h4>
<p>Generating C code for written Lean code to check out what to do is pretty clever, I'll definitely keep that in mind!</p>



<a name="285321820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285321820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285321820">(Jun 07 2022 at 22:23)</a>:</h4>
<p>Also you have incorrect declaration of  the <code>mathVec_get_val</code> function. </p>
<p>You have </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">lean_obj_res</span> <span class="n">mathVec_get_val</span><span class="o">(</span><span class="n">b_lean_obj_arg</span> <span class="n">_v</span><span class="o">,</span> <span class="n">uint32_t</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>But lean code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">mathVec</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">data</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">Float</span>

<span class="kd">@[export mathVec_get_val]</span>
<span class="kd">def</span> <span class="n">get</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">mathVec</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">Fin</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">v.data</span> <span class="n">i</span>
</code></pre></div>
<p>generates</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">mathVec_get_val</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_2</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_3</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_apply_1</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>Where <code>x_1</code> is the <code>{m : Nat}</code>,  <code>x_2</code> is the <code>(v : mathVec m)</code> and <code>x_3</code> is the <code>(i : Fin m)</code>. As you can see, those declarations are very different, but they have to match!</p>
<p>Few notes:</p>
<p>-  Every function accepting <code>mathVec m</code> will also accepts <code>m</code> as argument. It is usually implicit, i.e. with <code>{}</code>, but on C level it is always explicit. Therefore your  C struct <code>mathVec</code> does not need to hold the array size.<br>
   - Already mentioned before, <code>Fin m</code> is the same as <code>Nat</code> on C level. It is not <code>size_t</code> or <code>uint32_t</code>. For those you need to use <code>USize</code> or<code>UInt32</code></p>
<p>example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[export mathVec_get_val]</span>
<span class="kd">def</span> <span class="n">get</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">@&amp;</span><span class="n">mathVec</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">UInt32</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">v.data</span> <span class="o">⟨</span><span class="n">i.toNat</span><span class="o">,</span><span class="gr">sorry</span><span class="o">⟩</span>
</code></pre></div>
<p>generates</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">mathVec_get_val</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_2</span><span class="o">,</span> <span class="n">uint32_t</span> <span class="n">x_3</span><span class="o">)</span>
</code></pre></div>



<a name="285322765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285322765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285322765">(Jun 07 2022 at 22:33)</a>:</h4>
<p>In my project, I really try to minimize the amount of hand written C code involving <code>lean_object</code>.  To interface with lean, I mostly try to create lean functions accepting or returning <code>Float</code>, <code>USize</code> or <code>UInt</code> and tag them with <code>export</code> attribute to fix their corresponding C name. You really want to avoid messing with <code>lean_ctor_...</code> functions. To use them correctly you would need to know the exact memory layout.</p>
<p><a href="https://github.com/lecopivo/HouLean/blob/728f0decff3af9fa32091181f9fbc7d9c7bf534f/HouLean/Data.lean#L12">Example</a> of defining a three dimensional vector and accessing its components.</p>



<a name="285323224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285323224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285323224">(Jun 07 2022 at 22:38)</a>:</h4>
<p>Ahh there are more things incorrect. </p>
<p>The <code>mathVec_new</code> returns data with <code>lean_io_result_mk_ok(mathVec_boxer(v))</code> however this would mean the lean function <code>new</code> returns <code>IO (mathVec m)</code> but it returns only <code>mathVec m</code>.</p>



<a name="285323535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285323535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285323535">(Jun 07 2022 at 22:42)</a>:</h4>
<p>Unfortunately, I do not have the time to make your code work right now. I strongly recommend to mess around with lean code , generate C code with <code>lean -c</code> and inspect it.</p>



<a name="285325634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285325634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285325634">(Jun 07 2022 at 23:07)</a>:</h4>
<p>Also recommend having look at <a href="https://github.com/leanprover/lean4/blob/8ffa07ab254a5bd426944dff072e7b8b7871d24b/src/include/lean/lean.h#L744"><code>lean.h</code></a> file. The link takes to C implementation of <a href="https://github.com/leanprover/lean4/blob/8ffa07ab254a5bd426944dff072e7b8b7871d24b/src/Init/Prelude.lean#L1257"><code>Array.get!</code></a></p>



<a name="285329306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285329306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> z battleman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285329306">(Jun 07 2022 at 23:57)</a>:</h4>
<p>oh wow this is so incredibly useful!! I will spend some time trying to understand this and update my code accordingly, and I'll report back!</p>



<a name="285335414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285335414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> z battleman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285335414">(Jun 08 2022 at 01:46)</a>:</h4>
<p>This makes so much sense! This thread should be immortalized for how helpful it was to understand what's actually going on here. I've got a bunch of small examples working now! The one thing that I'm a bit unclear about is how to go to and from c. The direction from Lean to C is not that hard, as you mention you can just iterate over the lean object and put that into the C struct. However, for the other direction, I'm not sure what to do. The example from before simply has <code>box</code> and <code>unbox</code> functions, but going from an arbitrary c struct, I'm not sure how to go about this. I wrote a simple function to turn a Lean Float array into a Vector (in the hopes that it would be easily copyable, but... not so much</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="n">LEAN_EXPORT</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">l_mathVec_fromList___elambda__1___rarg</span><span class="p">(</span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">_start</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_3</span><span class="p">;</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_4</span><span class="p">;</span><span class="w"></span>
<span class="n">x_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_instInhabitedFloat</span><span class="p">;</span><span class="w"></span>
<span class="n">x_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lean_array_get</span><span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="w"> </span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">x_2</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">x_4</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">LEAN_EXPORT</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">l_mathVec_fromList___elambda__1</span><span class="p">(</span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">_start</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_2</span><span class="p">;</span><span class="w"></span>
<span class="n">x_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lean_alloc_closure</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">l_mathVec_fromList___elambda__1___rarg___boxed</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">x_2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">LEAN_EXPORT</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">mathVec_from_list</span><span class="p">(</span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">_start</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_3</span><span class="p">;</span><span class="w"></span>
<span class="n">lean_dec</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span><span class="w"></span>
<span class="n">x_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lean_alloc_closure</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">l_mathVec_fromList___elambda__1___rarg___boxed</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">lean_closure_set</span><span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x_2</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">x_3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">LEAN_EXPORT</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">l_mathVec_fromList___elambda__1___rarg___boxed</span><span class="p">(</span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">_start</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_3</span><span class="p">;</span><span class="w"></span>
<span class="n">x_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_mathVec_fromList___elambda__1___rarg</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="n">x_2</span><span class="p">);</span><span class="w"></span>
<span class="n">lean_dec</span><span class="p">(</span><span class="n">x_2</span><span class="p">);</span><span class="w"></span>
<span class="n">lean_dec</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">x_3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">LEAN_EXPORT</span><span class="w"> </span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">l_mathVec_fromList___elambda__1___boxed</span><span class="p">(</span><span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nl">_start</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="n">lean_object</span><span class="o">*</span><span class="w"> </span><span class="n">x_2</span><span class="p">;</span><span class="w"></span>
<span class="n">x_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_mathVec_fromList___elambda__1</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span><span class="w"></span>
<span class="n">lean_dec</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">x_2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Can someone help me make sense of this and/or give me some tips on how to write a much simpler version to do what I want? It would be nice to have this so I could have functions that return Vectors. Thank you again so so much!</p>



<a name="285338877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285338877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> z battleman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285338877">(Jun 08 2022 at 02:52)</a>:</h4>
<p>At the suggestion of <span class="user-mention" data-user-id="407274">@James Gallicchio</span> I'm going to put in a layer of abstraction between the Vector <code>Fin m -&gt; Float</code> and c. This layer will represent the vectors as Float Arrays rather than functions which should hopefully make converting to C easier. That being said, just boxing it up doesn't seem to be working. How can I tell lean how to interpret a c struct and convert it into a Lean structure? Fortunately, the lean sturcture and the c struct look very similar - both contain a Float/Double array and an length as a Nat/uint32_t</p>
<p>I'm currently trying</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">lean_object</span><span class="bp">*</span> <span class="n">cVec_new</span><span class="o">(</span><span class="n">double</span> <span class="n">val</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">len_</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">uint32_t</span> <span class="n">len</span> <span class="bp">=</span> <span class="n">lean_unbox_uint32</span><span class="o">(</span><span class="n">len_</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"hereee"</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"len: %d"</span><span class="o">,</span> <span class="n">len</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">fflush</span><span class="o">(</span><span class="n">stdout</span><span class="o">)</span><span class="bp">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="bp">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">return</span> <span class="n">make_error</span><span class="o">(</span><span class="s2">"invalid length"</span><span class="o">)</span><span class="bp">;</span>
    <span class="o">}</span>

    <span class="n">cVec</span><span class="bp">*</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">cVec_alloc</span><span class="o">(</span><span class="n">sizeof</span><span class="o">(</span><span class="n">double</span><span class="o">)</span><span class="bp">*</span><span class="n">len</span><span class="o">)</span><span class="bp">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="bp">!</span><span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">return</span> <span class="n">make_error</span><span class="o">(</span><span class="s2">"ERROR_INSUF_MEM"</span><span class="o">)</span><span class="bp">;</span>
    <span class="o">}</span>
    <span class="n">for</span> <span class="o">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">;</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">len</span><span class="bp">;</span> <span class="n">i</span><span class="bp">++</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">v</span><span class="bp">-&gt;</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="n">val</span><span class="bp">;</span>
    <span class="o">}</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"hereee2"</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">fflush</span><span class="o">(</span><span class="n">stdout</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">lean_object</span><span class="bp">*</span> <span class="n">out</span> <span class="bp">=</span> <span class="n">cVec_boxer</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"reting"</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">fflush</span><span class="o">(</span><span class="n">stdout</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">return</span> <span class="n">out</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>My guess is the proper way is to make a ctor with the array and the int, but that would require figuring out how to turn an array into a lean object. I'll keep looking!</p>
<p>Thanks!!</p>



<a name="285346161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285346161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285346161">(Jun 08 2022 at 05:12)</a>:</h4>
<p>I didn't read your code yet but I would recommend to have a look at this example how to wrap C++ object into <code>lean_external_object</code>. <a href="https://github.com/leanprover/lean4/tree/66fcfcce3716774dacbd35e1ea0f5c75356df311/tests/compiler/foreign">https://github.com/leanprover/lean4/tree/66fcfcce3716774dacbd35e1ea0f5c75356df311/tests/compiler/foreign</a></p>



<a name="285379887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285379887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285379887">(Jun 08 2022 at 11:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C/near/285321240">said</a>:</p>
<blockquote>
<p>Generating C code for written Lean code to check out what to do is pretty clever, I'll definitely keep that in mind!</p>
</blockquote>
<p>Indeed!</p>
<p>I also noticed that when using Lake, all the generated .c files are dumped into <code>./build/ir/...</code>, making it quite easy to inspect.</p>



<a name="285441700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Converting%20structures%20from%20lean4%20to%20C/near/285441700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> z battleman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Converting.20structures.20from.20lean4.20to.20C.html#285441700">(Jun 08 2022 at 19:29)</a>:</h4>
<p>Progress has been made! I have the new array working! However, now I am having some issues with retrieving elements from it. The c code that lean generates for this function looks like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">cVec_get_val</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_2</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_3</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_4</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_5</span><span class="bp">;</span>
<span class="n">x_3</span> <span class="bp">=</span> <span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">x_1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span>
<span class="n">lean_inc</span><span class="o">(</span><span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">l_instInhabitedFloat</span><span class="bp">;</span>
<span class="n">x_5</span> <span class="bp">=</span> <span class="n">lean_array_get</span><span class="o">(</span><span class="n">x_4</span><span class="o">,</span> <span class="n">x_3</span><span class="o">,</span> <span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_5</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>and my c code I wrote by hand looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">lean_object</span><span class="bp">*</span> <span class="n">cVec_get_val</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">v_</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">i_</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"here3"</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">fflush</span><span class="o">(</span><span class="n">stdout</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">lean_object</span><span class="bp">*</span> <span class="n">lean_arr</span> <span class="bp">=</span> <span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">v_</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"length?: %u</span><span class="se">\n</span><span class="s2">"</span><span class="o">,</span> <span class="n">lean_unbox_uint32</span><span class="o">(</span><span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">v_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)))</span><span class="bp">;</span>
    <span class="n">printf</span><span class="o">(</span><span class="s2">"index?: %u</span><span class="se">\n</span><span class="s2">"</span><span class="o">,</span> <span class="n">lean_unbox_uint32</span><span class="o">(</span><span class="n">i_</span><span class="o">))</span><span class="bp">;</span>
    <span class="n">lean_inc</span><span class="o">(</span><span class="n">lean_arr</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">lean_dec</span><span class="o">(</span><span class="n">v_</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">lean_object</span><span class="bp">*</span> <span class="n">out</span> <span class="bp">=</span> <span class="n">lean_array_get</span><span class="o">(</span><span class="n">l_instInhabitedFloat</span><span class="o">,</span> <span class="n">lean_arr</span><span class="o">,</span> <span class="n">i_</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">lean_dec</span><span class="o">(</span><span class="n">i_</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">lean_dec</span><span class="o">(</span><span class="n">lean_arr</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">return</span> <span class="n">out</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>which as far as I can tell are the same. I really have no idea on this one, but I'll keep trying stuff until it hopefully works (or I realize I made a typo somewhere haha)</p>
<p>Edit: Curiously, if I copy the generated code exactly and replace my get function with it, it still doesn't work. And even stranger, the get function is returning correctly. So something is happening between when it retrives the lean object from the array and returns it, and when it prints it. (I verified this by unbox the lean object just before returning from the get function, and it works properly)</p>
<p>I found the problem! But I have no idea whatsoever how to fix it. My code <code>cVec_get_val</code> returns a <code>lean_object*</code>, but for whatever reason, in the <code>Main.c</code> file,  it's trying to access it as if it were a double</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">static</span> <span class="n">double</span> <span class="n">_init_l_main___closed__3</span><span class="o">()</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_2</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_3</span><span class="bp">;</span>
<span class="n">x_1</span> <span class="bp">=</span> <span class="n">l_main___closed__2</span><span class="bp">;</span>
<span class="n">x_2</span> <span class="bp">=</span> <span class="n">lean_unsigned_to_nat</span><span class="o">(</span><span class="mi">2</span><span class="n">u</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_3</span> <span class="bp">=</span> <span class="n">cVec_get_val</span><span class="o">(</span><span class="n">x_1</span><span class="o">,</span> <span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_3</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>Edit 2: Apparently if I just make my <code>get</code> function return a double it works! But then the question is why are there inconsistencies between the function signatures when the functions are and are not exported?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
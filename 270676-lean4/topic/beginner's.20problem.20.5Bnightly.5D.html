---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html">beginner's problem [nightly]</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="285744988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285744988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285744988">(Jun 10 2022 at 23:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Logic.Basic</span>
<span class="c1">-- def exunique (p : α → Prop) := ∃ (x : α), (p x ∧ ∀ y, p y → x = y)</span>

<span class="c1">-- syntax "∃!" term "," term: term</span>
<span class="c1">-- macro_rules</span>
<span class="c1">-- | `(∃! $t:term, $p:term) =&gt; `(exunique (fun $t =&gt; $p))</span>

<span class="kd">class</span> <span class="n">incidence</span> <span class="o">(</span><span class="n">point</span> <span class="n">line</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">inc</span><span class="o">:</span><span class="n">point</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">Q</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">l</span><span class="o">,</span> <span class="n">inc</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">Q</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">two</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">Q</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">three</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">≠</span> <span class="n">R</span> <span class="bp">∧</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">R</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">inc</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">Q</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">R</span> <span class="n">l</span><span class="o">))</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">point</span> <span class="n">line</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">inc</span><span class="o">:</span><span class="n">point</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">incidence</span> <span class="n">point</span> <span class="n">line</span> <span class="n">inc</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">t1</span><span class="o">:</span>
<span class="bp">∀</span> <span class="n">l</span> <span class="n">m</span><span class="o">,</span>
<span class="n">l</span> <span class="bp">≠</span> <span class="n">m</span>
<span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="n">p</span><span class="o">,</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span>
<span class="n">intro</span> <span class="n">l</span> <span class="n">m</span> <span class="n">hlnm</span> <span class="n">hex</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">ha</span><span class="o">⟩:=</span> <span class="n">hex</span>
<span class="n">refine</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">_</span><span class="o">⟩</span>
<span class="c1">-- apply Classical.byContradiction; intro hanb</span>
<span class="n">refine</span> <span class="n">Classical.byContradiction</span> <span class="k">fun</span> <span class="n">hanb</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">_</span>
<span class="n">rewrite</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">,</span><span class="bp">←</span> <span class="n">ne_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">hanb</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">hal</span><span class="o">,</span><span class="n">ham</span><span class="o">⟩:=</span><span class="n">ha</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">hbl</span><span class="o">,</span><span class="n">hbm</span><span class="o">⟩:=</span><span class="n">hb</span>
<span class="k">have</span> <span class="n">h</span><span class="o">:=</span><span class="n">i.one</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hanb</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">hx1</span><span class="o">,</span><span class="n">hx2</span><span class="o">⟩:=</span><span class="n">h</span>
<span class="k">have</span> <span class="n">hl'</span><span class="o">:=</span> <span class="n">hx2</span> <span class="n">l</span> <span class="o">⟨</span><span class="n">hal</span><span class="o">,</span><span class="n">hbl</span><span class="o">⟩</span>
<span class="k">have</span> <span class="n">hm'</span><span class="o">:=</span> <span class="n">hx2</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">ham</span><span class="o">,</span><span class="n">hbm</span><span class="o">⟩</span>
<span class="k">have</span> <span class="n">hlm</span><span class="o">:=</span> <span class="n">Eq.trans</span> <span class="n">hl'</span> <span class="o">(</span><span class="n">Eq.symm</span> <span class="n">hm'</span><span class="o">)</span>
<span class="c1">-- hlm hlnm</span>
<span class="n">contradiction</span>


<span class="kd">theorem</span> <span class="n">t2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="n">intro</span> <span class="n">l</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span><span class="n">q</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">hpnq</span><span class="o">,</span><span class="n">hqnr</span><span class="o">,</span><span class="n">hpnr</span><span class="o">,</span><span class="n">hncol</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">i.three</span>
<span class="k">have</span> <span class="n">hnl</span><span class="o">:=</span> <span class="n">hncol</span> <span class="n">l</span>
<span class="n">apply</span> <span class="n">Classical.byContradiction</span>
<span class="n">intro</span> <span class="n">hallinc</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span><span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">hallinc</span>
<span class="c1">-- have hpqrinc:= And.intro (And.intro (hallinc p) (hallinc q)) (hallinc r)</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">././</span><span class="n">Trying.lean</span><span class="o">:</span><span class="mi">46</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">tactic</span> <span class="bp">'</span><span class="n">rewrite'</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="bp">¬¬?</span><span class="n">m.1516</span>
<span class="n">case</span> <span class="n">h</span>
<span class="n">point</span> <span class="n">line</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">inc</span> <span class="o">:</span> <span class="n">point</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">incidence</span> <span class="n">point</span> <span class="n">line</span> <span class="n">inc</span>
<span class="n">l</span> <span class="o">:</span> <span class="n">line</span>
<span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">point</span>
<span class="n">hpnq</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span>
<span class="n">hqnr</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≠</span> <span class="n">r</span>
<span class="n">hpnr</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">r</span>
<span class="n">hncol</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">line</span><span class="o">),</span> <span class="bp">¬</span><span class="o">(</span><span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">q</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">r</span> <span class="n">l</span><span class="o">)</span>
<span class="n">hnl</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">q</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">r</span> <span class="n">l</span><span class="o">)</span>
<span class="n">hallinc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">point</span><span class="o">),</span> <span class="bp">¬¬</span><span class="n">inc</span> <span class="n">x</span> <span class="n">l</span>
<span class="bp">⊢</span> <span class="n">False</span>
</code></pre></div>



<a name="285745006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285745006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285745006">(Jun 10 2022 at 23:52)</a>:</h4>
<p>See the last line, not_not is not matching its pattern.</p>



<a name="285745073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285745073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285745073">(Jun 10 2022 at 23:52)</a>:</h4>
<p>It isn't matching <code>¬¬something</code> in <code>hallinc : ∀ (x : point), ¬¬inc x l</code>.</p>



<a name="285752732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285752732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285752732">(Jun 11 2022 at 02:39)</a>:</h4>
<p>I believe <code>rewrite</code> will not work inside a <code>∀</code>. Here is one way to achieve what you want (replacing the last line).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">hallinc</span>
<span class="k">have</span> <span class="n">halinc'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">point</span><span class="o">),</span> <span class="n">inc</span> <span class="n">x</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
   <span class="n">intro</span> <span class="n">x</span>
   <span class="k">let</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">hallinc</span> <span class="n">x</span>
   <span class="n">rw</span> <span class="o">[</span><span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span>
   <span class="n">assumption</span>
</code></pre></div>
<p>Somebody more skilled than me at tactics will probably suggest a shorter way.</p>



<a name="285754275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754275">(Jun 11 2022 at 03:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266304">Siddhartha Gadgil</span> <a href="#narrow/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D/near/285752732">said</a>:</p>
<blockquote>
<p>I believe <code>rewrite</code> will not work inside a <code>∀</code>. Here is one way to achieve what you want (replacing the last line).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">hallinc</span>
<span class="k">have</span> <span class="n">halinc'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">point</span><span class="o">),</span> <span class="n">inc</span> <span class="n">x</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
   <span class="n">intro</span> <span class="n">x</span>
   <span class="k">let</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">hallinc</span> <span class="n">x</span>
   <span class="n">rw</span> <span class="o">[</span><span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span>
   <span class="n">assumption</span>
</code></pre></div>
<p>Somebody more skilled than me at tactics will probably suggest a shorter way.</p>
</blockquote>
<p>Why doesn't the nightly build automatically collapse not_not?</p>



<a name="285754365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754365">(Jun 11 2022 at 03:14)</a>:</h4>
<p>What do you mean by "collapse not_not"?</p>



<a name="285754504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754504">(Jun 11 2022 at 03:17)</a>:</h4>
<p>It seemed like the stable build of lean4 would automatically simplify not not p into p.</p>



<a name="285754505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754505">(Jun 11 2022 at 03:17)</a>:</h4>
<p>I don't expect <code>¬¬something</code> is _definitionally equal_ to <code>something</code>.</p>



<a name="285754630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754630">(Jun 11 2022 at 03:20)</a>:</h4>
<p>If <code>p</code> is a literal boolean that will happen. Did it happen with boolean expressions?</p>



<a name="285754732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754732">(Jun 11 2022 at 03:23)</a>:</h4>
<p>I don't see how one could have reflexive equality of <code>not not p</code> and <code>p</code> for arbitrary boolean expressions. The definition of <code>not</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">not</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="n">true</span>  <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="n">true</span>
</code></pre></div>
<p>which, due to _inline_, will expand for literals and so simplify. But for expressions it should just inline to a nested match.</p>



<a name="285754910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754910">(Jun 11 2022 at 03:26)</a>:</h4>
<p>I guess my lean3 examples had not_not as a simplification tactic because they were working classically.</p>



<a name="285754924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754924">(Jun 11 2022 at 03:26)</a>:</h4>
<p>That makes sense. Simplification will do all this expansion.</p>



<a name="285754930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285754930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285754930">(Jun 11 2022 at 03:27)</a>:</h4>
<p>i thought "automatically" meant definitional equality.</p>



<a name="285755007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285755007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285755007">(Jun 11 2022 at 03:29)</a>:</h4>
<p>I just checked: <code>simp</code> does work within functions, so you could simply replace your last lines with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">hallinc</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">hallinc</span>
</code></pre></div>



<a name="285755029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285755029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285755029">(Jun 11 2022 at 03:29)</a>:</h4>
<p>Better still, <code>simp [not_exists, not_not] at hallinc</code> does the job.</p>



<a name="285755427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285755427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285755427">(Jun 11 2022 at 03:37)</a>:</h4>
<p>Alright, now I'm having trouble getting And.assoc to work the way it advertises.</p>



<a name="285755498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285755498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285755498">(Jun 11 2022 at 03:38)</a>:</h4>
<p>Apparently it works fine in <code>rw</code>, but not as a direct application.</p>



<a name="285755862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285755862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285755862">(Jun 11 2022 at 03:47)</a>:</h4>
<p>Ignore that, the problem got solved so I don't mind.</p>



<a name="285795889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285795889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285795889">(Jun 11 2022 at 20:13)</a>:</h4>
<p>Alright, I've got another.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Logic.Basic</span>
<span class="c1">-- def exunique (p : α → Prop) := ∃ (x : α), (p x ∧ ∀ y, p y → x = y)</span>

<span class="c1">-- syntax "∃!" term "," term: term</span>
<span class="c1">-- macro_rules</span>
<span class="c1">-- | `(∃! $t:term, $p:term) =&gt; `(exunique (fun $t =&gt; $p))</span>

<span class="kd">class</span> <span class="n">incidence</span> <span class="o">(</span><span class="n">point</span> <span class="n">line</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">inc</span><span class="o">:</span><span class="n">point</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">Q</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">l</span><span class="o">,</span> <span class="n">inc</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">Q</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">two</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">Q</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">three</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="bp">≠</span> <span class="n">R</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">≠</span> <span class="n">R</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">inc</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">Q</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">R</span> <span class="n">l</span><span class="o">))</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">point</span> <span class="n">line</span><span class="o">:</span><span class="kt">Type</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">inc</span><span class="o">:</span><span class="n">point</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">incidence</span> <span class="n">point</span> <span class="n">line</span> <span class="n">inc</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">t1</span><span class="o">:</span>
<span class="bp">∀</span> <span class="n">l</span> <span class="n">m</span><span class="o">,</span>
<span class="n">l</span> <span class="bp">≠</span> <span class="n">m</span>
<span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">→</span> <span class="o">(</span><span class="bp">∃!</span> <span class="n">p</span><span class="o">,</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span>
<span class="n">intro</span> <span class="n">l</span> <span class="n">m</span> <span class="n">hlnm</span> <span class="n">hex</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">ha</span><span class="o">⟩:=</span> <span class="n">hex</span>
<span class="n">refine</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">_</span><span class="o">⟩</span>
<span class="c1">-- apply Classical.byContradiction; intro hanb</span>
<span class="n">refine</span> <span class="n">Classical.byContradiction</span> <span class="k">fun</span> <span class="n">hanb</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">_</span>
<span class="n">rewrite</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">,</span><span class="bp">←</span> <span class="n">ne_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">hanb</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">hal</span><span class="o">,</span><span class="n">ham</span><span class="o">⟩:=</span><span class="n">ha</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">hbl</span><span class="o">,</span><span class="n">hbm</span><span class="o">⟩:=</span><span class="n">hb</span>
<span class="k">have</span> <span class="n">h</span><span class="o">:=</span><span class="n">i.one</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hanb</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">hx1</span><span class="o">,</span><span class="n">hx2</span><span class="o">⟩:=</span><span class="n">h</span>
<span class="k">have</span> <span class="n">hl'</span><span class="o">:=</span> <span class="n">hx2</span> <span class="n">l</span> <span class="o">⟨</span><span class="n">hal</span><span class="o">,</span><span class="n">hbl</span><span class="o">⟩</span>
<span class="k">have</span> <span class="n">hm'</span><span class="o">:=</span> <span class="n">hx2</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">ham</span><span class="o">,</span><span class="n">hbm</span><span class="o">⟩</span>
<span class="k">have</span> <span class="n">hlm</span><span class="o">:=</span> <span class="n">Eq.trans</span> <span class="n">hl'</span> <span class="o">(</span><span class="n">Eq.symm</span> <span class="n">hm'</span><span class="o">)</span>
<span class="c1">-- hlm hlnm</span>
<span class="n">contradiction</span>

<span class="kd">theorem</span> <span class="n">t2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="n">intro</span> <span class="n">l</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span><span class="n">q</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">hpnq</span><span class="o">,</span><span class="n">hpnr</span><span class="o">,</span><span class="n">hqnr</span><span class="o">,</span><span class="n">hncol</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">i.three</span>
<span class="k">have</span> <span class="n">hnl</span><span class="o">:=</span> <span class="n">hncol</span> <span class="n">l</span>
<span class="n">apply</span> <span class="n">Classical.byContradiction</span>
<span class="n">intro</span> <span class="n">hallinc</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">not_not</span><span class="o">,</span><span class="n">not_exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">hallinc</span>
<span class="k">have</span> <span class="n">hl</span><span class="o">:=</span> <span class="n">And.intro</span> <span class="o">(</span><span class="n">And.intro</span> <span class="o">(</span><span class="n">hallinc</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hallinc</span> <span class="n">q</span><span class="o">))</span> <span class="o">(</span><span class="n">hallinc</span> <span class="n">r</span><span class="o">)</span>
<span class="c1">-- exact hnl (And.assoc hl)</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">And.assoc</span><span class="o">]</span> <span class="n">at</span> <span class="n">hl</span>
<span class="n">contradiction</span>

<span class="kd">theorem</span> <span class="n">another_point</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">point</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">q</span><span class="o">,</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span><span class="o">:=</span><span class="kd">by</span>
<span class="n">intro</span> <span class="n">p</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">hanb</span><span class="o">,</span><span class="n">hanc</span><span class="o">,</span><span class="n">hbnc</span><span class="o">,</span><span class="n">habc</span><span class="o">⟩:=</span> <span class="n">i.three</span>
<span class="n">apply</span> <span class="n">Classical.byContradiction</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span><span class="n">ne_eq</span><span class="o">]</span>
<span class="n">intro</span> <span class="n">h</span>
<span class="c1">-- exact hab (Eq.trans (eq_comm.mp (h a)) (h b))</span>
<span class="k">have</span> <span class="n">ha</span><span class="o">:=</span> <span class="n">h</span> <span class="n">a</span>
<span class="k">have</span> <span class="n">hb</span><span class="o">:=</span> <span class="n">h</span> <span class="n">b</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span>
<span class="k">have</span> <span class="n">hab</span><span class="o">:=</span> <span class="n">Eq.trans</span> <span class="n">ha</span> <span class="n">hb</span>
<span class="n">exact</span> <span class="n">hanb</span> <span class="n">hab</span>

<span class="kd">theorem</span> <span class="n">t3</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">l</span> <span class="n">m</span><span class="o">,</span> <span class="n">l</span> <span class="bp">≠</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="n">intro</span> <span class="n">p</span>
<span class="k">have</span> <span class="n">h</span><span class="o">:=</span> <span class="n">another_point</span> <span class="n">p</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">././</span><span class="n">Trying.lean</span><span class="o">:</span><span class="mi">66</span><span class="o">:</span><span class="mi">23</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">another_point</span> <span class="n">p</span>
<span class="n">argument</span>
  <span class="n">p</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">point</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span>
<span class="bp">././</span><span class="n">Trying.lean</span><span class="o">:</span><span class="mi">64</span><span class="o">:</span><span class="mi">53</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">unsolved</span> <span class="n">goals</span>
<span class="n">point</span> <span class="n">line</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">inc</span> <span class="o">:</span> <span class="n">point</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">incidence</span> <span class="n">point</span> <span class="n">line</span> <span class="n">inc</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">point</span>
<span class="n">h</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">line</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">inc</span> <span class="o">:</span> <span class="n">sorryAx</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="n">line</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">i</span> <span class="o">:</span> <span class="n">incidence</span> <span class="o">(</span><span class="n">sorryAx</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">line</span> <span class="n">inc</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">sorryAx</span> <span class="kt">Type</span><span class="o">),</span>
    <span class="bp">∃</span> <span class="n">q</span><span class="o">,</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">l</span> <span class="n">m</span><span class="o">,</span> <span class="n">l</span> <span class="bp">≠</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span>
</code></pre></div>
<p>I'm trying to apply <code>another_point</code> at the bottom line, but it's not typechecking.<br>
It's also saying the type involves sorryAx - not sure what that is.</p>



<a name="285797324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797324">(Jun 11 2022 at 20:53)</a>:</h4>
<p>If you hover over <code>another_point</code>, it'll show you the type of the theorem.</p>



<a name="285797721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797721">(Jun 11 2022 at 21:03)</a>:</h4>
<p>Yes, it's <code>∀ (line : Type) (inc : sorryAx Type → line → Prop) [i : incidence (sorryAx Type) line inc] (p : sorryAx Type),
  ∃ q, p ≠ q</code>.</p>



<a name="285797762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797762">(Jun 11 2022 at 21:04)</a>:</h4>
<p>So it's expecting a term of type Type and you gave it a term of type point</p>



<a name="285797768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797768">(Jun 11 2022 at 21:04)</a>:</h4>
<p>Which is exactly what the error says</p>



<a name="285797848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797848">(Jun 11 2022 at 21:06)</a>:</h4>
<p>Why would it be expecting a term of type <code>Type</code> when I defined the theorem with a term of type <code>point</code>?</p>



<a name="285797852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797852">(Jun 11 2022 at 21:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">another_point</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">point</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">q</span><span class="o">,</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span><span class="o">:=</span><span class="kd">by</span>
<span class="n">intro</span> <span class="n">p</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">hanb</span><span class="o">,</span><span class="n">hanc</span><span class="o">,</span><span class="n">hbnc</span><span class="o">,</span><span class="n">habc</span><span class="o">⟩:=</span> <span class="n">i.three</span>
<span class="n">apply</span> <span class="n">Classical.byContradiction</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span><span class="n">ne_eq</span><span class="o">]</span>
<span class="n">intro</span> <span class="n">h</span>
<span class="c1">-- exact hab (Eq.trans (eq_comm.mp (h a)) (h b))</span>
<span class="k">have</span> <span class="n">ha</span><span class="o">:=</span> <span class="n">h</span> <span class="n">a</span>
<span class="k">have</span> <span class="n">hb</span><span class="o">:=</span> <span class="n">h</span> <span class="n">b</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span>
<span class="k">have</span> <span class="n">hab</span><span class="o">:=</span> <span class="n">Eq.trans</span> <span class="n">ha</span> <span class="n">hb</span>
<span class="n">exact</span> <span class="n">hanb</span> <span class="n">hab</span>
</code></pre></div>



<a name="285797958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285797958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sébastien Michelland <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285797958">(Jun 11 2022 at 21:10)</a>:</h4>
<p>These are your <code>variable</code> definitions - the theorem implicitly uses them, so they have been included as parameters. The theorem uses them in the proof; see how you mention <code>i.three</code>.</p>
<p>If you change your <code>variable</code> declarations to use braces, the parameters will be made implicit and automatically inferred, resulting in the behavior that you expect - if inference succeeds.</p>



<a name="285798037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285798037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285798037">(Jun 11 2022 at 21:11)</a>:</h4>
<p>Oh, so if I were to keep the variables as is, I would have had to define <code>point</code>, <code>line</code>, and <code>inc</code> in the call to <code>another_point</code>. Makes sense.</p>



<a name="285798093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285798093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285798093">(Jun 11 2022 at 21:12)</a>:</h4>
<p>Tried changing to braces, everything's exploding.</p>



<a name="285798261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285798261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aron <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285798261">(Jun 11 2022 at 21:16)</a>:</h4>
<p>Figured out something that works without braces, but I'm not sure how I'd go about condensing it to get the definitions out of the way.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">another_point</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">point</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">q</span><span class="o">,</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span><span class="o">:=</span><span class="kd">by</span>
<span class="n">intro</span> <span class="n">p</span>
<span class="k">have</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">hanb</span><span class="o">,</span><span class="n">hanc</span><span class="o">,</span><span class="n">hbnc</span><span class="o">,</span><span class="n">habc</span><span class="o">⟩:=</span> <span class="n">i.three</span>
<span class="n">apply</span> <span class="n">Classical.byContradiction</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span><span class="n">ne_eq</span><span class="o">]</span>
<span class="n">intro</span> <span class="n">h</span>
<span class="c1">-- exact hab (Eq.trans (eq_comm.mp (h a)) (h b))</span>
<span class="k">have</span> <span class="n">ha</span><span class="o">:=</span> <span class="n">h</span> <span class="n">a</span>
<span class="k">have</span> <span class="n">hb</span><span class="o">:=</span> <span class="n">h</span> <span class="n">b</span>
<span class="k">have</span> <span class="n">hab</span><span class="o">:=</span> <span class="n">Eq.trans</span> <span class="o">(</span><span class="n">eq_comm.mp</span> <span class="n">ha</span><span class="o">)</span> <span class="n">hb</span>
<span class="n">exact</span> <span class="n">hanb</span> <span class="n">hab</span>

<span class="kd">theorem</span> <span class="n">t3</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">l</span> <span class="n">m</span><span class="o">,</span> <span class="n">l</span> <span class="bp">≠</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">inc</span> <span class="n">p</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="n">intro</span> <span class="n">p</span>
<span class="k">have</span> <span class="n">h</span><span class="o">:=</span> <span class="n">another_point</span> <span class="n">point</span> <span class="n">line</span> <span class="n">inc</span> <span class="n">p</span>
</code></pre></div>



<a name="285798262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285798262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sébastien Michelland <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285798262">(Jun 11 2022 at 21:16)</a>:</h4>
<p>Yes precisely. I'm not too surprised it's exploding, in my experience changing binder types is always tricky. It helps to get them right on the first try when you already know what you will be able to infer. It's also a limitation of <code>variable</code> that every theorem gets the same binder type.</p>



<a name="285800125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285800125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285800125">(Jun 11 2022 at 22:06)</a>:</h4>
<p>The rule of thumb is that something can be inferred if it appears in the type of a later argument.<br>
Applying this rule to your example, we can declare <code>variable {point line : Type}</code> implicit, but leave <code>inc</code> explicit. Then you can use <code>another_point inc p</code> and your file typechecks without issues.</p>



<a name="285800129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285800129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285800129">(Jun 11 2022 at 22:06)</a>:</h4>
<p>In Lean 3 you can change the binder type of a variable after it's been declared with a line such as <code>variable {line}</code></p>



<a name="285829306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/beginner%27s%20problem%20%5Bnightly%5D/near/285829306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/beginner's.20problem.20.5Bnightly.5D.html#285829306">(Jun 12 2022 at 08:30)</a>:</h4>
<p>that also works in lean 4</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
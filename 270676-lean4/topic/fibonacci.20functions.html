---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/fibonacci.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html">fibonacci functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="274319752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274319752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274319752">(Mar 06 2022 at 18:05)</a>:</h4>
<p>So i wrote a fibonacci function like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>and it didn't work because I had to prove termination. i then tried</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>and the same thing happened, but this version worked:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="n">n</span>
</code></pre></div>
<p>I didnt have to prove any termination at all. So my question is, is this a bug or just how the core language works?</p>



<a name="274319899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274319899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274319899">(Mar 06 2022 at 18:09)</a>:</h4>
<p>That's certainly not a bug. Do you know what 0-1 is? If so you can probably work out what's going on.</p>



<a name="274319987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274319987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274319987">(Mar 06 2022 at 18:11)</a>:</h4>
<p>Fundamentally, I think i am just not supposed to subtract</p>



<a name="274320246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274320246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274320246">(Mar 06 2022 at 18:17)</a>:</h4>
<p>The last version of your code is simply the only one that allows lean to automatically apply structural recursion since in every recursive call the parameter you are parsing is structually smaller than the one you got.</p>
<p>Now if you were to e.g. take your second version and apply termination by:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
<span class="n">termination_by</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span>
</code></pre></div>
<p>Lean will complain that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">termination</span><span class="o">,</span> <span class="n">possible</span> <span class="n">solutions</span><span class="o">:</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="k">have</span><span class="bp">`-</span><span class="n">expressions</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">the</span> <span class="n">remaining</span> <span class="n">goals</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">termination_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">different</span> <span class="n">well</span><span class="bp">-</span><span class="n">founded</span> <span class="n">relation</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">decreasing_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specity</span> <span class="n">your</span> <span class="n">own</span> <span class="n">tactic</span> <span class="n">for</span> <span class="n">discharging</span> <span class="n">this</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">goal</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="bp">⊢</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">Nat.succ</span> <span class="n">n</span>
</code></pre></div>
<p>and you'd have to prove this by hand since lean cannot just automagically see whats going on.</p>



<a name="274320308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274320308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274320308">(Mar 06 2022 at 18:19)</a>:</h4>
<p>Another solution is to mark it with <code>partial</code>, but that is generally not really ideal</p>



<a name="274320323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274320323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274320323">(Mar 06 2022 at 18:19)</a>:</h4>
<p>That's not a solution to prove termination that's telling lean to ignore termination on this one</p>



<a name="274320504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274320504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274320504">(Mar 06 2022 at 18:22)</a>:</h4>
<p>I mean not as a solution, but to ignore the termination errors.</p>



<a name="274321966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274321966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274321966">(Mar 06 2022 at 18:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span>
   <span class="k">have</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">Nat.lt_of_le_of_lt</span> <span class="o">(</span><span class="n">Nat.sub_le</span> <span class="bp">..</span><span class="o">)</span> <span class="o">(</span><span class="n">Nat.lt_succ_self</span> <span class="bp">..</span><span class="o">)</span> <span class="c1">-- This auxiliary prop will be proved automatically in the future</span>
   <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="274322756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274322756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274322756">(Mar 06 2022 at 19:09)</a>:</h4>
<p>What does the <code>..</code> syntax do? <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span></p>



<a name="274323224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274323224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> loki der quaeler <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274323224">(Mar 06 2022 at 19:18)</a>:</h4>
<p>I believe it's denoting that the arguments can be inferred - see the bottom of this page: <a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html">https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html</a></p>



<a name="274323294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274323294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274323294">(Mar 06 2022 at 19:20)</a>:</h4>
<p>Ah so a multi _ alias I see</p>



<a name="274324710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274324710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274324710">(Mar 06 2022 at 19:50)</a>:</h4>
<p>I think the <code>..</code> notation + named arguments is also quite useful for writing patterns.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Foo</span>
  <span class="bp">|</span> <span class="n">mk₁</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">mk₂</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">Foo.z</span> <span class="o">:</span> <span class="n">Foo</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">mk₁</span> <span class="o">(</span><span class="n">z</span> <span class="o">:=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">z</span>
  <span class="bp">|</span> <span class="n">mk₂</span> <span class="o">(</span><span class="n">z</span> <span class="o">:=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">z</span>
</code></pre></div>
<p><code>Foo.z</code> will not break if we add new fields to the constructors.</p>



<a name="274324842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274324842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274324842">(Mar 06 2022 at 19:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="467926">Joseph O</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274319752">said</a>:</p>
<blockquote>
<p>So i wrote a fibonacci function like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>and it didn't work because I had to prove termination.</p>
</blockquote>
<p>Just to mention what a problem is that prevents you from showing termination here, with <code>match</code> statements each pattern is independent: the third case doesn't "know" that <code>n</code> is neither <code>0</code> nor <code>1</code>.</p>
<p>If <code>match</code> could somehow give you that information (maybe as <code>n ≠ 0 ∧ n ≠ 1</code>), then you'd be able to show the function terminates.</p>



<a name="274324962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274324962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274324962">(Mar 06 2022 at 19:56)</a>:</h4>
<p>You could say the plus patterns (like <code>n+2</code>) are a way to avoid needing a fancy feature like that while still being relatively convenient.</p>



<a name="274325789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274325789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274325789">(Mar 06 2022 at 20:12)</a>:</h4>
<p>Note that lean 4 <em>has</em> that fancy feature, so potentially you could use it to prove the first one is terminating too</p>



<a name="274325863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274325863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274325863">(Mar 06 2022 at 20:14)</a>:</h4>
<p>I don't think there is syntax to expose the failing cases to the match expression itself though</p>



<a name="274326031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274326031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274326031">(Mar 06 2022 at 20:18)</a>:</h4>
<blockquote>
<p>If match could somehow give you that information (maybe as n ≠ 0 ∧ n ≠ 1), then you'd be able to show the function terminates.</p>
</blockquote>
<p>We have support for this only when reasoning about code that uses <code>match</code>. The <code>split</code> tactic will add this kind of antecedent.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">4</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">unfold</span> <span class="n">foo</span>
  <span class="n">split</span>
  <span class="n">trace_state</span> <span class="c1">-- In the third goal we have extra hypotheses that make sure the previous cases were not taken.</span>
  <span class="n">case</span> <span class="n">h_1</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">simp_arith</span> <span class="n">at</span> <span class="n">h</span>
  <span class="n">case</span> <span class="n">h_2</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">simp_arith</span> <span class="n">at</span> <span class="n">h</span>
  <span class="n">case</span> <span class="n">h_3</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">subst</span> <span class="n">h</span><span class="bp">;</span> <span class="n">simp_arith</span>
</code></pre></div>



<a name="274326055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274326055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274326055">(Mar 06 2022 at 20:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274325863">said</a>:</p>
<blockquote>
<p>I don't think there is syntax to expose the failing cases to the match expression itself though</p>
</blockquote>
<p>Unfortunately, we don't. We only have support for this when reasoning about <code>match</code> expressions as in the example above.</p>



<a name="274332902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274332902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274332902">(Mar 06 2022 at 22:49)</a>:</h4>
<p>Thanks for these great answers! <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span> <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="274339111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339111">(Mar 07 2022 at 01:08)</a>:</h4>
<p>Not really related to the original question, but why is this not structural recursion </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.unfoldr</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">s</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span><span class="o">::(</span><span class="n">unfoldr</span> <span class="n">f</span> <span class="n">b'</span><span class="o">)</span>
</code></pre></div>
<p>nor this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.unfoldlAux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">acc</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">s</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">acc</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">unfoldlAux</span> <span class="n">f</span> <span class="n">a'</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">acc</span><span class="o">)</span>
</code></pre></div>
<p>and how can i make it structural</p>



<a name="274339270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339270">(Mar 07 2022 at 01:11)</a>:</h4>
<p>i could just mark them with partial and leave it like that, as these functions are for personal use, but why may they never terminate?</p>



<a name="274339518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339518">(Mar 07 2022 at 01:16)</a>:</h4>
<p>It's not clear to me why <code>f s</code> can eventually be <code>none</code> (I'm guessing that's when you want your functions to terminate)</p>



<a name="274339685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339685">(Mar 07 2022 at 01:20)</a>:</h4>
<p>To answer the question "why is it not structural recursion": A structural recursion begins by matching on one of the function arguments, and then calling the function only on the values coming out of that match. Here you are matching on <code>f s</code>, which is not a function argument, and you are calling yourself recursively on <code>b'</code> which is not a value coming from a match on said function argument</p>



<a name="274339717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339717">(Mar 07 2022 at 01:21)</a>:</h4>
<p>As arthur says, not only is this not structurally recursive, it's not well founded recursive either, and you can in fact make it loop by passing the function <code>(\lam a, some (0, a))</code> for <code>f</code></p>



<a name="274339893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339893">(Mar 07 2022 at 01:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274339717">said</a>:</p>
<blockquote>
<p>As arthur says, not only is this not structurally recursive, it's not well founded recursive either, and you can in fact make it loop by passing the function <code>(\lam a, some (0, a))</code> for <code>f</code></p>
</blockquote>
<p>but what can i do to match on the argument?</p>



<a name="274339894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274339894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274339894">(Mar 07 2022 at 01:25)</a>:</h4>
<p>it wouldnt help</p>



<a name="274340023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274340023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274340023">(Mar 07 2022 at 01:28)</a>:</h4>
<p>I feel like for my purpose just marking it with <code>partial</code> would suffice</p>



<a name="274340444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274340444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274340444">(Mar 07 2022 at 01:38)</a>:</h4>
<p>but for the future, how would the structural recursive version look like?</p>



<a name="274340463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274340463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274340463">(Mar 07 2022 at 01:39)</a>:</h4>
<p>Wanna describe the problem you're trying to solve verbally on another thread to clear out the <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> noise? I <em>suspect</em> you'll need to rethink the whole solution design because your function can indeed loop forever for some functions <code>f</code> (e.g. with Mario's example).</p>



<a name="274340882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274340882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274340882">(Mar 07 2022 at 01:50)</a>:</h4>
<p><code>unfoldr</code> is a useful function in general, but I guess in Lean it should return something like <a href="https://leanprover-community.github.io/mathlib_docs/find/stream">docs#stream</a> instead of a List</p>



<a name="274345422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274345422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274345422">(Mar 07 2022 at 03:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="467926">Joseph O</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274340444">said</a>:</p>
<blockquote>
<p>but for the future, how would the structural recursive version look like?</p>
</blockquote>
<p>As <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> pointed out your function does not terminate in general. You can change the signature a bit, and ask the user to show that the new <code>b</code> is "smaller". Here are some examples</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.unfoldr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">sz</span> <span class="o">:</span> <span class="n">SizeOf</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="o">{</span> <span class="n">b'</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">//</span> <span class="n">sizeOf</span> <span class="n">b'</span> <span class="bp">&lt;</span> <span class="n">sizeOf</span> <span class="n">b</span><span class="o">}))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b'</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">unfoldr</span> <span class="n">f</span> <span class="n">b'</span>

<span class="kd">def</span> <span class="n">tst1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">List.unfoldr</span> <span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">n</span><span class="o">)</span> <span class="k">fun</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">none</span>
    <span class="bp">|</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp_arith</span><span class="o">⟩)</span>

<span class="k">#eval</span> <span class="n">tst1</span> <span class="mi">10</span>

<span class="kd">def</span> <span class="n">tst2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="c1">-- Similar example where we provide our custom `SizeOf` instance</span>
  <span class="n">List.unfoldr</span> <span class="o">(</span><span class="n">sz</span> <span class="o">:=</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="o">⟩)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">fun</span> <span class="n">b</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span>
      <span class="n">some</span> <span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decreasing_tactic</span><span class="o">⟩)</span>
    <span class="k">else</span>
      <span class="n">none</span>

<span class="k">#eval</span> <span class="n">tst2</span> <span class="mi">10</span>

<span class="c1">-- More general (and less convenient to use) version that can take an arbitrary well-founded relation.</span>
<span class="kd">def</span> <span class="n">List.unfoldr'</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">w</span> <span class="o">:</span> <span class="n">WellFoundedRelation</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="o">{</span> <span class="n">b'</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">//</span> <span class="n">w.rel</span> <span class="n">b'</span> <span class="n">b</span><span class="o">}))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b'</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">unfoldr'</span> <span class="n">f</span> <span class="n">b'</span>
<span class="n">termination_by</span> <span class="n">unfoldr'</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">b</span>

<span class="c1">-- We need the `master` branch to test the following example</span>

<span class="kd">def</span> <span class="n">tst3</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">List.unfoldr'</span> <span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">n</span><span class="o">)</span> <span class="k">fun</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">none</span>
    <span class="bp">|</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decreasing_tactic</span><span class="o">⟩)</span>

<span class="k">#eval</span> <span class="n">tst3</span> <span class="mi">10</span>

<span class="kd">def</span> <span class="n">tst4</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">List.unfoldr'</span> <span class="o">(</span><span class="n">w</span> <span class="o">:=</span> <span class="n">invImage</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="n">inferInstance</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">fun</span> <span class="n">b</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span>
      <span class="n">some</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decreasing_tactic</span><span class="o">⟩)</span>
    <span class="k">else</span>
      <span class="n">none</span>

<span class="k">#eval</span> <span class="n">tst4</span> <span class="mi">10</span>
</code></pre></div>



<a name="274345680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274345680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274345680">(Mar 07 2022 at 03:29)</a>:</h4>
<p>If the angle brackets bother you, you can define a macro. Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="s2">"#("</span> <span class="n">a</span> <span class="s2">")"</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decreasing_tactic</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">tst3</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">List.unfoldr'</span> <span class="o">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">n</span><span class="o">)</span> <span class="k">fun</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">none</span>
    <span class="bp">|</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="mi">2</span><span class="o">,</span> <span class="bp">#</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">tst3</span> <span class="mi">10</span>
</code></pre></div>



<a name="274365106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274365106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274365106">(Mar 07 2022 at 09:12)</a>:</h4>
<p>Thanks for the very helpful explanations and the updated docs. Can someone confirm my understanding of all the cases?</p>
<ul>
<li>To prove termination, we need a <em>well-founded relation</em> and a <em>proof that the argument is decreasing</em> for recursive calls (where decrease is with respect to the given relation).</li>
<li>If there is no <em>termination_by</em>, a well-founded relation is derived (if possible) by implicit resolution on the arguments of the function. It is an error if the typeclass resolution fails.</li>
<li>If  <em>termination_by</em> is specified, it maps the arguments of the function to a type α and implicit resolution looks for a well-founded relation on α (which we may view as giving a <em>pull-back</em> relation on the original arguments). Again it is an error if the implicit resolution fails, but this time for α .</li>
<li>In either case, we have to show that arguments for recursive calls are decreasing with respect to the well-founded relation. By default this is done using the <em>decreasing_tactic</em>, with an error if this fails and <em>decreasing_by</em> is not specified. One can instead use <em>decreasing_by</em> to specify the tactic.</li>
<li>A useful trick  to make things elegant is to note that <em>decreasing_tactic</em> includes <em>assumption</em>, so one can include a <code>have</code> statement that proves arguments are decreasing, and this gets picked up by assumption. This is especially useful if we have multiple recursive calls, since the appropriate <code>have</code> can be added just before each call (this is helpful to lean and to the reader).</li>
</ul>
<p>Thanks.</p>



<a name="274397170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274397170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274397170">(Mar 07 2022 at 14:17)</a>:</h4>
<p>this one doesnt terminate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.unfoldr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">sz</span> <span class="o">:</span> <span class="n">SizeOf</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="o">{</span> <span class="n">b'</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">//</span> <span class="n">sizeOf</span> <span class="n">b'</span> <span class="bp">&lt;</span> <span class="n">sizeOf</span> <span class="n">b</span><span class="o">}))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b'</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">unfoldr</span> <span class="n">f</span> <span class="n">b'</span>
<span class="bp">```</span> <span class="n">just</span> <span class="n">saying</span>
</code></pre></div>



<a name="274397286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274397286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274397286">(Mar 07 2022 at 14:18)</a>:</h4>
<p>and the second version has a type mismatch <a href="/user_uploads/3121/yh39Hv89tRD4rpIMLVtZZ_iz/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/yh39Hv89tRD4rpIMLVtZZ_iz/image.png" title="image.png"><img src="/user_uploads/3121/yh39Hv89tRD4rpIMLVtZZ_iz/image.png"></a></div>



<a name="274397391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274397391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274397391">(Mar 07 2022 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="467926">@Joseph O</span>  You need the Lean 4 master branch.<br>
Note that this examples are now in our CI :)</p>



<a name="274397571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274397571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274397571">(Mar 07 2022 at 14:20)</a>:</h4>
<p>(also please don't quote entire (long) comments)</p>



<a name="274397915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274397915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274397915">(Mar 07 2022 at 14:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274397571">said</a>:</p>
<blockquote>
<p>(also please don't quote entire (long) comments)</p>
</blockquote>
<p>Ah sorry</p>



<a name="274398037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398037">(Mar 07 2022 at 14:24)</a>:</h4>
<p>How do i get the master branch? Do i have to clone from source then?</p>



<a name="274398327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398327">(Mar 07 2022 at 14:26)</a>:</h4>
<p>I usually wait for the next nightly release</p>



<a name="274398421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398421">(Mar 07 2022 at 14:27)</a>:</h4>
<p>Yeah I would do that. Why do the examples <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> posted not work on the current nightly version? Was something added?</p>



<a name="274398494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398494">(Mar 07 2022 at 14:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="467926">Joseph O</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274398037">said</a>:</p>
<blockquote>
<p>How do i get the master branch? Do i have to clone from source then?</p>
</blockquote>
<p>Yes, this is an option, but the repo is quite big. Another option is to press the green "Code" button at GitHub, and select "Download Zip". The zip file includes just the master branch. The current nightly build is good enough for part of the examples.</p>



<a name="274398546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398546">(Mar 07 2022 at 14:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="467926">Joseph O</span> <a href="#narrow/stream/270676-lean4/topic/fibonacci.20functions/near/274398421">said</a>:</p>
<blockquote>
<p>Yeah I would do that. Why do the examples <span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> posted not work on the current nightly version? Was something added?</p>
</blockquote>
<p>The current nightly build is missing this commit <a href="https://github.com/leanprover/lean4/commit/619186b2a839ebd191257d78595d240e8eab47d7">https://github.com/leanprover/lean4/commit/619186b2a839ebd191257d78595d240e8eab47d7</a></p>



<a name="274398564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398564">(Mar 07 2022 at 14:28)</a>:</h4>
<p>It will probably be there tomorrow.</p>



<a name="274398660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398660">(Mar 07 2022 at 14:29)</a>:</h4>
<p>Without this commit, code generation will fail in the example that uses <code>invImage</code>.</p>



<a name="274398886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398886">(Mar 07 2022 at 14:31)</a>:</h4>
<p>ok well thank you</p>



<a name="274398961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274398961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274398961">(Mar 07 2022 at 14:31)</a>:</h4>
<p>Perhaps we should postpone the nightly cut-off time by a few hours so it's night for both of us <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="274399714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274399714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274399714">(Mar 07 2022 at 14:36)</a>:</h4>
<p>8AM CET/11PM PT sounds reasonable enough? Now I just need to find out the server timezones of GitHub and of the new bot</p>



<a name="274401159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274401159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274401159">(Mar 07 2022 at 14:46)</a>:</h4>
<p><span class="user-mention" data-user-id="266304">@Siddhartha Gadgil</span> Thanks for writing the summary. I included it in "Theorem Proving in Lean 4"</p>



<a name="274763626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274763626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274763626">(Mar 09 2022 at 22:42)</a>:</h4>
<p>What does <code>sizeOf</code> do  in your function <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> ?</p>



<a name="274765120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274765120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274765120">(Mar 09 2022 at 22:59)</a>:</h4>
<p><code>sizeOf</code> is an auxiliary function we use to prove termination. It has type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="o">[</span><span class="n">SizeOf</span> <span class="n">α</span><span class="o">]</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Nat</span>
</code></pre></div>
<p>When we declare a new inductive type or structure, Lean automatically generates a <code>SizeOf</code> instance for this type and equation theorems. For example, here are the theorems generated for <code>List</code>s.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">List.nil.sizeOf_spec</span>
<span class="c1">--  ∀ {α : Type u} [inst : SizeOf α], sizeOf [] = 1</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">List.cons.sizeOf_spec</span>
<span class="c1">-- ∀ {α : Type u} [SizeOf α] (head : α) (tail : List α), sizeOf (head :: tail) = 1 + sizeOf head + sizeOf tail</span>
</code></pre></div>
<p>The <code>decreasing_tactic</code> uses these theorems when proving termination.<br>
For <code>Nat</code>, the <code>SizeOf</code> instance is just the identity function.<br>
The short answer is: <code>SizeOf</code>already exists and was a convenient way of making <code>List.unfoldr</code> work for different types.</p>
<p>In the <code>List.unfoldr</code> example, Lean shows termination using the <code>decreasing_tactic</code>, this tactic succeeds because it also uses the <code>assumption</code> tactic, and we have <code>h : sizeOf b' &lt; sizeOf b</code> in the context. In <code>tst1</code>, when our function returns a new <code>b</code>, we also show <code>sizeOf b &lt; sizeOf (b+1)</code> using <code>simpArith</code>.</p>



<a name="274780000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274780000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274780000">(Mar 10 2022 at 01:52)</a>:</h4>
<p>What syntatic sugar are you using in <code>tst1</code>? Also, i really need to read TPIL4</p>



<a name="274780015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274780015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274780015">(Mar 10 2022 at 01:52)</a>:</h4>
<p>Or else im never going to be able to prove termination of my functions</p>



<a name="274782113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274782113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274782113">(Mar 10 2022 at 02:29)</a>:</h4>
<p>Are you referring to <code>⟨b, by simp_arith⟩</code>?  This is the anonymous constructor notation. We can use it for types that have only one constructor. In this case, it expands to <code>Subtype.mk b (by simp_arith)</code><br>
You can view a subtype as a pair: the element <code>b</code>, and a proof that <code>sizeof b &lt; sizeof (b+1)</code>. The proof is being constructed by the tactic <code>by simp_arith</code>.</p>



<a name="274782736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274782736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274782736">(Mar 10 2022 at 02:41)</a>:</h4>
<p>I was actually referring to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">none</span>
    <span class="bp">|</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp_arith</span><span class="o">⟩)</span>
</code></pre></div>
<p>i shouldve explained myself better, sorry</p>



<a name="274783011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274783011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274783011">(Mar 10 2022 at 02:46)</a>:</h4>
<p>This is sugar for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">none</span>
    <span class="bp">|</span> <span class="n">b</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="mi">2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp_arith</span><span class="o">⟩)</span>
</code></pre></div>



<a name="274783028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/fibonacci%20functions/near/274783028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/fibonacci.20functions.html#274783028">(Mar 10 2022 at 02:47)</a>:</h4>
<p>ah, like the <code>function</code> keyword in OCaml.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
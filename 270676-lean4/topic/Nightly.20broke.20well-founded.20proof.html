---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html">Nightly broke well-founded proof</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273278225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273278225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273278225">(Feb 25 2022 at 20:05)</a>:</h4>
<p>Just updated my toolchain to latest nightly, but going from <code>leanprover/lean4:nightly-2022-02-18</code> to the next day breaks some of my proofs</p>
<p><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/LazyList.lean#L65">https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/LazyList.lean#L65</a></p>
<p>^ this goal was closed before by simp, but now leaves some expression in terms of <code>WellFounded.fix</code></p>



<a name="273278571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273278571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273278571">(Feb 25 2022 at 20:08)</a>:</h4>
<p>(And doing the thing I normally do, of tossing a bunch more expressions to <code>simp</code>, gets stuck on <code>Acc.rec</code>. I'm sure how any of the WellFounded machinery works in lean 4 :/)</p>



<a name="273282462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273282462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273282462">(Feb 25 2022 at 20:41)</a>:</h4>
<p>Based on the timing this must be caused by the fix for <a href="https://github.com/leanprover/lean4/issues/1017">https://github.com/leanprover/lean4/issues/1017</a></p>



<a name="273671466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273671466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273671466">(Mar 01 2022 at 16:50)</a>:</h4>
<p>Just bumping this -- on <code>nightly-2022-03-01</code> I'm still getting stuck trying to get an expression through <code>Acc.rec</code></p>
<p>I never had to prove stuff in Lean 3 about functions that use well-founded recursion instead of structural recursion, so I'm not sure if this is something I can fix, or if my old solution should still be working and something broke in nightly</p>



<a name="273726486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273726486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273726486">(Mar 01 2022 at 23:16)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> Could you extract a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? This looks like something that needs to be addressed in core (we can probably find a workaround but this is exposing implementation details that don't look deliberate)</p>



<a name="273729104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273729104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273729104">(Mar 01 2022 at 23:39)</a>:</h4>
<p>This is as small as I can make it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Thunk</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">LazyList</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span>

<span class="c1">-- Height measures number of nodes (including delayeds)</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">height</span> <span class="o">(</span><span class="n">ll</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">LazyList.rec</span> <span class="o">(</span><span class="n">motive_1</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">motive_2</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="n">α</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="o">())</span> <span class="n">ll</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_nil</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.nil</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_cons</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.cons</span> <span class="n">α</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="n">l.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_delayed</span> <span class="o">(</span><span class="n">as</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.delayed</span> <span class="n">α</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">=</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">as.get</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">as</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">_</span> <span class="n">fn</span> <span class="bp">=&gt;</span> <span class="n">apply</span> <span class="n">congrArg</span><span class="bp">;</span> <span class="n">funext</span> <span class="o">()</span><span class="bp">;</span> <span class="n">rfl</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span><span class="bp">;</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Length of a list is number of actual elements</span>
<span class="cm">in the list, ignoring delays</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">_</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">length_nil</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">nil</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length</span><span class="o">]</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">length_cons</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">cons</span> <span class="n">α</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">as.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length</span><span class="o">]</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">length_delayed</span> <span class="o">(</span><span class="n">as</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">delayed</span> <span class="n">α</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">as.get.length</span>
  <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">=</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">as.get</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">as</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">_</span> <span class="n">fn</span> <span class="bp">=&gt;</span> <span class="n">apply</span> <span class="n">congrArg</span><span class="bp">;</span> <span class="n">funext</span> <span class="o">()</span><span class="bp">;</span> <span class="n">rfl</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span><span class="bp">;</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">toList</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">toList</span> <span class="n">as</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">length_toList</span> <span class="o">:</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">l.toList.length</span> <span class="bp">=</span> <span class="n">l.length</span>
  <span class="o">:=</span> <span class="bp">@</span><span class="n">rec</span> <span class="n">α</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">l.toList.length</span> <span class="bp">=</span> <span class="n">l.length</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span> <span class="bp">=&gt;</span> <span class="n">t.get.toList.length</span> <span class="bp">=</span> <span class="n">t.get.length</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">toList</span><span class="o">])</span>
    <span class="o">(</span><span class="kd">by</span>
      <span class="n">intros</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">tl_ih</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">tl_ih</span><span class="o">,</span> <span class="n">toList</span><span class="o">,</span> <span class="n">Thunk.get</span><span class="o">]</span>
      <span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span>
      <span class="n">intros</span> <span class="n">t</span> <span class="n">t_ih</span>
      <span class="n">assumption</span>
      <span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span>
      <span class="n">intros</span> <span class="n">fn</span> <span class="n">fn_ih</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">fn_ih</span> <span class="o">()</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">Thunk.get</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span> <span class="bp">|-</span>
      <span class="n">assumption</span>
      <span class="o">)</span>
</code></pre></div>
<p>I could mess around a bit more to try making it smaller but</p>



<a name="273729777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273729777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273729777">(Mar 01 2022 at 23:46)</a>:</h4>
<p>I will take a look at why <code>simp</code> is exposing the internal encoding. In the meantime, you can avoid the problem by deleting the unnecessary <code>length</code> theorems, Lean can create them automatically for us. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Thunk</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">LazyList</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">nil</span><span class="o">⟩</span>

<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">pure</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span>

<span class="c1">-- Height measures number of nodes (including delayeds)</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">height</span> <span class="o">(</span><span class="n">ll</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">LazyList.rec</span> <span class="o">(</span><span class="n">motive_1</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">motive_2</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="n">α</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="o">())</span> <span class="n">ll</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_nil</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.nil</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_cons</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.cons</span> <span class="n">α</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="n">l.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_delayed</span> <span class="o">(</span><span class="n">as</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.delayed</span> <span class="n">α</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">=</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">as.get</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">as</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">_</span> <span class="n">fn</span> <span class="bp">=&gt;</span> <span class="n">apply</span> <span class="n">congrArg</span><span class="bp">;</span> <span class="n">funext</span> <span class="o">()</span><span class="bp">;</span> <span class="n">rfl</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span><span class="bp">;</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Length of a list is number of actual elements</span>
<span class="cm">in the list, ignoring delays</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">_</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">toList</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">toList</span> <span class="n">as</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">toList</span> <span class="n">length</span>

<span class="kd">theorem</span> <span class="n">length_toList</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">l.toList.length</span> <span class="bp">=</span> <span class="n">l.length</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length_toList</span> <span class="n">as</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length_toList</span> <span class="n">as.get</span><span class="o">]</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">force</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">force</span> <span class="n">as.get</span>
  <span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">none</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">as</span><span class="o">)</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">theorem</span> <span class="n">toList_force_none</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">force</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">l.toList</span> <span class="bp">=</span> <span class="n">List.nil</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">force</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">force</span><span class="o">,</span> <span class="n">toList_force_none</span> <span class="n">as.get</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">force</span><span class="o">,</span> <span class="n">toList_force_none</span> <span class="n">as</span><span class="o">]</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>
</code></pre></div>



<a name="273738264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273738264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273738264">(Mar 02 2022 at 01:15)</a>:</h4>
<p>Oh, huh, so adding the simp attribute after declaration has different behavior than adding it directly to the declaration?</p>



<a name="273741194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273741194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273741194">(Mar 02 2022 at 01:52)</a>:</h4>
<p>I pushed a fix for this issue. I also added a nontrivial <code>SizeOf</code> instance for types like <code>Thunk</code>. The  <code>heigh</code> auxiliary function is not needed anymore. We can write the example above as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Thunk</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
  <span class="n">deriving</span> <span class="n">Inhabited</span>

<span class="kn">namespace</span> <span class="n">LazyList</span>

<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">pure</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Length of a list is number of actual elements</span>
<span class="cm">in the list, ignoring delays</span>
<span class="cm">-/</span>
<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">_</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">toList</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">toList</span> <span class="n">as</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as</span>

<span class="kd">theorem</span> <span class="n">length_toList</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">l.toList.length</span> <span class="bp">=</span> <span class="n">l.length</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length_toList</span> <span class="n">as</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length_toList</span> <span class="n">as.get</span><span class="o">]</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as</span>

<span class="kd">def</span> <span class="n">force</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">force</span> <span class="n">as.get</span>
  <span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">none</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">as</span><span class="o">)</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as</span>

<span class="kd">theorem</span> <span class="n">toList_force_none</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">force</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">l.toList</span> <span class="bp">=</span> <span class="n">List.nil</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">force</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">force</span><span class="o">,</span> <span class="n">toList_force_none</span> <span class="n">as.get</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">force</span><span class="o">,</span> <span class="n">toList_force_none</span> <span class="n">as</span><span class="o">]</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as</span>

<span class="kd">end</span> <span class="n">LazyList</span>
</code></pre></div>



<a name="273742824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273742824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273742824">(Mar 02 2022 at 02:11)</a>:</h4>
<p>Ah, amazing! Thank you :)</p>



<a name="273895402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Nightly%20broke%20well-founded%20proof/near/273895402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof.html#273895402">(Mar 02 2022 at 23:28)</a>:</h4>
<p>The trivial <code>termination_by _ as =&gt; as</code> annotations in the example above are not needed anymore. <br>
The simplified version is here: <a href="https://github.com/leanprover/lean4/blob/master/tests/lean/run/lazylistThunk.lean">https://github.com/leanprover/lean4/blob/master/tests/lean/run/lazylistThunk.lean</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html">associativity of `↔`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="236758486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236758486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236758486">(Apr 29 2021 at 22:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="c1">-- error</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">P ↔ P : Prop</span>
<span class="cm">expected command</span>
<span class="cm">-/</span>
</code></pre></div>
<p>Because I still don't understand how to check binding power of notation I can't figure out whether <code>↔</code> is supposed to be left or right associative, but the parser doesn't seem to fancy either choice here; it consumes <code>P ↔ P</code> and then decides it's all over.</p>



<a name="236759112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236759112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236759112">(Apr 29 2021 at 22:49)</a>:</h4>
<p><code>infix:20 " ↔ "   =&gt; Iff</code></p>



<a name="236759134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236759134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236759134">(Apr 29 2021 at 22:49)</a>:</h4>
<p>(from <a href="https://github.com/leanprover/lean4/blob/292bab5a11dc05e019068a579a42eac251bf587f/src/Init/Core.lean#L45">https://github.com/leanprover/lean4/blob/292bab5a11dc05e019068a579a42eac251bf587f/src/Init/Core.lean#L45</a> )</p>



<a name="236759983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236759983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236759983">(Apr 29 2021 at 22:57)</a>:</h4>
<p>Incidentally, <code>↔</code> is associative, although that's a classical theorem, not intuitionistic</p>



<a name="236760269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760269">(Apr 29 2021 at 23:00)</a>:</h4>
<p>It appears that lean 4 has a new command <code>infix</code> which means non-associative (in lean 3 this is a synonym for <code>infixl</code> meaning left-associative)</p>



<a name="236760394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760394">(Apr 29 2021 at 23:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- fine</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- unknown identifier `P`</span>
</code></pre></div>
<p>I think it's specific to <code>P</code>!</p>



<a name="236760682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760682">(Apr 29 2021 at 23:03)</a>:</h4>
<p>I can't replicate</p>



<a name="236760712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760712">(Apr 29 2021 at 23:03)</a>:</h4>
<p>I'm on today's nightly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- compiles</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">↔</span> <span class="n">A</span> <span class="bp">↔</span> <span class="n">A</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- fails on third A</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- compiles?!</span>
</code></pre></div>



<a name="236760792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760792">(Apr 29 2021 at 23:04)</a>:</h4>
<p>although this yields a very surprising result for me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">_</span> <span class="c1">-- (∀ (P : Prop), P ↔ P) ↔ P</span>
</code></pre></div>



<a name="236760837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760837">(Apr 29 2021 at 23:05)</a>:</h4>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>buzzard@ebony:~/lean-projects/mathlib4_experiments$ lean --version
Lean <span class="o">(</span>version <span class="m">4</span>.0.0-nightly-2021-04-29, commit 40b17bc364dd, Release<span class="o">)</span>
</code></pre></div>



<a name="236760981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236760981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236760981">(Apr 29 2021 at 23:06)</a>:</h4>
<p>just updated to that, still unchanged</p>



<a name="236761006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761006">(Apr 29 2021 at 23:07)</a>:</h4>
<p>oh wait it's different in a clean file</p>



<a name="236761031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761031">(Apr 29 2021 at 23:07)</a>:</h4>
<p>oh I see I had a variable P</p>



<a name="236761047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761047">(Apr 29 2021 at 23:07)</a>:</h4>
<p>this should work for you</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">_</span> <span class="c1">-- (∀ (P : Prop), P ↔ P) ↔ P</span>
</code></pre></div>



<a name="236761048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761048">(Apr 29 2021 at 23:07)</a>:</h4>
<p>I can replicate <code>(∀ (P : Prop), P ↔ P) ↔ P</code></p>



<a name="236761115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761115">(Apr 29 2021 at 23:08)</a>:</h4>
<p>and it makes sense why you would get unknown identifier with that parse</p>



<a name="236761241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761241">(Apr 29 2021 at 23:09)</a>:</h4>
<p>on the other hand</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="o">:=</span>
</code></pre></div>
<p>doesn't parse at all, the second <code>↔</code> seems to have ultra low precedence</p>



<a name="236761307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761307">(Apr 29 2021 at 23:10)</a>:</h4>
<p>I don't think this is non-associativity after all</p>



<a name="236761867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761867">(Apr 29 2021 at 23:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236760712">said</a>:</p>
<blockquote>
<p>I'm on today's nightly.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- compiles</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">↔</span> <span class="n">A</span> <span class="bp">↔</span> <span class="n">A</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- fails on third A</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- compiles?!</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This is because it is being parsed as <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span>  showed and then the unbound lowercase latin letters are being auto bound as specified in <a href="https://leanprover.github.io/lean4/doc/autobound.html">https://leanprover.github.io/lean4/doc/autobound.html</a></p>



<a name="236761933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761933">(Apr 29 2021 at 23:17)</a>:</h4>
<p>To quote from the page: "When Lean processes the header of a declaration, any unbound identifier is automatically added as an implicit argument if it is a single lower case or greek letter."</p>



<a name="236761942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236761942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236761942">(Apr 29 2021 at 23:17)</a>:</h4>
<p>I can confirm that <code>infix</code> is to blame:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">infix</span><span class="o">:</span><span class="mi">50</span> <span class="s2">" # "</span> <span class="bp">=&gt;</span> <span class="n">Eq</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">#</span> <span class="n">P</span> <span class="bp">#</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">_</span> <span class="c1">-- (∀ (P : Prop), P ↔ P) ↔ P</span>
</code></pre></div>
<p>changing <code>infix</code> for <code>infixl</code> or <code>infixr</code> causes the expected parse</p>



<a name="236762119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236762119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236762119">(Apr 29 2021 at 23:18)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="315577">@Mac</span> -- I had remembered the Greek letters but forgotten that it also worked with lower case</p>



<a name="236762120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236762120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236762120">(Apr 29 2021 at 23:18)</a>:</h4>
<p>Probably has to do with the fixity of the universal quantifier</p>



<a name="236762444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236762444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236762444">(Apr 29 2021 at 23:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236761942">said</a>:</p>
<blockquote>
<p>I can confirm that <code>infix</code> is to blame:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">infix</span><span class="o">:</span><span class="mi">50</span> <span class="s2">" # "</span> <span class="bp">=&gt;</span> <span class="n">Eq</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">#</span> <span class="n">P</span> <span class="bp">#</span> <span class="n">P</span> <span class="o">:=</span>
<span class="n">_</span> <span class="c1">-- (∀ (P : Prop), P ↔ P) ↔ P</span>
</code></pre></div>
<p>changing <code>infix</code> for <code>infixl</code> or <code>infixr</code> causes the expected parse</p>
</blockquote>
<p>Recall that <code>infix:50 " # " =&gt; Eq</code> really means <code>notation:50 lhs:51 " # " rhs:51 =&gt; Eq lhs rhs</code> (<a href="https://leanprover.github.io/lean4/doc/syntax.html">https://leanprover.github.io/lean4/doc/syntax.html</a>). As both sides have greater (numerical) precedence, neither side can now have <code>a # b</code> at all. So what happens is it falls down the precedence scale until reaches the universal quantifier, but then the precedence level resets inside the binder.</p>



<a name="236762852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236762852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236762852">(Apr 29 2021 at 23:27)</a>:</h4>
<p>Though all this confusion is somewhat expected considering that <code>P ↔ Q ↔ R</code> is not a particularly well-formed statement in intuitionistic logic in the first place (using the binary biconditional). Neither associative approach, i.e. <code>P ↔ (Q ↔ R)</code> or <code>(P ↔ Q) ↔ R</code>, is generally desired. What you might want is a variadic biconditional that expands <code>P ↔ Q ↔ R</code> to <code>P ↔ Q /\ Q ↔ R</code>, which could be done in a manner similar to the tuple notation.</p>



<a name="236763162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236763162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236763162">(Apr 29 2021 at 23:31)</a>:</h4>
<p>Actually I think a better way to parse non-associative operators is to allow them, say, as left associative, but then throw an explicit error during macro expansion</p>



<a name="236763560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236763560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236763560">(Apr 29 2021 at 23:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763162">said</a>:</p>
<blockquote>
<p>Actually I think a better way to parse non-associative operators is to allow them, say, as left associative, but then throw an explicit error during macro expansion</p>
</blockquote>
<p>That is certainly another option. Though I personally prefer that option that gives it meaning rather than one that deprives it of any. However, I do agree that, in the absence of a variadic version, an error is generally much more preferable than a cryptic parse.</p>



<a name="236763569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236763569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236763569">(Apr 29 2021 at 23:35)</a>:</h4>
<p>The only reason all this started was that I was porting a Lean 3 file which used <code>P \iff P \iff true</code></p>



<a name="236763707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236763707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236763707">(Apr 29 2021 at 23:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763569">said</a>:</p>
<blockquote>
<p>The only reason all this started was that I was porting a Lean 3 file which used <code>P \iff P \iff true</code></p>
</blockquote>
<p>Lol. This is why explicit parentheses are sometimes a very good thing. :)</p>



<a name="236763797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236763797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236763797">(Apr 29 2021 at 23:39)</a>:</h4>
<p>But in lean 3 I just look up the associativity of the operator and then I know how to parse. I still haven't really understood why this isn't going on in lean 4 although I do understand what's happening now you flagged the lower case issue</p>



<a name="236764516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236764516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236764516">(Apr 29 2021 at 23:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763797">said</a>:</p>
<blockquote>
<p>But in lean 3 I just look up the associativity of the operator and then I know how to parse.</p>
</blockquote>
<p>As far as I am aware, the same thing is true in Lean 4? Look up the definition of the notation and from there you can tell the precedence (the #) and the associativity, be it left (<code>infixl</code>), right (<code>infixr</code>) or none (<code>infix</code>).</p>



<a name="236764630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236764630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236764630">(Apr 29 2021 at 23:49)</a>:</h4>
<p>My understanding of lean 3 was that you only had two options depending on whether the binding power of the second variable was equal to the first or one less</p>



<a name="236765494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236765494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236765494">(Apr 29 2021 at 23:59)</a>:</h4>
<p>Ah, yeah, Lean 4 has expanded upon that.</p>



<a name="236766476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236766476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236766476">(Apr 30 2021 at 00:09)</a>:</h4>
<p>The point of non-associative operators is to <em>force</em> people to write the parentheses one way or another, exactly for cases like these where it's hard to guess</p>



<a name="236766607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236766607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236766607">(Apr 30 2021 at 00:10)</a>:</h4>
<p>which is why depriving that combination of operators of meaning is exactly the point. It's certainly better than the current behavior which is way outside what anyone would reasonably guess</p>



<a name="236768502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236768502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236768502">(Apr 30 2021 at 00:34)</a>:</h4>
<p>True. I was just saying variadic operators would be nice alternative too.</p>



<a name="236798289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236798289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236798289">(Apr 30 2021 at 07:49)</a>:</h4>
<p>Has a conscious choice been made by lean4 to not allow <code>x rel y rel z</code> (eg <code>0 ≤ i ≤ j &lt; n</code>) as a shorthand for <code>x rel y \and y rel z</code> like python, or is that still something that might be considered in future?</p>



<a name="236798427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236798427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236798427">(Apr 30 2021 at 07:51)</a>:</h4>
<p>Or can such a feature be built easily with a macro?</p>



<a name="236799132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236799132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236799132">(Apr 30 2021 at 07:58)</a>:</h4>
<p>It is definitely not the right semantics for all operators - <code>a \ne b \ne c</code> is usually meant to also imply <code>a \ne c</code>, for example. So I think we will leave such extensions to the community.</p>



<a name="236799145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236799145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236799145">(Apr 30 2021 at 07:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">infixr</span><span class="o">:</span><span class="mi">50</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="s2">" = "</span> <span class="bp">=&gt;</span> <span class="n">Eq</span>
<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">a</span> <span class="bp">=</span> <span class="bp">$</span><span class="n">b</span> <span class="bp">=</span> <span class="bp">$</span><span class="n">c</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">a</span> <span class="bp">=</span> <span class="bp">$</span><span class="n">b</span> <span class="bp">∧</span> <span class="bp">$</span><span class="n">b</span> <span class="bp">=</span> <span class="bp">$</span><span class="n">c</span><span class="o">)</span>

<span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span>
<span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span>
<span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">4</span>
</code></pre></div>



<a name="236799435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236799435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236799435">(Apr 30 2021 at 08:00)</a>:</h4>
<p>Personally I get annoyed by people writing <code>a \ne b \ne c</code> to also imply <code>a \ne c</code> because I can't ever understand the logic which is supposed to let me deduce this, but I agree that I've seen this convention used in the wild.</p>



<a name="236819096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236819096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236819096">(Apr 30 2021 at 11:13)</a>:</h4>
<p>I would rather have <code>a = b = c = d</code> expand to <code>tfae [a, b, c, d]</code>. In any case, my point was only for the default handling of <code>infix</code>. For specific operators it is possible to provide an alternative macro interpretation, especially if the normal one is explicitly declaiming responsibility.</p>



<a name="236821947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236821947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236821947">(Apr 30 2021 at 11:42)</a>:</h4>
<p>I think I like this idea that <code>infix</code> and <code>infixl</code> and <code>infixr</code> are three different things. Not everything has to parse, and I have had issues with students being confused when doing group theory from scratch because I state associativity as <code>(a * b) * c = a * (b * c)</code> and Lean prints it as <code>a * b * c = a * (b * c)</code>. I <em>think</em> that in Lean 3 there was no way of making the prettyprinter print the thing which all the maths books would write when explaining associativity, and now one could do this temporarily and then actively switch it off later when you're sick of it, and the students will understand better.</p>



<a name="236925373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236925373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236925373">(May 01 2021 at 01:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236821947">said</a>:</p>
<blockquote>
<p>I think I like this idea that <code>infix</code> and <code>infixl</code> and <code>infixr</code> are three different things. Not everything has to parse, and I have had issues with students being confused when doing group theory from scratch because I state associativity as <code>(a * b) * c = a * (b * c)</code> and Lean prints it as <code>a * b * c = a * (b * c)</code>. I <em>think</em> that in Lean 3 there was no way of making the prettyprinter print the thing which all the maths books would write when explaining associativity, and now one could do this temporarily and then actively switch it off later when you're sick of it, and the students will understand better.</p>
</blockquote>
<p>This actually precisely why I like the variadic operator approach for things like addition and multiplication. It makes <code>(a * b * c)</code> distinct from <code>(a * b) * c</code> and <code>a * (b * c)</code> so the pretty printer will keep them all separate.</p>



<a name="236925475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236925475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236925475">(May 01 2021 at 01:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236799435">said</a>:</p>
<blockquote>
<p>Personally I get annoyed by people writing <code>a \ne b \ne c</code> to also imply <code>a \ne c</code> because I can't ever understand the logic which is supposed to let me deduce this, but I agree that I've seen this convention used in the wild.</p>
</blockquote>
<p>Unfortunately, I am in camp <code>a \ne b \ne c</code> implies <code>a \ne c</code>. To me, the variadic <code>\ne</code> means mutual distinction, just as the variadic <code>=</code> means mutual equality.</p>



<a name="236927762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236927762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236927762">(May 01 2021 at 02:19)</a>:</h4>
<p>Variadic <code>ne</code> is just weird. I don't think I've ever seen it in a paper!</p>



<a name="236929397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236929397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236929397">(May 01 2021 at 02:42)</a>:</h4>
<p>I am in the camp that says <code>ne</code> is <code>infix</code> and <code>a \ne b \ne c</code> is ambiguous and should be avoided</p>



<a name="236949463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236949463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236949463">(May 01 2021 at 08:24)</a>:</h4>
<p>I might not have seen it in a paper but I've seen it on a blackboard (and winced)</p>



<a name="236950580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236950580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236950580">(May 01 2021 at 08:42)</a>:</h4>
<p>I mentally add an extra <code>\ne a</code>, for my mental sanity, when I see it...</p>



<a name="236951525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/236951525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#236951525">(May 01 2021 at 09:01)</a>:</h4>
<p><a href="https://xkcd.com/859/">https://xkcd.com/859/</a></p>



<a name="237043239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237043239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237043239">(May 02 2021 at 10:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236950580">said</a>:</p>
<blockquote>
<p>I mentally add an extra <code>\ne a</code>, for my mental sanity, when I see it...</p>
</blockquote>
<p>That only works for three variables, though. With four variables you can at least still draw a graph with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex"> \neq </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>-edges on the blackboard, with five variables, that graph isn't planar anymore ;)</p>



<a name="237043394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237043394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237043394">(May 02 2021 at 10:24)</a>:</h4>
<p>Now that's just planar silly</p>



<a name="237044497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237044497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237044497">(May 02 2021 at 10:47)</a>:</h4>
<p>Just do <code>a ≠ b ≠ c ≠ a ≠ d ≠ c ≠ d ≠ b</code>...</p>



<a name="237044601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237044601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237044601">(May 02 2021 at 10:48)</a>:</h4>
<p>Any path through the graph covering every edge is fine!</p>



<a name="237046990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237046990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237046990">(May 02 2021 at 11:37)</a>:</h4>
<p>You can't do that without repeating yourself somewhere for even n &gt; 2</p>



<a name="237047854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237047854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237047854">(May 02 2021 at 11:54)</a>:</h4>
<p>Yeah, I meant that as a joke</p>



<a name="237051387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237051387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237051387">(May 02 2021 at 13:00)</a>:</h4>
<p>I tend to write <code>a \ne b, c</code>, i feel like that's less ambiguous</p>



<a name="237051446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237051446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237051446">(May 02 2021 at 13:01)</a>:</h4>
<p>Unless <code>b \ne c</code> is also part of it</p>



<a name="237051464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237051464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237051464">(May 02 2021 at 13:01)</a>:</h4>
<p>I've seen profs write <code>a \ne b \ne c</code> before and I don't like it</p>



<a name="237064760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237064760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237064760">(May 02 2021 at 16:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237043239">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236950580">said</a>:</p>
<blockquote>
<p>I mentally add an extra <code>\ne a</code>, for my mental sanity, when I see it...</p>
</blockquote>
<p>That only works for three variables, though. With four variables you can at least still draw a graph with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex"> \neq </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span>-edges on the blackboard, with five variables, that graph isn't planar anymore ;)</p>
</blockquote>
<p>This actually why I like this definition of variadic <code>≠</code>, it means that <code>a ≠ b ≠ c ≠ d ≠ e</code> is shorthand for a much longer set of <code>≠</code>s. In fact, if I remember my math right, an <code>≠</code> of arity N is equal to <code>N choose 2</code> manually written <code>≠</code>s, which is some nice space savings. :)</p>



<a name="237064831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237064831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237064831">(May 02 2021 at 16:38)</a>:</h4>
<p>Probably you want <code>list.pairwise ne [a,b,c,d]</code> at that point though, or similar</p>



<a name="237064860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237064860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237064860">(May 02 2021 at 16:39)</a>:</h4>
<p>Else actually constructing or dissecting the terms would be awful</p>



<a name="237065064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065064">(May 02 2021 at 16:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237064831">said</a>:</p>
<blockquote>
<p>Probably you want <code>list.pairwise ne [a,b,c,d]</code> at that point though, or similar</p>
</blockquote>
<p>Well, yeah, that would be the logical expansion, yes. Just like <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  mentioned that <code>a = b = c = d</code> could be expanded to <code>tfae [a,b,c,d]</code>, <code>a ≠ b ≠ c ≠ d</code> could be expanded to <code>list.pairwise ne [a,b,c,d]</code></p>



<a name="237065082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065082">(May 02 2021 at 16:43)</a>:</h4>
<p>I think the notation itself is problematic though</p>



<a name="237065093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065093">(May 02 2021 at 16:43)</a>:</h4>
<p>It <em>could</em> be expanded to that, yes. I don't think it's a good idea</p>



<a name="237065102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065102">(May 02 2021 at 16:43)</a>:</h4>
<p>if you want pairwise ne then say so</p>



<a name="237065170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065170">(May 02 2021 at 16:44)</a>:</h4>
<p>When I read <code>a ≠ b ≠ c ≠ d</code> that is what I expect (pairwise ne) and that is also the way I would prefer pairwise ne to be denoted. I guess this just a place where we disagree on style.</p>



<a name="237065183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065183">(May 02 2021 at 16:45)</a>:</h4>
<p>For one thing, if it is expanded that way, then it won't be obvious that you should be looking in the <code>pairwise</code> namespace for lemmas about <code>a ≠ b ≠ c ≠ d</code></p>



<a name="237065211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065211">(May 02 2021 at 16:45)</a>:</h4>
<p>unless there are just two things in which case you should look at <code>ne</code></p>



<a name="237065267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065267">(May 02 2021 at 16:46)</a>:</h4>
<p>that kind of clever expansion seems like it would confuse more than help</p>



<a name="237065277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065277">(May 02 2021 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237065183">said</a>:</p>
<blockquote>
<p>For one thing, if it is expanded that way, then it won't be obvious that you should be looking in the <code>pairwise</code> namespace for lemmas about <code>a ≠ b ≠ c ≠ d</code></p>
</blockquote>
<p>I would probably define something like <code>def mutual_distinction := list.pairwise ne</code> and have it expand to <code>mutual_distinction</code> instead (and have theorems on <code>mutual_distinction</code></p>



<a name="237065289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065289">(May 02 2021 at 16:46)</a>:</h4>
<p>sure, same difference</p>



<a name="237065305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065305">(May 02 2021 at 16:47)</a>:</h4>
<p>the notation doesn't say <code>mutual_distinction</code> so how will you know to look there?</p>



<a name="237065341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065341">(May 02 2021 at 16:47)</a>:</h4>
<p>That's what I would assume <code>a ≠ b ≠ c ≠ d</code> means</p>



<a name="237065350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065350">(May 02 2021 at 16:47)</a>:</h4>
<p>I mean the words "mutual distinction" appear nowhere</p>



<a name="237065353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065353">(May 02 2021 at 16:47)</a>:</h4>
<p>In fact I would argue that is also what <code>a ≠ b</code> means</p>



<a name="237065399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065399">(May 02 2021 at 16:48)</a>:</h4>
<p>this is a non-discoverable bit of magic syntax</p>



<a name="237065422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065422">(May 02 2021 at 16:48)</a>:</h4>
<p>In the same vein: how do I know that <code>≠</code> means <code>ne</code>, where is that written in the notation?</p>



<a name="237065433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065433">(May 02 2021 at 16:49)</a>:</h4>
<p>If <code>a ≠ b</code> means <code>mutual_distinction [a, b]</code>, then how do you say <code>ne a b</code>?</p>



<a name="237065448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065448">(May 02 2021 at 16:49)</a>:</h4>
<p><code>mutual_distinction [a, b]</code> and <code>ne [a, b]</code> are defeq in my book..</p>



<a name="237065456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065456">(May 02 2021 at 16:49)</a>:</h4>
<p><code>ne</code> is a binary operator defined as <code>a = b -&gt; false</code></p>



<a name="237065510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065510">(May 02 2021 at 16:50)</a>:</h4>
<p>which exists regardless of whether <code>mutual_distinction</code> exists</p>



<a name="237065549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065549">(May 02 2021 at 16:50)</a>:</h4>
<p>Same thing with <code>eq a b</code>, we can't have everything be n-ary</p>



<a name="237065554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065554">(May 02 2021 at 16:51)</a>:</h4>
<p>If you are going by the current Lean Core, yes? This is about alternative definitions (as Lean doesn't currently have a variadic <code>ne</code>)</p>



<a name="237065571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065571">(May 02 2021 at 16:51)</a>:</h4>
<p>No, I'm talking about what it could/should be</p>



<a name="237065584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065584">(May 02 2021 at 16:51)</a>:</h4>
<p>It would be very disruptive if <code>Eq</code> was not a binary operator</p>



<a name="237065627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065627">(May 02 2021 at 16:52)</a>:</h4>
<p>Well then I don't agree that <code>ne</code> should actually always be defined as <code>a = b -&gt; false</code></p>



<a name="237065651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065651">(May 02 2021 at 16:52)</a>:</h4>
<p>Okay, so when I want <code>a = b -&gt; false</code> what do I write?</p>



<a name="237065666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065666">(May 02 2021 at 16:53)</a>:</h4>
<p>that?</p>



<a name="237065686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065686">(May 02 2021 at 16:53)</a>:</h4>
<p>I submit that the vast majority of the time when ne is used it is binary and means that</p>



<a name="237065699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065699">(May 02 2021 at 16:53)</a>:</h4>
<p>adding an indirection through <code>mutual_distinction</code> would make things worse for the majority of applications</p>



<a name="237065700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065700">(May 02 2021 at 16:53)</a>:</h4>
<p>I disagree, there are entire logics where <code>a = b -&gt; false</code> is not a valid construction (and yet ne exists)</p>



<a name="237065740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065740">(May 02 2021 at 16:54)</a>:</h4>
<p>?</p>



<a name="237065767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065767">(May 02 2021 at 16:54)</a>:</h4>
<p>We're talking about lean, yes?</p>



<a name="237065801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065801">(May 02 2021 at 16:55)</a>:</h4>
<p>Yes, and you can construct alternative logics in Lean.</p>



<a name="237065802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065802">(May 02 2021 at 16:55)</a>:</h4>
<p>If you want to make not not mean <code>p -&gt; false</code> that is considerably more disruptive</p>



<a name="237065830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065830">(May 02 2021 at 16:55)</a>:</h4>
<p>Yes, true, but sometimes that is desired.</p>



<a name="237065833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065833">(May 02 2021 at 16:55)</a>:</h4>
<p>Okay but in an alternative logic the notations are not my business</p>



<a name="237065885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065885">(May 02 2021 at 16:56)</a>:</h4>
<p>I'm talking about general mathematics a la mathlib</p>



<a name="237065907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237065907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237065907">(May 02 2021 at 16:56)</a>:</h4>
<p>Well, in my opinion, it is just like <code>+</code>, <code>=</code> and <code>≠</code> should just be defined based on classes that are defined differently for different types</p>



<a name="237066004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066004">(May 02 2021 at 16:58)</a>:</h4>
<p><code>Eq</code> is a typeclass now? Equality is a core concept of DTT, you can't get away from it and lean isn't really set up for that</p>



<a name="237066008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066008">(May 02 2021 at 16:58)</a>:</h4>
<p>I would define them something like the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">class</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">eq</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">P</span>

<span class="kd">class</span> <span class="n">Ne</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">ne</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">P</span>
</code></pre></div>
<p>This definition, afaik, is entirely compatible with the current definition of the two in Lean.</p>



<a name="237066029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066029">(May 02 2021 at 16:59)</a>:</h4>
<p><code>Eq</code> is heq, no?</p>



<a name="237066037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066037">(May 02 2021 at 16:59)</a>:</h4>
<p>No, <code>HEq</code> is heq</p>



<a name="237066175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066175">(May 02 2021 at 17:01)</a>:</h4>
<p>One issue with that definition is that you can't write <code>h : a = b</code> because <code>a = b</code>  isn't necessarily a type</p>



<a name="237066195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066195">(May 02 2021 at 17:02)</a>:</h4>
<p>The Prop instances (their current definitions) would look like the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[defaultInstance low]</span> <span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}:</span> <span class="n">Eq</span> <span class="kt">Prop</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span><span class="n">eq</span> <span class="o">:=</span> <span class="bp">...</span><span class="o">}</span>
<span class="kd">@[defaultInstance low]</span> <span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}:</span> <span class="n">Ne</span> <span class="kt">Prop</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span><span class="n">ne</span> <span class="o">:=</span> <span class="bp">...</span><span class="o">}</span>
</code></pre></div>



<a name="237066264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066264">(May 02 2021 at 17:02)</a>:</h4>
<p>Is <code>P</code> an outparam? I think it needs to be if you don't want lots of inference issues</p>



<a name="237066300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066300">(May 02 2021 at 17:03)</a>:</h4>
<p>The defaulting will resolve that (afaik)</p>



<a name="237066377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066377">(May 02 2021 at 17:04)</a>:</h4>
<p>(same reason you don't get all kinds of issues with inference with Nat literals)</p>



<a name="237066379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066379">(May 02 2021 at 17:04)</a>:</h4>
<p>What is the advantage of doing this? It won't make <code>Eq</code> the inductive type go away</p>



<a name="237066398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066398">(May 02 2021 at 17:05)</a>:</h4>
<p>I makes Lean's core (and the notation) more general, allowing it to be used more easily in alternative use cases (such as mine).</p>



<a name="237066424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066424">(May 02 2021 at 17:05)</a>:</h4>
<p>What is your use case?</p>



<a name="237066443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066443">(May 02 2021 at 17:05)</a>:</h4>
<p>I am writing a metalogic in Lean 4.</p>



<a name="237066487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066487">(May 02 2021 at 17:06)</a>:</h4>
<p>Each logic thus has its own <code>Prop</code> type (and thus possibly its own definition of equality).</p>



<a name="237066495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066495">(May 02 2021 at 17:06)</a>:</h4>
<p>Okay, that's been done in lean 3 and it doesn't require eliminating <code>=</code></p>



<a name="237066525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066525">(May 02 2021 at 17:07)</a>:</h4>
<p>You can overload the syntax if you really want to, but I wouldn't recommend it</p>



<a name="237066541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066541">(May 02 2021 at 17:07)</a>:</h4>
<p>because you need that equality for metatheory reasoning</p>



<a name="237066551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066551">(May 02 2021 at 17:07)</a>:</h4>
<p>So what, you want to always write <code>L |- eq a b</code> instead of the cleaner <code>L |- a = b</code>?</p>



<a name="237066558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066558">(May 02 2021 at 17:07)</a>:</h4>
<p>no, I would use some other = like symbol</p>



<a name="237066568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066568">(May 02 2021 at 17:08)</a>:</h4>
<p>I think flypitch used <code>\simeq</code></p>



<a name="237066606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066606">(May 02 2021 at 17:08)</a>:</h4>
<p>But, <em>it is</em> equality?</p>



<a name="237066617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066617">(May 02 2021 at 17:08)</a>:</h4>
<p>No it's not equality</p>



<a name="237066622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066622">(May 02 2021 at 17:08)</a>:</h4>
<p>it's provable equivalence in the theory</p>



<a name="237066659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066659">(May 02 2021 at 17:08)</a>:</h4>
<p>equality is equality of terms which is something else</p>



<a name="237066668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066668">(May 02 2021 at 17:08)</a>:</h4>
<p>Which is what Lean's <code>Eq</code> is: provable equivalence in Lean's theory?</p>



<a name="237066683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066683">(May 02 2021 at 17:09)</a>:</h4>
<p>Lean is the metatheory</p>



<a name="237066687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066687">(May 02 2021 at 17:09)</a>:</h4>
<p>your logic is the theory</p>



<a name="237066696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066696">(May 02 2021 at 17:09)</a>:</h4>
<p>I am aware?</p>



<a name="237066697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066697">(May 02 2021 at 17:09)</a>:</h4>
<p>You can only say that <code>Eq</code> is not true equality if you can step outside lean, which only works inside tactics and such</p>



<a name="237066709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066709">(May 02 2021 at 17:10)</a>:</h4>
<p>if you are doing mathematics in lean then <code>Eq</code> is equality</p>



<a name="237066753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066753">(May 02 2021 at 17:10)</a>:</h4>
<p>Maybe you and I have different ideas of what qualifies as "true equality"</p>



<a name="237066774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066774">(May 02 2021 at 17:10)</a>:</h4>
<p>It depends on the metalogic we are working in</p>



<a name="237066783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066783">(May 02 2021 at 17:10)</a>:</h4>
<p>Honestly, I am not even sure I agree that there is a "true equality" (except maybe identity -- and Lean's equality is most certainly not that)</p>



<a name="237066795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066795">(May 02 2021 at 17:11)</a>:</h4>
<p>identity is just another word for equality</p>



<a name="237066809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066809">(May 02 2021 at 17:11)</a>:</h4>
<p>I disagree?</p>



<a name="237066812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066812">(May 02 2021 at 17:11)</a>:</h4>
<p>Lean's equality is equality in the mathematical sense, provided we are not doing lean metatheory</p>



<a name="237066863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066863">(May 02 2021 at 17:12)</a>:</h4>
<p>No its not? Considering that defeq and Eq are not synonymous?</p>



<a name="237066866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066866">(May 02 2021 at 17:12)</a>:</h4>
<p>if we are using lean as a metatheory for another logic then that logic has provable equivalence and lean has equality</p>



<a name="237066881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066881">(May 02 2021 at 17:12)</a>:</h4>
<p>defeq is a metatheoretic notion</p>



<a name="237066910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066910">(May 02 2021 at 17:13)</a>:</h4>
<p>But as a result Lean's <code>Eq</code> does not satisfying the axioms of logical equality over Lean programs</p>



<a name="237066920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066920">(May 02 2021 at 17:13)</a>:</h4>
<p>Huh?</p>



<a name="237066925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066925">(May 02 2021 at 17:13)</a>:</h4>
<p><code>Eq</code> certainly does satisfy the axioms of equality</p>



<a name="237066934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066934">(May 02 2021 at 17:13)</a>:</h4>
<p>because we axiomatize it to be so</p>



<a name="237066997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237066997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237066997">(May 02 2021 at 17:14)</a>:</h4>
<p>within proofs, yes, but not within Lean as a whole.</p>



<a name="237067018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067018">(May 02 2021 at 17:15)</a>:</h4>
<p>I'm not sure what that means. In lean's logic, Eq is equality</p>



<a name="237067027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067027">(May 02 2021 at 17:15)</a>:</h4>
<p>A theory with logical equality should not be able (within the theory) to distinguish between two equal terms</p>



<a name="237067057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067057">(May 02 2021 at 17:15)</a>:</h4>
<p>Lean can, thus its <code>Eq</code> is not exactly true equality -- but I think you are said that when you were talking about tactics.</p>



<a name="237067097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067097">(May 02 2021 at 17:16)</a>:</h4>
<p>How can it?</p>



<a name="237067124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067124">(May 02 2021 at 17:16)</a>:</h4>
<p>tactics can distinguish between defeq and Eq terms?</p>



<a name="237067147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067147">(May 02 2021 at 17:17)</a>:</h4>
<p>I feel like we are going very deep on a tangent that I am not sure is that important.</p>



<a name="237067165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067165">(May 02 2021 at 17:17)</a>:</h4>
<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>



<a name="237067248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067248">(May 02 2021 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067165">said</a>:</p>
<blockquote>
<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>
</blockquote>
<p>What do you consider to be Lean? I would certainly consider tactics part of Lean.</p>



<a name="237067256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067256">(May 02 2021 at 17:18)</a>:</h4>
<p>I mean the lean logic</p>



<a name="237067259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067259">(May 02 2021 at 17:18)</a>:</h4>
<p>After all, you can prove things about them within Lean.</p>



<a name="237067280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067280">(May 02 2021 at 17:19)</a>:</h4>
<p>So there are two Lean logics then in your view? The Lean metalogic (used in tactics) and the Lean logic (where <code>Eq</code> is logical equality)?</p>



<a name="237067301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067301">(May 02 2021 at 17:19)</a>:</h4>
<p>Eh, things get complicated if you do that. It's true that lean's tactics are expressed in lean's logic, but there are unverified bits performing the reflection, compilation and such</p>



<a name="237067376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067376">(May 02 2021 at 17:20)</a>:</h4>
<p>It's certainly easiest to view them as entirely separate systems</p>



<a name="237067380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067380">(May 02 2021 at 17:20)</a>:</h4>
<p>Yes, but in Lean 4, all that is now writing in Lean, and can be dealt with in Lean proper.</p>



<a name="237067383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067383">(May 02 2021 at 17:20)</a>:</h4>
<p>The fact that lean 4 is implemented in lean is incidental to this discussion</p>



<a name="237067418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067418">(May 02 2021 at 17:21)</a>:</h4>
<p>In fact isn't one of the main long-term goals of Lean 4 to verify Lean's parser/compiler  in Lean?</p>



<a name="237067419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067419">(May 02 2021 at 17:21)</a>:</h4>
<p>The lean kernel is not implemented in lean (yet)</p>



<a name="237067500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067500">(May 02 2021 at 17:22)</a>:</h4>
<p>I don't know about that... I've suggested as much before but it seems that the developers have no intention of doing that themselves (although I think they would be fine with someone else doing it)</p>



<a name="237067526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067526">(May 02 2021 at 17:22)</a>:</h4>
<p>Certainly <code>partial</code> is one roadblock to doing that in today's lean 4</p>



<a name="237067543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067543">(May 02 2021 at 17:23)</a>:</h4>
<p>Well yes, but that is partly due to the limitations of well-founded recursion in current Lean 4.</p>



<a name="237067552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067552">(May 02 2021 at 17:23)</a>:</h4>
<p>Also, so is the Lean logic (in your view) that which is verified by the kernel? Though, aren't tactics verified by the kernel too? After all, it verifies proofs.</p>



<a name="237067616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067616">(May 02 2021 at 17:24)</a>:</h4>
<p>Yes, and yes (although calling tactics "verified by the kernel" is a bit of a stretch - they are typechecked)</p>



<a name="237067713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067713">(May 02 2021 at 17:26)</a>:</h4>
<p>As an analogue, perhaps it helps to consider that peano arithmetic is a logic that is capable of talking about other logics, including peano arithmetic. It can serve as its own metalogic</p>



<a name="237067725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067725">(May 02 2021 at 17:26)</a>:</h4>
<p>lean is doing something similar when you talk about lean tactics being objects in lean's logic</p>



<a name="237067743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067743">(May 02 2021 at 17:27)</a>:</h4>
<p>But it is best to keep them separate, name them PA(meta) and PA(object) if you need to</p>



<a name="237067805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067805">(May 02 2021 at 17:28)</a>:</h4>
<p>Perhaps "identity" and "equality" for you mean meta-<code>=</code> vs object-<code>=</code></p>



<a name="237067845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067845">(May 02 2021 at 17:29)</a>:</h4>
<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>



<a name="237067866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067866">(May 02 2021 at 17:30)</a>:</h4>
<p>"identity" for me means syntactic equality, but that is a fair alternative definition,</p>



<a name="237067932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067932">(May 02 2021 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067845">said</a>:</p>
<blockquote>
<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>
</blockquote>
<p>That is a fair approach. It is simply not mine.</p>



<a name="237067959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067959">(May 02 2021 at 17:31)</a>:</h4>
<p>When doing metamathematics in lean, it gets one step more complicated because we also get theory T and lean(object) is the metatheory for T</p>



<a name="237067972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237067972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237067972">(May 02 2021 at 17:32)</a>:</h4>
<p>I treat Lean more as the basic system by which to express my notions. I actually try to avoid Lean <code>Eq</code> as it destroys syntactic equality which is what I want to try to keep as my background equality.</p>



<a name="237068042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068042">(May 02 2021 at 17:32)</a>:</h4>
<p>For example, one place where <code>Eq</code> would come up when doing metamathematics is in defining substitution, which is an operation on terms</p>



<a name="237068094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068094">(May 02 2021 at 17:33)</a>:</h4>
<p>you might have a theorem that says <code>(P x)[a -&gt; b] = P[a -&gt; b] x[a -&gt; b]</code> where <code>=</code> is lean's <code>=</code></p>



<a name="237068230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068230">(May 02 2021 at 17:35)</a>:</h4>
<p>Equality comes up in a few places when defining proof rules. For example modus ponens, <code>|- P =&gt; |- P -&gt; Q =&gt; |- Q</code>, is asserting equality between the two instances of <code>P</code></p>



<a name="237068250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068250">(May 02 2021 at 17:35)</a>:</h4>
<p>not equality in the theory, "syntactic equality", which since lean is the metatheory means <code>Eq</code></p>



<a name="237068316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068316">(May 02 2021 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237068250">said</a>:</p>
<blockquote>
<p>not equality in the theory, "syntactic equality", which since lean is the metatheory means <code>Eq</code></p>
</blockquote>
<p>With all the macros and parsers, this is no longer entirely true.</p>



<a name="237068325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068325">(May 02 2021 at 17:36)</a>:</h4>
<p>the macros and parsers don't matter for this</p>



<a name="237068326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068326">(May 02 2021 at 17:36)</a>:</h4>
<p>they are all meta-lean</p>



<a name="237068352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068352">(May 02 2021 at 17:37)</a>:</h4>
<p>we're using lean to write the proof theory for some axiom system T here</p>



<a name="237068371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068371">(May 02 2021 at 17:38)</a>:</h4>
<p>meta-lean is only there to help us automate the construction of the inductive types defining provability and so on</p>



<a name="237068410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068410">(May 02 2021 at 17:38)</a>:</h4>
<p>Also how does " For example modus ponens, |- P =&gt; |- P -&gt; Q =&gt; |- Q, is asserting equality between the two instances of P" hold. Modus Ponens is not symmetric, equality is.</p>



<a name="237068438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068438">(May 02 2021 at 17:38)</a>:</h4>
<p>Modus Ponens is a rewrite/reduction rule, not an equivalence rule.</p>



<a name="237068454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068454">(May 02 2021 at 17:39)</a>:</h4>
<p>I'm saying that <code>MP(h, h2)</code> is a proof of <code>|- Q</code> provided <code>h</code> proves <code>|- P</code>, <code>h2</code> proves <code>|- P' -&gt; Q</code>, and <code>P = P'</code> where <code>=</code> is <code>@Eq term</code></p>



<a name="237068519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068519">(May 02 2021 at 17:40)</a>:</h4>
<p>Ah</p>



<a name="237068672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068672">(May 02 2021 at 17:43)</a>:</h4>
<p>as a rough sketch, that might look like this in lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Terms of theory T -/</span>
<span class="kd">inductive</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="sd">/-- Provable terms in theory T -/</span>
<span class="kd">inductive</span> <span class="n">proof</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mp</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">}</span> <span class="o">:</span> <span class="n">proof</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="n">imp</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="n">Q</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">P'</span> <span class="n">Q</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">proof</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">proof</span> <span class="o">(</span><span class="n">imp</span> <span class="n">P'</span> <span class="n">Q</span><span class="o">))</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">P'</span><span class="o">)</span> <span class="o">:</span> <span class="n">proof</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">e</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">proof.mp</span> <span class="n">h</span> <span class="n">h2</span>
</code></pre></div>



<a name="237068781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068781">(May 02 2021 at 17:45)</a>:</h4>
<p>That looks pretty familiar to me! XD <br>
Considering that I am writing  a metalogic in Lean, I have a definition very similar to this already.</p>



<a name="237068816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068816">(May 02 2021 at 17:45)</a>:</h4>
<p>The observation I want to make here is that the <code>=</code> in <code>e</code> is lean's interpretation of "syntactic equality"</p>



<a name="237068899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068899">(May 02 2021 at 17:46)</a>:</h4>
<p>if you step up a metalevel you will say "that's not syntactic equality! <em>This</em> is syntactic equality!" but you can keep playing that game</p>



<a name="237068958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068958">(May 02 2021 at 17:47)</a>:</h4>
<p>at every level there is some <code>=</code> relation that the logic thinks is equality and is valid up to the rules of the logic</p>



<a name="237068961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237068961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237068961">(May 02 2021 at 17:47)</a>:</h4>
<p>Well then there is also just real syntactic equality? What you are describing is what I would call logical equality.</p>



<a name="237069067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069067">(May 02 2021 at 17:48)</a>:</h4>
<p>Again, one person's syntactic equality is another's logical equality</p>



<a name="237069095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069095">(May 02 2021 at 17:49)</a>:</h4>
<p>what meta-lean thinks is syntactic equality is just logical equality in meta-meta-lean</p>



<a name="237069102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069102">(May 02 2021 at 17:49)</a>:</h4>
<p>No? Syntactically equality is equality of strings "a" = "a", "a" ne "b"?</p>



<a name="237069160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069160">(May 02 2021 at 17:50)</a>:</h4>
<p>That looks exactly like the way logical equality of strings is defined</p>



<a name="237069183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069183">(May 02 2021 at 17:50)</a>:</h4>
<p>Yes within a logic</p>



<a name="237069196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069196">(May 02 2021 at 17:51)</a>:</h4>
<p>Syntactic equality is formal language concept, not a logical concept</p>



<a name="237069208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069208">(May 02 2021 at 17:51)</a>:</h4>
<p>At least in my view.</p>



<a name="237069225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069225">(May 02 2021 at 17:52)</a>:</h4>
<blockquote>
<p>Syntactic equality is formal language concept</p>
</blockquote>
<p>Yes, that formal concept being equality, within the logic of the formalism itself</p>



<a name="237069270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069270">(May 02 2021 at 17:52)</a>:</h4>
<p>A logic can define an equality that does or does not mirror syntactic equality on the language, but that is different</p>



<a name="237069331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069331">(May 02 2021 at 17:53)</a>:</h4>
<p>I am curious, what is your position the philosophy of mathematics, are you a formalist or logicist (or something else)?</p>



<a name="237069343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069343">(May 02 2021 at 17:53)</a>:</h4>
<p>Formalist, of course <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span></p>



<a name="237069367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069367">(May 02 2021 at 17:54)</a>:</h4>
<p>? Well that makes me confused.</p>



<a name="237069424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069424">(May 02 2021 at 17:54)</a>:</h4>
<p>Because, afaik, formalism generally asserts that the notion of strings (and their identity) comes first before logic.</p>



<a name="237069427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069427">(May 02 2021 at 17:54)</a>:</h4>
<p>Which is my position</p>



<a name="237069465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069465">(May 02 2021 at 17:55)</a>:</h4>
<p>Whenever you look at a logical system from a meta-perspective, all the things that used to look like "actual equality" become "equality in the theory" or what you call "logical equality", and you gain access to another more precise "actual equality", which you might call "syntactic equality"</p>



<a name="237069484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069484">(May 02 2021 at 17:55)</a>:</h4>
<p>But any formal system can be meta-ified</p>



<a name="237069547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069547">(May 02 2021 at 17:56)</a>:</h4>
<p>My point is that there exists (imo) a notion of equality that lies outside of logic.</p>



<a name="237069573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069573">(May 02 2021 at 17:57)</a>:</h4>
<p>Sure, there is some philosophical notion of equality but I would not generally admit something like "a" = "a" under that because the two a's have different positions in space</p>



<a name="237069576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069576">(May 02 2021 at 17:57)</a>:</h4>
<p>This notion may or may not be the concept which a given logic chooses to formalize as "equality"</p>



<a name="237069685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069685">(May 02 2021 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069573">said</a>:</p>
<blockquote>
<p>Sure, there is some philosophical notion of equality but I would not generally admit something like "a" = "a" under that because the two a's have different positions in space</p>
</blockquote>
<p>Which is why the abstraction of characters and strings is need, only then can the philosophical notion bet applied. Neither of these, however, requires formal logic. At least from my formalist perspective. In fact, in my view, formal logic can only defined after these notions are grasped.</p>



<a name="237069712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069712">(May 02 2021 at 17:59)</a>:</h4>
<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>



<a name="237069716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069716">(May 02 2021 at 17:59)</a>:</h4>
<p>Formal logics can then, of course, formalize these notions within themselves.</p>



<a name="237069807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069807">(May 02 2021 at 18:00)</a>:</h4>
<p>and since formal logic can be applied to any mathematical field, including itself, you get this meta business</p>



<a name="237069814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069814">(May 02 2021 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069712">said</a>:</p>
<blockquote>
<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>
</blockquote>
<p>That strikes me more as a statement of Logicism <a href="https://en.wikipedia.org/wiki/Logicism">https://en.wikipedia.org/wiki/Logicism</a> than Formalism <a href="https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)">https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)</a></p>



<a name="237069854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069854">(May 02 2021 at 18:01)</a>:</h4>
<p>To quote from the page "In the philosophy of mathematics, formalism is the view that holds that statements of mathematics and <strong>logic</strong> can be considered to be statements about the consequences of the manipulation of strings (alphanumeric sequences of symbols, usually as equations) using established manipulation rules." (Emphasis mine)</p>



<a name="237069905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069905">(May 02 2021 at 18:01)</a>:</h4>
<p>I don't disagree with that</p>



<a name="237069964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069964">(May 02 2021 at 18:02)</a>:</h4>
<p>Mathematics is a game of symbols on a page</p>



<a name="237069975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069975">(May 02 2021 at 18:02)</a>:</h4>
<p>or in the computer, as it were</p>



<a name="237069978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069978">(May 02 2021 at 18:02)</a>:</h4>
<p>As someone who considers myself a formalist more than a logicism (by these definitions) I would thus disagree with your definition of Logic.</p>



<a name="237069989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237069989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237069989">(May 02 2021 at 18:02)</a>:</h4>
<p>Though I would also somewhat agree.</p>



<a name="237070054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070054">(May 02 2021 at 18:03)</a>:</h4>
<p>For me, "Reason" is closer to what you defined to be "Logic" and "Logic" is the manipulation of strings.</p>



<a name="237070059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070059">(May 02 2021 at 18:03)</a>:</h4>
<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>



<a name="237070115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070115">(May 02 2021 at 18:04)</a>:</h4>
<p>However, a fair alternative definition is "Logic" as you defined and "Formal Logic" as I have defined.</p>



<a name="237070175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070175">(May 02 2021 at 18:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070059">said</a>:</p>
<blockquote>
<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>
</blockquote>
<p>Logicism just claims that everything <em>in mathematics</em> reduces to logic (not everything in general). Do you disagree with that?</p>



<a name="237070189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070189">(May 02 2021 at 18:05)</a>:</h4>
<p>depends on what "reduces to" means</p>



<a name="237070204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070204">(May 02 2021 at 18:06)</a>:</h4>
<p>limiting to mathematics seems prudent</p>



<a name="237070277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070277">(May 02 2021 at 18:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070189">said</a>:</p>
<blockquote>
<p>depends on what "reduces to" means</p>
</blockquote>
<p>Hence why the Wikipedia article phrases it 3 different ways: "mathematics is an extension of logic, some or all of mathematics is reducible to logic, or some or all of mathematics may be modelled in logic" XD</p>



<a name="237070395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070395">(May 02 2021 at 18:08)</a>:</h4>
<p>If you rephrase something enough times it's hard to disagree with</p>



<a name="237070399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070399">(May 02 2021 at 18:09)</a>:</h4>
<p>Lol!</p>



<a name="237070547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070547">(May 02 2021 at 18:11)</a>:</h4>
<p>I think the key thrust of my point is this: I consider that abstraction of characters and strings and their identity (which I term "syntactic equality" or "identity")  to be a more fundamental concept than "logic".</p>



<a name="237070604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070604">(May 02 2021 at 18:12)</a>:</h4>
<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>



<a name="237070622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070622">(May 02 2021 at 18:12)</a>:</h4>
<p>"logic"s can (and may or may not) model these concepts but they exist (and can be conceived of) without them</p>



<a name="237070631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070631">(May 02 2021 at 18:12)</a>:</h4>
<p>When viewing lean itself as a logic it is not</p>



<a name="237070691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070691">(May 02 2021 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070604">said</a>:</p>
<blockquote>
<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>
</blockquote>
<p>No. In fact <code>Eq</code> to a certain extent prevents the true notion of "syntactic equality" from being modelled (in my view).</p>



<a name="237070748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070748">(May 02 2021 at 18:15)</a>:</h4>
<p>As syntactically distinct things such as '1 + 1' and '2' can be considered <code>Eq</code> and can be substituted with one another in proofs (prohibiting distinction)</p>



<a name="237070788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070788">(May 02 2021 at 18:15)</a>:</h4>
<p>1+1 is just a way to denote 2, says lean</p>



<a name="237070789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070789">(May 02 2021 at 18:15)</a>:</h4>
<p>Logical equality undermines syntactic equality.</p>



<a name="237070803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070803">(May 02 2021 at 18:15)</a>:</h4>
<p>if you want 1+1 in the logic you would use <code>term.add term.one term.one</code></p>



<a name="237070847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070847">(May 02 2021 at 18:16)</a>:</h4>
<p>and lean will agree that this is not <code>term.two</code></p>



<a name="237070869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070869">(May 02 2021 at 18:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070788">said</a>:</p>
<blockquote>
<p>1+1 is just a way to denote 2, says lean</p>
</blockquote>
<p>Exactly! Thus Lean does not preserve syntactic equality (within itself).</p>



<a name="237070883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070883">(May 02 2021 at 18:16)</a>:</h4>
<p>but the logic will agree that <code>proof (prop.eq (term.add term.one term.one) term.two)</code></p>



<a name="237070893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070893">(May 02 2021 at 18:16)</a>:</h4>
<p>However, with the new metaprogramming capabilities this can be resolved by cheating in many cases.</p>



<a name="237070938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070938">(May 02 2021 at 18:17)</a>:</h4>
<p>I feel like you are missing the point of mathematics, 1+1=2 is how it's supposed to work</p>



<a name="237070988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237070988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237070988">(May 02 2021 at 18:18)</a>:</h4>
<p>those two are the same number</p>



<a name="237071015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071015">(May 02 2021 at 18:18)</a>:</h4>
<p>they aren't terms, they are two ways to write the same natural number</p>



<a name="237071018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071018">(May 02 2021 at 18:18)</a>:</h4>
<p>That's fine, in mathematics.</p>



<a name="237071025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071025">(May 02 2021 at 18:18)</a>:</h4>
<p>yes, and lean is "mathematics" here</p>



<a name="237071039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071039">(May 02 2021 at 18:19)</a>:</h4>
<p>and theory T is "the logic under study"</p>



<a name="237071040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071040">(May 02 2021 at 18:19)</a>:</h4>
<p>No, Lean can be much more general than that.</p>



<a name="237071056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071056">(May 02 2021 at 18:19)</a>:</h4>
<p>After all, it is now a general purpose programming language.</p>



<a name="237071065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071065">(May 02 2021 at 18:19)</a>:</h4>
<p>But we're using it to do mathematics</p>



<a name="237071072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071072">(May 02 2021 at 18:19)</a>:</h4>
<p>My system is a metalogic and it needs to be able to represent logics where <code>1 + 1</code> is not exactly <code>2</code></p>



<a name="237071132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071132">(May 02 2021 at 18:20)</a>:</h4>
<p>They may be mathematically equal, but not equal in other ways.</p>



<a name="237071149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071149">(May 02 2021 at 18:20)</a>:</h4>
<p>That requires that you use the language of the theory under study</p>



<a name="237071150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071150">(May 02 2021 at 18:20)</a>:</h4>
<p>Like in general programming.</p>



<a name="237071158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071158">(May 02 2021 at 18:20)</a>:</h4>
<p>don't use <code>Nat</code> if you want that</p>



<a name="237071178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071178">(May 02 2021 at 18:20)</a>:</h4>
<p>Which I am not.</p>



<a name="237071221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071221">(May 02 2021 at 18:21)</a>:</h4>
<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>



<a name="237071225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071225">(May 02 2021 at 18:21)</a>:</h4>
<p>In computer science <code>1 + 1</code> is generally not <strong>logically</strong> equal to <code>2</code> (as one is a computation and one is a constant)</p>



<a name="237071295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071295">(May 02 2021 at 18:22)</a>:</h4>
<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>



<a name="237071299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071299">(May 02 2021 at 18:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071221">said</a>:</p>
<blockquote>
<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>
</blockquote>
<p>Yeah, and I do do something like this.</p>



<a name="237071357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071357">(May 02 2021 at 18:23)</a>:</h4>
<p>Certainly compilers seem to think that <code>1 + 1</code> is interchangeable with <code>2</code></p>



<a name="237071369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071369">(May 02 2021 at 18:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071295">said</a>:</p>
<blockquote>
<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>
</blockquote>
<p>Yes, but when it comes to compiling/optimizing they are initially distinct.</p>



<a name="237071427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071427">(May 02 2021 at 18:24)</a>:</h4>
<p>they are logically equal but syntactically different, in the language from earlier</p>



<a name="237071456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071456">(May 02 2021 at 18:25)</a>:</h4>
<p>The point of optimization is to pick the computational representation of two logically equivalent expressions that is more efficient (faster/less space), which requires you to be able to distinguish two logically equivalent terns.</p>



<a name="237071502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071502">(May 02 2021 at 18:25)</a>:</h4>
<p>right, which works because compilers work at the meta-level with respect to the program logic</p>



<a name="237071570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071570">(May 02 2021 at 18:26)</a>:</h4>
<p>Correct, though, you can also do the same within a single logic by reducing the scope of equality.</p>



<a name="237071593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071593">(May 02 2021 at 18:27)</a>:</h4>
<p>i.e. by making mathematical equality not identical to logical equality.</p>



<a name="237071600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071600">(May 02 2021 at 18:28)</a>:</h4>
<p>There are issues that crop up when you use a logic as its own metalogic. I think if the object-<code>=</code> and meta-<code>=</code> coincide it would have to be a fairly trivial logic</p>



<a name="237071749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071749">(May 02 2021 at 18:30)</a>:</h4>
<p>I disagree. In fact, I don't think equality is all that significant of a concept in the first place (to computation). For example, Peano arithmetic can be defined without it (or with just partial equality -- symmetric and transitive with no substitution).</p>



<a name="237071781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071781">(May 02 2021 at 18:30)</a>:</h4>
<p>peano arithmetic at least lets you prove 1+1=2</p>



<a name="237071796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071796">(May 02 2021 at 18:31)</a>:</h4>
<p>that theorem would fail if logical equality is exactly syntactic equality</p>



<a name="237071801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071801">(May 02 2021 at 18:31)</a>:</h4>
<p>For some definition of equality.</p>



<a name="237071806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071806">(May 02 2021 at 18:31)</a>:</h4>
<p>for a very useful definition of equality</p>



<a name="237071813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071813">(May 02 2021 at 18:31)</a>:</h4>
<p>Peano equality is actually not logical equality (it does not have predicate substitution as one of its axioms).</p>



<a name="237071856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071856">(May 02 2021 at 18:32)</a>:</h4>
<p>It is only reflexive, transitive, and symmetric (and only for natural numbers).</p>



<a name="237071874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071874">(May 02 2021 at 18:32)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Peano_axioms">https://en.wikipedia.org/wiki/Peano_axioms</a></p>



<a name="237071880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071880">(May 02 2021 at 18:32)</a>:</h4>
<p>It's closure property for nats is also not symmetric.</p>



<a name="237071932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237071932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237071932">(May 02 2021 at 18:33)</a>:</h4>
<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>



<a name="237072001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072001">(May 02 2021 at 18:34)</a>:</h4>
<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>



<a name="237072080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072080">(May 02 2021 at 18:35)</a>:</h4>
<p>In fact, the lack of symmetry is why Peano arithmetic is so popular in computer science. Because its definitions really don't need symmetry.</p>



<a name="237072128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072128">(May 02 2021 at 18:36)</a>:</h4>
<p>They only need rewrite and joinability.</p>



<a name="237072129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072129">(May 02 2021 at 18:36)</a>:</h4>
<p>PA builds on FOL, which generally has the substitution property either built in or derivable</p>



<a name="237072153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072153">(May 02 2021 at 18:36)</a>:</h4>
<p><strong>Modern</strong> PA builds on FOL, <strong>original</strong> PA does not.</p>



<a name="237072171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072171">(May 02 2021 at 18:37)</a>:</h4>
<p>In fact, original PA is second-order.</p>



<a name="237072178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072178">(May 02 2021 at 18:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071932">said</a>:</p>
<blockquote>
<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>
</blockquote>
<p>This one is listed as number 5 on wiki</p>



<a name="237072194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072194">(May 02 2021 at 18:37)</a>:</h4>
<p>number 5 is the converse</p>



<a name="237072207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072207">(May 02 2021 at 18:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237072001">said</a>:</p>
<blockquote>
<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>
</blockquote>



<a name="237072218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072218">(May 02 2021 at 18:38)</a>:</h4>
<p>equality is symmetric</p>



<a name="237072265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072265">(May 02 2021 at 18:38)</a>:</h4>
<p>Only for nats in PA.</p>



<a name="237072278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072278">(May 02 2021 at 18:38)</a>:</h4>
<p>number 3: "For all <strong>natural numbers</strong> x and y, if x = y, then y = x."</p>



<a name="237072282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072282">(May 02 2021 at 18:38)</a>:</h4>
<p>If b is unknown you can't use symmetry.</p>



<a name="237072304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072304">(May 02 2021 at 18:39)</a>:</h4>
<p>You first have prove that both sides are natural before you can use symmetry.</p>



<a name="237072319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072319">(May 02 2021 at 18:39)</a>:</h4>
<p>That seems like a typo or oversight in the presentation</p>



<a name="237072340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072340">(May 02 2021 at 18:40)</a>:</h4>
<p>I wrote proofs of all these things to test my metalogic.</p>



<a name="237072377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072377">(May 02 2021 at 18:40)</a>:</h4>
<p>It works as formulated on the Wiki page.</p>



<a name="237072386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072386">(May 02 2021 at 18:40)</a>:</h4>
<p>In formal treatments of this usually "is a natural number" isn't even a thing</p>



<a name="237072412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072412">(May 02 2021 at 18:40)</a>:</h4>
<p>you just have all things be natural numbers</p>



<a name="237072425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072425">(May 02 2021 at 18:41)</a>:</h4>
<p>true, but some interesting prosperities emerge if you do it like written.</p>



<a name="237072491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072491">(May 02 2021 at 18:42)</a>:</h4>
<p>It also probably because PA is generally embedded in other logics rather than used on its own.</p>



<a name="237072534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072534">(May 02 2021 at 18:43)</a>:</h4>
<p>Incidentally, I have been working for a while on a formal library which is based on PA; I don't know of any larger practical formal development using PA as the basis</p>



<a name="237072564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072564">(May 02 2021 at 18:43)</a>:</h4>
<p>Nat in Lean (and  most other functional languages) is  a embedding of (modern) PA?</p>



<a name="237072605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072605">(May 02 2021 at 18:44)</a>:</h4>
<p>DTT is way stronger than PA</p>



<a name="237072619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072619">(May 02 2021 at 18:44)</a>:</h4>
<p>Yes, true</p>



<a name="237072627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072627">(May 02 2021 at 18:44)</a>:</h4>
<p>I mean a formalization of the axiom system PA and its consequences</p>



<a name="237072655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072655">(May 02 2021 at 18:45)</a>:</h4>
<p>yes, you can do this in lean (in principle)</p>



<a name="237072684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072684">(May 02 2021 at 18:45)</a>:</h4>
<p>as far as I know no one has worked out a significant amount of mathematics in that setting</p>



<a name="237072685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072685">(May 02 2021 at 18:45)</a>:</h4>
<p>Well, now its done in practice.:)</p>



<a name="237072744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072744">(May 02 2021 at 18:46)</a>:</h4>
<p>I mostly just did it as a test of my system. I did find a lot of (what I consider to be) interesting results though.</p>



<a name="237072797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072797">(May 02 2021 at 18:47)</a>:</h4>
<p>It's one thing to write the axioms and quite another to construct finite set theory in it, recursive functions, provability, and some CS stuff</p>



<a name="237072861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072861">(May 02 2021 at 18:48)</a>:</h4>
<p>Well yeah</p>



<a name="237072882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072882">(May 02 2021 at 18:48)</a>:</h4>
<p>I would like lean 4 to get to the point that writing extended formal developments in embedded languages is easy; in lean 3 it's a pretty big ergonomic step down from regular lean proofs</p>



<a name="237072905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072905">(May 02 2021 at 18:49)</a>:</h4>
<p>What do you mean by an "embedded language"?</p>



<a name="237072913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072913">(May 02 2021 at 18:49)</a>:</h4>
<p>like, <em>in principle</em> you can write tactics and things to work on the embedded language but for the most part you are starting from scratch</p>



<a name="237072921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072921">(May 02 2021 at 18:50)</a>:</h4>
<p>I mean "theory T" that you are defining in lean</p>



<a name="237072994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237072994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237072994">(May 02 2021 at 18:50)</a>:</h4>
<p>like if you define the language and proof theory of PA and then want to prove a bazillion theorems in it because you want to prove godel incompleteness</p>



<a name="237073010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073010">(May 02 2021 at 18:51)</a>:</h4>
<p>the reason for writing it in lean is so that you can also prove theorems <em>about</em> the system, but theorems <em>in</em> the system are also important</p>



<a name="237073015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073015">(May 02 2021 at 18:51)</a>:</h4>
<p>I think my approach is rather ergonomic to a degree. I don't know what others would think of it though. It is also in super super alpha.</p>



<a name="237073065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073065">(May 02 2021 at 18:52)</a>:</h4>
<p>You can more or less create one-for-one tactics.</p>



<a name="237073081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073081">(May 02 2021 at 18:52)</a>:</h4>
<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>



<a name="237073089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073089">(May 02 2021 at 18:52)</a>:</h4>
<p>I think the most annoying thing to work with though would be linear logic as you <strong>cannot</strong> reduce most things to functions any more.</p>



<a name="237073116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073116">(May 02 2021 at 18:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073081">said</a>:</p>
<blockquote>
<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>
</blockquote>
<p>Ah, then no, you would probably not like my approach then. I avoid those two commands like the plague.</p>



<a name="237073118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073118">(May 02 2021 at 18:53)</a>:</h4>
<p>Hm, makes me wonder about porting Iris to lean 4</p>



<a name="237073175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073175">(May 02 2021 at 18:54)</a>:</h4>
<p>why are you avoiding them?</p>



<a name="237073190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073190">(May 02 2021 at 18:54)</a>:</h4>
<p>I dislike <code>rw</code> and <code>simp</code> because they hide what rules/theorems you are actually using.</p>



<a name="237073215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073215">(May 02 2021 at 18:55)</a>:</h4>
<p>if you are just trying to establish provability that's usually not a big deal</p>



<a name="237073223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073223">(May 02 2021 at 18:55)</a>:</h4>
<p>I want my proofs to be clear (and <code>go to definition</code> able)</p>



<a name="237073239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073239">(May 02 2021 at 18:55)</a>:</h4>
<p>plus you can use <code>simp only</code> or only mark things as simp lemmas that you want to elide</p>



<a name="237073242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073242">(May 02 2021 at 18:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073215">said</a>:</p>
<blockquote>
<p>if you are just trying to establish provability that's usually not a big deal</p>
</blockquote>
<p>True, but that is rarely my goal.</p>



<a name="237073260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073260">(May 02 2021 at 18:55)</a>:</h4>
<p>I am more interested in reverse mathematics.</p>



<a name="237073318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073318">(May 02 2021 at 18:56)</a>:</h4>
<p>i.e. I want to know exactly what assumptions were made to get to a given proof.</p>



<a name="237073326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073326">(May 02 2021 at 18:56)</a>:</h4>
<p>And  I want to minimize them.</p>



<a name="237073327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073327">(May 02 2021 at 18:56)</a>:</h4>
<p>That's what <code>#print axioms</code> is for</p>



<a name="237073340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073340">(May 02 2021 at 18:56)</a>:</h4>
<p>well, you have more refined mechanisms for that in a deep embedding</p>



<a name="237073382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073382">(May 02 2021 at 18:57)</a>:</h4>
<p>You can literally define a function on proofs that will tell you if you used only such and such assumptions</p>



<a name="237073387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073387">(May 02 2021 at 18:57)</a>:</h4>
<p>I like that stuff to be explicit. Also, print axioms only works for Lean axioms not other kinds of assumptions.</p>



<a name="237073449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073449">(May 02 2021 at 18:58)</a>:</h4>
<p>I also would like them to be readable in isolation from the source code.</p>



<a name="237073455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073455">(May 02 2021 at 18:58)</a>:</h4>
<p>If you don't want to assume something, don't assume it</p>



<a name="237073497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073497">(May 02 2021 at 18:59)</a>:</h4>
<p>I want my lean proofs to more-or-less work (and be readable) in a vacuum.</p>



<a name="237073557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073557">(May 02 2021 at 19:00)</a>:</h4>
<p>And I am pretty happy with what I have gotten working in that regard.</p>



<a name="237073560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073560">(May 02 2021 at 19:00)</a>:</h4>
<p>Those are not words I would use to describe lean</p>



<a name="237073739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073739">(May 02 2021 at 19:02)</a>:</h4>
<p>there are quite a lot of things that go into turning lean text into a theorem/assertion</p>



<a name="237073744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073744">(May 02 2021 at 19:02)</a>:</h4>
<p>Here is my proof of commutativity of PA addition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">addNatCommProof</span>
<span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Logic</span> <span class="n">P</span><span class="o">}</span>
<span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="n">PNat</span> <span class="n">P</span> <span class="n">T</span><span class="o">}</span> <span class="o">{</span><span class="n">Q</span> <span class="o">:</span> <span class="n">SEq</span> <span class="n">P</span> <span class="n">T</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">SAdd</span> <span class="n">T</span><span class="o">}</span>
<span class="o">(</span><span class="n">I</span>   <span class="o">:</span> <span class="n">NatInductionRight</span> <span class="n">L</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">NS</span>  <span class="o">:</span> <span class="n">NatSuccNat</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">(</span><span class="n">NA</span>  <span class="o">:</span> <span class="n">NatAddNat</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">QEL</span> <span class="o">:</span> <span class="n">EqNatLeftEuc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span><span class="o">)</span>
<span class="o">(</span><span class="n">QtS</span> <span class="o">:</span> <span class="n">EqNatToEqSucc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">(</span><span class="n">A0C</span> <span class="o">:</span> <span class="n">AddNatZeroComm</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">A</span> <span class="n">N.toZero</span><span class="o">)</span>
<span class="o">(</span><span class="n">ASn</span> <span class="o">:</span> <span class="n">AddSuccNatEqSucc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">A</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">(</span><span class="n">AnS</span> <span class="o">:</span> <span class="n">AddNatSuccEqSucc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">A</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine</span> <span class="n">natInductionRight</span> <span class="bp">?</span><span class="n">f0</span> <span class="bp">?</span><span class="n">fS</span>
  <span class="n">case</span> <span class="n">f0</span> <span class="bp">=&gt;</span>
    <span class="n">intro</span> <span class="n">a</span> <span class="n">Na</span>
    <span class="n">exact</span> <span class="n">addNatZeroComm</span> <span class="n">Na</span>
  <span class="n">case</span> <span class="n">fS</span> <span class="bp">=&gt;</span>
    <span class="n">intro</span> <span class="n">b</span> <span class="n">Nb</span> <span class="n">Anb_eq_Abn</span> <span class="n">a</span> <span class="n">Na</span>
    <span class="k">have</span> <span class="n">NSb</span> <span class="o">:=</span> <span class="n">natS</span> <span class="n">Nb</span>
    <span class="k">have</span> <span class="n">NAab</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">Na</span> <span class="n">Nb</span><span class="bp">;</span> <span class="k">have</span> <span class="n">NSAab</span> <span class="o">:=</span> <span class="n">natS</span> <span class="n">NAab</span><span class="bp">;</span>
    <span class="k">have</span> <span class="n">NAba</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">Nb</span> <span class="n">Na</span><span class="bp">;</span> <span class="k">have</span> <span class="n">NSAba</span> <span class="o">:=</span> <span class="n">natS</span> <span class="n">NAba</span>
    <span class="k">have</span> <span class="n">NASba</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">NSb</span> <span class="n">Na</span><span class="bp">;</span> <span class="k">have</span> <span class="n">NASab</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">Na</span> <span class="n">NSb</span>
    <span class="n">apply</span> <span class="n">eqNatLeftEuc</span> <span class="n">NSAab</span> <span class="n">NASab</span> <span class="n">NASba</span>
    <span class="n">exact</span> <span class="n">addNatSuccEqSucc</span> <span class="n">Na</span> <span class="n">Nb</span>
    <span class="n">apply</span> <span class="n">eqNatLeftEuc</span> <span class="n">NSAba</span> <span class="n">NASba</span> <span class="n">NSAab</span>
    <span class="n">exact</span> <span class="n">addSuccNatEqSucc</span> <span class="n">Nb</span> <span class="n">Na</span>
    <span class="n">apply</span> <span class="n">eqNatToEqSucc</span> <span class="n">NAab</span> <span class="n">NAba</span>
    <span class="n">exact</span> <span class="n">Anb_eq_Abn</span> <span class="n">a</span> <span class="n">Na</span>
</code></pre></div>
<p>I still think it needs some refinement, but I like the general structure (and notation).</p>



<a name="237073809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073809">(May 02 2021 at 19:03)</a>:</h4>
<p>I do want to try to automate the <code>nat</code> proofs though.</p>



<a name="237073911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073911">(May 02 2021 at 19:05)</a>:</h4>
<p>I'm not so sure about "readable in a vaccum" from this end</p>



<a name="237073947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073947">(May 02 2021 at 19:05)</a>:</h4>
<p>have/apply/exact is not a great recipe for proofs that can be read offline</p>



<a name="237073997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237073997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237073997">(May 02 2021 at 19:06)</a>:</h4>
<p>True</p>



<a name="237074013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074013">(May 02 2021 at 19:06)</a>:</h4>
<p>I do think my current orientation is more for reading in an editor sadly (with the goal info view).</p>



<a name="237074068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074068">(May 02 2021 at 19:07)</a>:</h4>
<p>My point here was mostly to demonstrate what I mean by making assumption/inference rules explicit</p>



<a name="237074148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074148">(May 02 2021 at 19:08)</a>:</h4>
<p>I think that part at least is readable in a vacuum.</p>



<a name="237074175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074175">(May 02 2021 at 19:08)</a>:</h4>
<p>I would have preferred to see the actual statements rather than <code>AddNatZeroComm</code></p>



<a name="237074469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074469">(May 02 2021 at 19:12)</a>:</h4>
<p>That's fair. My approach to that is one of things I want to fine. Though the actual statement approach can get a little verbose, and makes synthesizing derivative statements impossible (the reason they are written like this is to make them type classes).</p>



<a name="237074515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074515">(May 02 2021 at 19:12)</a>:</h4>
<p>why aren't they in square brackets then?</p>



<a name="237074590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074590">(May 02 2021 at 19:13)</a>:</h4>
<p>Because they aren't being synthesized.</p>



<a name="237074661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074661">(May 02 2021 at 19:14)</a>:</h4>
<p>I think that it would be better to just have a <code>#print axioms</code> like approach here, since listing the axioms on every theorem will get repetitive (for you and your readers)</p>



<a name="237074681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074681">(May 02 2021 at 19:14)</a>:</h4>
<p>just add the ability to query the axioms used by any theorem</p>



<a name="237074789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074789">(May 02 2021 at 19:15)</a>:</h4>
<p>That's fair. I just personally don't like that approach myself (though I will admit adding the axioms to every theorem can be tiresome).</p>



<a name="237074853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074853">(May 02 2021 at 19:16)</a>:</h4>
<p>For example, this <a href="http://us.metamath.org/mpeuni/ancom.html">metamath theorem</a> is a proof of commutativity of and, and in the axiom list it says it depends on ax-1, ax-2, ax-3, ax-mp, and definitions df-bi, df-an</p>



<a name="237074856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074856">(May 02 2021 at 19:16)</a>:</h4>
<p>Though, also, I am not sure how I would do that.</p>



<a name="237074907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074907">(May 02 2021 at 19:16)</a>:</h4>
<p>it's much easier for the computer to collect and organize this information, and it doesn't prevent the proof author from optimizing it</p>



<a name="237074958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237074958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237074958">(May 02 2021 at 19:17)</a>:</h4>
<p>In principle <code>#print axioms</code> does the same thing but because most of the DTT axioms aren't listed it has limited usefulness</p>



<a name="237075044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075044">(May 02 2021 at 19:18)</a>:</h4>
<p>I don't think Lean has a way of automatically inferring hypotheses though?</p>



<a name="237075066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075066">(May 02 2021 at 19:19)</a>:</h4>
<p>No, they aren't hypotheses here, just axioms/theorems</p>



<a name="237075082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075082">(May 02 2021 at 19:19)</a>:</h4>
<p>They are hypotheses.</p>



<a name="237075098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075098">(May 02 2021 at 19:19)</a>:</h4>
<p>In your version they are, but they can be set up as axioms</p>



<a name="237075108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075108">(May 02 2021 at 19:19)</a>:</h4>
<p>and then you can track the usage of those axioms</p>



<a name="237075120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075120">(May 02 2021 at 19:19)</a>:</h4>
<p>How so?</p>



<a name="237075165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075165">(May 02 2021 at 19:20)</a>:</h4>
<p>They are attached to a specific logic.</p>



<a name="237075191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075191">(May 02 2021 at 19:20)</a>:</h4>
<p>They don't hold in a vacuum</p>



<a name="237075194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075194">(May 02 2021 at 19:20)</a>:</h4>
<p>Yeah, the logic contains constructors for all the axioms</p>



<a name="237075205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075205">(May 02 2021 at 19:20)</a>:</h4>
<p>like the <code>proof</code> inductive I showed earlier</p>



<a name="237075208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075208">(May 02 2021 at 19:20)</a>:</h4>
<p>no it does not</p>



<a name="237075217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075217">(May 02 2021 at 19:20)</a>:</h4>
<p>Not in my system</p>



<a name="237075218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075218">(May 02 2021 at 19:20)</a>:</h4>
<p>which has a constructor for <code>mp</code></p>



<a name="237075236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075236">(May 02 2021 at 19:21)</a>:</h4>
<p>In fact, many of the inference rules I have cannot be written DTT.</p>



<a name="237075242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075242">(May 02 2021 at 19:21)</a>:</h4>
<p>??</p>



<a name="237075247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075247">(May 02 2021 at 19:21)</a>:</h4>
<p>as part of an inductive type</p>



<a name="237075276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075276">(May 02 2021 at 19:21)</a>:</h4>
<p>I don't believe you :P</p>



<a name="237075301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075301">(May 02 2021 at 19:21)</a>:</h4>
<p>For example by conditional proof, <code>((L |- p) -&gt; (L |- q)) -&gt; (L |- p -&gt; q)</code></p>



<a name="237075306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075306">(May 02 2021 at 19:22)</a>:</h4>
<p>That's fine</p>



<a name="237075352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075352">(May 02 2021 at 19:22)</a>:</h4>
<p>If L was an inductive type this could not be written like that.</p>



<a name="237075359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075359">(May 02 2021 at 19:22)</a>:</h4>
<p>well, actually it won't have the right effect</p>



<a name="237075376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075376">(May 02 2021 at 19:22)</a>:</h4>
<p>that's not how imp introduction works</p>



<a name="237075417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075417">(May 02 2021 at 19:23)</a>:</h4>
<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>



<a name="237075422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075422">(May 02 2021 at 19:23)</a>:</h4>
<p>Yes that is how conditional proof works (the mp was a typo).</p>



<a name="237075493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075493">(May 02 2021 at 19:24)</a>:</h4>
<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>



<a name="237075510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075510">(May 02 2021 at 19:24)</a>:</h4>
<p>basically you need the context to be an explicit part of the provability judgment</p>



<a name="237075534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075534">(May 02 2021 at 19:24)</a>:</h4>
<p>at least, if you want gentzen style imp introduction rules</p>



<a name="237075539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075539">(May 02 2021 at 19:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075417">said</a>:</p>
<blockquote>
<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>
</blockquote>
<p>What do you mean by this?</p>



<a name="237075568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075568">(May 02 2021 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493">said</a>:</p>
<blockquote>
<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>
</blockquote>
<p>I also don't know what that notation is meant to say.</p>



<a name="237075647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075647">(May 02 2021 at 19:26)</a>:</h4>
<p>Suppose <code>p</code> is neither provable nor disprovable. Then <code>L |- p</code> is false, so <code>L |- p -&gt; L |- false</code> is true, so <code>L |- (p -&gt; false)</code> by your proof rule and so <code>p</code> is provably false. Thus every statement is provable or disprovable in the logic</p>



<a name="237075722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075722">(May 02 2021 at 19:27)</a>:</h4>
<p>"Suppose <code> p</code> is neither provable nor disprovable." That would mean that neither <code>L |- p</code> or <code>(L |- p) -&gt; False</code> hold.</p>



<a name="237075803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075803">(May 02 2021 at 19:28)</a>:</h4>
<p>No, It means that <code>not (L |- p)</code> and <code>not (L |- not p)</code></p>



<a name="237075830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075830">(May 02 2021 at 19:29)</a>:</h4>
<p><code>L |- P</code> is not (necessarily) a Prop</p>



<a name="237075846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075846">(May 02 2021 at 19:29)</a>:</h4>
<p>doesn't really matter, use -&gt; False if you like</p>



<a name="237075848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075848">(May 02 2021 at 19:29)</a>:</h4>
<p><code>L |- not p</code> is not (necessarily) well-formed</p>



<a name="237075860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075860">(May 02 2021 at 19:29)</a>:</h4>
<p>That requires the language of L to have a <code>not</code></p>



<a name="237075927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075927">(May 02 2021 at 19:30)</a>:</h4>
<p>Okay... I am indeed making some bare minimum assumptions on the logic here</p>



<a name="237075966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075966">(May 02 2021 at 19:30)</a>:</h4>
<p>if the logic doesn't have a false then perhaps it's not inconsistent if only because you can't express it</p>



<a name="237075983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237075983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237075983">(May 02 2021 at 19:30)</a>:</h4>
<p>The logic is initially devoid of any rules and the prop is initially devoid of any syntax.</p>



<a name="237076106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076106">(May 02 2021 at 19:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075568">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493">said</a>:</p>
<blockquote>
<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>
</blockquote>
<p>I also don't know what that notation is meant to say.</p>
</blockquote>
<p>I'm not sure what L is, so let's add a context <code>G</code>, which is a list or set of formulas. The proof inductive is <code>L, G |- p</code>, and means that if we assume the formulas <code>G</code> then <code>p</code> follows. So in particular <code>L, G |- p</code> if <code>p \in G</code>. Then, the implication introduction rule is <code>(L, p::G |- q) -&gt; (L, G |- p -&gt; q)</code></p>



<a name="237076182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076182">(May 02 2021 at 19:33)</a>:</h4>
<p>But yes with conditional proof, if I have <code>(L |- p) -&gt; False</code> then <code>L |- p -&gt; q</code> for all <code>q</code>. I don't see why that is a problem.</p>



<a name="237076212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076212">(May 02 2021 at 19:34)</a>:</h4>
<p>Because you are lifting metalogical falsity into the logic</p>



<a name="237076286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076286">(May 02 2021 at 19:34)</a>:</h4>
<p>That says "if p is not provable then p is disprovable"</p>



<a name="237076299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076299">(May 02 2021 at 19:34)</a>:</h4>
<p>which is a very strong assumption</p>



<a name="237076351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076351">(May 02 2021 at 19:35)</a>:</h4>
<p>in particular it is false for PA and ZFC and every other reasonable first order logic</p>



<a name="237076358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076358">(May 02 2021 at 19:35)</a>:</h4>
<p>If one wants a weaker assumption, feel free to use a weaker rule. But that, at least, is how I view the conditional proof rule to work.</p>



<a name="237076705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076705">(May 02 2021 at 19:41)</a>:</h4>
<p>If I can prove that (L |- p) does not hold, I can with the law of excluded middle, prove (L |- ~p) in most FO logic.</p>



<a name="237076723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076723">(May 02 2021 at 19:41)</a>:</h4>
<p>The proof that L |- p does not hold is happening in the metalogic here</p>



<a name="237076758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076758">(May 02 2021 at 19:42)</a>:</h4>
<p>for example, Godel's unprovable sentence</p>



<a name="237076777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076777">(May 02 2021 at 19:42)</a>:</h4>
<p>It's not that the logic proves <code>not p</code></p>



<a name="237076807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076807">(May 02 2021 at 19:42)</a>:</h4>
<p>it is that the metalogic proves that <code>L |- p</code> is false, i.e. axiom system L does not prove p</p>



<a name="237076826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076826">(May 02 2021 at 19:43)</a>:</h4>
<p>the law of excluded middle says <code>L |- (p \/ ~p)</code></p>



<a name="237076832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076832">(May 02 2021 at 19:43)</a>:</h4>
<p>Incompleteness would be ((L |- p) \/ (L |- ~p) -&gt; False), right? Not for a given p, (L |- p) -&gt; False, correct?</p>



<a name="237076911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076911">(May 02 2021 at 19:44)</a>:</h4>
<p>Yes. The first one says <code>p</code> is independent, and the second one says that <code>p</code> is not provable</p>



<a name="237076923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076923">(May 02 2021 at 19:44)</a>:</h4>
<p>independent just means that neither <code>p</code> nor <code>not p</code> is provable</p>



<a name="237076962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237076962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237076962">(May 02 2021 at 19:45)</a>:</h4>
<p>but your axiom is essentially declaring that there are no independent sentences, which is also known as (syntactic) completeness</p>



<a name="237077079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077079">(May 02 2021 at 19:47)</a>:</h4>
<p>So it is saying that it implies that independence implies inconsistency, right?</p>



<a name="237077082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077082">(May 02 2021 at 19:47)</a>:</h4>
<p>and Godel proved that such a system is inconsistent if it can handle basic arithmetic</p>



<a name="237077124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077124">(May 02 2021 at 19:47)</a>:</h4>
<p>Well, that is only true if the logical also includes FOL</p>



<a name="237077130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077130">(May 02 2021 at 19:47)</a>:</h4>
<p>yes</p>



<a name="237077146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077146">(May 02 2021 at 19:47)</a>:</h4>
<p>If the metalogic is FOL (or DTT i.e. Lean), and the logic is just arithmatic that does not hold.</p>



<a name="237077188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077188">(May 02 2021 at 19:48)</a>:</h4>
<p>there are complete axiom systems that are not strong enough for basic arithmetic</p>



<a name="237077213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077213">(May 02 2021 at 19:48)</a>:</h4>
<p>but if it is strong enough to run godel's argument then it is inconsistent</p>



<a name="237077348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077348">(May 02 2021 at 19:51)</a>:</h4>
<p>take a look at <a href="https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem">https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem</a> to see whether your logic is weak enough; as long as it doesn't have FOL quantifiers or multiplication isn't total or something like that you might be able to get out of the issue</p>



<a name="237077356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077356">(May 02 2021 at 19:51)</a>:</h4>
<p>My point is that if you split the logic you can avoid that in many cases. For example, my fragment of PA is complete because only the equations and nat membership are statements in the logic. (It lacks quantifiers and propositional logical.)</p>



<a name="237077369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077369">(May 02 2021 at 19:51)</a>:</h4>
<p>Because all that is handled by the metalogic.</p>



<a name="237077388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077388">(May 02 2021 at 19:52)</a>:</h4>
<p>If there are no quantifiers, then just have "all true sentences" as your axiom system and this is complete (and decidable)</p>



<a name="237077449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077449">(May 02 2021 at 19:52)</a>:</h4>
<p>Exactly</p>



<a name="237077487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077487">(May 02 2021 at 19:53)</a>:</h4>
<p>in that case the <code>L |- </code> is just window dressing though</p>



<a name="237077509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077509">(May 02 2021 at 19:54)</a>:</h4>
<p>How so?</p>



<a name="237077550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077550">(May 02 2021 at 19:54)</a>:</h4>
<p>you can prove <code>L |- x = y &lt;-&gt; eval x = eval y</code> more or less</p>



<a name="237077595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077595">(May 02 2021 at 19:55)</a>:</h4>
<p>Well I might not be able to evaluate x and y in the metalogic though by default.</p>



<a name="237077620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077620">(May 02 2021 at 19:55)</a>:</h4>
<p>that's what I mean when I say it's decidable</p>



<a name="237077628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077628">(May 02 2021 at 19:55)</a>:</h4>
<p>you can just lift the expressions into the metalogic</p>



<a name="237077654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077654">(May 02 2021 at 19:56)</a>:</h4>
<p>you need some assumptions about plus and times</p>



<a name="237077687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077687">(May 02 2021 at 19:56)</a>:</h4>
<p>but the ones in your sample proof should be close to all you need</p>



<a name="237077729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077729">(May 02 2021 at 19:57)</a>:</h4>
<p>Wait, but L is only a subset of the things provable in the metalogic.</p>



<a name="237077741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077741">(May 02 2021 at 19:57)</a>:</h4>
<p>You will need to assume L is consistent for the reverse implication</p>



<a name="237077788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077788">(May 02 2021 at 19:58)</a>:</h4>
<p>like if I have (L |- 3 = 2) that does not mean that 3 = 2 in the metalogic.</p>



<a name="237077792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077792">(May 02 2021 at 19:58)</a>:</h4>
<p>It does, if L is consistent</p>



<a name="237077809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077809">(May 02 2021 at 19:58)</a>:</h4>
<p>no it doesn't</p>



<a name="237077817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077817">(May 02 2021 at 19:58)</a>:</h4>
<p>you might need something equivalent to not equal or less than in the logic</p>



<a name="237077820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077820">(May 02 2021 at 19:58)</a>:</h4>
<p>If I literally I have one axiom in I L, i.e L |- 3 = 2, that does not prove anything about 3 = 2 in the metalogic.</p>



<a name="237077836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077836">(May 02 2021 at 19:59)</a>:</h4>
<p>normally you would be able to combine that with other axioms of L to prove L is inconsistent</p>



<a name="237077841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077841">(May 02 2021 at 19:59)</a>:</h4>
<p>so if L is consistent then 3 = 2</p>



<a name="237077851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077851">(May 02 2021 at 19:59)</a>:</h4>
<p>consistency does not prove anything about the metalogic.</p>



<a name="237077933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077933">(May 02 2021 at 20:00)</a>:</h4>
<p>All consistency says is the ((p : P) -&gt; (L |- p) /\ (L |- ~p)  -&gt; False)</p>



<a name="237077990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237077990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237077990">(May 02 2021 at 20:01)</a>:</h4>
<p>If L is consistent, and L |- 3 = 2, then (by using other axioms) L |- False and so L is inconsistent, contradiction, thus 3 = 2</p>



<a name="237078016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078016">(May 02 2021 at 20:01)</a>:</h4>
<p>I'm assuming here that L is enough like PA that we can prove that L |- 3 != 2</p>



<a name="237078031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078031">(May 02 2021 at 20:02)</a>:</h4>
<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>



<a name="237078144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078144">(May 02 2021 at 20:03)</a>:</h4>
<p>You can use PA's other axioms to prove that 3 != 2</p>



<a name="237078180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078180">(May 02 2021 at 20:03)</a>:</h4>
<p>I am not talking about PA, I am just talking about some  random logic L</p>



<a name="237078196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078196">(May 02 2021 at 20:04)</a>:</h4>
<p>I'm talking about a random logic L with enough structure to run these arguments</p>



<a name="237078257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078257">(May 02 2021 at 20:04)</a>:</h4>
<p>That is sufficient structure.</p>



<a name="237078263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078263">(May 02 2021 at 20:04)</a>:</h4>
<p>A logic can be empty, it does not need proposition or rules.</p>



<a name="237078277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078277">(May 02 2021 at 20:05)</a>:</h4>
<p>Okay but then you can't prove anything about it</p>



<a name="237078293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078293">(May 02 2021 at 20:05)</a>:</h4>
<p>your earlier example had loads of assumptions about the logic</p>



<a name="237078305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078305">(May 02 2021 at 20:05)</a>:</h4>
<p>I'm using those assumptions, more or less</p>



<a name="237078308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078308">(May 02 2021 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078031">said</a>:</p>
<blockquote>
<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>
</blockquote>
<p>The logic here is a valid logic with 2 propositions and 1 axiom and is complete and consistent.</p>



<a name="237078311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078311">(May 02 2021 at 20:05)</a>:</h4>
<p>yes</p>



<a name="237078377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078377">(May 02 2021 at 20:06)</a>:</h4>
<p>I'm talking about a logic with at least <code>x + 0 = x</code> and <code>x + s y = s (x+y)</code></p>



<a name="237078384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078384">(May 02 2021 at 20:06)</a>:</h4>
<p>Yeah but the PA fragment used to prove the semiring properities doesn't even need negation.</p>



<a name="237078395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078395">(May 02 2021 at 20:06)</a>:</h4>
<p>So it is trivially consistent</p>



<a name="237078413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078413">(May 02 2021 at 20:06)</a>:</h4>
<p>If you add 3 = 2 to such a theory then you will get <code>x = y</code> for all x, y</p>



<a name="237078421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078421">(May 02 2021 at 20:06)</a>:</h4>
<p>which is the nearest equivalent to inconsistency</p>



<a name="237078469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078469">(May 02 2021 at 20:07)</a>:</h4>
<p>Yes, if you add that to axiom list</p>



<a name="237078470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078470">(May 02 2021 at 20:07)</a>:</h4>
<p>so if we assume that it is not inconsistent in that sense, then we will indeed have <code>L |- x = y -&gt; eval x = eval y</code></p>



<a name="237078531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078531">(May 02 2021 at 20:08)</a>:</h4>
<p>and the converse is trivial by reflexivity</p>



<a name="237078572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078572">(May 02 2021 at 20:08)</a>:</h4>
<p>actually no, L |- S 0 = 1 in PA, but S 0 = 1 is not true in the metalogic (Lean).</p>



<a name="237078581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078581">(May 02 2021 at 20:08)</a>:</h4>
<p><code>eval x = eval y</code></p>



<a name="237078598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078598">(May 02 2021 at 20:09)</a>:</h4>
<p>there is no eval (S 0) in the metalogic.</p>



<a name="237078599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078599">(May 02 2021 at 20:09)</a>:</h4>
<p>the right side equality is equality in <code>Nat</code></p>



<a name="237078605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078605">(May 02 2021 at 20:09)</a>:</h4>
<p>there is, it's pretty easy to define</p>



<a name="237078613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078613">(May 02 2021 at 20:09)</a>:</h4>
<p>Yes, if I define S and 0 and 1 as there Nat counterparts true.</p>



<a name="237078668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078668">(May 02 2021 at 20:10)</a>:</h4>
<p>but if I define them all as separate terms, then no.</p>



<a name="237078672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078672">(May 02 2021 at 20:10)</a>:</h4>
<p>the idea here is to turn any provability question <code>L |- x = y</code> into a statement <code>eval x = eval y</code> that we can just evaluate in lean</p>



<a name="237078702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078702">(May 02 2021 at 20:10)</a>:</h4>
<p>i.e.</p>
<div class="codehilite" data-code-language="lean4"><pre><span></span><code>inductive term
| zero : term
| one  : term
| succ : term -&gt; term
</code></pre></div>



<a name="237078728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078728">(May 02 2021 at 20:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">term.zero</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">term.one</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">term.succ</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">eval</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>



<a name="237078789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078789">(May 02 2021 at 20:12)</a>:</h4>
<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>



<a name="237078812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237078812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237078812">(May 02 2021 at 20:12)</a>:</h4>
<p>Mario, your <code>eval</code> is not injective</p>



<a name="237082713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/associativity%20of%20%60%E2%86%94%60/near/237082713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60.html#237082713">(May 02 2021 at 21:02)</a>:</h4>
<p>This topic was moved by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> to <a class="stream-topic" data-stream-id="236446" href="/#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204">#Type theory &gt; Metamathematics in lean 4</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
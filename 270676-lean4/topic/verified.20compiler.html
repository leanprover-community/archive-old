---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/verified.20compiler.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html">verified compiler</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272033791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272033791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272033791">(Feb 15 2022 at 20:32)</a>:</h4>
<p>What would it mean to have a verified Lean 4 compiler? What is there to be proved in such context?</p>



<a name="272034611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272034611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Taucher <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272034611">(Feb 15 2022 at 20:39)</a>:</h4>
<p><a href="https://compcert.org/">CompCert</a></p>



<a name="272034867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272034867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Taucher <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272034867">(Feb 15 2022 at 20:41)</a>:</h4>
<p>You might also like the <a href="https://en.wikipedia.org/wiki/Rainbow_Series">Rainbow Series</a> I have not herd of them being referenced much any more but the basic ideas still hold true.</p>



<a name="272036006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272036006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272036006">(Feb 15 2022 at 20:51)</a>:</h4>
<blockquote>
<p>Semantic preservation ‍ The formal verification of CompCert consists in proving the following theorem, which we take as the high-level specification of a correct compiler:</p>
</blockquote>
<blockquote>
<p>Semantic preservation theorem:<br>
For all source programs ‍S and compiler-generated code ‍C,<br>
if the compiler, applied to the source S, produces the code C,<br>
without reporting a compile-time error,<br>
then the observable behavior of C improves on one of the allowed observable behaviors of ‍S.</p>
</blockquote>
<p>Then it says:</p>
<blockquote>
<p>Second, the compiler is allowed to select one of the possible behaviors of the source program. The ‍C language has some nondeterminism in expression evaluation order; different orders can result in several different observable behaviors. By choosing an evaluation order of its liking, the compiler implements one of these valid observable behaviors.</p>
</blockquote>
<p>So there must be a formal description of "observable behavior". What would be a practical example for a Lean 4 compiler?</p>



<a name="272036622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272036622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272036622">(Feb 15 2022 at 20:56)</a>:</h4>
<p>For Lean 4's IR, <a href="https://leanprover.github.io/papers/beans_appendix.pdf">the appendix of Counting Immutable Beans</a> may be of interest</p>



<a name="272036739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272036739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272036739">(Feb 15 2022 at 20:57)</a>:</h4>
<p>But note that this is really just one step in the compilation pipeline</p>



<a name="272036747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272036747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272036747">(Feb 15 2022 at 20:57)</a>:</h4>
<p>I personally believe it would be quite hard to verify the entire lean compiler, you can certainly prove stuff about parts of it like e.g. the linked counting beans proof but due do its self extending nature anyone can basically add more to the lean semantics as they wish. SO even if we proved a certain compiler correct it would not be <em>that</em> useful in reality I think</p>



<a name="272036908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272036908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272036908">(Feb 15 2022 at 20:58)</a>:</h4>
<p>But I'm certainly not a compiler verification person so maybe I'm totally wrong on this,</p>



<a name="272037399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272037399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272037399">(Feb 15 2022 at 21:02)</a>:</h4>
<p>... FWIW I spent more or less my entire BSc thesis formalizing only theorem 9 in that appendix, and I didn't quite finish the proof entirely :-)<br>
Lean 3 has progressed quite a bit since then, though.</p>



<a name="272037493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272037493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272037493">(Feb 15 2022 at 21:02)</a>:</h4>
<p>Huh I did conside donig that as an exercise but seems like it's much harder than expected, thanks for warning me :p</p>



<a name="272037761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272037761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272037761">(Feb 15 2022 at 21:04)</a>:</h4>
<p>I learned Lean with that project, so it's likely that you'll do much better than me.</p>



<a name="272038359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272038359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272038359">(Feb 15 2022 at 21:08)</a>:</h4>
<p>I see, thanks for the input everyone <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="272038885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272038885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272038885">(Feb 15 2022 at 21:12)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Yes, it would be hard to verify the entire Lean compiler. BTW, for me "compiler" is referring to the Lean code generator that converts kernel terms/declarations into executable code. </p>
<blockquote>
<p>its self extending nature anyone can basically add more to the lean semantics as they wish.</p>
</blockquote>
<p>The kernel terms/declarations are fixed, we have no plans to extend them, and users cannot extend the kernel.<br>
All user notations and extensions can be viewed as syntax sugar for the actual terms/declarations that are accepted by the kernel.</p>



<a name="272045447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272045447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272045447">(Feb 15 2022 at 22:10)</a>:</h4>
<p>The book "Program Logics for Certified Compilers" might also be of interest. There's a chapter called "how to specify a compiler", and a section on the operational semantics and memory model of compcert.</p>



<a name="272045669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272045669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272045669">(Feb 15 2022 at 22:12)</a>:</h4>
<p>I think it's kind of expensive, but if you have access to a university library system it's available online through the Cambridge University Press.</p>



<a name="272084681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272084681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrés Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272084681">(Feb 16 2022 at 08:14)</a>:</h4>
<p>it would be pretty neat though, if Lean would be verified in itself it would be taking "bootstrapping" for compilers to a new level <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="272085057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272085057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272085057">(Feb 16 2022 at 08:19)</a>:</h4>
<p>Maybe not lean itself, but perhaps a <a href="https://github.com/digama0/mm0">simpler language, designed for the purpose...</a> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="272092422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272092422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Taucher <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272092422">(Feb 16 2022 at 09:38)</a>:</h4>
<p>"Program Logics for Certified Compilers" (<a href="https://www.cs.princeton.edu/~appel/papers/plcc.pdf">pdf</a>) is free from Andrew Appel's Princeton U. web page.</p>



<a name="272095985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272095985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272095985">(Feb 16 2022 at 10:11)</a>:</h4>
<p>On the topic of formally verified compilers for dependently typed languages, you might want to take a look at <a href="http://certicoq.org">certicoq.org</a>. That project seeks to provide verified extraction from Coq to C. It uses the compcert C semantics, which means you get an "end to end" correctness property when using CertiCoq to generate the C code and compcert to compile it.</p>



<a name="272096156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272096156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272096156">(Feb 16 2022 at 10:13)</a>:</h4>
<p>With regards to bootstrapping, the current leader is probably CakeML, which provides a robust foundation for the Isabelle ecosystem</p>



<a name="272097602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/verified%20compiler/near/272097602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Carstens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/verified.20compiler.html#272097602">(Feb 16 2022 at 10:27)</a>:</h4>
<p>In terms of porting Appel's framework to Lean, this is something Patrick Stach and I were heavily investing in circa Lean 2. We were targeting C++, not C, but we did manage to get some nontrivial stuff done (full port of indirection theory, full representation of C++ AST, tooling for getting the AST out of clang and into Lean, etc)</p>
<p>One amusing anecdote: at the time, the checker for inductive type definitions did not scale extremely well. This made it hard for us to prototype our AST representation for C++. To make life easier, Stach wrote some tooling to generate the inductive type definitions based on a less verbose syntax. It made things go smoother so he called it "vaso-lean" Thankfully these perf issues are long since a thing of the past</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Style.20for.20using.20external.20code.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html">Style for using external code</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247891292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247891292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xubai Wang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247891292">(Aug 02 2021 at 03:44)</a>:</h4>
<p>I'm going to add a Lean wrapper for the C++ Poco Library. After exploration, I find there are 3 styles of using external code in Lean 4:</p>
<ol>
<li><code>@[extern] constant</code> and <code>register_external_class</code>:</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">FS.Handle</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Unit</span>

<span class="kd">@[extern "lean_io_prim_handle_mk"]</span>
<span class="kd">constant</span> <span class="n">Handle.mk</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">mode</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Handle</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">_</span>
</code></pre></div>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">void</span> <span class="nf">initialize_io</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">g_io_error_nullptr_read</span> <span class="o">=</span> <span class="n">mk_string</span><span class="p">(</span><span class="s">"null reference read"</span><span class="p">);</span>
    <span class="n">mark_persistent</span><span class="p">(</span><span class="n">g_io_error_nullptr_read</span><span class="p">);</span>
    <span class="n">g_io_handle_external_class</span> <span class="o">=</span> <span class="n">lean_register_external_class</span><span class="p">(</span><span class="n">io_handle_finalizer</span><span class="p">,</span> <span class="n">io_handle_foreach</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">obj_res</span> <span class="n">lean_io_prim_handle_mk</span><span class="p">(</span><span class="n">b_obj_arg</span> <span class="n">filename</span><span class="p">,</span> <span class="n">b_obj_arg</span> <span class="n">modeStr</span><span class="p">,</span> <span class="n">obj_arg</span> <span class="cm">/* w */</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">lean_string_cstr</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">lean_string_cstr</span><span class="p">(</span><span class="n">modeStr</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">set_io_error</span><span class="p">(</span><span class="n">decode_io_error</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="n">filename</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">set_io_result</span><span class="p">(</span><span class="n">io_wrap_handle</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[extern "lean_string_hash"]</span>
<span class="kn">protected</span> <span class="kd">constant</span> <span class="n">String.hash</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">USize</span> <span class="o">:=</span> <span class="n">arbitrary</span> <span class="n">_</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Hashable</span> <span class="n">String</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">String.hash</span><span class="o">⟩</span>
</code></pre></div>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="kt">size_t</span> <span class="nf">lean_string_hash</span><span class="p">(</span><span class="n">b_lean_obj_arg</span><span class="p">);</span>
</code></pre></div>
<ol start="2">
<li><code>@[extern] def</code></li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[extern "lean_nat_add"]</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">Nat.add</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@&amp;</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">@&amp;</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">Nat.zero</span>   <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">Nat.succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="k">static</span> <span class="kr">inline</span> <span class="n">lean_obj_res</span> <span class="nf">lean_nat_add</span><span class="p">(</span><span class="n">b_lean_obj_arg</span> <span class="n">a1</span><span class="p">,</span> <span class="n">b_lean_obj_arg</span> <span class="n">a2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LEAN_LIKELY</span><span class="p">(</span><span class="n">lean_is_scalar</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lean_is_scalar</span><span class="p">(</span><span class="n">a2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">lean_usize_to_nat</span><span class="p">(</span><span class="n">lean_unbox</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="n">lean_unbox</span><span class="p">(</span><span class="n">a2</span><span class="p">));</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">lean_nat_big_add</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ol start="3">
<li><code>lean_ctor_get|set</code></li>
</ol>
<p>This style is taken from <span class="user-mention" data-user-id="315577">@Mac</span> 's <a href="https://github.com/tydeu/lean4-papyrus/blob/master/c/include/papyrus_ffi.h">lean4-papyrus</a></p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="c1">// Wrap a pointer in a linked pointer object, transfering ownership to of it to Lean.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">lean_object</span><span class="o">*</span> <span class="n">mkLinkedOwnedPtr</span><span class="p">(</span><span class="n">b_lean_obj_arg</span> <span class="n">link</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lean_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">lean_alloc_ctor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">lean_ctor_set</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
    <span class="n">lean_ctor_set</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mkOwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>What's the actual difference of <code>@[extern] constant</code> and <code>@[extern] def</code>? And when should we use the <code>lean_ctor_get|set</code> style?</p>



<a name="247891689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247891689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xubai Wang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247891689">(Aug 02 2021 at 04:03)</a>:</h4>
<p>There is also confusion on the type of C++ return value.<br>
It seems that C++ <code>uint64_t</code> can automatically convert to Lean's <code>UInt64</code>. And <code>lean_box()</code> can be used as many different types.<br>
And in <a href="https://github.com/tydeu/lean4-papyrus/blob/a71184e984e0dd4dbad93d44c0a2ace8cf1706b1/c/src/execution_engine.cpp">lean4-papyrus</a>,  the <code>indutive</code> can be used as <code>uint8</code> after annotated with <code>@attribute [unbox]</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">EngineKind</span>
<span class="bp">|</span> <span class="n">Either</span>
<span class="bp">|</span> <span class="n">JIT</span>
<span class="bp">|</span> <span class="n">Interpreter</span>
<span class="n">deriving</span> <span class="n">BEq</span><span class="o">,</span> <span class="n">Rec</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">unbox</span><span class="o">]</span> <span class="n">EngineKind</span>

<span class="kd">@[extern "papyrus_execution_engine_create_for_module"]</span>
<span class="kd">constant</span> <span class="n">createForModule</span> <span class="o">(</span><span class="n">mod</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">ModuleRef</span><span class="o">)</span> <span class="o">(</span><span class="n">kind</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">EngineKind</span> <span class="o">:=</span> <span class="n">EngineKind.Either</span><span class="o">)</span>
  <span class="o">(</span><span class="n">march</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">String</span> <span class="o">:=</span> <span class="s2">""</span><span class="o">)</span> <span class="o">(</span><span class="n">mcpu</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">String</span> <span class="o">:=</span> <span class="s2">""</span><span class="o">)</span> <span class="o">(</span><span class="n">mattrs</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">Array</span> <span class="n">String</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[])</span>
  <span class="o">(</span><span class="n">optLevel</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">OptLevel</span> <span class="o">:=</span> <span class="n">OptLevel.Default</span><span class="o">)</span> <span class="o">(</span><span class="n">verifyModule</span> <span class="o">:=</span> <span class="n">false</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">IO</span> <span class="n">ExecutionEngineRef</span>
</code></pre></div>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="k">extern</span> <span class="s">"C"</span> <span class="n">obj_res</span> <span class="n">papyrus_execution_engine_create_for_module</span>
<span class="p">(</span><span class="n">b_obj_arg</span> <span class="n">modObj</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">kindObj</span><span class="p">,</span> <span class="n">b_obj_arg</span> <span class="n">marchStr</span><span class="p">,</span> <span class="n">b_obj_arg</span> <span class="n">mcpuStr</span><span class="p">,</span>
  <span class="n">b_obj_arg</span> <span class="n">mattrsObj</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">optLevel</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">verifyModules</span><span class="p">,</span> <span class="n">obj_arg</span> <span class="cm">/* w */</span><span class="p">)</span>
</code></pre></div>



<a name="247892832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247892832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247892832">(Aug 02 2021 at 04:57)</a>:</h4>
<blockquote>
<p>What's the actual difference of <code>@[extern foo] constant</code> and <code>@[extern foo] def</code>?</p>
</blockquote>
<p>There should be no difference in the generated C code -- both will be calls to <code>foo</code>. There is a difference, however, in the kernel declaration emitted. <code>constant</code>s are opaque to the kernel, while <code>def</code>s can be unfolded, and you can generally prove things about them. Using <code>@[extern] def</code> has some pitfalls in that if your <code>extern</code> code does not match the <code>def</code> definition, the compiled code may not do what you think it should do.</p>



<a name="247892893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247892893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247892893">(Aug 02 2021 at 05:00)</a>:</h4>
<blockquote>
<p>And when should we use the <code>lean_ctor_get|set</code> style?</p>
</blockquote>
<p>I wouldn't say this is a separate style from the other ones. The <code>lean_ctor_*</code> family allows you to construct non-primitive Lean objects. You could use it to construct an object returned from an <code>@[extern] constant</code>, but that object could well also store an <code>external_class</code> as one of its fields.</p>



<a name="247893082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247893082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247893082">(Aug 02 2021 at 05:06)</a>:</h4>
<blockquote>
<p>It seems that C++ <code>uint64_t</code> can automatically convert to Lean's <code>UInt64</code>. And <code>lean_box()</code> can be used as many different types.</p>
</blockquote>
<p>Yes. <code>UInt64</code> is a <em>primitive</em> type which means it compiles directly to C <code>uint64_t</code>. You can find a list of the compiled types <a href="https://github.com/leanprover/lean4/blob/45b599ef69a6afc090de8670f00f69c903044bc8/src/Lean/Compiler/IR/EmitC.lean#L55">here</a>. As you can see, some types are represented directly, but most others (such as <code>inductive</code>s) are <code>lean_object</code>s whose types are <em>erased</em> in the compiled code. Hence why <code>lean_ctor_*</code> and <code>lean_box</code> can construct many different types.</p>



<a name="247893194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247893194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247893194">(Aug 02 2021 at 05:13)</a>:</h4>
<blockquote>
<p>And in lean4-papyrus, the <code>inductive</code> can be used as <code>uint8</code> after annotated with <code>@attribute [unbox]</code></p>
</blockquote>
<p>Oh, cool, I didn't know you could do that :)</p>



<a name="247899930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247899930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247899930">(Aug 02 2021 at 08:25)</a>:</h4>
<p>I'm pretty sure <code>[unbox]</code> currently is a no-op</p>



<a name="247930976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247930976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247930976">(Aug 02 2021 at 15:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>  is right, the unbox is a no-op. However, I put that attribute on it to make it clear the inductive is, in fact, unboxed (and to keep it that way if something in the core ever changes).</p>



<a name="247933646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Style%20for%20using%20external%20code/near/247933646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Style.20for.20using.20external.20code.html#247933646">(Aug 02 2021 at 15:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="128280">Wojciech Nawrocki</span> <a href="#narrow/stream/270676-lean4/topic/Style.20for.20using.20external.20code/near/247892893">said</a>:</p>
<blockquote>
<blockquote>
<p>And when should we use the <code>lean_ctor_get|set</code> style?</p>
</blockquote>
<p>I wouldn't say this is a separate style from the other ones. The <code>lean_ctor_*</code> family allows you to construct non-primitive Lean objects. You could use it to construct an object returned from an <code>@[extern] constant</code>, but that object could well also store an <code>external_class</code> as one of its fields.</p>
</blockquote>
<p>To add onto this, the advantage of non-external class objects is that they are memory managed by Lean. I take advantage of this in Papyrus's <code>LinkedOwnedPtr</code>, which <span class="user-mention" data-user-id="414345">@Xubai Wang</span>  mentioned.  </p>
<p>In particular, <code>LinkedOwnedPtr</code> is a special case of <code>LinkedPtr</code>, which is just a  <code>LinkedPtrImpl</code> -- a normal structure consisting of a <code>link</code> (a normal lean object) and a <code>ExternalPtr</code> (a<code>lean_external_object</code>). I, however, hide this detail by making <code>LinkedPtr</code> a <code>constant</code>. This prevents users from unfolding a <code>LinkedPtr</code> into a <code>LinkedPtrImpl</code> -- doing so would allow them to gaining access to the raw <code>ExternalPtr</code>, which can cause memory unsafety. This is because the <code>link</code> of a <code>LinkedPtr</code> is not supposed to be garbage collected before the <code>LinkedPtr</code> as the <code>ExternalPtr</code> expects the <code>link</code> to remain alive in its C code. If a user were to access the <code>ExternalPtr</code> directly and keep a reference to it while dropping its reference to the <code>LinkedPtr</code>, the <code>link</code> would be garbage collected, breaking the C bindings for the <code>ExternalPtr</code>.</p>
<p>Alternatively, this could be solved by having the <code>link</code> be contained within the <code>lean_external_object</code> itself (which <code>lean-llvm</code> does in its FFI). However, I choose to avoid this approach because I feel keeping as little data external to Lean as possible is idea. In particular, this makes it so the external object's finalizer and foreach are very simple and don't have to worry about the reference count of the <code>link</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html">Java AST in Lean4</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="251497351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251497351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251497351">(Sep 01 2021 at 04:12)</a>:</h4>
<p>What's the laziest way I can get a Java AST in Lean4?</p>



<a name="251498192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251498192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251498192">(Sep 01 2021 at 04:22)</a>:</h4>
<p>Have a java parser and print out the ast in s expressions or json or something</p>



<a name="251498383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251498383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251498383">(Sep 01 2021 at 04:25)</a>:</h4>
<p>Or write a java parser yourself in lean 4</p>



<a name="251584135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251584135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Kent <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251584135">(Sep 01 2021 at 16:01)</a>:</h4>
<p>I'm not sure what the laziest way is per se, but if you are wanting to define some types to represent the AST, the <a href="https://docs.oracle.com/javase/specs/jls/se16/html/index.html">Java Language Specification</a> isn't the worst document to work from at least.</p>
<p>If you're wanting a parser... these <a href="https://github.com/antlr/grammars-v4/tree/master/java">ANTLR Java grammars</a> might be a helpful starting point. I don't recall if in Java you have to interleave parsing with type checking and other analyses (like you do for C or C++)... hopefully not... since that is an absolute nightmare to get right.</p>



<a name="251590859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251590859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251590859">(Sep 01 2021 at 16:43)</a>:</h4>
<p>I'm trying out the lean4 <code>syntax</code> stuff, but I'm not sure how to solve something:</p>
<p>I have the following setup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"java"</span> <span class="s2">"{"</span> <span class="n">java_file</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">syntax</span> <span class="o">(</span><span class="n">pkg_decl</span><span class="o">)</span><span class="bp">?</span> <span class="n">import_decl</span><span class="bp">*</span> <span class="n">ty_decl</span><span class="bp">*</span> <span class="o">:</span> <span class="n">java_file</span>
<span class="n">syntax</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">"."</span> <span class="n">ident</span><span class="o">)</span><span class="bp">*</span> <span class="o">:</span> <span class="n">q_name</span>
<span class="n">syntax</span> <span class="s2">"package"</span> <span class="n">q_name</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">pkg_decl</span>
<span class="n">syntax</span> <span class="s2">"import"</span> <span class="o">(</span><span class="n">ident</span> <span class="s2">"."</span><span class="o">)</span><span class="bp">+</span> <span class="o">(</span><span class="s2">"*"</span> <span class="bp">&lt;|&gt;</span> <span class="n">ident</span><span class="o">)</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">import_decl</span>
<span class="n">syntax</span> <span class="s2">"public"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"protected"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"private"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"abstract"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"static"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"final"</span> <span class="o">:</span> <span class="n">modifier</span>
<span class="n">syntax</span> <span class="n">modifier</span><span class="bp">*</span> <span class="s2">"class"</span> <span class="n">ident</span> <span class="n">noWs</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="n">ty_super</span><span class="o">)</span><span class="bp">?</span> <span class="n">class_body</span> <span class="o">:</span> <span class="n">ty_decl</span>
<span class="n">syntax</span> <span class="s2">"&lt;"</span> <span class="o">(</span><span class="n">ident</span> <span class="o">(</span><span class="n">ty_super</span><span class="o">)</span><span class="bp">?</span><span class="o">),</span><span class="bp">*</span> <span class="s2">"&gt;"</span> <span class="o">:</span> <span class="n">ty_params</span>
<span class="n">syntax</span> <span class="s2">"&lt;"</span> <span class="o">(</span><span class="n">ty_ref</span><span class="o">),</span><span class="bp">*</span> <span class="s2">"&gt;"</span> <span class="o">:</span> <span class="n">ty_args</span>
<span class="n">syntax</span> <span class="o">(</span><span class="s2">"extends"</span> <span class="n">ty_ref</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="s2">"implements"</span> <span class="n">ty_ref</span><span class="o">,</span><span class="bp">*</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_super</span>
<span class="n">syntax</span> <span class="n">q_name</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_ref</span>
<span class="n">syntax</span> <span class="s2">"{"</span> <span class="n">class_body_decl</span><span class="bp">*</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">class_body</span>
<span class="n">syntax</span> <span class="n">modifier</span><span class="bp">*</span> <span class="o">(</span><span class="n">field_decl</span> <span class="bp">&lt;|&gt;</span> <span class="n">ctor_or_method_decl</span><span class="o">)</span> <span class="o">:</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">"="</span> <span class="n">expr</span><span class="o">)</span><span class="bp">?</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">field_decl</span>
<span class="n">syntax</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="n">ty_ret</span><span class="o">)</span><span class="bp">?</span> <span class="n">ident</span> <span class="n">params</span> <span class="o">(</span><span class="n">ty_throws</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ctor_or_method_decl</span>
<span class="n">syntax</span> <span class="s2">"void"</span> <span class="bp">&lt;|&gt;</span> <span class="n">ty</span> <span class="o">:</span> <span class="n">ty_ret</span>
<span class="n">syntax</span> <span class="s2">"("</span> <span class="n">param</span><span class="o">,</span><span class="bp">*</span> <span class="s2">")"</span> <span class="o">:</span> <span class="n">params</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="n">ident</span> <span class="o">:</span> <span class="n">param</span>
<span class="n">syntax</span> <span class="s2">"throws"</span> <span class="n">ty_ref</span><span class="o">,</span><span class="bp">+</span> <span class="o">:</span> <span class="n">ty_throws</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">:=</span> <span class="n">java</span> <span class="o">{</span>
  <span class="n">package</span> <span class="n">org.stnreu001.csc2002s</span><span class="bp">;</span>
  <span class="kn">import</span> <span class="n">java.util.</span><span class="bp">*;</span>

  <span class="n">public</span> <span class="kd">class</span> <span class="n">HelloWorld</span><span class="bp">&lt;</span><span class="n">A</span><span class="bp">&gt;</span> <span class="kd">extends</span> <span class="n">Comparator</span><span class="bp">&lt;</span><span class="n">A</span><span class="bp">&gt;</span> <span class="o">{</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">;</span>
    <span class="n">public</span> <span class="n">HelloWorld</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>But I don't know how to get the parser to distinguish between methods and fields.</p>



<a name="251591831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251591831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251591831">(Sep 01 2021 at 16:49)</a>:</h4>
<p><code>&lt;|&gt;</code> does not backtrack if the LHS has consumed input, so you'll want to split</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="n">modifier</span><span class="bp">*</span> <span class="o">(</span><span class="n">field_decl</span> <span class="bp">&lt;|&gt;</span> <span class="n">ctor_or_method_decl</span><span class="o">)</span> <span class="o">:</span> <span class="n">class_body_decl</span>
</code></pre></div>
<p>into two rules:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="n">modifier</span><span class="bp">*</span> <span class="n">field_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">modifier</span><span class="bp">*</span> <span class="n">ctor_or_method_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>
</code></pre></div>
<p>optionally factoring out the common <code>modifier*</code> prefix using yet another syntax category</p>



<a name="251594409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251594409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251594409">(Sep 01 2021 at 17:05)</a>:</h4>
<p>Is there a syntax category for number literals in lean? Where can I discover what syntax categories already exist?</p>



<a name="251594531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251594531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251594531">(Sep 01 2021 at 17:06)</a>:</h4>
<p><code>num</code></p>



<a name="251594643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251594643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251594643">(Sep 01 2021 at 17:07)</a>:</h4>
<p>It's not actually a syntax category, it's a parser (alias)</p>



<a name="251594796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251594796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251594796">(Sep 01 2021 at 17:08)</a>:</h4>
<p>They are sort of scattered all over, but that one is declared in a block with several others at the top of <code>Lean/Parser.lean</code></p>



<a name="251602893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251602893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251602893">(Sep 01 2021 at 18:03)</a>:</h4>
<p>How do parsers deal with the parsing of <code>Function&lt;A,Function&lt;B,C&gt;&gt;</code> so you don't have to do c++ style <code>`Function&lt;A,Function&lt;B,C&gt; &gt;</code>?</p>



<a name="251615076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251615076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251615076">(Sep 01 2021 at 19:27)</a>:</h4>
<p>You put a hack in so that <code>&gt;&gt;</code> counts as two <code>&gt;</code> when needed</p>



<a name="251615252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251615252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251615252">(Sep 01 2021 at 19:28)</a>:</h4>
<p>and I guess, <code>&gt;&gt;&gt;</code> counts as three <code>&gt;</code> (since java has <code>&gt;&gt;&gt;</code> too IIRC)</p>



<a name="251615676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251615676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251615676">(Sep 01 2021 at 19:31)</a>:</h4>
<p>For a lean 4 parser, I would suggest replacing <code>"&gt;"</code> in the <code>ty_args</code> and <code>ty_params</code> rules with a custom parser that consumes a <code>&gt;</code> character and doesn't use tokens</p>



<a name="251646904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251646904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251646904">(Sep 01 2021 at 23:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Java.20AST.20in.20Lean4/near/251615676">said</a>:</p>
<blockquote>
<p>For a lean 4 parser, I would suggest replacing <code>"&gt;"</code> in the <code>ty_args</code> and <code>ty_params</code> rules with a custom parser that consumes a <code>&gt;</code> character and doesn't use tokens</p>
</blockquote>
<p>This is actually much more difficult to do than it sounds since parsers to run for syntax categories are selected based on their tokens and their is no way (that I know of to so) to say declare that a parser can eat any token that begins with a '&gt;' . This means that if another parser that consumes the full token exists, the parser will likely choose that first. You may be able to get around this by having your parser having no declared <code>firstToken</code> and a very high priority.</p>



<a name="251658813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251658813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251658813">(Sep 02 2021 at 02:53)</a>:</h4>
<p>Yay, I caused a stack overflow. It happened when I added <code>ty_array</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">java_file</span>
<span class="n">syntax</span> <span class="s2">"java"</span> <span class="s2">"{"</span> <span class="n">java_file</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">term</span>

<span class="n">declare_syntax_cat</span> <span class="n">q_name</span>
<span class="n">syntax</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">"."</span> <span class="n">ident</span><span class="o">)</span><span class="bp">*</span> <span class="o">:</span> <span class="n">q_name</span>

<span class="n">declare_syntax_cat</span> <span class="n">pkg_decl</span>
<span class="n">syntax</span> <span class="s2">"package"</span> <span class="n">q_name</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">pkg_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">import_decl</span>
<span class="n">syntax</span> <span class="s2">"import"</span> <span class="o">(</span><span class="n">ident</span> <span class="s2">"."</span><span class="o">)</span><span class="bp">+</span> <span class="o">(</span><span class="s2">"*"</span> <span class="bp">&lt;|&gt;</span> <span class="n">ident</span><span class="o">)</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">import_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_ref</span>
<span class="n">declare_syntax_cat</span> <span class="n">ty_args</span>
<span class="n">syntax</span> <span class="n">ident</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_ref</span>
<span class="n">syntax</span> <span class="s2">"&lt;"</span> <span class="o">(</span><span class="n">ty_ref</span><span class="o">),</span><span class="bp">*</span> <span class="s2">"&gt;"</span> <span class="o">:</span> <span class="n">ty_args</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_prim</span>
<span class="n">syntax</span> <span class="s2">"int"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"long"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"float"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"double"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"boolean"</span> <span class="o">:</span> <span class="n">ty_prim</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty</span>
<span class="n">declare_syntax_cat</span> <span class="n">ty_array</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="s2">"["</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">ty_array</span>

<span class="n">syntax</span> <span class="n">ty_array</span> <span class="o">:</span> <span class="n">ty</span>
<span class="n">syntax</span> <span class="n">ty_prim</span> <span class="o">:</span> <span class="n">ty</span>
<span class="n">syntax</span> <span class="n">ty_ref</span> <span class="o">:</span> <span class="n">ty</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_ret</span>
<span class="n">syntax</span> <span class="s2">"void"</span> <span class="o">:</span> <span class="n">ty_ret</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="o">:</span> <span class="n">ty_ret</span>


<span class="n">syntax</span> <span class="n">q_name</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_ref</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_super</span>
<span class="n">syntax</span> <span class="o">(</span><span class="s2">"extends"</span> <span class="n">ty_ref</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="s2">"implements"</span> <span class="n">ty_ref</span><span class="o">,</span><span class="bp">*</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_super</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_access</span>
<span class="n">syntax</span> <span class="s2">"public"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"protected"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"private"</span> <span class="o">:</span> <span class="n">mod_access</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_class_method</span>
<span class="n">syntax</span> <span class="o">(</span><span class="n">mod_access</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"abstract"</span><span class="bp">?</span> <span class="s2">"final"</span><span class="bp">?</span> <span class="o">:</span> <span class="n">mod_class_method</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_static_method</span>
<span class="n">syntax</span> <span class="o">(</span><span class="n">mod_access</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"static"</span> <span class="s2">"final"</span><span class="bp">?</span> <span class="o">:</span> <span class="n">mod_static_method</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_method</span>
<span class="n">syntax</span> <span class="n">mod_class_method</span> <span class="o">:</span> <span class="n">mod_method</span>
<span class="n">syntax</span> <span class="n">mod_static_method</span> <span class="o">:</span> <span class="n">mod_method</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_field</span>
<span class="n">syntax</span> <span class="o">(</span><span class="n">mod_access</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"static"</span><span class="bp">?</span> <span class="s2">"final"</span><span class="bp">?</span> <span class="o">:</span> <span class="n">mod_field</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_local_var</span>
<span class="n">syntax</span> <span class="s2">"final"</span><span class="bp">?</span> <span class="o">:</span> <span class="n">mod_field</span>


<span class="n">declare_syntax_cat</span> <span class="n">ty_params</span>
<span class="n">syntax</span> <span class="s2">"&lt;"</span> <span class="o">(</span><span class="n">ident</span> <span class="o">(</span><span class="n">ty_super</span><span class="o">)</span><span class="bp">?</span><span class="o">),</span><span class="bp">*</span> <span class="s2">"&gt;"</span> <span class="o">:</span> <span class="n">ty_params</span>

<span class="n">declare_syntax_cat</span> <span class="n">lit</span>
<span class="n">syntax</span> <span class="n">num</span> <span class="o">:</span> <span class="n">lit</span>

<span class="n">declare_syntax_cat</span> <span class="n">expr</span>
<span class="n">syntax</span> <span class="n">lit</span> <span class="o">:</span> <span class="n">expr</span>
<span class="n">syntax</span> <span class="n">ident</span> <span class="o">:</span> <span class="n">expr</span>

<span class="n">declare_syntax_cat</span> <span class="n">var_decl</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">"="</span> <span class="n">expr</span><span class="o">)</span><span class="bp">?</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">var_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">field_decl</span>
<span class="n">syntax</span> <span class="n">mod_field</span> <span class="n">var_decl</span> <span class="o">:</span> <span class="n">field_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">field_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">class_body</span>
<span class="n">syntax</span> <span class="s2">"{"</span> <span class="n">class_body_decl</span><span class="bp">*</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">class_body</span>

<span class="n">declare_syntax_cat</span> <span class="n">param</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="n">ident</span> <span class="o">:</span> <span class="n">param</span>

<span class="n">declare_syntax_cat</span> <span class="n">params</span>
<span class="n">syntax</span> <span class="s2">"("</span> <span class="n">param</span><span class="o">,</span><span class="bp">*</span> <span class="s2">")"</span> <span class="o">:</span> <span class="n">params</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_throws</span>
<span class="n">syntax</span> <span class="s2">"throws"</span> <span class="n">ty_ref</span><span class="o">,</span><span class="bp">+</span> <span class="o">:</span> <span class="n">ty_throws</span>

<span class="n">declare_syntax_cat</span> <span class="n">local_var_decl</span>
<span class="n">syntax</span> <span class="n">mod_local_var</span> <span class="n">var_decl</span> <span class="o">:</span> <span class="n">local_var_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">assign</span>
<span class="n">syntax</span> <span class="n">expr</span> <span class="s2">"="</span> <span class="n">expr</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">assign</span>

<span class="n">declare_syntax_cat</span> <span class="n">stmt</span>
<span class="n">declare_syntax_cat</span> <span class="n">block</span>
<span class="n">syntax</span> <span class="s2">"{"</span> <span class="n">stmt</span><span class="bp">*</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">block</span>
<span class="n">syntax</span> <span class="n">block</span> <span class="o">:</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">var_decl</span> <span class="o">:</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">local_var_decl</span> <span class="o">:</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">assign</span> <span class="o">:</span> <span class="n">stmt</span>

<span class="n">declare_syntax_cat</span> <span class="n">method_body</span>
<span class="n">syntax</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">method_body</span>
<span class="n">syntax</span> <span class="n">block</span> <span class="o">:</span> <span class="n">method_body</span>

<span class="n">declare_syntax_cat</span> <span class="n">method_decl</span>
<span class="n">syntax</span> <span class="n">mod_method</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="n">ty_ret</span> <span class="n">ident</span> <span class="n">params</span> <span class="o">(</span><span class="n">ty_throws</span><span class="o">)</span><span class="bp">?</span> <span class="n">method_body</span> <span class="o">:</span> <span class="n">method_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">ctor_decl</span>
<span class="n">syntax</span> <span class="n">mod_class_method</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="n">ty_ret</span><span class="o">)</span><span class="bp">?</span> <span class="n">ident</span> <span class="n">params</span> <span class="o">(</span><span class="n">ty_throws</span><span class="o">)</span><span class="bp">?</span> <span class="n">method_body</span> <span class="o">:</span> <span class="n">ctor_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_decl</span>
<span class="n">syntax</span> <span class="n">mod_method</span> <span class="s2">"class"</span> <span class="n">ident</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="n">ty_super</span><span class="o">)</span><span class="bp">?</span> <span class="n">class_body</span> <span class="o">:</span> <span class="n">ty_decl</span>

<span class="n">syntax</span> <span class="o">(</span><span class="n">pkg_decl</span><span class="o">)</span><span class="bp">?</span> <span class="n">import_decl</span><span class="bp">*</span> <span class="n">ty_decl</span><span class="bp">*</span> <span class="o">:</span> <span class="n">java_file</span>

<span class="n">syntax</span> <span class="n">field_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">ctor_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">method_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>

<span class="n">syntax</span> <span class="n">num</span> <span class="o">:</span> <span class="n">lit</span>


<span class="kd">def</span> <span class="n">test</span> <span class="o">:=</span> <span class="n">java</span> <span class="o">{</span>
  <span class="n">package</span> <span class="n">org.stnreu001.csc2002s</span><span class="bp">;</span>
  <span class="kn">import</span> <span class="n">java.util.</span><span class="bp">*;</span>

  <span class="n">public</span> <span class="kd">class</span> <span class="n">HelloWorld</span><span class="bp">&lt;</span><span class="n">A</span> <span class="kd">extends</span> <span class="n">Object</span> <span class="n">implements</span> <span class="n">List</span><span class="bp">&lt;</span><span class="n">B</span><span class="bp">&gt;</span> <span class="bp">&gt;</span> <span class="kd">extends</span> <span class="n">Comparator</span><span class="bp">&lt;</span><span class="n">A</span><span class="bp">&gt;</span><span class="o">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">final</span> <span class="n">int</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">;</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">HelloWorld</span><span class="o">()</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="n">int</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">3</span><span class="bp">;</span>
      <span class="n">y</span> <span class="bp">=</span> <span class="mi">4</span><span class="bp">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>



<a name="251663428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251663428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251663428">(Sep 02 2021 at 04:09)</a>:</h4>
<p>Ah, fixed</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">ty_no_array</span>
<span class="n">syntax</span> <span class="n">ty_prim</span> <span class="o">:</span> <span class="n">ty_no_array</span>
<span class="n">syntax</span> <span class="n">ty_ref</span> <span class="o">:</span> <span class="n">ty_no_array</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty</span>
<span class="n">syntax</span> <span class="n">ty_no_array</span> <span class="o">(</span><span class="s2">"["</span> <span class="s2">"]"</span><span class="o">)</span><span class="bp">*</span> <span class="o">:</span> <span class="n">ty</span>
</code></pre></div>



<a name="251664588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251664588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251664588">(Sep 02 2021 at 04:30)</a>:</h4>
<p>I don't have to interleave parsing and typechecking at least, but I need to be able to differentiate type names from expression names. Would it be possible to reuse Lean4's existing binders and unification to resolve names in context and propagate information when a name is used like a type?</p>



<a name="251676018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251676018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251676018">(Sep 02 2021 at 07:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Java.20AST.20in.20Lean4/near/251646904">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Java.20AST.20in.20Lean4/near/251615676">said</a>:</p>
<blockquote>
<p>For a lean 4 parser, I would suggest replacing <code>"&gt;"</code> in the <code>ty_args</code> and <code>ty_params</code> rules with a custom parser that consumes a <code>&gt;</code> character and doesn't use tokens</p>
</blockquote>
<p>This is actually much more difficult to do than it sounds since parsers to run for syntax categories are selected based on their tokens and their is no way (that I know of to so) to say declare that a parser can eat any token that begins with a '&gt;' . This means that if another parser that consumes the full token exists, the parser will likely choose that first. You may be able to get around this by having your parser having no declared <code>firstToken</code> and a very high priority.</p>
</blockquote>
<p>You can say that your parser will eat tokens <code>&gt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></p>



<a name="251676359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251676359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251676359">(Sep 02 2021 at 07:30)</a>:</h4>
<p><span class="user-mention" data-user-id="244748">@ohhaimark</span> Where in the grammar do you need to distinguish type names from expression names? I thought java didn't inherit this cursed feature from C++</p>



<a name="251676917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251676917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251676917">(Sep 02 2021 at 07:35)</a>:</h4>
<p>In distinguishing method calls from static method calls.</p>
<div class="codehilite" data-code-language="Java"><pre><span></span><code><span class="n">typenamenotfollowingjavaconventions</span><span class="p">.</span><span class="na">staticcall</span><span class="p">()</span>
<span class="n">localvariableinscope</span><span class="p">.</span><span class="na">membercall</span><span class="p">()</span>
</code></pre></div>



<a name="251677162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251677162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251677162">(Sep 02 2021 at 07:38)</a>:</h4>
<p>The java spec talks about having different levels of knowledge about a name in its grammar. AmbigiousName, TypeName, PackageOrTypeName, etc.</p>



<a name="251677849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251677849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251677849">(Sep 02 2021 at 07:45)</a>:</h4>
<p>It seems like you can still parse that without knowing which is which, just have an ambiguous production and determine the difference at typechecking time</p>



<a name="251680303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251680303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251680303">(Sep 02 2021 at 08:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Java.20AST.20in.20Lean4/near/251646904">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Java.20AST.20in.20Lean4/near/251615676">said</a>:</p>
<blockquote>
<p>For a lean 4 parser, I would suggest replacing <code>"&gt;"</code> in the <code>ty_args</code> and <code>ty_params</code> rules with a custom parser that consumes a <code>&gt;</code> character and doesn't use tokens</p>
</blockquote>
<p>This is actually much more difficult to do than it sounds since parsers to run for syntax categories are selected based on their tokens and their is no way (that I know of to so) to say declare that a parser can eat any token that begins with a '&gt;' .</p>
</blockquote>
<p>I don't see the issue, there are no category parsers starting with <code>&gt;</code> here</p>



<a name="251683431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251683431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251683431">(Sep 02 2021 at 08:41)</a>:</h4>
<p><span class="user-mention" data-user-id="244748">@ohhaimark</span> Btw, instead of a single-parser syntax category, you can also use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="n">ty</span> <span class="o">:=</span> <span class="n">ty_no_array</span> <span class="o">(</span><span class="s2">"["</span> <span class="s2">"]"</span><span class="o">)</span><span class="bp">*</span>
</code></pre></div>



<a name="251687355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251687355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251687355">(Sep 02 2021 at 09:15)</a>:</h4>
<p>Yay</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="n">q_name</span> <span class="o">:=</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">"."</span> <span class="n">ident</span><span class="o">)</span><span class="bp">*</span>

<span class="n">syntax</span> <span class="n">pkg_decl</span> <span class="o">:=</span> <span class="s2">"package"</span> <span class="n">q_name</span> <span class="s2">";"</span>

<span class="n">syntax</span> <span class="n">import_decl</span> <span class="o">:=</span> <span class="s2">"import"</span> <span class="o">(</span><span class="n">ident</span> <span class="s2">"."</span><span class="o">)</span><span class="bp">+</span> <span class="o">(</span><span class="s2">"*"</span> <span class="bp">&lt;|&gt;</span> <span class="n">ident</span><span class="o">)</span> <span class="s2">";"</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_ref</span>
<span class="n">declare_syntax_cat</span> <span class="n">ty_args</span>
<span class="n">syntax</span> <span class="n">ident</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_ref</span>
<span class="n">syntax</span> <span class="s2">"&lt;"</span> <span class="o">(</span><span class="n">ty_ref</span><span class="o">),</span><span class="bp">*</span> <span class="s2">"&gt;"</span> <span class="o">:</span> <span class="n">ty_args</span>

<span class="n">syntax</span> <span class="n">ty_prim</span> <span class="o">:=</span> <span class="s2">"int"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"long"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"float"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"double"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"boolean"</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_no_array</span>
<span class="n">syntax</span> <span class="n">ty_prim</span> <span class="o">:</span> <span class="n">ty_no_array</span>
<span class="n">syntax</span> <span class="n">ty_ref</span> <span class="o">:</span> <span class="n">ty_no_array</span>

<span class="n">syntax</span> <span class="n">ty</span> <span class="o">:=</span> <span class="n">ty_no_array</span> <span class="o">(</span><span class="s2">"["</span> <span class="s2">"]"</span><span class="o">)</span><span class="bp">*</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_ret</span>
<span class="n">syntax</span> <span class="s2">"void"</span> <span class="o">:</span> <span class="n">ty_ret</span>
<span class="n">syntax</span> <span class="n">ty</span> <span class="o">:</span> <span class="n">ty_ret</span>

<span class="n">syntax</span> <span class="n">q_name</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">ty_ref</span>

<span class="n">syntax</span> <span class="n">ty_super</span> <span class="o">:=</span> <span class="o">(</span><span class="s2">"extends"</span> <span class="n">ty_ref</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="s2">"implements"</span> <span class="n">ty_ref</span><span class="o">,</span><span class="bp">*</span><span class="o">)</span><span class="bp">?</span>

<span class="n">syntax</span> <span class="n">mod_access</span> <span class="o">:=</span> <span class="s2">"public"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"protected"</span> <span class="bp">&lt;|&gt;</span> <span class="s2">"private"</span>

<span class="n">syntax</span> <span class="n">mod_class_method</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mod_access</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"abstract"</span><span class="bp">?</span> <span class="s2">"final"</span><span class="bp">?</span>

<span class="n">syntax</span> <span class="n">mod_static_method</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mod_access</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"static"</span> <span class="s2">"final"</span><span class="bp">?</span>

<span class="n">declare_syntax_cat</span> <span class="n">mod_method</span>
<span class="n">syntax</span> <span class="n">mod_class_method</span> <span class="o">:</span> <span class="n">mod_method</span>
<span class="n">syntax</span> <span class="n">mod_static_method</span> <span class="o">:</span> <span class="n">mod_method</span>

<span class="n">syntax</span> <span class="n">mod_field</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mod_access</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"static"</span><span class="bp">?</span> <span class="s2">"final"</span><span class="bp">?</span>

<span class="n">syntax</span> <span class="n">mod_local_var</span> <span class="o">:=</span> <span class="s2">"final"</span><span class="bp">?</span>

<span class="n">syntax</span> <span class="n">ty_params</span> <span class="o">:=</span> <span class="s2">"&lt;"</span> <span class="o">(</span><span class="n">ident</span> <span class="o">(</span><span class="n">ty_super</span><span class="o">)</span><span class="bp">?</span><span class="o">),</span><span class="bp">*</span> <span class="s2">"&gt;"</span>

<span class="n">declare_syntax_cat</span> <span class="n">lit</span>
<span class="n">syntax</span> <span class="n">num</span> <span class="o">:</span> <span class="n">lit</span>

<span class="n">syntax</span> <span class="n">param</span> <span class="o">:=</span> <span class="n">ty</span> <span class="n">ident</span>
<span class="n">syntax</span> <span class="n">params</span> <span class="o">:=</span> <span class="s2">"("</span> <span class="n">param</span><span class="o">,</span><span class="bp">*</span> <span class="s2">")"</span>

<span class="n">declare_syntax_cat</span> <span class="n">expr</span>

<span class="n">syntax</span> <span class="n">args</span> <span class="o">:=</span> <span class="s2">"("</span> <span class="n">expr</span><span class="o">,</span><span class="bp">*</span> <span class="s2">")"</span>

<span class="n">syntax</span> <span class="n">ident_or_invoke</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="n">ident</span> <span class="o">(</span><span class="n">args</span><span class="o">)</span><span class="bp">?</span>
<span class="n">syntax</span> <span class="n">dot</span> <span class="o">:=</span> <span class="n">ident_or_invoke</span> <span class="o">(</span><span class="s2">"."</span> <span class="n">ident_or_invoke</span><span class="o">)</span><span class="bp">*</span>

<span class="n">syntax</span> <span class="n">lit</span> <span class="o">:</span> <span class="n">expr</span>
<span class="n">syntax</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">expr</span>

<span class="n">syntax</span> <span class="n">var_decl</span> <span class="o">:=</span> <span class="n">ty</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">"="</span> <span class="n">expr</span><span class="o">)</span><span class="bp">?</span> <span class="s2">";"</span>

<span class="n">syntax</span> <span class="n">field_decl</span> <span class="o">:=</span> <span class="n">mod_field</span> <span class="n">var_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">field_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">ty_throws</span>
<span class="n">syntax</span> <span class="s2">"throws"</span> <span class="n">ty_ref</span><span class="o">,</span><span class="bp">+</span> <span class="o">:</span> <span class="n">ty_throws</span>

<span class="n">declare_syntax_cat</span> <span class="n">method_body</span>

<span class="n">declare_syntax_cat</span> <span class="n">ctor_decl</span>
<span class="n">syntax</span> <span class="n">ctor_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">mod_class_method</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="n">ident</span> <span class="n">params</span> <span class="o">(</span><span class="n">ty_throws</span><span class="o">)</span><span class="bp">?</span> <span class="n">method_body</span> <span class="o">:</span> <span class="n">ctor_decl</span>

<span class="n">declare_syntax_cat</span> <span class="n">method_decl</span>
<span class="n">syntax</span> <span class="n">method_decl</span> <span class="o">:</span> <span class="n">class_body_decl</span>
<span class="n">syntax</span> <span class="n">mod_method</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="n">ty_ret</span> <span class="n">ident</span> <span class="n">params</span> <span class="o">(</span><span class="n">ty_throws</span><span class="o">)</span><span class="bp">?</span> <span class="n">method_body</span> <span class="o">:</span> <span class="n">method_decl</span>

<span class="n">syntax</span> <span class="n">class_body</span> <span class="o">:=</span> <span class="s2">"{"</span> <span class="n">class_body_decl</span><span class="bp">*</span> <span class="s2">"}"</span>

<span class="n">syntax</span> <span class="n">local_var_decl</span> <span class="o">:=</span> <span class="n">mod_local_var</span> <span class="n">var_decl</span>

<span class="n">syntax</span> <span class="n">assign</span> <span class="o">:=</span> <span class="n">expr</span> <span class="s2">"="</span> <span class="n">expr</span> <span class="s2">";"</span>

<span class="n">declare_syntax_cat</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">block</span> <span class="o">:=</span> <span class="s2">"{"</span> <span class="n">stmt</span><span class="bp">*</span> <span class="s2">"}"</span>
<span class="n">syntax</span> <span class="n">block</span> <span class="o">:</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">var_decl</span> <span class="o">:</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">local_var_decl</span> <span class="o">:</span> <span class="n">stmt</span>
<span class="n">syntax</span> <span class="n">assign</span> <span class="o">:</span> <span class="n">stmt</span>

<span class="n">syntax</span> <span class="s2">";"</span> <span class="o">:</span> <span class="n">method_body</span>
<span class="n">syntax</span> <span class="n">block</span> <span class="o">:</span> <span class="n">method_body</span>

<span class="n">syntax</span> <span class="n">ty_decl</span> <span class="o">:=</span> <span class="n">mod_method</span> <span class="s2">"class"</span> <span class="n">ident</span> <span class="o">(</span><span class="n">ty_params</span><span class="o">)</span><span class="bp">?</span> <span class="o">(</span><span class="n">ty_super</span><span class="o">)</span><span class="bp">?</span> <span class="n">class_body</span>

<span class="n">syntax</span> <span class="n">num</span> <span class="o">:</span> <span class="n">lit</span>

<span class="n">syntax</span> <span class="n">java_compilation_unit</span> <span class="o">:=</span> <span class="o">(</span><span class="n">pkg_decl</span><span class="o">)</span><span class="bp">?</span> <span class="n">import_decl</span><span class="bp">*</span> <span class="n">ty_decl</span><span class="bp">*</span>

<span class="n">syntax</span> <span class="s2">"java"</span> <span class="s2">"{"</span> <span class="n">java_compilation_unit</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">term</span>
</code></pre></div>
<p>I should probably start putting this in a Gist or something.</p>



<a name="251687466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251687466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251687466">(Sep 02 2021 at 09:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">:=</span> <span class="n">java</span> <span class="o">{</span>
  <span class="n">package</span> <span class="n">org.stnreu001.csc2002s</span><span class="bp">;</span>
  <span class="kn">import</span> <span class="n">java.util.</span><span class="bp">*;</span>

  <span class="n">public</span> <span class="kd">class</span> <span class="n">Test</span> <span class="bp">&lt;</span><span class="n">A</span> <span class="kd">extends</span> <span class="n">Object</span> <span class="n">implements</span> <span class="n">List</span><span class="bp">&lt;</span><span class="n">B</span><span class="bp">&gt;</span> <span class="bp">&gt;</span> <span class="kd">extends</span> <span class="n">Comparator</span><span class="bp">&lt;</span><span class="n">A</span><span class="bp">&gt;</span><span class="o">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">final</span> <span class="n">int</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">;</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">List</span><span class="bp">&lt;</span><span class="n">Map</span><span class="bp">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Double</span><span class="bp">&gt;</span> <span class="bp">&gt;</span> <span class="n">listOfMaps</span><span class="bp">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">HelloWorld</span><span class="o">()</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="n">final</span> <span class="n">int</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">3</span><span class="bp">;</span>
      <span class="n">y</span> <span class="bp">=</span> <span class="mi">4</span><span class="bp">;</span>
      <span class="n">y.x</span> <span class="bp">=</span> <span class="n">f</span><span class="o">(</span><span class="n">y.z</span><span class="o">)</span><span class="bp">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>



<a name="251688699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251688699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251688699">(Sep 02 2021 at 09:28)</a>:</h4>
<p>Can precedence help a production rule that's left recursive? e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="n">syntax</span> <span class="n">ident_or_invoke</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ty_args</span><span class="o">)</span><span class="bp">?</span> <span class="n">ident</span> <span class="o">(</span><span class="n">args</span><span class="o">)</span><span class="bp">?</span>
<span class="n">declare_syntax_cat</span> <span class="n">expr</span>
<span class="n">syntax</span> <span class="n">dot</span> <span class="o">:=</span> <span class="n">expr</span> <span class="s2">"."</span> <span class="n">ident_or_invoke</span>
<span class="n">syntax</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">expr</span>
<span class="n">syntax</span> <span class="n">ident_or_invoke</span> <span class="o">:</span> <span class="n">expr</span>
</code></pre></div>



<a name="251693598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251693598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251693598">(Sep 02 2021 at 10:17)</a>:</h4>
<p>No. A syntax rule must be syntactically left-recursive to be handled correctly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="n">expr</span> <span class="s2">"."</span> <span class="n">ident_or_invoke</span> <span class="o">:</span> <span class="n">expr</span>
</code></pre></div>



<a name="251696059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251696059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251696059">(Sep 02 2021 at 10:46)</a>:</h4>
<p>Can macro_rules for translating to AST give you pretty printing?</p>



<a name="251699708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251699708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251699708">(Sep 02 2021 at 11:22)</a>:</h4>
<p>Not directly, if I understood your question correctly, but the parser itself can contain hints for Lean's built-in pretty printer <a href="https://github.com/leanprover/lean4/blob/aba0a479ec221ad2e31de09c6e71ce82a705ec38/src/Lean/Parser/Extra.lean#L63-L78">https://github.com/leanprover/lean4/blob/aba0a479ec221ad2e31de09c6e71ce82a705ec38/src/Lean/Parser/Extra.lean#L63-L78</a><br>
<a href="https://github.com/leanprover/lean4/blob/aba0a479ec221ad2e31de09c6e71ce82a705ec38/src/Init/Notation.lean#L143">https://github.com/leanprover/lean4/blob/aba0a479ec221ad2e31de09c6e71ce82a705ec38/src/Init/Notation.lean#L143</a></p>



<a name="251703016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251703016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251703016">(Sep 02 2021 at 11:56)</a>:</h4>
<p>Whats happening here</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"lolol"</span> <span class="o">:</span> <span class="n">term</span>

<span class="kd">inductive</span> <span class="n">testlol</span> <span class="o">:=</span> <span class="bp">|</span> <span class="n">lol</span>

<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">lolol</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">``</span><span class="o">(</span><span class="n">testlol.lol</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">yee</span> <span class="o">:</span> <span class="n">testlol</span> <span class="o">:=</span> <span class="n">lolol</span>

<span class="k">#eval</span> <span class="n">yee</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span>
  <span class="n">Lean.MetaEval</span> <span class="n">testlol</span>
</code></pre></div>



<a name="251703199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251703199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251703199">(Sep 02 2021 at 11:58)</a>:</h4>
<p>Oh lol, has nothing to do with the macro stuff.</p>



<a name="251703243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251703243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251703243">(Sep 02 2021 at 11:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">testlol</span> <span class="o">:=</span> <span class="bp">|</span> <span class="n">lol</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">testlol.lol</span><span class="o">)</span>
</code></pre></div>



<a name="251704249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251704249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251704249">(Sep 02 2021 at 12:07)</a>:</h4>
<p>Also with <a href="https://github.com/leanprover/lean4/blob/aba0a479ec221ad2e31de09c6e71ce82a705ec38/src/Init/Notation.lean#L410-L414">https://github.com/leanprover/lean4/blob/aba0a479ec221ad2e31de09c6e71ce82a705ec38/src/Init/Notation.lean#L410-L414</a>, I see that the trivial tactic can macro expand into various other tactics. Does that mean the macro expander is backtracking?</p>



<a name="251713032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251713032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251713032">(Sep 02 2021 at 13:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/Java.20AST.20in.20Lean4/near/251683431">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="244748">ohhaimark</span> Btw, instead of a single-parser syntax category, you can also use</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="n">ty</span> <span class="o">:=</span> <span class="n">ty_no_array</span> <span class="o">(</span><span class="s2">"["</span> <span class="s2">"]"</span><span class="o">)</span><span class="bp">*</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I thought you said that <code>("a" "b")*</code> was bad practice?</p>



<a name="251728767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251728767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251728767">(Sep 02 2021 at 14:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Why is there no MetaEval instance for the inductive definitions I make?</p>



<a name="251728835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251728835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251728835">(Sep 02 2021 at 14:56)</a>:</h4>
<p>because one hasn't been defined</p>



<a name="251728904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251728904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251728904">(Sep 02 2021 at 14:57)</a>:</h4>
<p>What is it you want to get out of evaluating the expression?</p>



<a name="251728958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251728958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251728958">(Sep 02 2021 at 14:57)</a>:</h4>
<p>If you want to print it then use <code>deriving Repr</code> and then <code>#eval repr testlol.lol</code></p>



<a name="251729160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729160">(Sep 02 2021 at 14:58)</a>:</h4>
<p>Is there a deriving mechanism for it?<br>
I expect inductive definitions to evaluate to themselves.<br>
Oh, so it's also the printed output?<br>
Can you select arbitrary reductions to be used?</p>



<a name="251729313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729313">(Sep 02 2021 at 14:59)</a>:</h4>
<p>You can <em>evaluate</em> expressions of type <code>testlol</code>, but <code>let _ := testlol.lol; ()</code> isn't very useful, you presumably want to print it at the end or something</p>



<a name="251729444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729444">(Sep 02 2021 at 15:00)</a>:</h4>
<p>So it's just defining how to pretty print?</p>



<a name="251729461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729461">(Sep 02 2021 at 15:00)</a>:</h4>
<p>and for that you need <code>deriving Repr</code> or <code>ToString</code> (I forget if that has a deriving instance)</p>



<a name="251729482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729482">(Sep 02 2021 at 15:00)</a>:</h4>
<p>yes</p>



<a name="251729525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729525">(Sep 02 2021 at 15:00)</a>:</h4>
<p>You can define a printer yourself too</p>



<a name="251729616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251729616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251729616">(Sep 02 2021 at 15:01)</a>:</h4>
<p>Or just use the inductive as an intermediate type and construct some base type at the end like strings or tuples or something</p>



<a name="251730166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251730166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251730166">(Sep 02 2021 at 15:04)</a>:</h4>
<p>Can you have deriving for mutual inductive types?</p>



<a name="251730354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251730354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251730354">(Sep 02 2021 at 15:06)</a>:</h4>
<p>Nvm, I just didn't put enough deriving Reprs.</p>



<a name="251732426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251732426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ohhaimark <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251732426">(Sep 02 2021 at 15:19)</a>:</h4>
<p>How would I write a syntax extension that takes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Flags</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">Flag</span>
   <span class="n">deriving</span> <span class="n">Repr</span> <span class="n">Flags</span>
</code></pre></div>
<p>and produces something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Flags</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">Flag</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Repr</span> <span class="n">Flags</span> <span class="o">:=</span> <span class="n">inferInstanceAs</span> <span class="o">(</span><span class="n">Repr</span> <span class="o">(</span><span class="n">List</span> <span class="n">Flag</span><span class="o">))</span>
</code></pre></div>
<p>or find something which doesn't require something like this in the first place.</p>



<a name="251814121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251814121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251814121">(Sep 03 2021 at 02:27)</a>:</h4>
<p>cc: <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> , can we get this in lean core? Mathlib wants this too</p>



<a name="251818444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251818444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251818444">(Sep 03 2021 at 03:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Isn't tis the same problem as discussed in the previous <code>inferInstance</code> Zulip thread where <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/inferInstance/near/250009490">said</a> that "Ah, well, the current API doesn't quite allow for that yet".</p>



<a name="251818463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251818463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251818463">(Sep 03 2021 at 03:38)</a>:</h4>
<p>yes, this is a <em>syntax</em> extension</p>



<a name="251818494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251818494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251818494">(Sep 03 2021 at 03:39)</a>:</h4>
<p>The API issue might have to do with needing to use terms instead of class names</p>



<a name="251818549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251818549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251818549">(Sep 03 2021 at 03:40)</a>:</h4>
<p>but for this basic example it could just be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Flags</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">Flag</span>
   <span class="n">deriving</span> <span class="n">Repr</span>
</code></pre></div>



<a name="251924507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251924507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251924507">(Sep 03 2021 at 18:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I added basic support for <code>deriving</code> at <code>def</code>. We can now write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Boo</span> <span class="o">:=</span> <span class="n">List</span> <span class="o">(</span><span class="n">String</span> <span class="bp">×</span> <span class="n">String</span><span class="o">)</span>
  <span class="n">deriving</span> <span class="n">BEq</span><span class="o">,</span> <span class="n">Repr</span><span class="o">,</span> <span class="n">DecidableEq</span>

<span class="kd">def</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">ReaderT</span> <span class="n">String</span> <span class="o">(</span><span class="n">StateT</span> <span class="n">Nat</span> <span class="n">IO</span><span class="o">)</span>
  <span class="n">deriving</span> <span class="n">Monad</span><span class="o">,</span> <span class="n">MonadState</span><span class="o">,</span> <span class="n">MonadReader</span>
</code></pre></div>
<p>It is very simple for now. It only supports</p>
<ul>
<li>Type "aliases".</li>
<li>Classes with a prefix of outParams followed by one parameter.</li>
</ul>



<a name="251956152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/251956152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#251956152">(Sep 03 2021 at 23:49)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> Thanks!</p>



<a name="252454652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Java%20AST%20in%20Lean4/near/252454652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alcides Fonseca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Java.20AST.20in.20Lean4.html#252454652">(Sep 08 2021 at 12:59)</a>:</h4>
<p>A completely different take is to use an existing Java parser (<a href="https://javaparser.org">https://javaparser.org</a> or <a href="https://spoon.gforge.inria.fr">https://spoon.gforge.inria.fr</a>) and create a tool that translates the parsed instances of the Java AST to a similar Java AST in Lean.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
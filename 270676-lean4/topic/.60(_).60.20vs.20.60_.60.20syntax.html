---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html">`(_)` vs `_` syntax</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="313936557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313936557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313936557">(Dec 05 2022 at 10:56)</a>:</h4>
<p>I was surprised to find <a href="#narrow/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt/near/313868751">while helping with a mathlib port PR</a> that <code>(_)</code> no longer seems to mean the same thing as <code>_</code> when used in places where typeclass arguments are expected. I assume this is intentional; but it's hard to search for! Can someone point me to the relevant documentation if any exists?</p>



<a name="313942730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313942730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313942730">(Dec 05 2022 at 11:32)</a>:</h4>
<p>I don't think it's an intentional feature for this specific use case but a combination of other aspects. Do you have an MWE?</p>



<a name="313946801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313946801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313946801">(Dec 05 2022 at 11:57)</a>:</h4>
<p>Sure, here's a mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">MyClass</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">M</span>

<span class="kd">structure</span> <span class="n">MyHom</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">MyClass</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span>
  <span class="sd">/-- The underlying function -/</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span> <span class="o">}</span>  <span class="c1">-- fails</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">MyHom.mk</span> <span class="n">M</span> <span class="n">M</span> <span class="n">_</span> <span class="n">_</span> <span class="n">id</span>  <span class="c1">-- fails</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">MyHom.mk</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">id</span>  <span class="c1">-- ok</span>
</code></pre></div>



<a name="313946838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313946838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313946838">(Dec 05 2022 at 11:57)</a>:</h4>
<p>(deleted)</p>



<a name="313948468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313948468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313948468">(Dec 05 2022 at 12:07)</a>:</h4>
<p>Oh my, ambiguous instances in the context? But yes, inside <code>@...</code> there is a syntactic distinction between instance arguments that are given as <code>_</code>, which are inferred by typeclass resolution, and any other term including <code>(_)</code>, which are synthesized by regular elaboration, in this case unification <a href="https://github.com/leanprover/lean4/blob/5286c2b5aa30403cbf75f9e67d406edbfca12b67/src/Lean/Elab/App.lean#L622-L630">https://github.com/leanprover/lean4/blob/5286c2b5aa30403cbf75f9e67d406edbfca12b67/src/Lean/Elab/App.lean#L622-L630</a></p>



<a name="313948575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313948575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313948575">(Dec 05 2022 at 12:08)</a>:</h4>
<p>Could that syntactic distinction be represented in the hover text?</p>



<a name="313948691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313948691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313948691">(Dec 05 2022 at 12:08)</a>:</h4>
<p>Right now hovering over the <code>_</code> says "A placeholder term, to be synthesized by unification."; but it sounds like that's wrong in this case, and it's actually inferred by TC search?</p>



<a name="313949033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313949033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313949033">(Dec 05 2022 at 12:10)</a>:</h4>
<p>Relatedly; the <code>{toFun := </code> spelling works fine in Lean 3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">MyClass</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">MyHom</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">MyClass</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">toFun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span> <span class="o">}</span>  <span class="c1">-- ok (fails in Lean 4, ???)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">MyHom.mk</span> <span class="n">M</span> <span class="n">M</span> <span class="n">_</span> <span class="n">_</span> <span class="n">id</span>  <span class="c1">-- fails in both</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">MyHom.mk</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">id</span>  <span class="c1">-- fails (ok in Lean 4, answered above)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">MyHom.mk</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">id</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="n">id</span>  <span class="c1">-- ok in both</span>
</code></pre></div>
<p>Is <code>{ toFun := id }</code> no longer working a deliberate choice?</p>



<a name="313949564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313949564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313949564">(Dec 05 2022 at 12:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/313948691">said</a>:</p>
<blockquote>
<p>Right now hovering over the <code>_</code> says "A placeholder term, to be synthesized by unification."; but it sounds like that's wrong in this case, and it's actually inferred by TC search?</p>
</blockquote>
<p>Ah, that's true. It comes back to the discussion between <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and me whether the hover text should be taken from the parser or the elaborator, haha. Indeed only the parenthesized <code>_</code> has an elaborator attached.</p>



<a name="313949922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313949922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313949922">(Dec 05 2022 at 12:14)</a>:</h4>
<p>Not your question, but one difference I can explain: Lean 3 was literally unable to differentiate between <code>(_)</code> and <code>_</code> because it worked on an AST. In Lean 4 we could implement either semantics.</p>



<a name="313950876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313950876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313950876">(Dec 05 2022 at 12:20)</a>:</h4>
<p>as to <code>{...}</code>, I would say it makes it more consistent with regular application. I don't think it was a conscious breakage choice though.</p>



<a name="313951470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313951470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313951470">(Dec 05 2022 at 12:24)</a>:</h4>
<p>I think the key difference is that <code>{...}</code> (almost?) always knows the destination type in advance, so there will almost never be a situation where unification can't make progress and TC search is needed</p>



<a name="313951663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313951663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313951663">(Dec 05 2022 at 12:25)</a>:</h4>
<p>It's particularly bad for nested types like <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom">docs#ring_hom</a> with complicated inheritance heirarchies which can't be written as <code>@RingHom.mk R R (id _) _ id _ _ _ _</code> like they can in Lean3 with old structures, but have to be written as lots of painful nested applications of <code>MonoidHom.mk</code>, <code>OneHom.mk</code>, etc</p>



<a name="313952899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313952899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313952899">(Dec 05 2022 at 12:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/313951470">said</a>:</p>
<blockquote>
<p>I think the key difference is that <code>{...}</code> (almost?) always knows the destination type in advance</p>
</blockquote>
<p>Right, but there can still be constructor instance arguments that cannot be inferred from the expected type. Lean 4 does not differentiate between those cases.</p>



<a name="313952985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/313952985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#313952985">(Dec 05 2022 at 12:33)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> has thought more about unification vs. TC inference, we should probably wait for him</p>



<a name="314577074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314577074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314577074">(Dec 07 2022 at 23:18)</a>:</h4>
<p>Any thoughts, <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>?</p>



<a name="314579429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314579429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314579429">(Dec 07 2022 at 23:40)</a>:</h4>
<p>Are we really doing this a lot?  (I assume this is what the thread is about.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">m₁</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">m₂</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">MyHom</span> <span class="n">M</span> <span class="n">M</span> <span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span> <span class="o">}</span>  <span class="c1">-- fails</span>
</code></pre></div>
<p>Having different instances for the same type is going to break a lot.  This is not the only place where we assume that we can just resynthesize them.</p>



<a name="314581194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314581194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314581194">(Dec 08 2022 at 00:00)</a>:</h4>
<p>My guess is that this might come up in topology or measure theory, where we switch between having a canonical measure / topological space found via typeclass search, and having two different such objects on the same type</p>



<a name="314581270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314581270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314581270">(Dec 08 2022 at 00:00)</a>:</h4>
<p>Right now we're seeing it in things like <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid.ext">docs#monoid.ext</a> which are certainly the exception and not the rule</p>



<a name="314583235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314583235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314583235">(Dec 08 2022 at 00:21)</a>:</h4>
<p>I think any declaration you want to make that has two competing typeclasses, you should expect to have to write <code>@</code> on every single function, and give every implicit by hand. Perhaps we should even have a linter for that. :-)</p>



<a name="314583743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314583743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314583743">(Dec 08 2022 at 00:27)</a>:</h4>
<p>Can we come up with a case to justify the new behavior that fails in Lean 3 but succeeds in Lean 4?</p>



<a name="314584041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314584041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314584041">(Dec 08 2022 at 00:30)</a>:</h4>
<blockquote>
<p>I think any declaration you want to make that has two competing typeclasses, you should expect to have to write @ on every single function</p>
</blockquote>
<p>In this case though you already said "I'm going to construct a term of this weird <code>@MyHom M M m₁ m₂</code> type". It's very annoying that lean complains "oh it looks like you used <code>@MyHom.mk M M m₁ m₂</code>, but I found <code>@MyHom.mk M M m₂ m₂</code> even though that doesn't typecheck here, so I'm going to error"</p>



<a name="314584150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314584150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314584150">(Dec 08 2022 at 00:31)</a>:</h4>
<p>I think my claim is that typeclass arguments in constructor indices should be allowed to unify even if that disagrees with the result due to typeclass search, because there's no actual ambiguity present. I'd be happy to be proven wrong about that.</p>



<a name="314586601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314586601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314586601">(Dec 08 2022 at 01:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/314583235">said</a>:</p>
<blockquote>
<p>I think any declaration you want to make that has two competing typeclasses, you should expect to have to write <code>@</code> on every single function, and give every implicit by hand. Perhaps we should even have a linter for that. :-)</p>
</blockquote>
<p>This might be painful for e.g. <code>OrderDual</code>, <code>MulOpposite</code>.</p>



<a name="314702469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314702469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314702469">(Dec 08 2022 at 15:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/314583235">said</a>:</p>
<blockquote>
<p>I think any declaration you want to make that has two competing typeclasses, you should expect to have to write <code>@</code> on every single function, and give every implicit by hand. Perhaps we should even have a linter for that. :-)</p>
</blockquote>
<p>Actually, what would really be nice is if there were a way to refer to typeclass arguments by name in the same way that you can provide values of implicit arguments without <code>@</code> by using their names. The only question would be: what is the name?</p>



<a name="314703237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314703237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314703237">(Dec 08 2022 at 15:38)</a>:</h4>
<p>I've previously suggested <code>toString (‹ToString _› := ...)</code>, though I don't know how to find that conversation...</p>



<a name="314703269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314703269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314703269">(Dec 08 2022 at 15:38)</a>:</h4>
<p>I suggested a mechanism for this: instance implicits should, instead of getting the default name of hygienic "inst", get an unhygienic name which is the class name with initial downcase</p>



<a name="314703451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314703451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314703451">(Dec 08 2022 at 15:39)</a>:</h4>
<p>but that name should only be usable after the function is closed, not while it's in the local context</p>



<a name="314703542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314703542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314703542">(Dec 08 2022 at 15:39)</a>:</h4>
<p>That wouldn't help much in my example since I'm not calling a function in the first place, but trying to use <code>{ field := val }</code> notation</p>



<a name="314704263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314704263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314704263">(Dec 08 2022 at 15:43)</a>:</h4>
<p>It also seems like it might be of limited (but non-zero) value. For example, it may frequently be the case that there are two <code>topology</code> instances in the declaration (e.g., for a continuous function between two topological spaces), then how would either proposal allow you to change one but not the other? Perhaps the answer is: "then you have to use <code>@</code>", which is understandable, but it would be convenient if there were another way.</p>



<a name="314704538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314704538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314704538">(Dec 08 2022 at 15:44)</a>:</h4>
<p>well this is only the default, you can always name them manually</p>



<a name="314704683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314704683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314704683">(Dec 08 2022 at 15:45)</a>:</h4>
<p>the real thing it's trying to battle is the many many functions that use unnamed typeclass args (they are even linted against if you use names!) which make later attempts to use <code>(a := _)</code> notation impossible</p>



<a name="314704712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314704712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314704712">(Dec 08 2022 at 15:45)</a>:</h4>
<p>Right, but when you're calling declarations you wouldn't be able to name the variables (and likely you wouldn't want to in the original declaration).</p>



<a name="314704773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314704773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314704773">(Dec 08 2022 at 15:45)</a>:</h4>
<p>You can though?</p>



<a name="314704964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314704964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314704964">(Dec 08 2022 at 15:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="k">#check</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- ok</span>
<span class="k">#check</span> <span class="n">foo</span> <span class="o">(</span><span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- error</span>
</code></pre></div>
<p>parameter names are observable in lean 4</p>



<a name="314705033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314705033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314705033">(Dec 08 2022 at 15:46)</a>:</h4>
<p>That's not what I mean, one moment.</p>



<a name="314705354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314705354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314705354">(Dec 08 2022 at 15:48)</a>:</h4>
<p>Actually, I think you said it already "the many many functions that use unnamed typeclass args"</p>



<a name="314705427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314705427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314705427">(Dec 08 2022 at 15:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">[</span><span class="n">ToString</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">toString</span> <span class="c1">-- this should remain an error</span>
<span class="kd">def</span> <span class="n">bar1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">[</span><span class="n">toString</span> <span class="o">:</span> <span class="n">ToString</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">bar2</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">[</span><span class="n">ToString</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">x</span>

<span class="k">#check</span> <span class="n">bar1</span> <span class="o">(</span><span class="n">toString</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">)</span> <span class="c1">-- ok</span>
<span class="k">#check</span> <span class="n">bar2</span> <span class="o">(</span><span class="n">toString</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">)</span> <span class="c1">-- I want this to work too</span>
</code></pre></div>



<a name="314705624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314705624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314705624">(Dec 08 2022 at 15:49)</a>:</h4>
<p>Yes, making <code>bar2</code> work is exactly what I mean. Perhaps I wasn't clear before.</p>



<a name="314705913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314705913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314705913">(Dec 08 2022 at 15:51)</a>:</h4>
<p>It's also possible for names to be disambiguated, e.g. <code>topology</code> and <code>topology_1</code>, although I don't love it and would probably start naming stuff explicitly if it came up</p>



<a name="314706372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314706372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314706372">(Dec 08 2022 at 15:53)</a>:</h4>
<p>This would also be nice for <code>Ord</code> and <code>BEq</code> and such, where you occasionally want to override the default order.</p>



<a name="314706890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314706890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314706890">(Dec 08 2022 at 15:55)</a>:</h4>
<p>Right. If we don't do something like this, I think we will need to change the recommended practice for libraries like Std to use named instances everywhere and it seems like boilerplate</p>



<a name="314710424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314710424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314710424">(Dec 08 2022 at 16:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax/near/314704263">said</a>:</p>
<blockquote>
<p>For example, it may frequently be the case that there are two <code>topology</code> instances in the declaration (e.g., for a continuous function between two topological spaces), then how would either proposal allow you to change one but not the other?</p>
</blockquote>
<p>If the two instances differ in their types, you can put those inside the <code>‹_›</code>. The lookup logic is supposed to be the same as for the term syntax.</p>



<a name="314919783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314919783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314919783">(Dec 09 2022 at 15:28)</a>:</h4>
<p>Can we maybe have a compromise here where <code>@!MyHom.mk id</code> is short for <code>@MyHom.mk (_) (_) (_) (_) id</code>, that is "invoke using unification to solve typeclass arguments"</p>



<a name="314919912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%60%28_%29%60%20vs%20%60_%60%20syntax/near/314919912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.60(_).60.20vs.20.60_.60.20syntax.html#314919912">(Dec 09 2022 at 15:28)</a>:</h4>
<p>This came up again in a different context <a href="#narrow/stream/287929-mathlib4/topic/Type.20synonyms/near/314917223">here</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
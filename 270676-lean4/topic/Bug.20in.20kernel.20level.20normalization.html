---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html">Bug in kernel level normalization</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="304823172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/304823172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Parth Shastri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#304823172">(Oct 18 2022 at 19:10)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/blob/084a173a47266b5c108dae1ba721bb22149843bd/src/kernel/level.cpp#L492-L496">https://github.com/leanprover/lean4/blob/084a173a47266b5c108dae1ba721bb22149843bd/src/kernel/level.cpp#L492-L496</a></p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">level</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_offset</span><span class="p">(</span><span class="n">l</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">level</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">kind</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">level_kind</span><span class="o">::</span><span class="no">IMax</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">imax_lhs</span><span class="p">(</span><span class="n">r</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">imax_rhs</span><span class="p">(</span><span class="n">r</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">mk_imax</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="w"> </span><span class="n">l2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The result only takes into consideration the level offset <code>p.first</code> and not the offset <code>p.second</code>. The corresponding code in lean includes <code>addOffset</code>, which is missing here:<br>
<a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Level.lean#L380-L382">https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Level.lean#L380-L382</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>        <span class="k">let</span> <span class="n">l₁</span> <span class="o">:=</span> <span class="n">normalize</span> <span class="n">l₁</span>
        <span class="k">let</span> <span class="n">l₂</span> <span class="o">:=</span> <span class="n">normalize</span> <span class="n">l₂</span>
        <span class="n">addOffset</span> <span class="o">(</span><span class="n">mkIMaxAux</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">k</span>
</code></pre></div>
<p>I believe the correct code should be <code>return mk_succ(mk_imax(l1, l2), p.second);</code>.</p>
<p>A consequence of this is that the following code</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Unit</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>
<p>results in this error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">kernel</span><span class="o">)</span> <span class="n">declaration</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="bp">'</span><span class="n">_example'</span> <span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="mi">0</span> <span class="o">(</span><span class="n">imax</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span>
<span class="n">but</span> <span class="n">it</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="o">(</span><span class="n">imax</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>
<p>The type of the value is <code>Sort (imax 1 (imax u v + 1))</code>, which the Lean version correctly simplifies to <code>Sort (imax u v + 1) = Type (imax u v)</code>. However, the kernel seems to incorrectly simplify it to <code>Sort (max 1 (imax u v))</code>, where the <code>+ 1</code> is missing (I'm not entirely sure where the <code>max 0</code> is coming from).</p>
<p>(On a side note, is there any way to pass a term directly to the kernel without the intermediate type checking step done in Lean?)</p>



<a name="306163438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306163438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Parth Shastri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306163438">(Oct 26 2022 at 04:28)</a>:</h4>
<p>I figured out how to directly send declarations to the kernel.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"kdef "</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">".{"</span> <span class="n">ident</span><span class="o">,</span><span class="bp">+</span> <span class="s2">"}"</span><span class="o">)</span><span class="bp">?</span> <span class="s2">" : "</span> <span class="n">term</span> <span class="s2">" := "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">command</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Command</span> <span class="n">Term</span> <span class="k">in</span>
<span class="n">elab_rules</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">kdef</span> <span class="bp">$</span><span class="n">name</span> <span class="bp">$</span><span class="o">[</span><span class="bp">.</span><span class="o">{</span> <span class="bp">$</span><span class="n">levelParams</span><span class="bp">?</span><span class="o">,</span><span class="bp">*</span> <span class="o">}]</span><span class="bp">?</span> <span class="o">:</span> <span class="bp">$</span><span class="n">type</span> <span class="o">:=</span> <span class="bp">$</span><span class="n">value</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">levelParams</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="k">let</span> <span class="n">some</span> <span class="n">levelParams</span> <span class="o">:=</span> <span class="n">levelParams</span><span class="bp">?</span>
    <span class="k">then</span> <span class="n">levelParams.getElems.toList.map</span> <span class="o">(</span><span class="bp">·.</span><span class="n">getId</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">[]</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="bp">←</span> <span class="n">runTermElabM</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="n">setLevelNames</span> <span class="n">levelParams</span>
    <span class="k">let</span> <span class="n">type</span> <span class="bp">←</span> <span class="n">elabTermAndSynthesize</span> <span class="n">type</span> <span class="n">none</span>
    <span class="k">let</span> <span class="n">value</span> <span class="bp">←</span> <span class="n">elabTermAndSynthesize</span> <span class="n">value</span> <span class="n">none</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>
  <span class="n">liftCoreM</span> <span class="bp">&lt;|</span> <span class="n">addDecl</span> <span class="bp">&lt;|</span> <span class="bp">.</span><span class="n">defnDecl</span> <span class="o">{</span>
    <span class="n">name</span> <span class="o">:=</span> <span class="n">name.getId</span>
    <span class="n">levelParams</span>
    <span class="n">type</span>
    <span class="n">value</span>
    <span class="n">hints</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">abbrev</span>
    <span class="n">safety</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">safe</span>
  <span class="o">}</span>
</code></pre></div>
<p>I'm curious if it is possible to provide a proof of <code>False</code> with this. We can already define a term <code>e := Sort l₁</code> such that <code>e := Sort l₂</code> for any constants <code>l₁</code> and <code>l₂</code>, though I'm unsure of how Girard's paradox could be implemented.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">kdef</span> <span class="n">bug'.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="n">u</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">bug</span> <span class="o">:=</span> <span class="n">bug'.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>

<span class="k">#check</span> <span class="n">bug</span>      <span class="c1">-- bug : Type 1</span>
<span class="k">#reduce</span> <span class="n">bug</span>     <span class="c1">-- Type</span>
</code></pre></div>



<a name="306166165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306166165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306166165">(Oct 26 2022 at 05:07)</a>:</h4>
<p>No, <code>addDecl</code> goes to the kernel, and the kernel checks that things are valid for the type theory, so you should not be able to prove <code>False</code> if lean is consistent</p>



<a name="306166311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306166311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306166311">(Oct 26 2022 at 05:09)</a>:</h4>
<p>(To be clear, this all typechecks in Lean4 nightly; I think Parth found a consistency bug, albeit a small one)</p>



<a name="306166484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306166484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306166484">(Oct 26 2022 at 05:11)</a>:</h4>
<p>Although, since the environment is itself implemented in lean I think you can bypass the kernel by calling <code>Environment.add</code> instead of <code>addDecl</code></p>



<a name="306169266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306169266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306169266">(Oct 26 2022 at 05:44)</a>:</h4>
<p>Great, I knew I proved <a href="https://cs.brown.edu/courses/cs1951x/docs/logic/girard.html">girard's paradox</a> for a reason. (Thanks mathport!)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="n">syntax</span> <span class="s2">"kdef "</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">".{"</span> <span class="n">ident</span><span class="o">,</span><span class="bp">+</span> <span class="s2">"}"</span><span class="o">)</span><span class="bp">?</span> <span class="s2">" : "</span> <span class="n">term</span> <span class="s2">" := "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">command</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Command</span> <span class="n">Term</span> <span class="k">in</span>
<span class="n">elab_rules</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">kdef</span> <span class="bp">$</span><span class="n">name</span> <span class="bp">$</span><span class="o">[</span><span class="bp">.</span><span class="o">{</span> <span class="bp">$</span><span class="n">levelParams</span><span class="bp">?</span><span class="o">,</span><span class="bp">*</span> <span class="o">}]</span><span class="bp">?</span> <span class="o">:</span> <span class="bp">$</span><span class="n">type</span> <span class="o">:=</span> <span class="bp">$</span><span class="n">value</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">levelParams</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="k">let</span> <span class="n">some</span> <span class="n">levelParams</span> <span class="o">:=</span> <span class="n">levelParams</span><span class="bp">?</span>
    <span class="k">then</span> <span class="n">levelParams.getElems.toList.map</span> <span class="o">(</span><span class="bp">·.</span><span class="n">getId</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">[]</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="bp">←</span> <span class="n">runTermElabM</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="n">setLevelNames</span> <span class="n">levelParams</span>
    <span class="k">let</span> <span class="n">type</span> <span class="bp">←</span> <span class="n">elabTermAndSynthesize</span> <span class="n">type</span> <span class="n">none</span>
    <span class="k">let</span> <span class="n">value</span> <span class="bp">←</span> <span class="n">elabTermAndSynthesize</span> <span class="n">value</span> <span class="n">none</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>
  <span class="n">liftCoreM</span> <span class="bp">&lt;|</span> <span class="n">addDecl</span> <span class="bp">&lt;|</span> <span class="bp">.</span><span class="n">defnDecl</span> <span class="o">{</span>
    <span class="n">name</span> <span class="o">:=</span> <span class="n">name.getId</span>
    <span class="n">levelParams</span>
    <span class="n">type</span>
    <span class="n">value</span>
    <span class="n">hints</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">abbrev</span>
    <span class="n">safety</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">safe</span>
  <span class="o">}</span>

<span class="n">kdef</span> <span class="n">Univ'.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">Univ</span> <span class="o">:=</span> <span class="n">Univ'.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">Univ</span> <span class="o">:</span> <span class="n">Univ</span><span class="o">)</span> <span class="c1">-- !!!</span>

<span class="n">abbrev</span> <span class="n">Set</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">syntax</span> <span class="s2">"{"</span> <span class="n">ident</span> <span class="o">(</span><span class="s2">":"</span> <span class="n">term</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"|"</span> <span class="n">term</span> <span class="s2">"}"</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">({</span><span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">ty</span><span class="o">]</span><span class="bp">?|</span> <span class="bp">$</span><span class="n">p</span><span class="o">})</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">λ</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">ty</span><span class="o">]</span><span class="bp">?</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">p</span><span class="o">)</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">x</span> <span class="bp">∈</span> <span class="bp">$</span><span class="n">p</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">p</span> <span class="bp">$</span><span class="n">x</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">iff_of_eq</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">e</span> <span class="bp">▸</span> <span class="bp">.</span><span class="n">rfl</span>

<span class="sd">/-- **Girard's paradox**: there are no universes `u` such that `Type u : Type u`.</span>
<span class="sd">Since we can't actually change the type of Lean's `Π` operator, we assume the existence of</span>
<span class="sd">`pi`, `lam`, `app` and the `beta` rule equivalent to the `Π` and `app` constructors of type theory.</span>
<span class="sd">-/</span>
<span class="kd">theorem</span> <span class="n">girard</span>
    <span class="o">(</span><span class="n">pi</span> <span class="o">:</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
    <span class="o">(</span><span class="n">lam</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pi</span> <span class="n">A</span><span class="o">)</span>
    <span class="o">(</span><span class="n">app</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span><span class="o">},</span> <span class="n">pi</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="n">beta</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">app</span> <span class="o">(</span><span class="n">lam</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">False</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">F</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">X</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">U</span> <span class="o">:=</span> <span class="n">pi</span> <span class="n">F</span>
  <span class="k">let</span> <span class="n">G</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">U</span><span class="o">))</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="n">X</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="o">{</span> <span class="n">p</span> <span class="bp">|</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">app</span> <span class="n">x</span> <span class="n">X</span> <span class="n">f</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">p</span> <span class="o">}</span> <span class="bp">∈</span> <span class="n">T</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">τ</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">U</span><span class="o">))</span> <span class="o">:</span> <span class="n">U</span> <span class="o">:=</span> <span class="n">lam</span> <span class="o">(</span><span class="n">G</span> <span class="n">T</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">σ</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="n">S</span> <span class="n">U</span> <span class="n">τ</span>
  <span class="k">have</span> <span class="n">στ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">s</span> <span class="n">S</span><span class="o">},</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">σ</span> <span class="o">(</span><span class="n">τ</span> <span class="n">S</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">}</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span> <span class="bp">@</span><span class="k">fun</span> <span class="n">s</span> <span class="n">S</span> <span class="bp">=&gt;</span>
    <span class="n">iff_of_eq</span> <span class="o">(</span><span class="n">congrArg</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">=&gt;</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">τ</span><span class="o">)</span> <span class="o">(</span><span class="n">beta</span> <span class="o">(</span><span class="n">G</span> <span class="n">S</span><span class="o">)</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">_</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">ω</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">δ</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">(</span><span class="n">Set</span> <span class="n">U</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">τ</span> <span class="n">S</span> <span class="bp">∈</span> <span class="n">p</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">δ</span> <span class="n">ω</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">p</span> <span class="n">d</span> <span class="bp">=&gt;</span> <span class="n">d</span> <span class="o">(</span><span class="n">τ</span> <span class="n">ω</span><span class="o">)</span> <span class="bp">&lt;|</span> <span class="n">στ.2</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">d</span> <span class="o">(</span><span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">στ.2</span> <span class="n">h</span><span class="o">)</span>
  <span class="n">this</span> <span class="o">{</span> <span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span><span class="n">δ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">y</span><span class="o">)</span> <span class="o">}</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">e</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">_</span> <span class="n">e</span> <span class="k">fun</span> <span class="n">p</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">_</span> <span class="o">(</span><span class="n">στ.1</span> <span class="n">h</span><span class="o">))</span> <span class="k">fun</span> <span class="n">p</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">this</span> <span class="n">_</span> <span class="o">(</span><span class="n">στ.1</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">contradiction</span> <span class="o">:</span> <span class="n">False</span> <span class="o">:=</span> <span class="n">girard</span>
  <span class="o">(</span><span class="n">pi</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">F</span> <span class="bp">=&gt;</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">Univ</span> <span class="o">:</span> <span class="n">Univ</span><span class="o">),</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">lam</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">f</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">app</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">f</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">beta</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="o">)</span>

<span class="k">#print</span> <span class="kd">axioms</span> <span class="n">contradiction</span>
<span class="c1">-- 'contradiction' does not depend on any axioms</span>
</code></pre></div>



<a name="306170110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306170110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306170110">(Oct 26 2022 at 05:56)</a>:</h4>
<p>It would be nice to try this out on an external checker. cc: <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>, does trepplein work on lean 4 proofs?</p>



<a name="306170140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306170140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306170140">(Oct 26 2022 at 05:57)</a>:</h4>
<p>The analogous code fails as expected in lean 3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">tactic</span> <span class="n">level</span> <span class="n">expr</span>

<span class="k">#eval</span> <span class="k">do</span>
  <span class="n">add_decl</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="bp">`</span><span class="n">bad'</span> <span class="o">[</span><span class="bp">`</span><span class="n">u</span><span class="o">]</span>
    <span class="o">(</span><span class="n">sort</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">imax</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="o">(</span><span class="n">param</span> <span class="bp">`</span><span class="n">u</span><span class="o">))))</span>
    <span class="o">(</span><span class="n">sort</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">imax</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="o">(</span><span class="n">param</span> <span class="bp">`</span><span class="n">u</span><span class="o">)))))</span>
    <span class="n">reducibility_hints.abbrev</span>
    <span class="n">ff</span><span class="o">)</span>
<span class="c1">-- type mismatch at definition 'bad'', has type</span>
<span class="c1">--   Type ((imax 1 u)+2)</span>
<span class="c1">-- but is expected to have type</span>
<span class="c1">--   Type (imax 1 u)</span>
</code></pre></div>



<a name="306175864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306175864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306175864">(Oct 26 2022 at 06:59)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/pull/1781">lean4#1781</a></p>



<a name="306276132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306276132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rish Vaishnav <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306276132">(Oct 26 2022 at 16:09)</a>:</h4>
<p>FWIW, our <a href="https://github.com/yatima-inc/yatima-lang/tree/f5927f39681fec02dfda2e9efcee161b74d1a68f/Yatima/Typechecker">WIP Yatima typechecker</a> (based on NbE) that I'm working on with <span class="user-mention" data-user-id="436006">@Gabriel Barreto</span> seems to (correctly?) fail at the definition of <code>Univ'</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">×</span> <span class="n">contradiction</span> <span class="o">(</span><span class="kd">theorem</span><span class="o">)</span> <span class="n">typechecks</span>
    <span class="n">Expected</span> <span class="bp">'</span><span class="s2">"ok _"</span><span class="bp">'</span> <span class="n">but</span> <span class="n">got</span> <span class="bp">'</span><span class="s2">"error Expected (Sort 1+(imax 1 (u#0))), found (Sort 2+(imax 1 (u#0)))"</span><span class="bp">'</span>
<span class="bp">×</span> <span class="n">Univ</span> <span class="o">(</span><span class="kd">definition</span><span class="o">)</span> <span class="n">typechecks</span>
    <span class="n">Expected</span> <span class="bp">'</span><span class="s2">"ok _"</span><span class="bp">'</span> <span class="n">but</span> <span class="n">got</span> <span class="bp">'</span><span class="s2">"error Expected (Sort 1+(imax 1 (u#0))), found (Sort 2+(imax 1 (u#0)))"</span><span class="bp">'</span>
<span class="bp">×</span> <span class="n">Univ'</span> <span class="o">(</span><span class="kd">definition</span><span class="o">)</span> <span class="n">typechecks</span>
   <span class="n">Expected</span> <span class="bp">'</span><span class="s2">"ok _"</span><span class="bp">'</span> <span class="n">but</span> <span class="n">got</span> <span class="bp">'</span><span class="s2">"error Expected (Sort 1+(imax 1 (u#0))), found (Sort 2+(imax 1 (u#0)))"</span><span class="bp">'</span>
</code></pre></div>



<a name="306276945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug%20in%20kernel%20level%20normalization/near/306276945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rish Vaishnav <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Bug.20in.20kernel.20level.20normalization.html#306276945">(Oct 26 2022 at 16:12)</a>:</h4>
<p>(this was from a commit where we just got the prelude to typecheck, we're in the midst of a refactor right now)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
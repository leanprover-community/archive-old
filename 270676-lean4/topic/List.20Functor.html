---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/List.20Functor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html">List Functor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="261700339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/261700339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#261700339">(Nov 16 2021 at 20:14)</a>:</h4>
<p>I was writing some code that tried to map on a list haskell style like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">foo</span>
</code></pre></div>
<p>and my Lean complains that List has no Functor instance? Is this correct? If so why doesn't it have one it seems like a rather trivial instance to me.</p>



<a name="261736966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/261736966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#261736966">(Nov 17 2021 at 02:35)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span>  The <code>Functor</code>/<code>Applicative</code>/<code>Monad</code> classes in Lean are considered control flow classes for control types like <code>OptionM</code>/<code>ExceptM</code>/etc. Data types (like <code>Option</code>/<code>Except</code>/<code>List</code>) do not implement them (to prevent them two from being confused). This allows for much better type inference and predictable behavior in the <code>do</code> notation.</p>



<a name="261737063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/261737063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#261737063">(Nov 17 2021 at 02:36)</a>:</h4>
<p>There is a decent argument, though, that <code>Functor</code> should not be included in this (or there should be a data version), since <code>map</code> is  used quote often in pure programming..</p>



<a name="261751027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/261751027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#261751027">(Nov 17 2021 at 07:30)</a>:</h4>
<p>The regular <code>Option</code> type does already seem to implement <code>Functor</code>: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44">https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44</a> so I guess it would be valid to just do it for <code>List</code> as well in this case?</p>



<a name="290365781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290365781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> cognivore <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290365781">(Jul 21 2022 at 11:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/261736966">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span>  The <code>Functor</code>/<code>Applicative</code>/<code>Monad</code> classes in Lean are considered control flow classes for control types like <code>OptionM</code>/<code>ExceptM</code>/etc. Data types (like <code>Option</code>/<code>Except</code>/<code>List</code>) do not implement them (to prevent the two from being confused). This allows for much better type inference and predictable behavior in the <code>do</code> notation.</p>
</blockquote>
<p>My 2c: <code>List Option</code> is a great model for a continuation-passing-style computation.</p>
<p>One of the bigger "patterns" in ML-style FP is the pattern of describing a computation in one place (and in composable manner) and running it in another. List is a great, albeit a little bit primitive, way to describe computations.</p>



<a name="290368765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290368765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290368765">(Jul 21 2022 at 12:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/261751027">said</a>:</p>
<blockquote>
<p>The regular <code>Option</code> type does already seem to implement <code>Functor</code>: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44">https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44</a> so I guess it would be valid to just do it for <code>List</code> as well in this case?</p>
</blockquote>
<p>Yes, <code>Option</code> implements <code>Monad</code> at master. <code>OptionM</code> is gone. See discussion at <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084</a><br>
Regarding <code>Monad List</code>, it would be great to have more feedback from our user base because Lean is a strict language.</p>



<a name="290369129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290369129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290369129">(Jul 21 2022 at 12:32)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Regarding <code>Functor List</code>, please feel free to submit a PR.</p>



<a name="290370886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290370886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290370886">(Jul 21 2022 at 12:49)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/pull/1338/files">https://github.com/leanprover/lean4/pull/1338/files</a></p>



<a name="290373368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290373368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290373368">(Jul 21 2022 at 13:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/290368765">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/261751027">said</a>:</p>
<blockquote>
<p>The regular <code>Option</code> type does already seem to implement <code>Functor</code>: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44">https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44</a> so I guess it would be valid to just do it for <code>List</code> as well in this case?</p>
</blockquote>
<p>Yes, <code>Option</code> implements <code>Monad</code> at master. <code>OptionM</code> is gone. See discussion at <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084</a><br>
Regarding <code>Monad List</code>, it would be great to have more feedback from our user base because Lean is a strict language.</p>
</blockquote>
<p>The one advantage of having <code>Monad List</code> (as with <code>Monad Option</code>) is that this is a familiar type and gives a very good example of Monads for a mathematical audience for whom meta-programming examples may be too complex (and encoding effects may seem artificial).</p>
<p>I am just saying this as an argument in one direction -- arguments the other way may be stronger.</p>



<a name="290383219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290383219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290383219">(Jul 21 2022 at 14:33)</a>:</h4>
<p>The issue with <code>Monad List</code> is not that <code>List</code> isn't a monad / acts as an example monad, but rather that it has completely different strictness behavior than it does in e.g. Haskell which makes it unsuitable for use as a "nondeterminism" monad</p>



<a name="290383301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290383301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290383301">(Jul 21 2022 at 14:33)</a>:</h4>
<p>and giving it a monad structure could result in unexpected results for folks expecting the haskell behavior</p>



<a name="290392474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290392474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290392474">(Jul 21 2022 at 15:39)</a>:</h4>
<blockquote>
<p>rather that it has completely different strictness behavior than it does in e.g. Haskell</p>
</blockquote>
<p>I'm not sure I understand this part.  The only time the strictness differs is if you only look at, say, the first element (<code>head (do { x &lt;- [1..10^10]; pure (x+1) })</code>).  That doesn't work in Lean because the resulting list is evaluated strictly, <em>like every other list in Lean</em>.  If you do <code>println do ...</code> then both Haskell and Lean behave the same AFAICT.</p>



<a name="290398682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290398682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290398682">(Jul 21 2022 at 16:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/290383219">said</a>:</p>
<blockquote>
<p>The issue with <code>Monad List</code> is not that <code>List</code> isn't a monad / acts as an example monad, but rather that it has completely different strictness behavior than it does in e.g. Haskell which makes it unsuitable for use as a "nondeterminism" monad</p>
</blockquote>
<p>One can safely assume that those who "expect Haskell behaviour" are rather skilled. On the other hand mathematicians knowing not much programming can use a simple example of a Monad.</p>



<a name="290399266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290399266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290399266">(Jul 21 2022 at 16:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I think the order of evaluation of the bind functions is also different, although possibly this is not observable since we would only be able to use non-monadic functions in this situation</p>



<a name="290399602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290399602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290399602">(Jul 21 2022 at 16:28)</a>:</h4>
<p>Okay, that seems plausible.  But "does the same pure computations only in an unexpected order" is a rather weak argument against <code>Monad List</code> though.</p>



<a name="290401788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290401788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290401788">(Jul 21 2022 at 16:44)</a>:</h4>
<p>In my eyes, the only good argument against <code>Monad List</code> and <code>Monad Array</code> is that they have subpar performance (compared to <code>Monad DList</code> and <code>Monad DArray</code>).  But that is also true of the Haskell version if you don't have stream fusion.</p>



<a name="290413991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290413991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290413991">(Jul 21 2022 at 18:21)</a>:</h4>
<p>One reason for <code>Monad List</code> is that it's the basis for list comprehensions, which many strict languages (like Python) have. Python for example also has generator comprehensions for the lazy version, so it's possible for practitioners to be able to handle strictness issues.</p>



<a name="290415708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290415708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290415708">(Jul 21 2022 at 18:35)</a>:</h4>
<p>It uses separate syntax for both cases though. So that's not an argument for <code>List</code> satisfying a generic abstraction.</p>



<a name="290416036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290416036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290416036">(Jul 21 2022 at 18:37)</a>:</h4>
<p>That's true, but what I meant is that you could choose to use <code>Monad LazyList</code> when you want a lazy version, which is vaguely similar to choosing to use square brackets or parentheses in Python.</p>



<a name="290416189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290416189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290416189">(Jul 21 2022 at 18:39)</a>:</h4>
<p>It'd fair having a separate class for comprehensions (and specialized syntax to go with it) instead of using <code>Monad</code>.</p>



<a name="290416717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290416717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290416717">(Jul 21 2022 at 18:42)</a>:</h4>
<p>To move the discussion forward, it would probably help to provide specific use cases where <code>Monad List</code> would be useful</p>



<a name="290431128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290431128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290431128">(Jul 21 2022 at 20:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/290392474">said</a>:</p>
<blockquote>
<p>If you do <code>println do ...</code> then both Haskell and Lean behave the same AFAICT.</p>
</blockquote>
<p>From my experience, it's not exactly out of order evaluation, but rather that intermediate lists will be computed and stored in memory prior to invoking <code>println</code>.   I remember at one point naively translating some Haskell List monad code to Lean and immediately hitting out-of-memory issues.</p>
<p>That said, I think <code>Monad List</code> is a good idea in Lean.  I don't have a particular use case in mind at the moment, but it's just nice to be able to generate and transform lists using <code>do</code> notation.</p>



<a name="290433574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290433574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290433574">(Jul 21 2022 at 21:00)</a>:</h4>
<p>I have made use of <code>Monad List</code> for unit tests. (<code>Monad Array</code> is essentially the same but I feel like the strict semantics are more expected in that context.) I think that the "unusual" evaluation order may be a paper cut, but I think it's worthwhile to have despite this, and we should just teach people to use <code>LazyList</code> if they want the haskell style nondeterminism monad</p>



<a name="290433849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290433849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290433849">(Jul 21 2022 at 21:03)</a>:</h4>
<p>Stuff like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="k">do</span>
  <span class="n">a</span> <span class="bp">←</span> <span class="n">list.range</span> <span class="mi">5</span><span class="o">,</span>
  <span class="n">b</span> <span class="bp">←</span> <span class="n">list.range</span> <span class="mi">5</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">-</span> <span class="mi">2</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">b</span> <span class="bp">-</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">guard</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">a</span> <span class="bp">%</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">int.nat_abs</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">pure</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="c1">-- [(0, 0), (1, 0), (2, 0)]</span>
</code></pre></div>



<a name="290440285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290440285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290440285">(Jul 21 2022 at 22:07)</a>:</h4>
<p>One confusion I have always had with <code>Monad List</code> is that there are actually a variety of monad-like operations (not all of which are lawful) that can be defined on aggregate types like <code>List</code> -- list comprehension is just one of them. So having there be a specific <code>Monad List</code> instance strikes me as off.</p>



<a name="290440644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290440644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290440644">(Jul 21 2022 at 22:11)</a>:</h4>
<p>For instance, one can define the monad function <code>seq : (fs : List (a -&gt; b)) -&gt; (as : List a) -&gt; List b</code> to be such that <code>bs[i] = fs[i] a[i]</code>.</p>



<a name="290450593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290450593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290450593">(Jul 22 2022 at 00:17)</a>:</h4>
<p>I think list comprehension is the instance most people want most of the time, which is why it's become a common language feature elsewhere</p>
<p>Also, isn't there a slick way to specify a monad instance at the call site? List comprehension can be the typeclass instance, and I don't think that severely inhibits people using other monad instances on lists</p>



<a name="290451305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290451305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290451305">(Jul 22 2022 at 00:29)</a>:</h4>
<p>Personally, I have found most list comprehension code I have seen to be completely incomprehensible. The special syntax most languages have for it  doesn't help readability (as it tends to aim for conciseness rather intuitiveness). And this coming from someone who likes the functional paradigm (and, in some places, considers it more intuitive than its imperative equivalent), which is already stigmatized in CS as been difficulty to understand.</p>
<p>For instance, it took me a number of re-reads of Mario's example to figure out what it was doing and how it got the answer it got.</p>



<a name="290451459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290451459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290451459">(Jul 22 2022 at 00:32)</a>:</h4>
<p>However, I guess that is all just matter of taste and not really a relevant objective criticism of <code>Monad List</code>.</p>



<a name="290451848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290451848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290451848">(Jul 22 2022 at 00:38)</a>:</h4>
<p>I agree to some extent... scala's <code>for</code> syntax always felt more comprehensible to my brain because it triggered my "iteration is happening" senses <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="290452386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290452386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290452386">(Jul 22 2022 at 00:47)</a>:</h4>
<p>I don't know about Haskell or Scala, but list comprehension in python is wonderful and very readable. I'd love to have that in Lean.</p>



<a name="290454279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290454279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290454279">(Jul 22 2022 at 01:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/290452386">said</a>:</p>
<blockquote>
<p>but list comprehension in python is wonderful and very readable. </p>
</blockquote>
<p>Sadly, I disagree. I am acclimatized to the CS <code>for</code> were the order is <code>for x in iterable do expression</code> and Python putting the expression first in its list comprehensions always throws me off. However, the ordering in Python is more like math where <code>{x i in S s.t. expression}</code> is the natural order so I can understand why others (especially mathematicians) would find it intuitive.</p>



<a name="290454310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290454310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290454310">(Jul 22 2022 at 01:25)</a>:</h4>
<p>I know you disagree, this is why I wrote my message bringing a different perspective.</p>



<a name="290454373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290454373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290454373">(Jul 22 2022 at 01:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Oh, sorry! How did you know that? I did not mention Python in my original critique?</p>



<a name="290454503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290454503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290454503">(Jul 22 2022 at 01:28)</a>:</h4>
<p>I've noticed for a very long time that your programming taste is orthogonal to python and mathematics <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="290454687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290454687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290454687">(Jul 22 2022 at 01:32)</a>:</h4>
<p>Ah, fair enough. <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span>  That may be a bit extreme though, I did originally find Lean by looking for a theorem prover to  try some mathematical proofs. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="290454721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290454721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290454721">(Jul 22 2022 at 01:33)</a>:</h4>
<p>Though, I guess that could count as the point/line were the two orthogonal lines/planes cross.</p>



<a name="290455044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290455044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290455044">(Jul 22 2022 at 01:40)</a>:</h4>
<p>Right now I'm writing Lean 4 code where I really wish I could use a python list comprehension</p>



<a name="290455415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290455415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290455415">(Jul 22 2022 at 01:49)</a>:</h4>
<p>I believe you can get away with some macro expansion for that</p>



<a name="290456697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290456697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290456697">(Jul 22 2022 at 02:15)</a>:</h4>
<p>Indeed you can:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"for "</span> <span class="n">term</span> <span class="s2">" in "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"if "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">compClause</span>

<span class="n">syntax</span> <span class="s2">"["</span> <span class="n">term</span> <span class="s2">" | "</span> <span class="n">compClause</span><span class="o">,</span><span class="bp">*</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span>

<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">])</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">t</span><span class="o">)</span> <span class="bp">$</span><span class="n">xs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="k">if</span> <span class="bp">$</span><span class="n">x</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="k">if</span> <span class="bp">$</span><span class="n">x</span> <span class="k">then</span> <span class="o">[</span><span class="bp">$</span><span class="n">t</span><span class="o">]</span> <span class="k">else</span> <span class="o">[])</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">,</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.join</span> <span class="o">[[</span><span class="bp">$</span><span class="n">t</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">]</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">])</span>

<span class="k">#eval</span> <span class="o">[</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="c1">-- [2, 3, 4]</span>
<span class="k">#eval</span> <span class="o">[</span><span class="mi">4</span> <span class="bp">|</span> <span class="k">if</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">]</span>
<span class="c1">-- []</span>
<span class="k">#eval</span> <span class="o">[</span><span class="mi">4</span> <span class="bp">|</span> <span class="k">if</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">]</span>
<span class="c1">-- [4]</span>
<span class="k">#eval</span> <span class="o">[(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">List.range</span> <span class="mi">5</span><span class="o">,</span> <span class="n">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">List.range</span> <span class="mi">5</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="mi">3</span><span class="o">]</span>
<span class="c1">-- [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]</span>
</code></pre></div>



<a name="290456701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290456701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290456701">(Jul 22 2022 at 02:15)</a>:</h4>
<p>For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="s2">"["</span> <span class="n">term</span><span class="o">:</span><span class="n">max</span> <span class="s2">" for "</span> <span class="n">term</span> <span class="s2">" in "</span> <span class="n">term</span> <span class="o">(</span><span class="s2">" if "</span> <span class="n">term</span><span class="o">)</span><span class="bp">?</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">a</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">xs</span> <span class="bp">|&gt;.</span><span class="n">map</span> <span class="k">fun</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">a</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span> <span class="k">if</span> <span class="bp">$</span><span class="n">c</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">xs</span> <span class="bp">|&gt;.</span><span class="n">filterMap</span> <span class="k">fun</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="bp">$</span><span class="n">c</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">$</span><span class="n">a</span> <span class="k">else</span> <span class="n">none</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">[(</span><span class="n">x</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">)</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">List.range</span> <span class="mi">5</span><span class="o">]</span> <span class="c1">-- [0, 2, 4, 6, 8]</span>
<span class="k">#eval</span> <span class="o">[(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="bp">#</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">]</span> <span class="c1">-- #[1, 3]</span>
</code></pre></div>



<a name="290456750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290456750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290456750">(Jul 22 2022 at 02:16)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> you literally posted that while I was pasting my example into the comment box. <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="290456913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290456913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290456913">(Jul 22 2022 at 02:20)</a>:</h4>
<p>I learned from yours that if you use <code>term</code> instead of <code>ident</code> that you can do pattern matching in the <code>for</code> clause. That's neat</p>



<a name="290457008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290457008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290457008">(Jul 22 2022 at 02:21)</a>:</h4>
<p>For sake of example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.prod</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">xs</span><span class="o">,</span> <span class="n">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">ys</span><span class="o">]</span>

<span class="k">#eval</span> <span class="o">[</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">|</span> <span class="n">for</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span> <span class="n">List.prod</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)]</span>
<span class="c1">-- [0, 0, 0, 0, 1, 2, 0, 2, 4]</span>
</code></pre></div>



<a name="290457100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290457100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290457100">(Jul 22 2022 at 02:23)</a>:</h4>
<p>Or, using the already defined <code>List.zip</code> <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">[(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="n">for</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span> <span class="n">List.zip</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)]</span>
<span class="c1">-- [0, 0, 0, 0, 1, 2, 0, 2, 4]; edit: actually [0, 1, 4]</span>
</code></pre></div>



<a name="290457205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290457205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290457205">(Jul 22 2022 at 02:25)</a>:</h4>
<p>I'm getting different output with <code>List.zip</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">[</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">|</span> <span class="n">for</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span> <span class="n">List.zip</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)]</span>
<span class="c1">-- [0, 1, 4]</span>
</code></pre></div>
<p>That's using the "diagonal monad" you mentioned earlier.</p>



<a name="290457267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290457267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290457267">(Jul 22 2022 at 02:26)</a>:</h4>
<p>You are correct, sorry.</p>



<a name="290458221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290458221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290458221">(Jul 22 2022 at 02:45)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> Still, that got me thinking, why not make list comprehension even more baffling and allow it to do zips too?</p>
<p>For example,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.zip'</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">[(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">|</span> <span class="bp">Δ</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">xs</span><span class="o">,</span> <span class="n">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">ys</span><span class="o">]</span>
  <span class="c1">-- Delta temporarily switches to using the diagonal monad instead of the usual list monad</span>

<span class="k">#eval</span> <span class="n">List.zip'</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">]</span>
<span class="c1">-- [(1, 4), (2, 5), (3, 6)]</span>
</code></pre></div>
<p>Code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"for "</span> <span class="n">term</span> <span class="s2">" in "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"if "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"Δ"</span> <span class="n">compClause</span> <span class="o">:</span> <span class="n">compClause</span>

<span class="n">syntax</span> <span class="s2">"["</span> <span class="n">term</span> <span class="s2">" | "</span> <span class="n">compClause</span><span class="o">,</span><span class="bp">*</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span>

<span class="kd">def</span> <span class="n">List.diag</span> <span class="o">(</span><span class="n">xss</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">xss</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">[]::</span><span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">_</span><span class="o">)::</span><span class="n">xss</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">List.diag</span> <span class="o">(</span><span class="n">List.map</span> <span class="o">(</span><span class="bp">·</span> <span class="bp">|&gt;.</span><span class="n">tailD</span> <span class="o">[])</span> <span class="n">xss</span><span class="o">)</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">xss.length</span>

<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">])</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">t</span><span class="o">)</span> <span class="bp">$</span><span class="n">xs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="k">if</span> <span class="bp">$</span><span class="n">x</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="k">if</span> <span class="bp">$</span><span class="n">x</span> <span class="k">then</span> <span class="o">[</span><span class="bp">$</span><span class="n">t</span><span class="o">]</span> <span class="k">else</span> <span class="o">[])</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="bp">Δ</span> <span class="bp">$</span><span class="n">c</span><span class="o">,</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.diag</span> <span class="o">[[</span><span class="bp">$</span><span class="n">t</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">]</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">])</span> <span class="c1">-- warning, inefficient</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">,</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.join</span> <span class="o">[[</span><span class="bp">$</span><span class="n">t</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">]</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">])</span>

<span class="k">#eval</span> <span class="o">[</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span>
<span class="c1">-- [2, 3, 4]</span>
<span class="k">#eval</span> <span class="o">[</span><span class="mi">4</span> <span class="bp">|</span> <span class="k">if</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">]</span>
<span class="c1">-- []</span>
<span class="k">#eval</span> <span class="o">[</span><span class="mi">4</span> <span class="bp">|</span> <span class="k">if</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">]</span>
<span class="c1">-- [4]</span>
<span class="k">#eval</span> <span class="o">[(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">List.range</span> <span class="mi">5</span><span class="o">,</span> <span class="n">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">List.range</span> <span class="mi">5</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="mi">3</span><span class="o">]</span>
<span class="c1">-- [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]</span>

<span class="kd">def</span> <span class="n">List.prod</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">[(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">xs</span><span class="o">,</span> <span class="n">for</span> <span class="n">y</span> <span class="k">in</span> <span class="n">ys</span><span class="o">]</span>

<span class="k">#eval</span> <span class="o">[</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">|</span> <span class="n">for</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span> <span class="n">List.prod</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">List.range</span> <span class="mi">3</span><span class="o">)]</span>
<span class="c1">-- [0, 0, 0, 0, 1, 2, 0, 2, 4]</span>
</code></pre></div>



<a name="290458292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290458292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290458292">(Jul 22 2022 at 02:46)</a>:</h4>
<p>FYI lean will do zips using the notation <code>for x in xs, y in ys do</code> so I guess you could just leave off the second <code>for</code>?</p>



<a name="290458294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290458294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290458294">(Jul 22 2022 at 02:46)</a>:</h4>
<p>it's kind of evil though</p>



<a name="290544851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290544851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290544851">(Jul 22 2022 at 17:47)</a>:</h4>
<p>I missed those messages during the night, it's great!</p>



<a name="290627295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290627295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juan Pablo Romero <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290627295">(Jul 23 2022 at 18:36)</a>:</h4>
<p>My 2 cents:  when more than one List/Collection is involved,  Scala's for-comprehension is much easier to read than Python's:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">for</span>
    <span class="n">x</span> <span class="bp">&lt;-</span> <span class="n">List.range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="n">y</span> <span class="bp">&lt;-</span> <span class="n">List.range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="mi">3</span>
  <span class="n">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="290627655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290627655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290627655">(Jul 23 2022 at 18:44)</a>:</h4>
<p>I still prefer python's version by far.</p>



<a name="290628864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290628864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290628864">(Jul 23 2022 at 19:14)</a>:</h4>
<p>Oftentimes it seems like list comprehensions could be more flexible (which is a point against the List monad). Mathematica has Reap and Sow for setting up a comprehension and collecting values. Here's a Lean 4 version of that for collecting an <code>Array</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">CollectM</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">StateM</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">sow</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">CollectM</span> <span class="n">α</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">·</span> <span class="bp">|&gt;.</span><span class="n">push</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">reap</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">CollectM</span> <span class="n">α</span> <span class="n">Unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m.run</span> <span class="bp">#</span><span class="o">[])</span><span class="bp">.</span><span class="mi">2</span>

<span class="k">#eval</span> <span class="n">reap</span> <span class="k">do</span>
  <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">5</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">for</span> <span class="n">y</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">5</span><span class="o">]</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">&lt;=</span> <span class="mi">3</span> <span class="k">then</span>
        <span class="n">sow</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">-- #[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]</span>
</code></pre></div>



<a name="290631300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290631300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290631300">(Jul 23 2022 at 20:16)</a>:</h4>
<p>Is that just an eager special case of iterator generators with <code>yield</code>?</p>



<a name="290631851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290631851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290631851">(Jul 23 2022 at 20:30)</a>:</h4>
<p>Yeah, it's basically eager Python/Javascript-style (anonymous) generator functions.</p>



<a name="290631941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290631941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290631941">(Jul 23 2022 at 20:32)</a>:</h4>
<p>The Mathematica version of this is wilder since it somehow attaches to the global continuation, so <em>any</em> function can <code>Sow</code>.</p>



<a name="290632109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290632109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290632109">(Jul 23 2022 at 20:37)</a>:</h4>
<p>I just hope we don't use these exact names because I would not be able to use them with a straight face without thinking of <a href="https://twitter.com/screaminbutcalm/status/1105577845642878976?lang=en">https://twitter.com/screaminbutcalm/status/1105577845642878976?lang=en</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/screaminbutcalm/status/1105577845642878976?lang=en"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/5db1c79ad46cef505f2719f7b38ca14a729c91cb/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313031353635373730383338373831353432352f68724532625172535f6e6f726d616c2e6a7067"></a><p>Me sowing: Haha fuck yeah!!! Yes!! 

Me reaping: Well this fucking sucks. What the fuck.</p><span>- The Golden Sir (@screaminbutcalm)</span></div></div>



<a name="290637001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290637001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290637001">(Jul 23 2022 at 22:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> That seems like a point in favor of using those terms, no? <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="290666215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290666215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290666215">(Jul 24 2022 at 10:55)</a>:</h4>
<p>I don't have a horse in this race but, if I recall correctly, <code>ListT</code> monad transformer is ill-behaved with strict lists (but the <code>List</code> monad by itself is fine with strictness).  It would be unusual if the list monad were significantly different from <code>ListT Id</code>.</p>



<a name="290666283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/290666283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#290666283">(Jul 24 2022 at 10:57)</a>:</h4>
<p>(Of course, this is not a problem if neither <code>ListM</code> nor <code>ListT</code> exist.)</p>



<a name="294796803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/294796803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#294796803">(Aug 23 2022 at 03:13)</a>:</h4>
<p>For another data point on this excellent discussion I also love Python list comprehensions, and I was looking for it the other day, until I found Kyle's awesome implementation here.  But I have also thought of these as only useful on very concise list comprehensions and I move to the more powerful "<a href="https://python.plainenglish.io/python-yield-iterator-and-generator-introduction-15be182f6135">yield pattern</a>" (which I also love in C#) where you can write a huge function to compute what you are yielding and inject yield statements in various places to turn your entire function into an iterator.  So I've always thought of the yield iterator as a more powerful version and it's nice to have both.  So I like the <code>yield</code> keyword better than <code>sow</code> and with yield in C# you don't need to reap.  In fact, you don't want to build that Array in memory since the whole point is to be able to operate on infinite streams efficiently, like pulling transformed rows out of a database and returning them as Json over HTTP, with minimal memory footprint, etc.</p>



<a name="294945138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/294945138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#294945138">(Aug 23 2022 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/290628864">said</a>:</p>
<blockquote>
<p>Oftentimes it seems like list comprehensions could be more flexible (which is a point against the List monad). Mathematica has Reap and Sow for setting up a comprehension and collecting values. Here's a Lean 4 version of that for collecting an <code>Array</code>:</p>
</blockquote>
<p>This also can generalize nicely -- my collection library has a generalization for any collection that  can be built up one element at a time, so <code>CollectM</code> can be defined over any result collection and a nice syntax could be added.</p>
<p>It seems like python's for comprehensions connect the two (distinct &amp; dual) notions, iterating over a collection vs building one up</p>
<p>We already have a generalization for iterating over a collection (<code>ForIn</code>), so I think it best to add a notion for building one up (<a href="https://jamesgallicchio.github.io/LeanColls/docs///LeanColls/Classes.html#LeanColls.Enumerable"><code>Enumerable</code></a>), add instances for <code>List</code> and <code>Array</code>, and add some pythonic syntax behind an import for those that want it</p>



<a name="295114141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295114141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295114141">(Aug 24 2022 at 19:41)</a>:</h4>
<p>Here's an implementation of the nondeterminism monad which uses continuation passing style to avoid creating lots of intermediate arrays:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ArrayM</span> <span class="o">(</span><span class="n">κ</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">κ</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">κ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">κ</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">κ</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Monad</span> <span class="o">(</span><span class="n">ArrayM</span> <span class="n">κ</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">pure</span> <span class="n">a</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">k</span> <span class="n">a</span>
  <span class="n">bind</span> <span class="n">f</span> <span class="n">g</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="bp">·</span> <span class="n">k</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">MonadLift</span> <span class="n">List</span> <span class="o">(</span><span class="n">ArrayM</span> <span class="n">κ</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">monadLift</span> <span class="n">l</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">l.foldl</span> <span class="o">(</span><span class="k">fun</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">k</span> <span class="n">a</span> <span class="n">r</span><span class="o">)</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">MonadLift</span> <span class="n">Array</span> <span class="o">(</span><span class="n">ArrayM</span> <span class="n">κ</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">monadLift</span> <span class="n">l</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">l.foldl</span> <span class="o">(</span><span class="k">fun</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">k</span> <span class="n">a</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">ArrayM.run</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ArrayM</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">x</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r.push</span> <span class="n">a</span><span class="o">)</span> <span class="bp">#</span><span class="o">[]</span>

<span class="k">#eval</span> <span class="n">ArrayM.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">a</span> <span class="bp">←</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">b</span> <span class="bp">←</span> <span class="bp">#</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
  <span class="n">return</span> <span class="mi">10</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span>
<span class="c1">-- #[11, 12, 13, 21, 22, 23, 31, 32, 33]</span>
</code></pre></div>



<a name="295128350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295128350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295128350">(Aug 24 2022 at 21:15)</a>:</h4>
<p>Is there an application in Lean where you'd want an eager nondeterminism monad implementation?</p>
<p>It would seem reasonable to me to have an explicit <code>Nondet</code> monad with a <code>choose : [ToStream α ρ] -&gt; ρ -&gt; Nondet α</code> operation, and some eliminators for it</p>



<a name="295128536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295128536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295128536">(Aug 24 2022 at 21:17)</a>:</h4>
<p>You mentioned you used <code>Monad List</code> in tests, is there a file that has some examples?</p>



<a name="295129504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295129504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295129504">(Aug 24 2022 at 21:26)</a>:</h4>
<p>Using a <code>ToStream</code> instance is a bit weird, since that introduces a dependency between the various nondet branches</p>



<a name="295129600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295129600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295129600">(Aug 24 2022 at 21:27)</a>:</h4>
<p>Yeah, I'm not sure what the right class is there. But some class that exposes external iteration.</p>



<a name="295129729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295129729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295129729">(Aug 24 2022 at 21:28)</a>:</h4>
<p>(or do you mean a type dependency? I'm not sure I understand what you mean)</p>



<a name="295130266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/295130266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#295130266">(Aug 24 2022 at 21:32)</a>:</h4>
<p>I mean that the various branches can't be executed independently, you need to hold on to the iterator state</p>



<a name="299054100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299054100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299054100">(Sep 15 2022 at 21:24)</a>:</h4>
<p>I ran into this using the Kyle's List Comprehension syntax extension mentioned above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vec</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Int</span> <span class="o">:=</span> <span class="o">[</span><span class="bp">-</span><span class="mi">4</span><span class="o">,</span> <span class="bp">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
<span class="c1">-- filter the list to exclude negative numbers</span>
<span class="k">#eval</span> <span class="o">[</span><span class="n">x</span> <span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">vec</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&gt;=</span> <span class="mi">0</span><span class="o">]</span>
<span class="c1">-- [0, 2, 4]</span>
</code></pre></div>
<p>which errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">List.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="k">then</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="k">else</span> <span class="o">[])</span> <span class="n">vec</span>
<span class="n">argument</span>
  <span class="n">vec</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">List</span> <span class="n">Int</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">List</span> <span class="n">Nat</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>
<p>To fix it I have to coerce the 0 to an int using <code>#eval [x | for x in vec, if x &gt;= (0: Int)]</code>.</p>
<p>So my question, is whether the Lean syntax extensions can improve how type inference happens?  I would imagine that  since <code>vec</code> is a <code>List Int</code>, then Lean should know that <code>x</code> must be an Int, therefore the 0 must be an Int also ?</p>



<a name="299055407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299055407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299055407">(Sep 15 2022 at 21:33)</a>:</h4>
<p>Yes you can do this with a custom elaborator that forces <code>x</code> to be elaborated with <code>a</code> for <code>List a</code> but not just with a simple macro.</p>



<a name="299055409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299055409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299055409">(Sep 15 2022 at 21:33)</a>:</h4>
<p><span class="user-mention" data-user-id="434989">@Chris Lovett</span> This is an elaboration order issue.</p>
<p>If you define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.map'</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">List.map</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></div>
<p>then alter the <code>macro_rules</code> to instead have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.map'</span> <span class="bp">$</span><span class="n">xs</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">t</span><span class="o">))</span>
</code></pre></div>
<p>then your example works without the type ascription.</p>



<a name="299055648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299055648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299055648">(Sep 15 2022 at 21:35)</a>:</h4>
<p>My understanding of what is going on is that the elaborator elaborates arguments in order, so while it elaborates the function argument to <code>List.map</code> it doesn't yet know the type of the argument to the function since it hasn't visited the list argument yet. Reversing the order of the arguments to <code>List.map</code> is sufficient in this case.</p>



<a name="299057547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299057547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299057547">(Sep 15 2022 at 21:51)</a>:</h4>
<p>wow, thanks!</p>



<a name="299057822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299057822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299057822">(Sep 15 2022 at 21:53)</a>:</h4>
<p>Unfortunately it doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">declare_syntax_cat</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"for "</span> <span class="n">term</span> <span class="s2">" in "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">compClause</span>
<span class="n">syntax</span> <span class="s2">"if "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">compClause</span>

<span class="n">syntax</span> <span class="s2">"["</span> <span class="n">term</span> <span class="s2">" | "</span> <span class="n">compClause</span><span class="o">,</span><span class="bp">*</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span>

<span class="kd">def</span> <span class="n">List.map'</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">List.map</span> <span class="n">f</span> <span class="n">xs</span>

<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">])</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.map'</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">t</span><span class="o">)</span> <span class="bp">$</span><span class="n">xs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="k">if</span> <span class="bp">$</span><span class="n">x</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="k">if</span> <span class="bp">$</span><span class="n">x</span> <span class="k">then</span> <span class="o">[</span><span class="bp">$</span><span class="n">t</span><span class="o">]</span> <span class="k">else</span> <span class="o">[])</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">,</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.join</span> <span class="o">[[</span><span class="bp">$</span><span class="n">t</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">cs</span><span class="o">,</span><span class="bp">*</span><span class="o">]</span> <span class="bp">|</span> <span class="bp">$</span><span class="n">c</span><span class="o">])</span>

<span class="kd">def</span> <span class="n">vec</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Int</span> <span class="o">:=</span> <span class="o">[</span><span class="bp">-</span><span class="mi">4</span><span class="o">,</span> <span class="bp">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
<span class="k">#eval</span> <span class="o">[</span><span class="n">x</span> <span class="bp">|</span> <span class="n">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">vec</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&gt;=</span> <span class="mi">0</span><span class="o">]</span>
</code></pre></div>
<p>And it also breaks <code>def List.prod (xs : List α) (ys : List β) : List (α × β) := [(x, y) | for x in xs, for y in ys]</code></p>



<a name="299058487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299058487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299058487">(Sep 15 2022 at 21:59)</a>:</h4>
<p>Make sure to change the order of the arguments to <code>List.map'</code> in the <code>macro_rules</code> too</p>



<a name="299058865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299058865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299058865">(Sep 15 2022 at 22:02)</a>:</h4>
<p>Doh! thanks.</p>



<a name="299066709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299066709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299066709">(Sep 15 2022 at 23:17)</a>:</h4>
<p>So <span class="user-mention" data-user-id="306601">@Kyle Miller</span> I turned your solution into a new Lean sample because I think it's a really great example of Lean syntax extension.  See <a href="https://github.com/leanprover/lean4-samples/pull/10">https://github.com/leanprover/lean4-samples/pull/10</a>, let me know there if you have any comments or suggestions, thanks.</p>



<a name="299347388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299347388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299347388">(Sep 17 2022 at 17:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/List.20Functor/near/299055409">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="434989">Chris Lovett</span> This is an elaboration order issue.</p>
<p>If you define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.map'</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">List.map</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></div>
<p>then alter the <code>macro_rules</code> to instead have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="bp">|</span> <span class="n">for</span> <span class="bp">$</span><span class="n">x</span> <span class="k">in</span> <span class="bp">$</span><span class="n">xs</span><span class="o">])</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">List.map'</span> <span class="bp">$</span><span class="n">xs</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">t</span><span class="o">))</span>
</code></pre></div>
<p>then your example works without the type ascription.</p>
</blockquote>
<p>This has been fixed in <a href="https://github.com/leanprover/lean4/commit/d3b0b49c432e9e2ca7c6dd6017fbed074ff1ccb6">https://github.com/leanprover/lean4/commit/d3b0b49c432e9e2ca7c6dd6017fbed074ff1ccb6</a></p>



<a name="299691069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List%20Functor/near/299691069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/List.20Functor.html#299691069">(Sep 20 2022 at 06:34)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> I removed <code>List.map'</code> from the new sample at <a href="https://github.com/leanprover/lean4-samples/tree/main/ListComprehension">https://github.com/leanprover/lean4-samples/tree/main/ListComprehension</a> and everything works.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Question.3A.20strong.20normalization.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Question.3A.20strong.20normalization.20in.20Lean.html">Question: strong normalization in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="296437972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Question%3A%20strong%20normalization%20in%20Lean/near/296437972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Question.3A.20strong.20normalization.20in.20Lean.html#296437972">(Aug 31 2022 at 19:46)</a>:</h4>
<p>I was a bit surprised (not that my surprise means much) when I read in "An Abstract Machine for Strong Call by Need" that "the current version of the Coq proof assistant employs an abstract machine that uses a lazy strategy to fully normalize terms".</p>
<p>Is the (strong) normalization strategy used in Lean4 also lazy/call-by-need? Or is it strict/call-by-value?</p>



<a name="296438564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Question%3A%20strong%20normalization%20in%20Lean/near/296438564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Question.3A.20strong.20normalization.20in.20Lean.html#296438564">(Aug 31 2022 at 19:50)</a>:</h4>
<p>It's not exactly the call by need algorithm, but it is essentially a lazy algorithm</p>



<a name="296438694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Question%3A%20strong%20normalization%20in%20Lean/near/296438694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Question.3A.20strong.20normalization.20in.20Lean.html#296438694">(Aug 31 2022 at 19:51)</a>:</h4>
<p>(this is in contrast to the VM / compiler, which is strictly call by value)</p>



<a name="296438764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Question%3A%20strong%20normalization%20in%20Lean/near/296438764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Question.3A.20strong.20normalization.20in.20Lean.html#296438764">(Aug 31 2022 at 19:51)</a>:</h4>
<p>This is because it's not really an evaluation strategy, it is doing unification</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
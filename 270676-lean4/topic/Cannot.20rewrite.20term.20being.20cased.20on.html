---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html">Cannot rewrite term being cased on</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273286474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/273286474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#273286474">(Feb 25 2022 at 21:23)</a>:</h4>
<p>I've been trying for a while to step through a match expression in a proof, but the rewrite that should be succeeding is not.</p>
<p>Here, I'm trying to rewrite the <code>LazyList.force F</code> to <code>none</code> with <code>h'</code>, so that I can step through the match. <code>rw [h']</code> fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="bp">'</span><span class="n">rewrite'</span> <span class="n">failed</span><span class="o">,</span> <span class="n">motive</span> <span class="n">is</span> <span class="n">not</span> <span class="n">type</span> <span class="n">correct</span>
<span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="n">u.3819</span>
<span class="n">F</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span>
<span class="n">F_len</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="n">R</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span>
<span class="n">R_len</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="bp">...</span>
<span class="n">h'</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">none</span>
<span class="bp">...</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="k">match</span> <span class="n">LazyList.force</span> <span class="n">F</span><span class="o">,</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">LazyList.force</span> <span class="n">F</span><span class="o">)</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">),</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">LBQueue.balance</span> <span class="n">F'</span> <span class="o">(</span><span class="n">F_len</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">R</span> <span class="n">R_len</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">LazyList.length</span> <span class="n">F'</span> <span class="bp">=</span> <span class="n">F_len</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">LazyList.length</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">R_len</span><span class="o">))</span>
    <span class="bp">|</span> <span class="n">none</span><span class="o">,</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">none</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">none</span>
</code></pre></div>
<p>Full code is <a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Queue/LazyBankerQueue.lean">here</a><br>
(sorry for the not-MWE, I can't figure out how to get this issue to appear elsewhere <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span>)</p>



<a name="273286670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/273286670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#273286670">(Feb 25 2022 at 21:25)</a>:</h4>
<p>I can spend some more time trying to find an MWE if the issue is too unintelligible like this</p>



<a name="273300455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/273300455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#273300455">(Feb 25 2022 at 23:42)</a>:</h4>
<p>Try <code>cases h'</code>? In lean 3 this would probably make progress, as would <code>subst h'</code>.</p>



<a name="273332258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/273332258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#273332258">(Feb 26 2022 at 10:28)</a>:</h4>
<p>I believe <code>split</code> should work in this case. (Lean 4 <code>split</code> is like <code>split_ifs</code> from lean 3 but it also works on matches)</p>



<a name="273368323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/273368323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#273368323">(Feb 26 2022 at 23:03)</a>:</h4>
<p>Ah, <code>cases h'</code> seems to reveal the issue:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">dependent</span> <span class="n">elimination</span> <span class="n">failed</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">solve</span> <span class="n">equation</span>
  <span class="n">none</span> <span class="bp">=</span>
    <span class="n">Acc.rec</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">x₁</span> <span class="n">ac₁</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
        <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">=&gt;</span>
            <span class="n">PSigma.casesOn</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span>
<span class="bp">...</span>
</code></pre></div>
<p>Seems like maybe same issue as <a href="#narrow/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof">this topic</a></p>



<a name="274085934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274085934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274085934">(Mar 04 2022 at 06:18)</a>:</h4>
<p>Huh, so even after the other topic was resolved, this is still having trouble. Weirdly if I just case on <code>F.force</code> again (and eliminate one case via contradiction) it works... I just can't directly rewrite into the match, nor split on it</p>



<a name="274085948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274085948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274085948">(Mar 04 2022 at 06:19)</a>:</h4>
<p>(Doing <code>cases h'</code> still gives the same dependent elimination failure)</p>



<a name="274086422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274086422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274086422">(Mar 04 2022 at 06:25)</a>:</h4>
<p>can you make a MWE?</p>



<a name="274087009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274087009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274087009">(Mar 04 2022 at 06:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Thunk</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">LazyList</span>

<span class="kd">def</span> <span class="n">force</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">force</span> <span class="n">as.get</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">none</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">as</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">LazyList</span>


<span class="kd">def</span> <span class="n">deq</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span><span class="o">:</span><span class="n">Q.force</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">none</span>

<span class="kd">theorem</span> <span class="n">deq_correct</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">deq</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">Q.force</span> <span class="bp">=</span> <span class="n">none</span>
  <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">h'</span><span class="o">:</span><span class="n">Q.force</span>
    <span class="n">case</span> <span class="n">none</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">h'</span>
    <span class="gr">sorry</span>
</code></pre></div>



<a name="274087056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274087056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274087056">(Mar 04 2022 at 06:34)</a>:</h4>
<p>I think (?) this shows the right behavior</p>



<a name="274087170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274087170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274087170">(Mar 04 2022 at 06:36)</a>:</h4>
<p>And this works perfectly fine in replacement of the <code>cases h'</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">match</span> <span class="n">h''</span><span class="o">:</span><span class="n">Q.force</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">_</span> <span class="bp">=&gt;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h'</span><span class="o">]</span> <span class="n">at</span> <span class="n">h''</span>
  <span class="n">contradiction</span>
</code></pre></div>



<a name="274087221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274087221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274087221">(Mar 04 2022 at 06:38)</a>:</h4>
<p>wait, no, doing that causes a really strange error at the top level declaration deq_correct ???</p>



<a name="274087271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274087271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274087271">(Mar 04 2022 at 06:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">deq.match_1</span> <span class="n">Q</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span>
<span class="n">argument</span> <span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">✝</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">but</span> <span class="n">function</span> <span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span>
      <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">F'</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">))</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">))</span> <span class="n">h</span><span class="o">)</span> <span class="bp">→</span>
          <span class="o">((</span><span class="n">h</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">none</span> <span class="n">h</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">x</span> <span class="n">h</span>
</code></pre></div>



<a name="274154336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274154336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274154336">(Mar 04 2022 at 16:35)</a>:</h4>
<p>Ideally we would want to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">deq_correct</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">deq</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">Q.force</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>
  <span class="n">cases</span> <span class="n">Q.force</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
</code></pre></div>
<p>or </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">deq_correct</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">deq</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">Q.force</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>
  <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
</code></pre></div>
<p>Both <code>cases Q.force</code> and <code>split</code> fail when trying to generalize <code>Q.force</code>. Auxiliary declarations (<code>deq.match_1</code> and <code>deq.proof_1</code>) created by Lean are preventing <code>generalize</code> from creating a type correct term. <code>deq.match_1</code> is an auxiliary declaration used to represent the <code>match</code> expression in <code>deq</code>, and <code>deq.proof_1</code> is used by Lean when "hiding" all proof terms nested in a definition. We can work around these issues by unfolding these definitions.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">deq_correct</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">deq</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">Q.force</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>
  <span class="n">unfold</span> <span class="n">deq.match_1</span>
  <span class="n">unfold</span> <span class="n">deq.proof_1</span>
  <span class="n">cases</span> <span class="n">Q.force</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
</code></pre></div>
<p>We will try to improve <code>generalize</code> and how we encode <code>match</code> expressions to avoid these workarounds in the future.</p>



<a name="274323635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274323635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274323635">(Mar 06 2022 at 19:27)</a>:</h4>
<p>Trying to apply this workaround in more complicated situations I'm a bit lost again... Here's an MWE that's closer to my actual application:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Thunk</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">LazyList</span>

<span class="kd">def</span> <span class="n">force</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">force</span> <span class="n">as.get</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">none</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">as</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">_</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">as.get</span>

<span class="kd">theorem</span> <span class="n">F_force_some_len_minus_one</span> <span class="o">{</span><span class="n">L</span> <span class="n">L'</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">:</span> <span class="n">L.force</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">L'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L'.length</span> <span class="bp">=</span> <span class="n">L.length</span> <span class="bp">-</span> <span class="mi">1</span>
  <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">LazyList</span>

<span class="kd">structure</span> <span class="n">LazyBatchQueue</span> <span class="o">(</span><span class="n">τ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">F</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span>
  <span class="n">F_len</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">h_lens</span> <span class="o">:</span> <span class="n">F.length</span> <span class="bp">=</span> <span class="n">F_len</span>


<span class="kd">def</span> <span class="n">deq</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyBatchQueue</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyBatchQueue</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span><span class="o">:</span><span class="n">Q.F.force</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span> <span class="bp">=&gt;</span>
    <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span>
      <span class="o">⟨</span><span class="n">F'</span><span class="o">,</span> <span class="n">Q.F_len</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
        <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">LazyList.F_force_some_len_minus_one</span> <span class="n">h</span><span class="o">,</span> <span class="n">Q.h_lens</span><span class="o">]⟩)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">none</span>

<span class="kd">theorem</span> <span class="n">deq_correct</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyBatchQueue</span> <span class="n">τ</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">deq</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">Q.F.force</span> <span class="bp">=</span> <span class="n">none</span>
  <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>
    <span class="n">unfold</span> <span class="n">deq.match_1</span>
    <span class="n">unfold</span> <span class="n">deq.proof_1</span>
    <span class="n">unfold</span> <span class="n">deq.proof_2</span>
    <span class="k">match</span> <span class="n">h'</span><span class="o">:</span><span class="n">Q.F.force</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
</code></pre></div>
<p>The biggest difference from the last is that now we are carrying around a proof term with the queue structure (so perhaps that's causing other proof-erasing definitions to be generated?).</p>
<p>The same proof as before (which I think should in principle still work) fails with a reference to <code>deq.proof_2</code>, so I tried unfolding that also, but now it generates a type incorrect term because it is generalizing <code>Q.F.force</code> within the proof term from the implementation of <code>deq</code>...</p>
<p>Is there a consistent way to apply this workaround? I can also just leave <code>sorry</code>s until the behavior improves, since it isn't urgent.</p>



<a name="274325641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274325641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274325641">(Mar 06 2022 at 20:09)</a>:</h4>
<p>My old standby for solving this situation in lean 3 still works in lean 4: Write the generalization motive explicitly. It's not pretty but it works when you have messy dependencies</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">deq_correct</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyBatchQueue</span> <span class="n">τ</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">deq</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">Q.F.force</span> <span class="bp">=</span> <span class="n">none</span>
  <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">deq</span><span class="o">]</span>
    <span class="k">suffices</span> <span class="bp">∀</span> <span class="n">o</span> <span class="n">h</span><span class="o">,</span> <span class="n">deq.match_1</span> <span class="n">Q</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span> <span class="n">o</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">↔</span> <span class="n">_</span> <span class="k">from</span> <span class="n">this</span> <span class="n">_</span> <span class="n">rfl</span>
    <span class="n">intros</span> <span class="n">o</span> <span class="n">h</span>
    <span class="n">cases</span> <span class="n">o</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
</code></pre></div>



<a name="274325952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274325952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274325952">(Mar 06 2022 at 20:16)</a>:</h4>
<p>Oh boy, okay -- let me try to parse what that's doing</p>



<a name="274326114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274326114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274326114">(Mar 06 2022 at 20:20)</a>:</h4>
<p>the basic idea is that we are simultaneously generalizing <code>Q.F.force</code>and <code>rfl : Q.F.force = Q.F.force</code> because the <code>rfl</code> proof is what prevents us from generalizing <code>Q.F.force</code>. These two are passed as arguments to <code>deq.match_1</code>, which already states the generalized type of <code>h : Q.F.force = o</code>, so if we introduce them at the same time then we don't get any "motive is not type correct" issues</p>



<a name="274326130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/274326130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#274326130">(Mar 06 2022 at 20:21)</a>:</h4>
<p>(It helps to set <code>set_option pp.match false</code> to see what the actual match application looks like)</p>



<a name="277546023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/277546023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#277546023">(Apr 02 2022 at 19:06)</a>:</h4>
<p>Sorry for dragging up an old thread — I’m back to trying to figure this out.</p>



<a name="277546156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/277546156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#277546156">(Apr 02 2022 at 19:08)</a>:</h4>
<p>Where are the <code>proof_i</code> terms used in the match encoding? Even with <code>pp.match</code> off and <code>pp.all</code> on they don’t appear anywhere — is it only occurring in the proof of the relevant proposition?</p>



<a name="277546184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/277546184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#277546184">(Apr 02 2022 at 19:09)</a>:</h4>
<p>(Trying to understand why those need to be unfolded/what it’s doing when I unfold those)</p>



<a name="277546473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/277546473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#277546473">(Apr 02 2022 at 19:15)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> We discussed this issue in the dev channel. To provide a better experience for users, we have to change how we encode <code>match</code> expressions. This is on our TODO list, but it will not happen in the next two months. We have a tutorial at the end of May, and fixing things and adding missing features for it is our current priority. Here are the notes from the dev channel if you are interested.</p>
<hr>
<p>A user wrote the following function.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">deq</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span><span class="o">:</span><span class="n">Q.force</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span>         <span class="bp">=&gt;</span> <span class="n">none</span>
</code></pre></div>
<p>The following auxiliary definition is created</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">deq.match_1</span> <span class="o">:</span>
  <span class="c1">-- Parameters</span>
  <span class="o">{</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span>
  <span class="c1">-- Motive</span>
  <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u_2</span><span class="o">)</span> <span class="bp">→</span>
  <span class="c1">-- Discriminants aka major premises</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span>
  <span class="c1">-- Alternatives aka minor premises</span>
  <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">F'</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">))</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">))</span> <span class="n">h</span><span class="o">)</span> <span class="bp">→</span>
  <span class="o">((</span><span class="n">h</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">none</span> <span class="n">h</span><span class="o">)</span> <span class="bp">→</span>
  <span class="c1">-- Result type</span>
  <span class="n">motive</span> <span class="n">x</span> <span class="n">h</span>
</code></pre></div>
<p>If the goal contains the term <code>deq.match_1 Q &lt;some-motive&gt; (LazyList.force Q) ...</code>, we cannot generalize <code>LazyList.force Q</code>.<br>
The auxiliary definition above follows the structure of kernel recursors where the motive does not depend on the major premises (aka discriminants), but it prevents us from generalizing effectively. We could work karound this particular issue by using a different encoding where the motive depends on the discriminants</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">def</span> <span class="n">deq.match</span>
    <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
    <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span>
    <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">d₁</span> <span class="bp">=</span> <span class="n">d₁</span><span class="o">)</span>
    <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">d₁</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">F'</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">d₁</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">))</span> <span class="n">h</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">none</span> <span class="bp">=</span> <span class="n">d₁</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">none</span> <span class="n">h</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">motive</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">d₁</span>
  <span class="n">exact</span> <span class="n">h₂</span> <span class="n">rfl</span>
  <span class="n">exact</span> <span class="n">h₁</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span>
</code></pre></div>
<p>BTW, I hit similar problems a few times whenever we have <code>match h:t ...</code> where <code>t</code> is not a variable. This kind of <code>match</code> creates a term that cannot be generalized by tactics such as <code>cases</code> and <code>split</code>. The issue also affects any <code>match</code> where the user manually provides a complex <code>motive</code> by hand + discriminants that are not variables. This second scenario is rare since very few people are willing to write complex motives by hand. The problem with <code>match h:t ...</code> is that it makes it super easy for users to create a nontrivial motive. <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span><br>
This issue is bothering me <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> Here is another encoding that fixes the problem, but does not change the order: parameter, motive, discriminants, alternatives.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">deq.match</span> <span class="o">{</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span>
              <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">))</span>
              <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">F'</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">))</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)))</span>
              <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">none</span><span class="o">)</span>
              <span class="o">:</span> <span class="n">motive</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">h</span><span class="o">:</span><span class="n">d</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">h</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h₁</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span>
</code></pre></div>
<p>It removes <code>rfl</code> as a discriminant. In retrospect, it is a bit pointless to take an argument that is always set with <code>rfl</code>.<br>
This fix also avoids the workaround <code>unfold deq.proof_1</code>.<br>
We would need some extra annotation to make sure we can delaborate this kind of match, but the result will be better.<br>
For example, the <code>deq</code> function </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">deq</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span><span class="o">:</span><span class="n">Q.force</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">none</span>
</code></pre></div>
<p>is currently delaborated as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">deq.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="o">:</span> <span class="o">{</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">τ</span> <span class="bp">×</span> <span class="n">LazyList</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">{</span><span class="n">τ</span><span class="o">}</span> <span class="n">Q</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">LazyList.force</span> <span class="n">Q</span><span class="o">,</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">LazyList.force</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">LazyList.force</span> <span class="n">Q</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">),</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">F'</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span><span class="o">,</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">none</span>
</code></pre></div>
<p>The output is correct, but it exposes our encoding for <code>h:</code>.</p>



<a name="280728296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/280728296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#280728296">(Apr 30 2022 at 10:09)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span>, in case you decide it's worth your attention:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}:</span> <span class="n">True</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span>     <span class="bp">=&gt;</span> <span class="n">True.intro</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="n">trace_state</span>
    <span class="n">exact</span> <span class="n">True.intro</span>
</code></pre></div>
<p><code>h</code> has type:</p>
<p>. <code>nightly-2022-04-29</code>: <code>h : n✝ = n + 1</code><br>
. <code>nightly-2022-04-30</code>: <code>h : n✝ = Nat.succ n</code></p>



<a name="280744725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/280744725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#280744725">(Apr 30 2022 at 16:43)</a>:</h4>
<p><span class="user-mention" data-user-id="407798">@Evgeniy Kuznetsov</span> Thanks for the reporting the discrepancy. I changed how the <code>h :</code> is encoded in to address the issue in this thread and <a href="#narrow/stream/270676-lean4/topic/hypothesis.20can't.20be.20used/near/280252919">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/hypothesis.20can't.20be.20used/near/280252919</a><br>
In the new encoding, <code>h : &lt;discriminant&gt; = &lt;pattern&gt;</code>. The issues in these threads are not fully resolved, I still have to write a new <code>split</code> tactic that takes into account the new encoding, and add support in <code>simp</code> too.<br>
In your example, the discrepancy is on the <code>&lt;pattern&gt;</code> of <code>h : &lt;discriminant&gt; = &lt;pattern&gt;</code>, because <code>x+1</code> is a pseudo-pattern, and only becomes a "real" pattern after we reduce it to <code>Nat.succ x</code>. The new behavior seems reasonable to me.<br>
I have also noticed discrepancies on the <code>&lt;discriminant&gt;</code>. In the new encoding, it is exactly the discriminant we typed, and in the previous encoding, the <code>&lt;discriminant&gt;</code> would be "refined" by previous patterns. <br>
We want to make sure we have the final encoding before we make the first official Lean 4 release this summer.</p>



<a name="280745011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/280745011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#280745011">(Apr 30 2022 at 16:50)</a>:</h4>
<p>Note that you can still simulate previous encoding by manually providing the "motive" for the <code>match</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ex</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}:</span> <span class="n">True</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n'</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n'</span> <span class="bp">→</span> <span class="n">_</span><span class="o">)</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">h</span>     <span class="bp">=&gt;</span> <span class="n">True.intro</span>
  <span class="bp">|</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="n">trace_state</span> <span class="c1">-- h : n = y + 1</span>
    <span class="n">exact</span> <span class="n">True.intro</span>
</code></pre></div>



<a name="280745646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/280745646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#280745646">(Apr 30 2022 at 17:04)</a>:</h4>
<p>BTW, I will be tweaking with the new encoding in the next few days. So, we may have a few more discrepancies.</p>



<a name="280745982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Cannot%20rewrite%20term%20being%20cased%20on/near/280745982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Cannot.20rewrite.20term.20being.20cased.20on.html#280745982">(Apr 30 2022 at 17:12)</a>:</h4>
<p>Thank you for a comprehensive answer! Just wanted to make sure this is the expected behavior.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
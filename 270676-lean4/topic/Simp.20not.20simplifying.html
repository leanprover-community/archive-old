---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Simp.20not.20simplifying.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html">Simp not simplifying</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="237680202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237680202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237680202">(May 06 2021 at 15:38)</a>:</h4>
<p>Hello, I have this "efficient" function that given a nat, computes true.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>  <span class="bp">=&gt;</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">true</span>
    <span class="o">)</span>
    <span class="bp">&amp;&amp;</span> <span class="n">f</span> <span class="n">n</span>
</code></pre></div>
<p>Now i'm trying to prove the important math theorem: f 1 = true</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">p</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">f</span><span class="o">]</span>
  <span class="gr">admit</span>
</code></pre></div>
<p>My issue is that simp does not simplify (in lean4 nightly-2021-05-06) even when being specific about f</p>
<p>I'm learning lean so I'm not very sure, but I expected that simp would replace f 1 with its computed result: true in the goal state.</p>
<p>Maybe the tactic is not smart enough, but is there a way to force f 1 to unwrap itself in a single step?</p>



<a name="237688666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237688666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237688666">(May 06 2021 at 16:29)</a>:</h4>
<p><code>refl</code>?</p>



<a name="237688735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237688735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237688735">(May 06 2021 at 16:29)</a>:</h4>
<p><code>refl</code> is called <code>rfl</code> in Lean 4.</p>



<a name="237688901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237688901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237688901">(May 06 2021 at 16:30)</a>:</h4>
<p>I am not too sure that I expect <code>simp</code> to work here. You have defined no <code>simp</code> lemmas and so this will just unfold to some f.rec term which the simplifier probably won't know what to do with? I'm not 100% sure of what I'm talking about though</p>



<a name="237689002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689002">(May 06 2021 at 16:31)</a>:</h4>
<p>Are they really the same?<br>
Lean3: <code>theorem hi : "".data = [] := by refl</code><br>
Lean4: <code> example : "".data = [] := by rfl </code> &lt;-- doesn't go through</p>



<a name="237689041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689041">(May 06 2021 at 16:31)</a>:</h4>
<p>They're not the same no</p>



<a name="237689321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689321">(May 06 2021 at 16:33)</a>:</h4>
<p>In lean 4 <code>rfl</code> only proves a=a. Lean 3's <code>refl</code> tactic proves <code>R a a</code> for any reflexive binary relation whose proof of reflexivity has been tagged with the <code>@[refl]</code> tag. Lean 4 <code>refl</code> does exist but only in my mathlib port :p</p>



<a name="237689479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689479">(May 06 2021 at 16:34)</a>:</h4>
<p>And instead of tagging the refl lemma you have to add it to the list of lemmas which the tactic tries ;-)</p>



<a name="237689581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689581">(May 06 2021 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="228135">@Scott Viteri</span> my answer no longer applies to your post because you changed <code>==</code> to <code>=</code></p>



<a name="237689668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689668">(May 06 2021 at 16:35)</a>:</h4>
<p>sorry copy paste error</p>



<a name="237689782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689782">(May 06 2021 at 16:36)</a>:</h4>
<p>I'm not at lean right now so can't check the definition of .data</p>



<a name="237689862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237689862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237689862">(May 06 2021 at 16:37)</a>:</h4>
<p>Don't want to derail this, I'll make a separate thread</p>



<a name="237707804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237707804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237707804">(May 06 2021 at 18:34)</a>:</h4>
<p>Interestingly enough <code>rfl</code> doesn't work either when using <code>and</code> in this order (on <code>master</code>).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">true</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="n">f</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">g</span> <span class="n">n</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">true</span><span class="o">)</span>

<span class="k">#reduce</span> <span class="n">f</span> <span class="mi">1</span> <span class="c1">-- true</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
<span class="k">#reduce</span> <span class="n">g</span> <span class="mi">1</span> <span class="c1">-- true</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">g</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="237709911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237709911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237709911">(May 06 2021 at 18:48)</a>:</h4>
<p>It works with <code>set_option smartUnfolding false</code>.</p>



<a name="237728831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237728831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237728831">(May 06 2021 at 21:04)</a>:</h4>
<p>This one is subtle. Here are the smart-unfolding lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f._sunfold</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="n">Bool</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">=&gt;</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="n">Bool</span> <span class="n">true</span>
      <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="n">Bool</span> <span class="n">true</span><span class="o">)</span> <span class="bp">&amp;&amp;</span>
      <span class="n">f</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">g._sunfold</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="n">Bool</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">=&gt;</span>
    <span class="n">g</span> <span class="n">n</span> <span class="bp">&amp;&amp;</span>
      <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="n">Bool</span> <span class="n">true</span>
      <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="n">Bool</span> <span class="n">true</span>
</code></pre></div>
<p>The call <code>f 1</code> will smart-unfold to <code>f 0</code>, which recursively smart-unfolds to <code>Bool.true</code>, which is not wrapped with <code>idRHS</code>; currently WHNF does not realize that this term is acceptable, and so rejects the smart-unfold. In contrast, <code>g 1</code> will smart-unfold to <code>idRHS true</code>, and so <code>true</code> is accepted.</p>



<a name="237752495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237752495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237752495">(May 07 2021 at 00:55)</a>:</h4>
<p>This bug looks similar to <a href="#narrow/stream/270676-lean4/topic/Smart.20unfolding.20produces.20ununfoldable.20terms">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Smart.20unfolding.20produces.20ununfoldable.20terms</a> . The <code>idRhs</code> applications in the <code>match n</code> seem to be spurious, it should be around the <code>&amp;&amp;</code>.</p>



<a name="237753514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237753514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237753514">(May 07 2021 at 01:09)</a>:</h4>
<p>reported as <a href="https://github.com/leanprover/lean4/issues/445">leanprover/lean4#445</a></p>



<a name="237753677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237753677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237753677">(May 07 2021 at 01:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you know if "smart-unfolding" has a precise semantics?</p>



<a name="237754424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237754424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237754424">(May 07 2021 at 01:21)</a>:</h4>
<p>The specification I would propose is that smart unfolding is a transformation on terms like so:</p>
<ul>
<li>
<p>If <code>e</code> is <code>match x with (| pat_i =&gt; e_i)*</code> where <code>x</code> is a variable,<br>
  then <code>smart_unfold(e)</code> is <code>match x with (| pat_i =&gt; smart_unfold(e_i))*</code></p>
</li>
<li>
<p>Otherwise, <code>smart_unfold(e) = idRhs _ e</code>.</p>
</li>
</ul>
<p>Another possible clause would apply to if statements:</p>
<ul>
<li>If <code>e</code> is <code>if c then e1 else e2</code> then <code>smart_unfold(e)</code> is <code>if c then smart_unfold(e1) else smart_unfold(e2)</code></li>
</ul>
<p>but given how this interacts with the consumer of smart unfolding, namely <code>isDefEq</code> when it wants to unfold a function, it seems like having it depend on an arbitrary predicate being true will be difficult to control. So I would stick with <em>just</em> top level match (on a variable) being smart unfolded, as in the first two bullets.</p>



<a name="237755840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237755840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237755840">(May 07 2021 at 01:42)</a>:</h4>
<p>Are you sure that wouldn't cause <code>simp</code> to loop?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">False</span> <span class="k">then</span> <span class="mi">1000</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span>   <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">foo</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">foo._proposed_sunfold</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">idRhs</span> <span class="bp">$</span>
  <span class="k">if</span> <span class="n">False</span> <span class="k">then</span> <span class="mi">1000</span> <span class="k">else</span>
    <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
    <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">foo</span> <span class="n">n</span>
</code></pre></div>
<p>Simp on <code>foo n</code>:</p>
<ul>
<li>smart-unfold <code>foo n</code> to expose the <code>if</code></li>
<li>traverse down to inner <code>foo n</code></li>
<li>repeat</li>
</ul>



<a name="237756019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237756019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237756019">(May 07 2021 at 01:45)</a>:</h4>
<p>Yes, this is a common problem with definitions that don't start with a pattern match. I don't think that is an issue for smart unfolding to solve though</p>



<a name="237756238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237756238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237756238">(May 07 2021 at 01:47)</a>:</h4>
<p>You hit this problem in lean 3 when unfolding definitions by well founded recursion because those often don't start with a pattern match, for example <code>gcd</code>.</p>



<a name="237756394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237756394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237756394">(May 07 2021 at 01:49)</a>:</h4>
<p>One potential fix is for <code>simp</code> to detect simple infinite loops, in this case that a definition is going to unfold unconditionally to a term containing itself, and then handle these definitions specially, either never unfolding them or only unfolding once. In such cases I don't think it is unreasonable to ask the user to use another tactic or another configuration of <code>simp</code> like <code>single_pass := true</code></p>



<a name="237756642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237756642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237756642">(May 07 2021 at 01:52)</a>:</h4>
<p>For <code>isDefEq</code> this isn't a major problem since it only unfolds lazily so having a recursive unfolding like this is fine as long as it is "productive" (i.e. doesn't unfold trivially to an application of itself like <code>foo := foo</code>)</p>



<a name="237756671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/237756671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#237756671">(May 07 2021 at 01:53)</a>:</h4>
<p>(plus these kinds of unfolding aren't definitional anyway so <code>isDefEq</code> generally doesn't have to worry about them)</p>



<a name="240319796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240319796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240319796">(May 26 2021 at 12:59)</a>:</h4>
<p>Hi. Here is another example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">binary_tree</span> <span class="n">α</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">node</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">left_subtree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right_subtree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">binary_tree</span>

<span class="kd">def</span> <span class="n">binary_tree_is_full</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Bool</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">left_tree</span> <span class="n">right_tree</span> <span class="bp">=&gt;</span>
  <span class="n">binary_tree_is_full</span> <span class="n">left_tree</span> <span class="bp">&amp;&amp;</span> <span class="n">binary_tree_is_full</span> <span class="n">right_tree</span>

<span class="kd">theorem</span> <span class="n">th</span>
  <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">left_tree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right_tree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">left_tree_is_full</span> <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="n">left_tree</span><span class="o">)</span>
  <span class="o">(</span><span class="n">right_tree_is_full</span> <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="n">right_tree</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="o">(</span><span class="n">node</span> <span class="n">value</span> <span class="n">left_tree</span> <span class="n">right_tree</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
  <span class="gr">admit</span>
</code></pre></div>
<p>simp doesn't unfold binary_tree_is_full. I expect it unfolds.<br>
Is this still a bug? I'm using Lean (version 4.0.0-nightly-2021-05-26, commit 02e917793e07, Release)</p>



<a name="240321747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240321747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240321747">(May 26 2021 at 13:13)</a>:</h4>
<p>What do you expect it to unfold to? The case is not sufficiently determined.</p>



<a name="240322594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240322594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240322594">(May 26 2021 at 13:19)</a>:</h4>
<p>oh i see you're right</p>



<a name="240324451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240324451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240324451">(May 26 2021 at 13:31)</a>:</h4>
<p>What about this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">binary_tree</span> <span class="n">α</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">node</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">left_subtree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right_subtree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">binary_tree</span>

<span class="kd">def</span> <span class="n">binary_tree_is_full</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Bool</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">left_tree</span> <span class="n">right_tree</span> <span class="bp">=&gt;</span>
  <span class="n">binary_tree_is_full</span> <span class="n">left_tree</span> <span class="bp">&amp;&amp;</span> <span class="n">binary_tree_is_full</span> <span class="n">right_tree</span>

<span class="kd">theorem</span> <span class="n">th</span>
  <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">left_tree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right_tree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">left_tree_is_full</span> <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="n">left_tree</span><span class="o">)</span>
  <span class="o">(</span><span class="n">right_tree_is_full</span> <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="n">right_tree</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="o">(</span><span class="n">node</span> <span class="n">value</span> <span class="n">left_tree</span> <span class="n">right_tree</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">let</span> <span class="n">tree</span> <span class="o">:=</span> <span class="n">node</span> <span class="n">value</span> <span class="n">left_tree</span> <span class="n">right_tree</span>
  <span class="k">match</span> <span class="n">tree</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="gr">admit</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="gr">admit</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="gr">admit</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="gr">admit</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
    <span class="gr">admit</span>
</code></pre></div>
<p>Shouldn't the last simp unfold to <code>binary_tree_is_full l &amp;&amp; binary_tree_is_full r</code>  ?</p>



<a name="240325860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240325860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240325860">(May 26 2021 at 13:40)</a>:</h4>
<p>Maybe this unprovable theorem is cleaner:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">th1</span> <span class="o">(</span><span class="n">tree</span> <span class="o">:</span> <span class="n">binary_tree</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">binary_tree_is_full</span> <span class="n">tree</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">tree</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">_</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
    <span class="gr">admit</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
    <span class="gr">admit</span>
  <span class="bp">|</span> <span class="n">node</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">binary_tree_is_full</span><span class="o">]</span>
    <span class="gr">admit</span>
</code></pre></div>
<p>I match with the same structure as in binary_tree definition, the first simps seem to work but not the last ones</p>



<a name="240326255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240326255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240326255">(May 26 2021 at 13:43)</a>:</h4>
<p>It's not that simple in presence of overlapping patterns. Your last case will only unfold if it's clear the prior ones did not match, i.e. on <code>node/node</code>. So you should match on <code>node _ (node ..) (node ..)</code> in the last proof case.</p>



<a name="240326629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240326629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240326629">(May 26 2021 at 13:45)</a>:</h4>
<p>Accumulating the knowledge that the prior <em>proof cases</em> did not match either would in theory be possible, but is very much nontrivial. It's also not clear how to actually make that knowledge accessible in general. E.g. if you match first on <code>node _ nil _</code> and then <code>node ..</code>, what should the goal state look like?</p>



<a name="240326892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240326892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240326892">(May 26 2021 at 13:46)</a>:</h4>
<p>I see... I think I will try to avoid overlapping patterns now</p>



<a name="240326947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240326947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240326947">(May 26 2021 at 13:47)</a>:</h4>
<p>Thanks</p>



<a name="240327180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240327180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240327180">(May 26 2021 at 13:49)</a>:</h4>
<p>At least in your proofs, yes :)</p>



<a name="240330378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240330378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240330378">(May 26 2021 at 14:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> when you talk about "in proofs" are you referring to <code>noConfusion</code> not working in <code>Sort 0</code>?</p>



<a name="240330458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simp%20not%20simplifying/near/240330458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simp.20not.20simplifying.html#240330458">(May 26 2021 at 14:11)</a>:</h4>
<p>No, I don't know about any connection to that</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html">Web Programming with Lean 4</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222834635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222834635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tom Houl√© <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222834635">(Jan 15 2021 at 09:13)</a>:</h4>
<p>I have been working with rust for a long time, currently I am using Lean (3) as a tool to learn more maths, and I have to say the perspective of Rust &lt;-&gt; Lean 4 interop is extremely exciting ‚Äî you could do things like embed wasmtime as a library, or get a mature regex engine "for free" by wrapping the <code>regex</code> crate. I haven't looked into that in depth yet, but an ergonomic bindgen-style crate could be possible. The fact that the Lean 4 objects are reference counted should make this easier.</p>



<a name="222838264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222838264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Uranus Testing <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222838264">(Jan 15 2021 at 09:56)</a>:</h4>
<p>If you interested, you can look at example of connecting libwebsockets (C-library, which also provides some kind of web server) to Lean 4 via FFI: <a href="https://github.com/o89/n2o">https://github.com/o89/n2o</a>. Connecting Rust-libraries shouldn ºt be harder, I guess.</p>



<a name="222852371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222852371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222852371">(Jan 15 2021 at 12:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346896">Henry Story</span> <a href="#narrow/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204/near/222816525">said</a>:</p>
<blockquote>
<p>Also am very intrigued by what the future holds for programming using proof assistants, especially with HoTT allowing one to transport proofs between types. As I am building a security platform, being able to produce proofs of the correctness of the code,  would be very advantageous.</p>
</blockquote>
<p>Worth noting, then, that Lean is explicitly HoTT-incompatible. However, I suspect that HoTT or no HoTT wouldn't make much of a difference for whatever proofs you want to do.</p>



<a name="222861385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222861385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Story <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222861385">(Jan 15 2021 at 14:08)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="256311">@Jannis Limperg</span>. Is it still true that Lean4 maintains HoTT incompatibility? As I understood from watching a few videos Lean4 is very extensible... (I have no idea of what would be needed to add such a feature to Lean4).<br>
The interest of HoTT as I understand is that one could say prove something on a simple data structure (say 0 and succ for Nat) and transport the proofs to another more complicated type (eg binary numbers). I could see that being useful in many places, such as proving things on simple representations of RDF say and then transporting those findings to more efficient representations (perhaps B-Trees or what not).</p>



<a name="222861441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222861441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222861441">(Jan 15 2021 at 14:09)</a>:</h4>
<p>You don't need HoTT to do that</p>



<a name="222862023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222862023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Story <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222862023">(Jan 15 2021 at 14:14)</a>:</h4>
<p>Ah it is the main example of this <a href="https://dl.acm.org/doi/10.1145/3341691">article on Cubical Agda</a>. It may be that I oversimplified the story of the benefits to be gained.</p>



<a name="222862394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222862394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Story <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222862394">(Jan 15 2021 at 14:17)</a>:</h4>
<p>Mind you, that is really looking a few (very large) steps ahead of where I am :-)<br>
For the moment I guess I'd first be interested to see where it would make sense to use Lean4 as a programming language. Perhaps everywhere? I mean could one even envision writing a web server with it? (or does that require codata?). But perhaps everywhere eventually, but initially most useful for working with ... ?</p>



<a name="222870854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222870854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222870854">(Jan 15 2021 at 15:14)</a>:</h4>
<p>The HoTT issue is about the core type theory of Lean, which assumes an axiom that contradicts HoTT. So afaict, Lean 4 will always remain HoTT-incompatible. (I'm not 100% sure what happens if you define an equality type in <code>Type</code>, not <code>Prop</code>, and axiomatise univalence for this type.)</p>
<p>Wrt practical uses of HoTT, it is still unclear to me whether it really helps or mostly shuffles proof obligations around. I did one project using HoTT (axiomatised in Agda) where I saw clear benefits but also had to do some nasty HoTT-specific proofs. In any case, I would expect that any practical development using HoTT could also be done without it, with at most a moderate increase in boilerplate.</p>
<p>Wrt suitability of Lean as a general-purpose programming language, I don't think anyone except Joe and his team has any practical experience, so it's hard to tell. I'm pretty sure, though, that the lack of codata is not a major limitation. If you need a program that runs indefinitely, you can just write a <code>partial</code> main loop that calls your request handling code, and each request is handled by a finite computation. More generally, you can work in a partiality monad and use a <code>partial</code> interpreter for that monad, though this may introduce some overhead.</p>



<a name="222874832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222874832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222874832">(Jan 15 2021 at 15:36)</a>:</h4>
<p>Whenever HoTT is mentioned here I have to shamelessly promote <a href="https://github.com/gebner/hott3">https://github.com/gebner/hott3</a><br>
It <em>is</em> possible to formalize HoTT in Lean 3, but of course it doesn't integrate with mathlib (which is probably impossible no matter how you do it due to mathlib's extensive use of choice).  The same approach to formalize HoTT also works in Lean 4 (and maybe even nicer because you can change the syntax).<br>
That said, HoTT in Lean 3 never really took off and it hasn't advanced beyond a proof-of-concept stage.  If I wanted to formalize something in HoTT, I'd rather look into the cubical system du jour.</p>



<a name="222890990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222890990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222890990">(Jan 15 2021 at 17:14)</a>:</h4>
<p>My experience with HoTT <em>in undergraduate or MSc level pure mathematics</em> (and my comments are restricted to this domain) is that it looks like it promises much, but doesn't actually deliver. I know of one example where it would help, and several examples where it looks like it will help but probably won't help. I have never used a HoTT system seriously and my main concern is that there might also be several examples where it actively hinders. Nothing like mathlib has been developed in any HoTT system, which one might want to take as evidence that it can't be done, but having talked a lot to HoTT people my impression is that the main reason there's no HoTT undergraduate maths library is that there are many foundational questions regarding HoTT which are regarded as fashionable (e.g. work on cubical), and so people in HoTT tend to work on those questions -- they regard formalising undergraduate and MSc pure mathematics as pointless, in the main.</p>
<p>Let me first start by explaining the example I know where it would help. A _local ring_ is -- it doesn't really matter what it is, it's a ring which satisfies some axioms. It's a theorem that if R is a local ring and S is a ring which is isomorphic to R, then S is also a local ring. I have asked many mathematicians how to prove this, and some are able to sketch a proof, but some just look at me like I'm an idiot and say that there is nothing to prove (this is a completely consistent viewpoint within mathematics departments -- all predicates we consider are isomorphism-invariant; a predicate which isn't isomorphism-invariant would just die out in the mathematics ecosystem). In a HoTT system there <em>is</em> nothing to prove: R is isomorphic to S, so R equals S, so done. In a non-HoTT system like Lean we have to build this proof. However the proof is mechanical -- a ring is local if it has a unique maximal ideal, which is just some predicate on the lattice of ideals of the ring, so you have to check that isomorphic rings have isomorphic lattices of ideals, that sort of thing.</p>
<p>Now here's another example, which looks very similar. Say X is a compact topological space, and Y is a topological space which is homeomorphic (i.e. isomorphic as a topological space) to X. Prove that Y is compact. Again this is immediate in a HoTT theory. But there is a more general theorem here: if X is compact and X -&gt; Y is a continuous surjection (a condition weaker than a homeomorphism) then Y is compact. This can't be proved for free, and should be in any decent maths library. The original assertion, that Y isomorphic to X is compact if X is, follows immediately from this. This is an observation of Mario, and ever since I internalised it I've always looked out for examples of when mathematicians want to transfer structure along isomorphisms, and in a surprisingly large amount of cases this transfer can be done just using more general results in the API. In fact it's worth revisiting the local ring example above. If we have a surjective ring hom R -&gt; S from a local ring R to a ring S then S is either local, or the zero ring. So there is a (weird to mathematicians, but apparently helpful here) predicate on a ring of being "pre-local", which means "either a local ring, or zero" (a bit like "either a prime, or 1"), and if R is prelocal and R -&gt; S is surjective then S is pre-local, something which one could imagine in a maths library, and so to transfer locality one just has to check that if R is non-zero and isomorphic to S, then S is non-zero, which is easy. This rather weakens (for me, at least) the argument that we should be (a) using HoTT to do this kind of mathematics or (b) making a tactic which transfers isomorphism-invariant predicates (e.g. any predicate which comes up in mathematics, such as local or compact).</p>
<p>The second instance where I've seen HoTT people telling me "this would be easy in HoTT" is an example where I recently discovered (when writing <a href="https://arxiv.org/abs/2101.02602">https://arxiv.org/abs/2101.02602</a> a couple of weeks ago) that actually I no longer believe the claims of the HoTTers. I give more details in section 3.4 of the paper but here's the gist of it. Say I want to prove that a map A -&gt; B satisfies some predicate (in the actual example I have a pair of maps A -&gt; B and B -&gt; C and want to prove that the pair satisfy a predicate, but let's drop C and just consider A -&gt; B because the point I'm trying to make remains). I have in my possession rings A' and B', a map A' -&gt; B', proofs that A' and A are isomorphic and that B' and B are isomorphic, and a proof that the map A' -&gt; B' satisfies the predicate. To prove that A -&gt; B satisfies the predicate in Lean I had to check that this predicate transferred over isomorphisms (which was a small amount of work) and also that the commutative square [a square with A -&gt; B on the top, A' -&gt; B' on the bottom, and isomorphisms A -&gt; A' and B -&gt; B' on the sides] commutes (this was a larger amount of work). The problem superficially looks like it is one which HoTT could help with, but I am no longer so sure. I think classical HoTT really could not help at all. We know A=A' and B=B' but we do not know that the maps A -&gt; B and A' -&gt; B' are equal, and in a HoTT theory my impression is that if you use univalence then you will not be able to prove this, because you will transfer the A' -&gt; B' map which satisfies the predicate into some map A -&gt; B' which you know satisfies the predicate but which you can't compute with, as you've used an axiom to construct it, so you can't show it equals your original map A -&gt; B. The point is that the commutativity of the diagram is a theorem, not something which comes for free. With cubical you'd be able to construct a map A -&gt; B which has the property and which you can compute with, but then you still have to do the computation to prove it's the map you're interested in, which boils down to checking the diagram commutes anyway. In the schemes work we solve this problem by using the fact that A -&gt; B comes from a universal property which we show also holds for A' and B' and then the proof becomes rather conceptual; the proof that A' -&gt; B' has the property just compiles equally well to also prove that A -&gt; B has the property. </p>
<p>In short then, within the domain of undergraduate and MSc mathematics I cannot <em>yet</em> see a useful application of HoTT which we can't get relatively straightforwardly in Lean, and furthermore I do not have much evidence for the assertion that there will be no hidden extra difficulties in making a HoTT library containing the kind of material which is in mathlib -- I am concerned that <code>rfl</code> will be highly degraded in a HoTT version of mathlib, and we use rfl a lot in mathlib. The reason I'm interested in making an UG maths library in a theorem prover is that it's something which mainstream mathematicians seem to be able to identify with, which is more than can be said for the HoTT theory right now; my impression is that in mathematical circles the achievements of the HoTT people are really regarded as foundational and hence "not really proper mathematics" in some sense. Of course, as a "proper mathematician" I am offering a perhaps rather biased viewpoint, so some of what I've said should be taken with a pinch of salt perhaps.</p>



<a name="222910558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222910558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Story <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222910558">(Jan 15 2021 at 19:19)</a>:</h4>
<p>Thanks very much for the detailed answer <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> . It will take me a long time to digest your answer, especially as I now have to reduce my time exploring Category Theory, which I came across programming the semantic web  and go back to working on the access control layer of Tim Berners-Lee's <a href="https://www.nytimes.com/2021/01/10/technology/tim-berners-lee-privacy-internet.html">Social Linked Data Server</a>.</p>
<p>It don't really know how far the mathematics of undergraduate and MSc level Math students compares to the mathematics we are using in programming languages (mostly with little knowledge of the theory). I went to a course by Abbas Edelat in 1994 on Category Theory at Imperial College but could not understand what was going on (I was also short on time). It is only when I started programming Scala 15 years later that I came across them explicitly. There I found some very interesting uses of  Free Monads, leading me to wonder how the notion of context that they bring in might be related to Modal Logics which I knew through careful studying David Lewis  as an undergraduate). Somehow I ended up back at university which gave me time to explore these things, and I found that indeed Indexed Strong Monads <a href="https://www.sciencedirect.com/science/article/pii/S1571066107000746">are related to modalities useful for Security Reasoning</a>.  <br>
Another example is the now very popular <a href="https://www.rust-lang.org">Rust programming language</a> which is based on work on Linear Logic and later studied in Category Theory by people like Samson Abramsky. When I first came across Linear Logic 3 years ago, I had no idea what to make of it. It is only when I saw how it was applied in Languages such as Idris2 and Granule -- which has Linear Graded Modal Types (<a href="https://twitter.com/bblfish/status/1195393138661216256">see talk</a>) -- that I could see how it could be interpreted.  Linear types allow one to write code with the efficiency of C, no garbage collection, but without the constant danger of resource (memory, sockets, etc.. leakage). Now  whole ecosystem of programmers are using linear logic happily every day, and being surprisingly productive doing.<br>
  So I it is quite possible that HoTT (and the recent work on <a href="https://golem.ph.utexas.edu/category/2020/02/modal_homotopy_type_theory_the.html">Modal HoTT</a>) will have very interesting applications to programming. Even without HoTT I'd be happy to see a few more examples of programs written in Lean4 in areas I understand, to see how I could use it.<br>
  (Btw. I think for an (under)graduate course in Mathematics you made a good choice with Lean, as it does have a very clean environment to allow students to step into. Agda would have required those students to learn Emacs, where I think you would have lost most of them. That is being improved.)<br>
  I guess as I have a programming background, I am always interested to see what tools are available, and how and where they would be usefully applied, so that I can understand when to reach for them. I have only 2 months experience working with Agda,  but none yet compiling it to something I could use in an application I need. But I can see that the future of programming is mathematics :-)</p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/bblfish/status/1195393138661216256"><img class="twitter-avatar" src="https://pbs.twimg.com/profile_images/1004326761608417281/HjxjS9BX_normal.jpg"></a><p><a href="https://twitter.com/sci_tec">@sci_tec</a> <a href="https://twitter.com/dorchard">@dorchard</a> <a href="https://twitter.com/smdiehl">@smdiehl</a> <a href="https://twitter.com/buggymcbugfix">@buggymcbugfix</a> <a href="https://twitter.com/heades">@heades</a> A talk on Granule, a functional programming language with linear and graded modal types using (co)monads for fine tuning of (co)effects given at this summer <a href="https://twitter.com/typelevel">@typelevel</a> summit organised by the #Scala community. See <a href="https://t.co/vnziOSmm7X">https://www.cs.kent.ac.uk/people/staff/dao7/publ/granule-icfp19.pdf</a>
<a href="https://t.co/4g2NQc21Pz">https://portal.klewel.com/watch/webcast/typelevel-summit-lausanne-2019/talk/4/</a></p><span>- The‚Äâüêü‚Äç‚Äç‚ÄâBabelFish (@bblfish)</span></div></div>



<a name="222921642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222921642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222921642">(Jan 15 2021 at 20:35)</a>:</h4>
<p>What happens in HoTT to statements that are not isomorphism-invariant? I guess that one simply cannot write them, but does this mean that stating a theorem is more difficult in HoTT than in (say) Lean? I mean, the fact that being a local ring is preserved by ring isomorphisms is trivial, but it still is a mathematical statement.</p>



<a name="222921726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222921726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222921726">(Jan 15 2021 at 20:36)</a>:</h4>
<p>Maybe I am being completely naive, but I find it surprising that one can prove this literally without doing anything</p>



<a name="222922924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222922924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222922924">(Jan 15 2021 at 20:46)</a>:</h4>
<p>You can write them, but you can't prove equality.</p>



<a name="222923348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222923348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222923348">(Jan 15 2021 at 20:50)</a>:</h4>
<p>Concerning Kevin's example with algebras (i.e. morphisms of commutative rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>), if I understand correctly, you can still make it work in the following way. You can define some structure which consists of the data of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, and the morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚Üí</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. You can define isomorphisms between two such structures in the usual way, and prove that isomorphic terms are equal, hence you can rewrite along such an equality. But like Kevin mentions this doesn't "save" any work, since you still have to prove something about the commutativity of the diagram involved at some point. You just moved the proof somewhere else.</p>



<a name="222924121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222924121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222924121">(Jan 15 2021 at 20:56)</a>:</h4>
<p>I mean (ridiculous) statements like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">3 \in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> is the integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">3 \in \mathbf{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span>. This is true for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">R =\mathbf {Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span>, but false for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="bold">Z</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">S = \mathbf{Z}[X]/X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Z</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, even if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>‚âÖ</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \cong S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚âÖ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>. Of course this is a statement that is completely irrelevant mathematically, but still...</p>



<a name="222924152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222924152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222924152">(Jan 15 2021 at 20:56)</a>:</h4>
<p>I apologize if I am writing total nonsense <span aria-label="innocent" class="emoji emoji-1f607" role="img" title="innocent">:innocent:</span></p>



<a name="222924180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222924180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222924180">(Jan 15 2021 at 20:57)</a>:</h4>
<p>Take a look at the cubical agda librrary where they prove that isomorphic rings are equal:<br>
<a href="https://github.com/agda/cubical/blob/390ac95aa2f87a131844aabe20a7b3ed81d608f4/Cubical/Algebra/Ring/Base.agda#L232">https://github.com/agda/cubical/blob/390ac95aa2f87a131844aabe20a7b3ed81d608f4/Cubical/Algebra/Ring/Base.agda#L232</a></p>



<a name="222924275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222924275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222924275">(Jan 15 2021 at 20:57)</a>:</h4>
<p>What is the actual proposition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">3 \in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>?</p>



<a name="222924607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222924607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222924607">(Jan 15 2021 at 21:00)</a>:</h4>
<p>I admit I don't know how to write it in Lean (in my set-theoretic mind <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">3 \in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a proposition, it means the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> is an element of the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, this can be true or false).</p>



<a name="222924649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222924649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222924649">(Jan 15 2021 at 21:00)</a>:</h4>
<p>But what is 3?</p>



<a name="222925132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925132">(Jan 15 2021 at 21:04)</a>:</h4>
<p>The integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1+1+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> or whatever you want. But in any case, non isomorphism-invariant statements do exist, right? If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is such a statement that hold for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is "something$$ but doesn't hold for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>‚âÖ</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \cong Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚âÖ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, it is surprising that we can consider <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X=Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> (since, I believe, one of the properties of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span> that we want is that if something holds for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X=Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> then the same thing holds for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>)</p>



<a name="222925190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925190">(Jan 15 2021 at 21:05)</a>:</h4>
<p>In real world mathematics what we usually don't say, but use all the time, is that all our statements are isomorphism-invariant, so this doesn't matter</p>



<a name="222925239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925239">(Jan 15 2021 at 21:05)</a>:</h4>
<p>Agait it is <em>very</em> possible that this is completely nonsensical</p>



<a name="222925314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925314">(Jan 15 2021 at 21:06)</a>:</h4>
<p>The trick in HoTT is that you can just transfer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">3 \in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">3 \in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> along the isomequality...</p>



<a name="222925385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925385">(Jan 15 2021 at 21:06)</a>:</h4>
<p>so even "non-isomorphism-invariant" props are just beaten into isomorphism-invariant shapes...</p>



<a name="222925437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925437">(Jan 15 2021 at 21:07)</a>:</h4>
<p>It is just that the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àà</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">‚àà</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">3 \in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> no longer means what you think it does...</p>



<a name="222925442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925442">(Jan 15 2021 at 21:07)</a>:</h4>
<p>Yeah, in HoTT there is no statement which is not "equality invariant", but there are some things you can call "isomorphic" which you cannot prove are actually "equal"</p>



<a name="222925568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222925568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222925568">(Jan 15 2021 at 21:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204/near/222890990">said</a>:</p>
<blockquote>
<p>I have in my possession rings A' and B', a map A' -&gt; B', proofs that A' and A are isomorphic and that B' and B are isomorphic, and a proof that the map A' -&gt; B' satisfies the predicate. To prove that A -&gt; B satisfies the predicate in Lean I had to check that this predicate transferred over isomorphisms (which was a small amount of work) and also that the commutative square [a square with A -&gt; B on the top, A' -&gt; B' on the bottom, and isomorphisms A -&gt; A' and B -&gt; B' on the sides] commutes (this was a larger amount of work). The problem superficially looks like it is one which HoTT could help with, but I am no longer so sure. I think classical HoTT really could not help at all. We know A=A' and B=B' but we do not know that the maps A -&gt; B and A' -&gt; B' are equal, and in a HoTT theory my impression is that if you use univalence then you will not be able to prove this, because you will transfer the A' -&gt; B' map which satisfies the predicate into some map A -&gt; B' which you know satisfies the predicate but which you can't compute with, as you've used an axiom to construct it, so you can't show it equals your original map A -&gt; B.</p>
</blockquote>
<p>You are right that HoTT does not help you here, but it does not hinder either. Say you have an iso <code>i : A ~= A'</code> and you use univalence to turn this into an equality <code>e : A = A'</code>. This induces a map <code>transp e : A -&gt; A'</code>, the 'transport' of <code>e</code>. Then the univalence axiom also implies that <code>transp e = i</code>. In a cubical type theory, this equality is definitional, but even the propositional version should suffice for whatever you want to do.</p>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204/near/222925190">said</a>:</p>
<blockquote>
<p>In real world mathematics what we usually don't say, but use all the time, is that all our statements are isomorphism-invariant, so this doesn't matter</p>
</blockquote>
<p>In a type theory which is consistent with HoTT, statements which are not invariant under isomorphism cannot be expressed. Otherwise the type theory would not be consistent with HoTT since, as you note, we would have <code>P X</code> and <code>X = Y</code> but not <code>P Y</code>. This is one of the major differences between set theory and Martin-L√∂f type theory.</p>



<a name="222926093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222926093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222926093">(Jan 15 2021 at 21:12)</a>:</h4>
<p>I think an interesting example is the type of degree <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>37</mn></mrow><annotation encoding="application/x-tex">37</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">7</span></span></span></span> extensions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_5</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83889em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. As a homotopy type, this is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>37</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(\mathbb{Z}/37)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord">3</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>, and any two terms of this type are isomorphic as fields.</p>



<a name="222927042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222927042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222927042">(Jan 15 2021 at 21:20)</a>:</h4>
<p>It seems a little bit some kind of black magic, but also type theory was confusing at the beginning...</p>



<a name="222935806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222935806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222935806">(Jan 15 2021 at 22:37)</a>:</h4>
<p>Riccardo I remember being confused by all of this a couple of years ago. I've just seen sufficiently many examples to make it not confusing any more. Your <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>‚àà</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">3\in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>  thing doesn't make sense because every term has exactly one type -- type theory stops you making a lot of non-isomorphism-invariant statements. On the other hand you might be surprised to know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is unprovable in Lean. The reason for this is that it could easily be true! You could just define <code>int</code> to be <code>nat</code> and put a new addition on it. But we don't do it like that, so it's unprovable.</p>



<a name="222937408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222937408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222937408">(Jan 15 2021 at 22:53)</a>:</h4>
<p>I think I got the point, but just to make an example taken from real mathematics: let us consider the category of metric spaces and continuous functions. The statement "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>X</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X, d_X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is bounded" is now a completely legitimate proposition. But now we can have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>X</mi></msub><mo stretchy="false">)</mo><mo>‚âÖ</mo><mo stretchy="false">(</mo><mi>Y</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>Y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X, d_X) \cong (Y, d_Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚âÖ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> in our category, with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>X</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X, d_X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> bounded and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>Y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y, d_Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> unbounded.</p>



<a name="222938374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222938374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222938374">(Jan 15 2021 at 23:03)</a>:</h4>
<p>I don't know much about HoTT but presumably what's going on is that being bounded is a predicate on metric spaces, and an isomorphism of metric spaces will be distance-preserving -- an isomorphism will by definition preserve all structure. Your isomorphism is an isomorphism of topological spaces but boundedness doesn't make sense on topological spaces</p>



<a name="222938575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222938575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222938575">(Jan 15 2021 at 23:05)</a>:</h4>
<p>Given a random structure you don't get a category because you can't work out what the morphisms are, they're not intrinsic to the structure. But there is a notion of isomorphism which is intrinsic to the structure and it's an <code>equiv</code> which literally maps the fields to each other.</p>



<a name="222938614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222938614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222938614">(Jan 15 2021 at 23:05)</a>:</h4>
<p>Yes exactly. To get an equality of metric spaces for an isomorphism you need the isomorphism to be distance preserving. It's not enough  to have a homeomorphism on the topological spaces. On the other hand, homeomorphic topological spaces are equal.</p>



<a name="222938876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222938876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222938876">(Jan 15 2021 at 23:08)</a>:</h4>
<p>Aah, isomorphism doesn't mean isomorphism in some category I can play with, it is something formal given by the structure itself. Now it's clear, thank you!</p>



<a name="222938885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222938885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222938885">(Jan 15 2021 at 23:08)</a>:</h4>
<p>You have put a standard category structure on metric spaces but this is not intrinsic to the type, like continuous maps are not intrinsic to topological spaces -- they are no more canonical from the type theory point of view than the category of top spaces with open, possibly discontinuous, maps as morphisms. Mathematicians just use the idea which turned out to be useful. In my research I once had to consider a category of metric spaces but with distance-nonincreasing maps as morphisms.</p>



<a name="222956645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/222956645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#222956645">(Jan 16 2021 at 03:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204/near/222938885">said</a>:</p>
<blockquote>
<p>You have put a standard category structure on metric spaces but this is not intrinsic to the type, like continuous maps are not intrinsic to topological spaces -- they are no more canonical from the type theory point of view than the category of top spaces with open, possibly discontinuous, maps as morphisms. Mathematicians just use the idea which turned out to be useful. In my research I once had to consider a category of metric spaces but with distance-nonincreasing maps as morphisms.</p>
</blockquote>
<p>On top of this, this latter category is what's usually referred to as "the category of metric spaces": it seems to be more useful in practice. See eg <a href="https://en.wikipedia.org/wiki/Category_of_metric_spaces">https://en.wikipedia.org/wiki/Category_of_metric_spaces</a></p>



<a name="223815785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/223815785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#223815785">(Jan 24 2021 at 14:11)</a>:</h4>
<p>Wait, wasn't this about writing a web server?</p>



<a name="223908241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Web%20Programming%20with%20Lean%204/near/223908241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henry Story <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Web.20Programming.20with.20Lean.204.html#223908241">(Jan 25 2021 at 15:00)</a>:</h4>
<p>Still happy to learn about Web Programming with Lean4 :-) I guess the theme  is a bit forward looking as the new Lean4 is just coming out. So the thread went all the way to looking at possibilities with HoTT.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
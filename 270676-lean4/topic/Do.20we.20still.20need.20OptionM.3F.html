---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html">Do we still need OptionM?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279761084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/279761084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#279761084">(Apr 22 2022 at 00:50)</a>:</h4>
<p>This came up in a discussion today with some HOL4 folks, who were surprised to see that Option and OptionM are not the same thing in lean 4. As I recall, the issue had to do with type inference in auto-pure situations. Since auto-pure has since been removed, does this mean that these types can be reunified? Or are there some examples that show bad behavior if <code>Option A</code> is a monad?</p>



<a name="279764777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/279764777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#279764777">(Apr 22 2022 at 01:04)</a>:</h4>
<p>Another issue was that Lean is not lazy, but we have already adjusted the types of key combinators <code>&lt;|&gt;</code>, <code>*&gt;</code>, etc.<br>
Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">OrElse</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">orElse</span>  <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>
<p>I don't recall other pending issues, but I don't have all the details in my mind right now. <br>
<span class="user-mention" data-user-id="354934">@David Thrane Christiansen</span> If I remember correctly you had some reservations regarding the fusion, but I forgot them, sorry. Could you please remind us?</p>



<a name="279767351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/279767351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#279767351">(Apr 22 2022 at 01:44)</a>:</h4>
<p>In any case we should put documentation about this issue somewhere (like on <code>OptionM</code> docs) since I expect it to be a recurring question</p>



<a name="279974145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/279974145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Thrane Christiansen <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#279974145">(Apr 24 2022 at 10:17)</a>:</h4>
<p>My only reservation was that datatypes used as control structures a la Haskell and datatypes used to contain actual data often demand different laziness properties from operations defined on them. It seems quite plausible, however, that it's sufficient to make everything control-structure-like take explicitly thunked expressions in the places where a C programmer would expect short-circuiting, and then arrange for the syntactic overhead to go away via macrology, and then make everything data-manipulation-like be straightforwardly strict. I think this is probably a "try it and see what happens" kind of situation.</p>



<a name="281229701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/281229701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#281229701">(May 04 2022 at 22:35)</a>:</h4>
<p><code>OptionM</code> has been deleted, and <code>Monad Option</code> is back.</p>



<a name="281282312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/281282312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#281282312">(May 05 2022 at 10:58)</a>:</h4>
<p>This is especially nice for exposition to a mathematical audience, as <code>Option</code> is (to me at least) the first natural monad. Thanks</p>



<a name="296271096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/296271096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#296271096">(Aug 31 2022 at 07:39)</a>:</h4>
<p>Does this mean we can have <code>Monad Task</code>?</p>



<a name="296277181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/296277181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#296277181">(Aug 31 2022 at 08:20)</a>:</h4>
<p>It's of course possible.  But there are a couple of gotchas with <code>Monad Task</code>, which I believe is the reason we don't have it as a default instance.</p>
<ol>
<li><code>Task.bind</code> and co. have a priority argument, with <code>Monad Task</code> you'd always get the default.</li>
<li>Every <code>bind</code> creates a new task, which might be a bit expensive.</li>
</ol>



<a name="296278820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/296278820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#296278820">(Aug 31 2022 at 08:31)</a>:</h4>
<p>It might be nice to have a <code>TaskBuilder</code> monad which encapsulates the task structure but is only actually launched when you do <code>TaskBuilder.run : TaskBuilder A -&gt; Task A</code></p>



<a name="296278909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/296278909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#296278909">(Aug 31 2022 at 08:31)</a>:</h4>
<p>I'm not actually sure where you would want to use <code>Task.map</code> or <code>Task.bind</code></p>



<a name="296278979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/296278979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#296278979">(Aug 31 2022 at 08:32)</a>:</h4>
<p>since they seem to be variations on <code>Task.spawn</code></p>



<a name="296279370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/296279370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#296279370">(Aug 31 2022 at 08:34)</a>:</h4>
<p><code>Task.map</code> and <code>Task.bind</code> are used in the LSP request handling logic.</p>



<a name="297421670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297421670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297421670">(Sep 06 2022 at 15:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/296278909">said</a>:</p>
<blockquote>
<p>I'm not actually sure where you would want to use <code>Task.map</code> or <code>Task.bind</code></p>
</blockquote>
<blockquote>
<p>since they seem to be variations on <code>Task.spawn</code></p>
</blockquote>
<p>They are much more efficient (c.f. my old task <a href="#narrow/stream/270676-lean4/topic/IO.20Tasks/near/248578429">thread</a>).</p>



<a name="297422481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297422481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297422481">(Sep 06 2022 at 15:08)</a>:</h4>
<p>is <code>IO.mapTask</code> different from <code>Task.map</code>?</p>



<a name="297422808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297422808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297422808">(Sep 06 2022 at 15:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> it executes <code>IO</code>  code and is impure (so it can be optimized out). Otherwise, it is the same.</p>



<a name="297422989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297422989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297422989">(Sep 06 2022 at 15:10)</a>:</h4>
<p>Sorry, that is in relation to <code>Taks.bind</code>/<code>IO.bindTask</code> not <code>Task.map</code>/<code>IO.mapTask</code>.</p>



<a name="297423020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297423020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297423020">(Sep 06 2022 at 15:10)</a>:</h4>
<p><code>IO.mapTask</code> is actually a bind not a map.</p>



<a name="297423095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297423095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297423095">(Sep 06 2022 at 15:10)</a>:</h4>
<p><code>Task.map</code> is just an ordinary map.</p>



<a name="297425755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297425755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297425755">(Sep 06 2022 at 15:14)</a>:</h4>
<p>I still can't imagine situations where <code>Task.map</code> would be a good idea compared to just determining in advance what the thread is going to return and then launching it (e.g. by passing around <code>(A -&gt; Task R) -&gt; Task R</code> if you don't yet know what <code>R</code> is)</p>



<a name="297426127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297426127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297426127">(Sep 06 2022 at 15:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I am pretty sure <code>Task.map</code> is much more efficient than generating closures. Remember, CPS is not efficient in Lean.</p>



<a name="297426234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297426234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297426234">(Sep 06 2022 at 15:16)</a>:</h4>
<p><a href="http://Task.map">Task.map</a> is going to be just as bad since you have to build up the closure in the task structure itself</p>



<a name="297426575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297426575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297426575">(Sep 06 2022 at 15:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297426127">said</a>:</p>
<blockquote>
<p>Remember, CPS is not efficient in Lean.</p>
</blockquote>
<p>citation needed? As long as it turns into join points I don't see a major issue with CPS</p>



<a name="297426888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297426888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297426888">(Sep 06 2022 at 15:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297426575">said</a>:</p>
<blockquote>
<p>citation needed? As long as it turns into join points I don't see a major issue with CPS</p>
</blockquote>
<p>Leo has directly said this to me. They did benchmarking and for whatever reason (he did not explain why to me) they found the Lean compiler to produce very inefficient code w/ CPS . This is why the Lean monads are not implemented using CPS.</p>



<a name="297427186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297427186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297427186">(Sep 06 2022 at 15:21)</a>:</h4>
<p>You don't want to spawn a thread and then spawn another thread just to join on the first one. The cost of calling a closure should be a lot less than the threading overhead</p>



<a name="297427656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297427656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297427656">(Sep 06 2022 at 15:23)</a>:</h4>
<p>plus there's a big difference between using CPS everywhere and just at points where you would otherwise use <code>Task.map</code></p>



<a name="297427671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297427671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297427671">(Sep 06 2022 at 15:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <code>Task.map</code> does not spawn a new thread. It is an extern function implemented in C. It works like the closure you mentioned but produces more efficient code.</p>



<a name="297427860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297427860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297427860">(Sep 06 2022 at 15:24)</a>:</h4>
<p>The problem is fundamentally more complicated if the thread has already been spawned, which is the case for <code>Task.map</code></p>



<a name="297427971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297427971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297427971">(Sep 06 2022 at 15:24)</a>:</h4>
<p>because then you have to swap out the code the thread is currently running</p>



<a name="297428140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297428140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297428140">(Sep 06 2022 at 15:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> yes, but the problem is already solved through Lean's runtime task manager which for <code>Task.map</code> adds a non-thread task (produced from the map closure) as a dependency to the previous task and waits for it on a <code>Task.get</code>/<code>IO.wait</code>.</p>



<a name="297428776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297428776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297428776">(Sep 06 2022 at 15:29)</a>:</h4>
<p>I think the answer to my question then is that you should use <code>Task.map</code> when you want to clone the original task object and <code>map</code> it twice or poll both it and the <code>map</code>ped task later</p>



<a name="297428924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297428924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297428924">(Sep 06 2022 at 15:29)</a>:</h4>
<p>if it's just a linear sequence of steps then you should build up a closure instead to avoid the overhead in the task manager</p>



<a name="297429503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297429503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297429503">(Sep 06 2022 at 15:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297428776">said</a>:</p>
<blockquote>
<p>when you want to clone the original task object</p>
</blockquote>
<p>There is no cloning going on.</p>



<a name="297429818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297429818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297429818">(Sep 06 2022 at 15:33)</a>:</h4>
<p>I mean something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">Task.spawn</span> <span class="n">foo</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a.map</span> <span class="n">bar</span>
<span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">a.map</span> <span class="n">baz</span>
<span class="n">return</span> <span class="o">(</span><span class="n">a.get</span><span class="o">,</span> <span class="n">b.get</span><span class="o">,</span> <span class="n">c.get</span><span class="o">)</span>
</code></pre></div>



<a name="297430031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297430031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297430031">(Sep 06 2022 at 15:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297428924">said</a>:</p>
<blockquote>
<p>if it's just a linear sequence of steps then you should build up a closure instead to avoid the overhead in the task manager</p>
</blockquote>
<p>This is true -- composing functions (e.g., manually or with <code>comp</code>) before a <code>Task.map</code> is better than doing so after (with <code>&lt;$&gt;</code>). However, this is almost always the case with functors (and not thus not particularly special to <code>Task.map</code>).</p>



<a name="297430504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297430504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297430504">(Sep 06 2022 at 15:36)</a>:</h4>
<p>what makes <code>Task.map</code> special is that you can also compose inside the argument to spawn. If in the example we only needed <code>b.get</code> we could instead write it as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">Task.spawn</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">bar</span> <span class="o">(</span><span class="n">foo</span> <span class="o">())</span>
<span class="n">return</span> <span class="n">b.get</span>
</code></pre></div>



<a name="297430595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297430595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297430595">(Sep 06 2022 at 15:36)</a>:</h4>
<p>that's not a transformation that applies generally to any functor</p>



<a name="297430732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297430732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297430732">(Sep 06 2022 at 15:37)</a>:</h4>
<p>true, though generally <code>Task.map</code> is used when you already have an arbitrary spawned task, not at spawn.</p>



<a name="297430819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297430819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297430819">(Sep 06 2022 at 15:37)</a>:</h4>
<p>right but why would you be in that situation?</p>



<a name="297430958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297430958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297430958">(Sep 06 2022 at 15:38)</a>:</h4>
<p>???</p>



<a name="297431001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431001">(Sep 06 2022 at 15:38)</a>:</h4>
<p>For instance, Lake uses <code>Task.map</code> a lot. So does the LSP.</p>



<a name="297431007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431007">(Sep 06 2022 at 15:38)</a>:</h4>
<p>the CPS trick is how you can avoid spawning the task in the "arbitrary context" case</p>



<a name="297431236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431236">(Sep 06 2022 at 15:39)</a>:</h4>
<p>Oh, I think understand the confusion. When one uses <code>Task.map</code> it is because one wants to modify an already spawned task running in parallel (or is already finished). That is, you have some set of tasks that you spawned previously to run in parallel and later on you wish to map their values.</p>



<a name="297431332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431332">(Sep 06 2022 at 15:40)</a>:</h4>
<p>I assume they mostly fall in the case above though? That is, the task to map is not a "private" one, it is being cloned around</p>



<a name="297431424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431424">(Sep 06 2022 at 15:40)</a>:</h4>
<p>e.g. file elaboration tasks or module build tasks</p>



<a name="297431716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431716">(Sep 06 2022 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297431332">said</a>:</p>
<blockquote>
<p>I assume they mostly fall in the case above though? That is, the task to map is not a "private" one, it is being cloned around</p>
</blockquote>
<p>Yes they likely do fit your previous <code>a</code>, <code>b</code>, <code>c</code> example. Though, again, no cloning is taking place.</p>



<a name="297431827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431827">(Sep 06 2022 at 15:42)</a>:</h4>
<p>when I say clone I mean it in the rust sense, i.e. sharing a pointer</p>



<a name="297431936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297431936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297431936">(Sep 06 2022 at 15:43)</a>:</h4>
<p>in lean that usually just means you can't take advantage of unshared opts</p>



<a name="297432036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432036">(Sep 06 2022 at 15:43)</a>:</h4>
<p>so the gist of my argument is that <em>unshared</em> <code>Task.map</code> is an antipattern</p>



<a name="297432117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432117">(Sep 06 2022 at 15:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297422481">said</a>:</p>
<blockquote>
<p>is <code>IO.mapTask</code> different from <code>Task.map</code>?</p>
</blockquote>
<p>Yes, <code>Task.map</code> will be cancelled if the refcount reaches zero.  While <code>IO.mapTask</code> will always be executed.</p>



<a name="297432148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432148">(Sep 06 2022 at 15:44)</a>:</h4>
<p>Okay, in that case, I guess I am taking issue with Rust's misuse of terminology. That is not what cloning is. The whole point of a clone (pre-Rust) is that the two objects are <em>not</em> pointing to the same data (e.g., JS's clone and Ruby's clone methods).</p>



<a name="297432226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432226">(Sep 06 2022 at 15:44)</a>:</h4>
<p>That's not a thing in lean</p>



<a name="297432380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432380">(Sep 06 2022 at 15:45)</a>:</h4>
<p>there is no way as far as I know to force two objects to have disjoint object graphs</p>



<a name="297432549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432549">(Sep 06 2022 at 15:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297432226">said</a>:</p>
<blockquote>
<p>That's not a thing in lean</p>
</blockquote>
<p>Lean mutations produce clones (if RC &gt; 1).</p>



<a name="297432604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432604">(Sep 06 2022 at 15:46)</a>:</h4>
<p>no, they can still have common data</p>



<a name="297432724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432724">(Sep 06 2022 at 15:47)</a>:</h4>
<p>Which is fine (and is what a (shallow) clone is). Only a deep clone requires no nested sharing.</p>



<a name="297432863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432863">(Sep 06 2022 at 15:47)</a>:</h4>
<p>when you clone an RC you get two pointers to the same thing and an incremented refcount</p>



<a name="297432923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297432923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297432923">(Sep 06 2022 at 15:48)</a>:</h4>
<p>same thing happens in C++</p>



<a name="297433090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297433090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297433090">(Sep 06 2022 at 15:49)</a>:</h4>
<p>That's not a clone, that is just a copy-on-write. JS and Ruby also use reference counters, but their clones generate new objects.</p>



<a name="297433110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297433110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297433110">(Sep 06 2022 at 15:49)</a>:</h4>
<p>that <em>is</em> a "shallow clone" if you want to call it that. The pointer objects themselves are distinct, they just point to the same thing</p>



<a name="297433263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297433263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297433263">(Sep 06 2022 at 15:49)</a>:</h4>
<p>A shallow clone is one in which one can mutate the clone's (top-level) data without effecting the original. A RC increment does not do that.</p>



<a name="297433583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297433583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297433583">(Sep 06 2022 at 15:51)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Object_copying">https://en.wikipedia.org/wiki/Object_copying</a></p>



<a name="297433774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297433774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297433774">(Sep 06 2022 at 15:52)</a>:</h4>
<p>cloning is always done lazily in lean, it copies as much as it needs to to do mutations</p>



<a name="297433984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297433984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297433984">(Sep 06 2022 at 15:53)</a>:</h4>
<p><em>copying</em> is always done lazily (copy-on-write) in Lean, the term clone has historically always been used to refer to shallow or deep copies (not lazy ones).</p>



<a name="297434017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434017">(Sep 06 2022 at 15:53)</a>:</h4>
<p>e.g., Java, JS, Ruby.</p>



<a name="297434060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434060">(Sep 06 2022 at 15:53)</a>:</h4>
<p>I think the disconnect here is a disagreement about what "top level" means. You can change the pointer to point to something else without affecting the original, for example</p>



<a name="297434151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434151">(Sep 06 2022 at 15:54)</a>:</h4>
<p>in rust objects are on the stack by default so that's the top level</p>



<a name="297434199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434199">(Sep 06 2022 at 15:54)</a>:</h4>
<p>in GC languages everything is behind a heap pointer so that's the top level</p>



<a name="297434234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434234">(Sep 06 2022 at 15:54)</a>:</h4>
<p>A shallow copy/clone is defined as: "In that case a new object B is created, and the fields values of A are copied over to B"</p>



<a name="297434338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434338">(Sep 06 2022 at 15:55)</a>:</h4>
<p>A pointer copy (e.g., a lazy copy or copy-on-write) is something else (not a shallow copy).</p>



<a name="297434418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434418">(Sep 06 2022 at 15:55)</a>:</h4>
<p>yup, a pointer object B is created and it's value from A is copied to B</p>



<a name="297434673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434673">(Sep 06 2022 at 15:56)</a>:</h4>
<p>Note  in the definition, the "fields values of A" not A itself.</p>



<a name="297434730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434730">(Sep 06 2022 at 15:57)</a>:</h4>
<p>well a pointer is a simple struct with one field</p>



<a name="297434800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434800">(Sep 06 2022 at 15:57)</a>:</h4>
<p>No it is not, it is not a struct at all.</p>



<a name="297434859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434859">(Sep 06 2022 at 15:57)</a>:</h4>
<p>or in lean's case, a union between a pointer and a u64</p>



<a name="297434992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297434992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297434992">(Sep 06 2022 at 15:58)</a>:</h4>
<p>both of which are not structs but simple (non-aggregate) data values, from whom the notion of copying/cloning doesn't even exist.</p>



<a name="297435071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435071">(Sep 06 2022 at 15:58)</a>:</h4>
<p>a value exists in memory on the stack or in a register, so you can certainly copy it elsewhere</p>



<a name="297435217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435217">(Sep 06 2022 at 15:59)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Cloning_(programming)">https://en.wikipedia.org/wiki/Cloning_(programming)</a></p>



<a name="297435366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435366">(Sep 06 2022 at 16:00)</a>:</h4>
<p>The article literally separates what you are talking about (a primitive copy) from the notion of cloning.</p>



<a name="297435630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435630">(Sep 06 2022 at 16:01)</a>:</h4>
<p>in languages like C++ and Rust where objects on the stack can have destructors, the concept of cloning certainly applies to them</p>



<a name="297435766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435766">(Sep 06 2022 at 16:02)</a>:</h4>
<p>pointers are just the trivial case where cloning is a memcopy</p>



<a name="297435917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435917">(Sep 06 2022 at 16:02)</a>:</h4>
<p>True, it does. Never did I say on object's location (stack, heap, disk, etc.) is relevant to the definition.</p>



<a name="297435953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297435953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297435953">(Sep 06 2022 at 16:02)</a>:</h4>
<p>What is relevant is the object's structure.</p>



<a name="297436034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436034">(Sep 06 2022 at 16:03)</a>:</h4>
<p>Pointers a primitive values, thus they cannot be accurately described as being cloned.</p>



<a name="297436080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436080">(Sep 06 2022 at 16:03)</a>:</h4>
<p>The object pointed to by a pointer though can.</p>



<a name="297436091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436091">(Sep 06 2022 at 16:03)</a>:</h4>
<p>An RC pointer in fact has a nontrivial destructor and clone operation</p>



<a name="297436189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436189">(Sep 06 2022 at 16:04)</a>:</h4>
<p>Yes, the pointer object is clonable.</p>



<a name="297436212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436212">(Sep 06 2022 at 16:04)</a>:</h4>
<p>the clone operation makes a copy of the pointer value but also increments the underlying refcount</p>



<a name="297436240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436240">(Sep 06 2022 at 16:04)</a>:</h4>
<p>But that is not the same as cloning the object it points to.</p>



<a name="297436324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436324">(Sep 06 2022 at 16:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/297436212">said</a>:</p>
<blockquote>
<p>the clone operation makes a copy of the pointer value but also increments the underlying refcount</p>
</blockquote>
<p>That is not a proper clone in the first place.</p>



<a name="297436382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436382">(Sep 06 2022 at 16:05)</a>:</h4>
<p>That is a C++ abuse of the clone function to do pointer magic.</p>



<a name="297436404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436404">(Sep 06 2022 at 16:05)</a>:</h4>
<p>...</p>



<a name="297436439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436439">(Sep 06 2022 at 16:05)</a>:</h4>
<p>C++ feature abuse being very common in C++ (and, after a while, the abuse generally becomes standard practice, as with shared pointers). That is, the original idea behind the <code>clone</code> in C++ was to produce shallow/deep clones (hence the name), but eventually people realized it could be used to conveniently manage shared pointers, so it eventually acquired that use as well (even though that does not fit the meaning of the term).</p>



<a name="297436653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436653">(Sep 06 2022 at 16:06)</a>:</h4>
<p>Again, the term clone has a clear common definition (as noted on Wikipedia). RC increments do not meet this definition.</p>



<a name="297436761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297436761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297436761">(Sep 06 2022 at 16:07)</a>:</h4>
<p>Literally the definition from Wikipedia is: "The process of actually making another exact replica of the object <strong>instead of just its reference</strong> is called cloning"  (emphasis mine)</p>



<a name="297438168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297438168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297438168">(Sep 06 2022 at 16:14)</a>:</h4>
<p>Obviously, this is just a debate over semantics, and there is nothing wrong with different people and groups having different terminology. My point is simply my definition of cloning is not an outlier and is the historically common notion.</p>



<a name="297438367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do%20we%20still%20need%20OptionM%3F/near/297438367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F.html#297438367">(Sep 06 2022 at 16:15)</a>:</h4>
<p>However, as you pointed out, that distinction is now blurred in many places (e.g., C++ and Rust), thus creating a terminology schism.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/typeclass.20failure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html">typeclass failure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="241318335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241318335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241318335">(Jun 02 2021 at 20:52)</a>:</h4>
<p>I would expect type class inference to succeed here. I couldn't get it to work in Lean 3 either. What am I doing wrong?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span> <span class="o">:</span> <span class="n">M</span>

<span class="kd">notation</span> <span class="s2">"♩"</span> <span class="bp">=&gt;</span> <span class="n">has_note.note</span>

<span class="kd">class</span> <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_note</span> <span class="n">M</span> <span class="n">where</span>
  <span class="n">foo</span> <span class="o">:</span> <span class="n">Unit</span> <span class="c1">-- in Lean 3 you can just extend has_note with no extra fields and the problem persists</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">dfinsupp</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">dfinsupp.has_note</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">dfinsupp.has_note_and_foo</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="bp">♩</span>
  <span class="n">foo</span> <span class="o">:=</span> <span class="o">()</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">finsupp</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span>             <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">finsupp.has_note</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">finsupp.has_note_and_foo</span> <span class="o">[</span><span class="n">has_note_and_foo</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="bp">♩</span>
  <span class="n">foo</span> <span class="o">:=</span> <span class="o">()</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">has_note_and_foo</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">inferInstance</span> <span class="c1">-- fails</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">has_note_and_foo</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">dfinsupp.has_note_and_foo</span> <span class="n">_</span> <span class="c1">-- works</span>

<span class="c1">-- in Lean 3, removing the instance attribute from `finsupp.has_note` makes inferInstance work</span>
</code></pre></div>
<p>Supplementary questions which came up when I was making this: <br>
(1) I know it's ridiculous but I didn't know how to make a class foo2 extend foo1 and then add no more fields (so foo2 is a copy of foo1). In Lean 3 you can do <code>class foo2 extends foo1.</code>. <br>
(2) In Lean 3 I could try and debug using <code>set_option trace.class_instances true</code>. How do you say that in Lean 4?<br>
(3) In Lean 3 I could experiment with removing <code>instance</code> tags from my defs with <code>local attribute [-instance] finsupp.has_zero</code> (which fixes the problem). How do you say that in Lean 4?</p>
<p>PS <a href="#narrow/stream/113488-general/topic/dfinsupp.2Ffinsupp.20type.20class.20issue/near/241300314">here</a> is the Lean 3 discussion, with some traces.</p>



<a name="241324392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241324392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241324392">(Jun 02 2021 at 21:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241318335">said</a>:</p>
<blockquote>
<p>(2) In Lean 3 I could try and debug using <code>set_option trace.class_instances true</code>. How do you say that in Lean 4?</p>
</blockquote>
<p>The equivalent seems to now be <code>set_option trace.Meta.synthInstance true</code></p>
<blockquote>
<p>(3) In Lean 3 I could experiment with removing <code>instance</code> tags from my defs with <code>local attribute [-instance] finsupp.has_zero</code> (which fixes the problem). How do you say that in Lean 4?</p>
</blockquote>
<p>I don't know if you can remove attributes anymore, but manually removing <code>finsupp.has_note</code> and including it into <code>finsupp.has_note_and_foo</code> seems to make the <code>inferInstance</code> succeed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">--instance finsupp.has_note [has_note M] :</span>
<span class="c1">--  has_note (finsupp α M) := ⟨⟨λ i =&gt; ♩⟩⟩</span>

<span class="kd">instance</span> <span class="n">finsupp.has_note_and_foo</span> <span class="o">[</span><span class="n">has_note_and_foo</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩</span>
  <span class="n">foo</span> <span class="o">:=</span> <span class="o">()</span>
</code></pre></div>



<a name="241328496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241328496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241328496">(Jun 02 2021 at 22:34)</a>:</h4>
<p>I'm not sure why exactly typeclass resolution doesn't work, but somehow splitting off <code>has_foo</code> and creating a <code>has_note_and_foo</code> synonym class makes it succeed.  (I'm not recommending anything by posting this.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span> <span class="o">:</span> <span class="n">M</span>

<span class="kd">notation</span> <span class="s2">"♩"</span> <span class="bp">=&gt;</span> <span class="n">has_note.note</span>

<span class="kd">class</span> <span class="n">has_foo</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">where</span>
  <span class="n">ax</span> <span class="o">:</span> <span class="o">(</span><span class="bp">♩</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">♩</span> <span class="c1">-- example axiom that has_note should satisfy</span>

<span class="kd">class</span> <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_note</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_foo</span> <span class="n">M</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">has_note_and_foo.mk</span>

<span class="kd">structure</span> <span class="n">dfinsupp</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">→</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="n">where</span>
  <span class="n">to_fun</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">i</span>

<span class="kd">instance</span> <span class="n">dfinsupp._has_note</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">→</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">dfinsupp._has_foo</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">[(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">→</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">[(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">→</span> <span class="n">has_foo</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_foo</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ax</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">structure</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="n">where</span>
  <span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span>

<span class="kd">instance</span> <span class="n">finsupp._has_note</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">finsupp._has_foo</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_foo</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_foo</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ax</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_foo</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">):</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">inferInstance</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_foo</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">):</span>
  <span class="n">has_foo</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">inferInstance</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_foo</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">):</span>
  <span class="n">has_note_and_foo</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">inferInstance</span>
</code></pre></div>



<a name="241329310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241329310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241329310">(Jun 02 2021 at 22:46)</a>:</h4>
<p>In the Lean 3 use case, note = 0, foo = +, and finsupp and dfinsupp are finitely supported functions.</p>



<a name="241345942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241345942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241345942">(Jun 03 2021 at 03:53)</a>:</h4>
<blockquote>
<p>(1) I know it's ridiculous but I didn't know how to make a class foo2 extend foo1 and then add no more fields (so foo2 is a copy of foo1). In Lean 3 you can do <code>class foo2 extends foo1.</code>. </p>
</blockquote>
<p>That sounds like it could be an issue on the lean 4 repo. I have noticed a number of uses of "1 or more" in the grammar where "0 or more" would be valid, useful and no harder to parse: the fields after <code>where</code> in this case as well as <code>match x with arms+</code> come to mind. There are probably some variations of the <code>where</code> syntax appearing like <code>instance ... where</code>, <code>def ... where</code>, as well as <code>let rec</code>, <code>mutual</code>, <code>variable</code>.</p>



<a name="241357693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241357693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241357693">(Jun 03 2021 at 07:43)</a>:</h4>
<p>I think you can do <code>class Foo2 extends Foo1 where</code> now.</p>



<a name="241357800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241357800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241357800">(Jun 03 2021 at 07:44)</a>:</h4>
<p>Weirdly enough, it's impossible to extend the <em>empty</em> structure:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Bar</span>
<span class="kd">class</span> <span class="n">Foo</span> <span class="kd">extends</span> <span class="n">Bar</span> <span class="n">where</span>
<span class="c1">-- 'Bar' is not a structure</span>
</code></pre></div>



<a name="241357856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241357856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241357856">(Jun 03 2021 at 07:45)</a>:</h4>
<p>oh, <code>class Bar</code> works?</p>



<a name="241357876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241357876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241357876">(Jun 03 2021 at 07:46)</a>:</h4>
<p>I'm surprised it's not <code>class Bar where</code></p>



<a name="241357879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241357879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241357879">(Jun 03 2021 at 07:46)</a>:</h4>
<p>Yes!</p>



<a name="241357974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241357974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241357974">(Jun 03 2021 at 07:47)</a>:</h4>
<p>Wait, I don't need the <code>where</code> after extends either.  This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Bar</span> <span class="n">where</span>
  <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="kd">class</span> <span class="n">Foo</span> <span class="kd">extends</span> <span class="n">Bar</span>
</code></pre></div>



<a name="241358328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241358328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241358328">(Jun 03 2021 at 07:51)</a>:</h4>
<p>Oh! I had sort of assumed Kevin tried that, since it does seem like the style we want to encourage</p>



<a name="241358969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241358969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241358969">(Jun 03 2021 at 07:59)</a>:</h4>
<p>I am an idiot</p>



<a name="241359048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241359048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241359048">(Jun 03 2021 at 08:00)</a>:</h4>
<p>and indeed <code>inferInstance</code> is still failing even with foo removal</p>



<a name="241426431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241426431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241426431">(Jun 03 2021 at 17:42)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> , do you have an idea why typeclass inference fails on <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241318335">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241318335</a> ?</p>



<a name="241455170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241455170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241455170">(Jun 03 2021 at 21:14)</a>:</h4>
<p>Here's the foo-free version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span> <span class="o">:</span> <span class="n">M</span>

<span class="kd">notation</span> <span class="s2">"♩"</span> <span class="bp">=&gt;</span> <span class="n">has_note.note</span>

<span class="kd">class</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_note</span> <span class="n">M</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">dfinsupp</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">dfinsupp.has_note</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">dfinsupp.has_note2</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note2</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="bp">♩</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">finsupp</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span>             <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">finsupp.has_note</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">finsupp.has_note2</span> <span class="o">[</span><span class="n">has_note2</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_note2</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="bp">♩</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">has_note2</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">inferInstance</span> <span class="c1">-- fails</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">has_note2</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">dfinsupp.has_note2</span> <span class="n">_</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="241455348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241455348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241455348">(Jun 03 2021 at 21:15)</a>:</h4>
<p>And here's the variant that works -- "remove <code>finsupp.has_note</code> and bundle it into <code>finsupp.has_note2</code>":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span> <span class="o">:</span> <span class="n">M</span>

<span class="kd">notation</span> <span class="s2">"♩"</span> <span class="bp">=&gt;</span> <span class="n">has_note.note</span>

<span class="kd">class</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_note</span> <span class="n">M</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">dfinsupp</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">dfinsupp.has_note</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="n">dfinsupp.has_note2</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">has_note2</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="bp">♩</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">finsupp</span> <span class="o">[</span><span class="n">has_note</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span>             <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">finsupp.has_note2</span> <span class="o">[</span><span class="n">has_note2</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">finsupp</span> <span class="n">α</span> <span class="n">M</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">note</span>      <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="bp">♩</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">has_note2</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">inferInstance</span> <span class="c1">-- now works</span>
</code></pre></div>



<a name="241469009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241469009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241469009">(Jun 03 2021 at 23:23)</a>:</h4>
<p>I imagine this has to do  with the fact that the original <code>finsupp</code> has two <code>has_note</code> instances, one explicit and one it implicitly acquires through its explicit <code>has_note2</code> instance extending <code>has_note</code>. Lean might not like  these kind of psuedo-diamonds.</p>



<a name="241469959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241469959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241469959">(Jun 03 2021 at 23:35)</a>:</h4>
<p>Those instances are defeq, right? I don't think this is the issue. I think that what you describe happens all over the place in mathlib in lean 3, you make something an additive abelian group and then a ring and this is no problem at all.</p>



<a name="241470232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241470232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241470232">(Jun 03 2021 at 23:39)</a>:</h4>
<p>I think it's something to do with the pi type in the class. You can test your hypothesis by removing the pi type and trying to get type class inference to fail without it but still having your pseudo-diamond.</p>



<a name="241506248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241506248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241506248">(Jun 04 2021 at 08:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.Meta.synthInstance</span> <span class="n">true</span>
<span class="bp">#</span><span class="n">synth</span> <span class="o">[</span><span class="n">has_note2</span> <span class="n">N</span><span class="o">]</span> <span class="bp">→</span> <span class="n">has_note2</span> <span class="o">(</span><span class="n">dfinsupp</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">finsupp</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">N</span><span class="o">))</span>

<span class="c1">-- ...</span>
<span class="c1">-- [Meta.synthInstance.tryResolve] has_note2</span>
<span class="c1">--   (dfinsupp fun (i : ι) =&gt; finsupp (η i) N) =?= has_note2 (dfinsupp fun (i : ?m.1404) =&gt; ?m.1405 i)</span>
<span class="c1">-- [Meta.synthInstance.tryResolve] failure</span>
</code></pre></div>
<p>It appears to be a unification problem involving metavariables under a lambda. It looks like a bug, or at least a regression from lean 3 behavior - here <code>?m.1405 i</code> should be unified with <code>finsupp (η i) N</code> but this is being rejected, and the synthesis fails.</p>



<a name="241506732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241506732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241506732">(Jun 04 2021 at 08:46)</a>:</h4>
<p>It's also failing in lean 3</p>



<a name="241506820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241506820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241506820">(Jun 04 2021 at 08:48)</a>:</h4>
<p>Should I open an issue?</p>



<a name="241507750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241507750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241507750">(Jun 04 2021 at 08:58)</a>:</h4>
<p>Hm, if it fails in lean 3 too then that lowers the chance that it will be fixable, but it's certainly something that Daniel or Leo will want to consider, so I would say yes</p>



<a name="241523492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/241523492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#241523492">(Jun 04 2021 at 11:45)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/509">lean4#509</a></p>



<a name="242094672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242094672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242094672">(Jun 09 2021 at 16:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241426431">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> , do you have an idea why typeclass inference fails on <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241318335">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241318335</a> ?</p>
</blockquote>
<p>Hey, was away last week. I don't have time to address this now but I took a quick look and my first guess is that it tries to unify: <code>((?m &lt;something&gt;).1 : has_note2 M) =?= (&lt;something-else&gt; : has_note M)</code> and that the solution may be to add special support for unification hints for structures with a single field, i.e. making it so that <code>x.1 =?= y</code> would try <code>x =?= ⟨y⟩</code>.</p>



<a name="242095364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242095364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242095364">(Jun 09 2021 at 16:42)</a>:</h4>
<p>Also, it would be nice to have such hints for structures where all but one field is a Prop.</p>



<a name="242095602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242095602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242095602">(Jun 09 2021 at 16:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119741">François G. Dorais</span> <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/242095364">said</a>:</p>
<blockquote>
<p>Also, it would be nice to have such hints for structures where all but one field is a Prop.</p>
</blockquote>
<p>Can you please clarify?</p>



<a name="242100705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242100705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242100705">(Jun 09 2021 at 17:21)</a>:</h4>
<p>NVM: wrong way around.</p>



<a name="242386704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242386704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242386704">(Jun 11 2021 at 18:41)</a>:</h4>
<p>fixed in <a href="https://github.com/leanprover/lean4/pull/521">lean4#521</a>. Thanks to the devs!</p>



<a name="242403188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242403188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242403188">(Jun 11 2021 at 21:06)</a>:</h4>
<p>Does that fix actually help for the dfinsupp case? Wasn't <code>add_zero_class</code> relevant there, which has multiple fields?</p>



<a name="242405315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242405315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242405315">(Jun 11 2021 at 21:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/242403188">said</a>:</p>
<blockquote>
<p>Does that fix actually help for the dfinsupp case? Wasn't <code>add_zero_class</code> relevant there, which has multiple fields?</p>
</blockquote>
<p>The example with <code>dfinsupp</code> posted at <a href="#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241455170">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass.20failure/near/241455170</a> works now as well.</p>



<a name="242412054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242412054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242412054">(Jun 11 2021 at 22:39)</a>:</h4>
<p>Is it likely it would be doable for a lean 3 expert (and obviously not an already busy lean4 dev!) to backport to lean 3? Or does the strategy used to fix this only really exist in lean 4?</p>



<a name="242412905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/242412905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#242412905">(Jun 11 2021 at 22:53)</a>:</h4>
<p>I don't see any obstacle. It is a reasonably local and lightweight change.</p>



<a name="248961197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/typeclass%20failure/near/248961197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/typeclass.20failure.html#248961197">(Aug 10 2021 at 10:13)</a>:</h4>
<p>(deleted)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/UnionFind.20proof.20assistance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html">UnionFind proof assistance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="292861343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292861343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292861343">(Aug 11 2022 at 03:00)</a>:</h4>
<p>Hello. I'd like some assistance writing proofs for a Union-Find implementation. I've figured out how to write all the proofs except for growing the collection, which is Fin-specific and I couldn't find the right rewrites to apply. That aside, I feel there are better ways to write the proofs. Any suggestions?</p>
<p>Oh and I feel like it'd be nice to have a proof there cannot exist cycles, but for now I've just gone with a for-loop for worst-case fuel and exit early. Not even sure where I'd start to express such an acyclic proof, can do without, just would be a very nice property to have proven.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">UnionFind</span> <span class="o">(</span><span class="n">size</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">data</span> <span class="o">:</span> <span class="n">Array</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">size</span><span class="o">))</span>
  <span class="o">(</span><span class="n">correct_size</span> <span class="o">:</span> <span class="n">size</span> <span class="bp">=</span> <span class="n">data.size</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">UnionFind</span>
  <span class="kd">def</span> <span class="n">parent</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="n">u.data</span><span class="o">[</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">u.correct_size</span><span class="o">]</span> <span class="n">at</span> <span class="n">i</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i</span><span class="o">]</span>

  <span class="kd">def</span> <span class="n">grow</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="o">(</span><span class="n">size</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">{</span>
      <span class="n">data</span> <span class="o">:=</span> <span class="n">u.data.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">Fin.mk</span> <span class="n">x.val</span> <span class="gr">sorry</span><span class="o">)</span> <span class="bp">|&gt;.</span><span class="n">push</span> <span class="o">(</span><span class="n">Fin.mk</span> <span class="n">size</span> <span class="gr">sorry</span><span class="o">),</span>
      <span class="n">correct_size</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="o">}</span>

  <span class="kn">private</span> <span class="kd">def</span> <span class="n">set_parent</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">u.correct_size</span><span class="o">]</span> <span class="n">at</span> <span class="n">i</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i</span>
    <span class="o">{</span>
      <span class="n">data</span> <span class="o">:=</span> <span class="n">u.data.set</span> <span class="n">i</span> <span class="n">p</span><span class="o">,</span>
      <span class="n">correct_size</span> <span class="o">:=</span> <span class="kd">by</span> <span class="k">have</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">u.data.size_set</span> <span class="n">i</span> <span class="n">p</span><span class="bp">;</span> <span class="k">have</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">u.correct_size</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">q.symm</span><span class="o">]</span> <span class="n">at</span> <span class="n">s</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">}</span>

  <span class="kd">def</span> <span class="n">find</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">mut</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">u</span>
    <span class="k">let</span> <span class="n">mut</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
    <span class="n">for</span> <span class="n">_</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span> <span class="o">:</span> <span class="n">size</span><span class="o">]</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">u.parent</span> <span class="n">i</span>
      <span class="k">let</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">u.parent</span> <span class="n">p</span>
      <span class="k">if</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">g</span> <span class="k">then</span>
        <span class="n">break</span>
      <span class="n">u</span> <span class="o">:=</span> <span class="n">u.set_parent</span> <span class="n">i</span> <span class="n">g</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">g</span>
    <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>

  <span class="kd">def</span> <span class="n">union</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">u.find</span> <span class="n">a</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">u.find</span> <span class="n">b</span>
    <span class="n">u.set_parent</span> <span class="n">a</span> <span class="n">b</span>
<span class="kd">end</span> <span class="n">UnionFind</span>
</code></pre></div>



<a name="292861472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292861472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292861472">(Aug 11 2022 at 03:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I noted your UnionFind implementation in Mathlib. 300 lines, returns proofs, not quite what I expected. Was there any specific goal with this approach not met by my approach? <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean</a></p>



<a name="292861619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292861619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292861619">(Aug 11 2022 at 03:05)</a>:</h4>
<p>I will add ranks to my implementation.</p>



<a name="292861700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292861700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292861700">(Aug 11 2022 at 03:06)</a>:</h4>
<p>I have written very few proofs so far. Was happy to get as far as I did here. :)</p>



<a name="292865762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292865762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292865762">(Aug 11 2022 at 04:29)</a>:</h4>
<p>Updated towards adding the rank, but stuck with the proofs still.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">UFNode</span> <span class="o">(</span><span class="n">size</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">parent</span> <span class="n">rank</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">UnionFind</span> <span class="o">(</span><span class="n">size</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">data</span> <span class="o">:</span> <span class="n">Array</span> <span class="o">(</span><span class="n">UFNode</span> <span class="n">size</span><span class="o">))</span>
  <span class="o">(</span><span class="n">correct_size</span> <span class="o">:</span> <span class="n">size</span> <span class="bp">=</span> <span class="n">data.size</span><span class="o">)</span>
<span class="c1">-- Iff a node is not its own parent, the rank must increase.</span>
<span class="c1">--(rank_proof : forall s : Fin data.size, s != data[s].parent &lt;-&gt; data[s].rank &lt; data[data[s].parent].rank))</span>

<span class="kn">namespace</span> <span class="n">UnionFind</span>
  <span class="kd">def</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="mi">0</span> <span class="n">where</span>
    <span class="n">data</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span>
    <span class="n">correct_size</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">decide</span>

  <span class="kd">def</span> <span class="n">grow</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="o">(</span><span class="n">size</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">data</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- u.data.map (fun x =&gt; Fin.mk x.val sorry) |&gt;.push (Fin.mk size sorry),</span>
    <span class="n">correct_size</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">--by decide</span>

  <span class="kd">def</span> <span class="n">lookup</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UFNode</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="n">u.data</span><span class="o">[</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">u.correct_size</span><span class="o">]</span> <span class="n">at</span> <span class="n">i</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i</span><span class="o">]</span>

  <span class="kd">def</span> <span class="n">set_parent</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">u.correct_size</span><span class="o">]</span> <span class="n">at</span> <span class="n">i</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">parent</span> <span class="o">:=</span> <span class="n">p</span><span class="o">,</span> <span class="n">rank</span> <span class="o">:=</span> <span class="n">u.lookup</span> <span class="n">p</span> <span class="bp">|&gt;.</span><span class="n">rank</span> <span class="c">/-</span><span class="cm"> + 1 -/</span> <span class="o">}</span>
    <span class="o">{</span>
      <span class="n">data</span> <span class="o">:=</span> <span class="n">u.data.set</span> <span class="n">i</span> <span class="n">n</span>
      <span class="n">correct_size</span> <span class="o">:=</span> <span class="kd">by</span> <span class="k">have</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">u.data.size_set</span> <span class="n">i</span> <span class="n">n</span><span class="bp">;</span> <span class="k">have</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">u.correct_size</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">q.symm</span><span class="o">]</span> <span class="n">at</span> <span class="n">s</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">}</span>

  <span class="c1">-- find with path halving.</span>
  <span class="kd">def</span> <span class="n">find</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">UFNode</span> <span class="n">size</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">:=</span> <span class="n">u.lookup</span> <span class="n">i</span>
    <span class="k">if</span> <span class="n">node.parent</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span>
      <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="k">let</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">u.lookup</span> <span class="n">node.parent</span> <span class="bp">|&gt;.</span><span class="n">parent</span>
      <span class="n">find</span> <span class="o">(</span><span class="n">u.set_parent</span> <span class="n">i</span> <span class="n">g</span><span class="o">)</span> <span class="n">g</span>
  <span class="n">decreasing_by</span> <span class="gr">sorry</span> <span class="c1">-- rank is monotonic</span>

  <span class="kd">def</span> <span class="n">union</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UnionFind</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">u.find</span> <span class="n">a</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">u.find</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">_h</span> <span class="o">:</span> <span class="n">a.rank</span> <span class="bp">&lt;</span> <span class="n">b.rank</span> <span class="k">then</span>
      <span class="n">u.set_parent</span> <span class="n">a.parent</span> <span class="n">b.parent</span> <span class="c1">-- h</span>
    <span class="k">else</span>
      <span class="n">u.set_parent</span> <span class="n">b.parent</span> <span class="n">a.parent</span> <span class="c1">-- h.symm</span>
<span class="kd">end</span> <span class="n">UnionFind</span>
</code></pre></div>



<a name="292866358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292866358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292866358">(Aug 11 2022 at 04:40)</a>:</h4>
<p>Whoops, there are 3 orders, not 2. Should be an extra branch in that union. Also.. <code>(not h).symm</code> ?</p>



<a name="292868957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292868957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292868957">(Aug 11 2022 at 05:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> <a href="#narrow/stream/270676-lean4/topic/UnionFind.20proof.20assistance/near/292861472">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> I noted your UnionFind implementation in Mathlib. 300 lines, returns proofs, not quite what I expected. Was there any specific goal with this approach not met by my approach? <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean</a></p>
</blockquote>
<ul>
<li>The <code>UnionFind</code> type itself does not depend on <code>size</code></li>
<li>It stores data associated to the nodes, although that could arguably be separated from the data structure itself</li>
<li>It does path compression, which is required to get the famed inverse-ackermann runtime bound</li>
<li>It supports <code>grow</code> without remapping the array (which is O(n))</li>
</ul>
<p>I can concede that putting the <code>size</code> in the type leads to an easier interface though, since it's easier to track the size that way.</p>



<a name="292869723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292869723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292869723">(Aug 11 2022 at 05:36)</a>:</h4>
<p>'Full' path compression has more memory accesses due to the second iteration. 'Splitting' updates the same number of nodes and 'halving' updates half the nodes. Full path compression is known to be slower, and splitting and halving perform the same. I've chosen halving to reduce write throughput regardless. <a href="https://arxiv.org/abs/1911.06347">https://arxiv.org/abs/1911.06347</a></p>



<a name="292870012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292870012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292870012">(Aug 11 2022 at 05:40)</a>:</h4>
<p>I might add the data in, but have a few other details to figure out before deciding quite how everything is laid out. For context, I'm implementing UnionFind towards an E-graph implementation which compiles to a Datalog incremental relational database for worst-case optimal queries, with multi-patterns and adaptive query scheduling. <a href="https://arxiv.org/abs/2108.02290">https://arxiv.org/abs/2108.02290</a></p>



<a name="292870421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292870421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292870421">(Aug 11 2022 at 05:46)</a>:</h4>
<p>Also curious about implementing an SMT solver using the E-graph with these incremental worst-case optimal queries.</p>



<a name="292872260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872260">(Aug 11 2022 at 06:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Oh I forgot to ask. Does the map over <code>Fin</code> values to update their bound not become free? IIUC Lean will understand the value is used once, thus do an in-place map, then realize the only changes are in proof terms, thus are no-ops, right?</p>



<a name="292872537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872537">(Aug 11 2022 at 06:15)</a>:</h4>
<p>One would hope so, but you have to look at the generated code to now for sure. I'm fairly confident that this is still too magical for lean ATM</p>



<a name="292872645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872645">(Aug 11 2022 at 06:17)</a>:</h4>
<p>In general I'm dubious about all these changes without actual performance numbers for comparison</p>



<a name="292872698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872698">(Aug 11 2022 at 06:17)</a>:</h4>
<p>If you mean the path compression methods? That paper I linked is all about those numbers.</p>



<a name="292872758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872758">(Aug 11 2022 at 06:18)</a>:</h4>
<p>I mean in lean</p>



<a name="292872779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872779">(Aug 11 2022 at 06:18)</a>:</h4>
<p>the paper seems to be about concurrent unionfind, which is completely different</p>



<a name="292872793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872793">(Aug 11 2022 at 06:18)</a>:</h4>
<p>all the unionfind functions are inherently serial, they mutate the data structure</p>



<a name="292872904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872904">(Aug 11 2022 at 06:20)</a>:</h4>
<p>if you used them with a shared pointer to the <code>UnionFind</code> value it would have terrible performance, since it would have to copy the whole array first</p>



<a name="292872950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872950">(Aug 11 2022 at 06:20)</a>:</h4>
<p>It discusses both. An interesting detail of the concurrent union find is you can use plain reads/writes to update the structure and you only need memory barriers to check if a self-parent candidate is actually true. No atomics, just a single fence at the end of <code>find</code> whose result is likely true.</p>



<a name="292872993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292872993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292872993">(Aug 11 2022 at 06:21)</a>:</h4>
<p>This is because stale or not, all invariants hold.</p>



<a name="292873009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873009">(Aug 11 2022 at 06:21)</a>:</h4>
<p>This isn't C / Rust, we don't have that level of access to memory in the first place</p>



<a name="292873080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873080">(Aug 11 2022 at 06:22)</a>:</h4>
<p>Optimization is very dependent on the compiler and runtime here</p>



<a name="292873110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873110">(Aug 11 2022 at 06:22)</a>:</h4>
<p>Indeed. Would be nice though. Either way, the path compression methods were benchmarked serially in addition to later for the concurrent case.</p>



<a name="292873121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873121">(Aug 11 2022 at 06:22)</a>:</h4>
<p>again, it needs to be lean numbers</p>



<a name="292873142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873142">(Aug 11 2022 at 06:23)</a>:</h4>
<p>I think the bigger problem would be all the pointer-chasing. Ex. An array of fin or nat aren't inlined IIUC.</p>



<a name="292873149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873149">(Aug 11 2022 at 06:23)</a>:</h4>
<p>Sure</p>



<a name="292873305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873305">(Aug 11 2022 at 06:25)</a>:</h4>
<p>Note that the implementation of unionfind didn't start out 300 lines. That's only after doing all the proofs. It was only around 30 lines before all the proofs and invariants were added</p>



<a name="292873478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873478">(Aug 11 2022 at 06:26)</a>:</h4>
<p>Aye. It was the interface which returns the size proof that I found surprising at first. But it does feel like that was a lot of proof work and I wonder if there would be a better way to represent it.</p>



<a name="292873517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873517">(Aug 11 2022 at 06:26)</a>:</h4>
<p>you know it didn't start out looking like that, it got added because you need it to do a later part of the proof</p>



<a name="292873561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873561">(Aug 11 2022 at 06:27)</a>:</h4>
<p>Right.</p>



<a name="292873566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873566">(Aug 11 2022 at 06:27)</a>:</h4>
<p>I think there could be another way to represent it, but it's tricky to avoid passing unnecessary arguments</p>



<a name="292873579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873579">(Aug 11 2022 at 06:27)</a>:</h4>
<p>in particular <code>size</code></p>



<a name="292873666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873666">(Aug 11 2022 at 06:28)</a>:</h4>
<p>Speaking of, I was a little surprised when I started playing with Lean 4 that <code>Vect a k</code> isn't implemented (except in comments), everything seems to use <code>Array a</code>.</p>



<a name="292873696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873696">(Aug 11 2022 at 06:28)</a>:</h4>
<p>dependent types are not good for the compiler</p>



<a name="292873753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873753">(Aug 11 2022 at 06:29)</a>:</h4>
<p>Heh. Well, I hope this will not be true for my own.</p>



<a name="292873830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873830">(Aug 11 2022 at 06:30)</a>:</h4>
<p>They block various kinds of code motion optimizations because of having to introduce <code>cast</code></p>



<a name="292873851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292873851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292873851">(Aug 11 2022 at 06:30)</a>:</h4>
<p>I don't think yours is an exception, unless you have reason to believe that the blocked optimizations aren't important for you</p>



<a name="292874016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292874016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292874016">(Aug 11 2022 at 06:32)</a>:</h4>
<p>Not quite sure which block you mean. Either way my design is largely based on equality saturation, and reasoning with symbolic terms.</p>



<a name="292874447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292874447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292874447">(Aug 11 2022 at 06:37)</a>:</h4>
<p>In the case of storing a vector, letting it grow, then shrink, if the compiler can see the upper bound (and it isn't too high), then it can allocate that region without re-allocating and copying the data around to make it fit. While in the earlier or intermediate stages, any unused allocated area can be repurposed for ephemeral local scratch space. Similarly any padding can be used for sentinels.</p>



<a name="292874603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292874603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292874603">(Aug 11 2022 at 06:39)</a>:</h4>
<p>Most of the time arrays/vectors can have statically known upper bounds through a little symbolic analysis. When this analysis fails, then we have to pay for the re-allocations and copies if necessary. Further we don't just want to consider the worst-case, as the average may be much friendlier and we don't want to waste memory just to be conservative.</p>



<a name="292875061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292875061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292875061">(Aug 11 2022 at 06:44)</a>:</h4>
<p>Linear memory management is a really good starting point.</p>



<a name="292922441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292922441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292922441">(Aug 11 2022 at 12:44)</a>:</h4>
<p>Huh. I updated Lean, now I get this error on one of my proofs which was working before.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">def</span> <span class="n">lookup</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">@&amp;</span> <span class="n">UnionFind</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="n">UFNode</span> <span class="n">size</span> <span class="o">:=</span>
    <span class="n">u.data</span><span class="o">[</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">u.correct_size</span><span class="o">]</span> <span class="n">at</span> <span class="n">i</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i</span><span class="o">]</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">UnionFind.lean</span><span class="o">:</span><span class="mi">60</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">index</span> <span class="n">is</span> <span class="n">valid</span><span class="o">,</span> <span class="n">possible</span> <span class="n">solutions</span><span class="o">:</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="k">have</span><span class="bp">`-</span><span class="n">expressions</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">the</span> <span class="n">index</span> <span class="n">is</span> <span class="n">valid</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">!`</span> <span class="kd">notation</span> <span class="n">instead</span><span class="o">,</span> <span class="n">runtime</span> <span class="n">check</span> <span class="n">is</span> <span class="n">perfomed</span><span class="o">,</span> <span class="n">and</span> <span class="bp">'</span><span class="n">Panic'</span> <span class="n">error</span> <span class="n">message</span> <span class="n">is</span> <span class="n">produced</span> <span class="k">if</span> <span class="n">index</span> <span class="n">is</span> <span class="n">not</span> <span class="n">valid</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">?`</span> <span class="kd">notation</span> <span class="n">instead</span><span class="o">,</span> <span class="n">result</span> <span class="n">is</span> <span class="n">an</span> <span class="bp">`</span><span class="n">Option</span><span class="bp">`</span> <span class="n">type</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">'</span><span class="n">h</span><span class="bp">`</span> <span class="kd">notation</span> <span class="n">instead</span><span class="o">,</span> <span class="n">where</span> <span class="bp">`</span><span class="n">h</span><span class="bp">`</span> <span class="n">is</span> <span class="n">a</span> <span class="n">proof</span> <span class="n">that</span> <span class="n">index</span> <span class="n">is</span> <span class="n">valid</span>
</code></pre></div>



<a name="292929123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292929123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292929123">(Aug 11 2022 at 13:23)</a>:</h4>
<p>you could use <code>.get</code> there</p>



<a name="292929217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292929217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292929217">(Aug 11 2022 at 13:24)</a>:</h4>
<p>the <code>a[i]</code> syntax now expects a <code>Nat</code> in the first position</p>



<a name="292929251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292929251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292929251">(Aug 11 2022 at 13:24)</a>:</h4>
<p>or a <code>Fin _</code> but you would have to type ascribe it</p>



<a name="292931894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292931894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292931894">(Aug 11 2022 at 13:40)</a>:</h4>
<p>Ah. First it was Nat, then Fin, now Nat again. o.o</p>



<a name="292931931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292931931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292931931">(Aug 11 2022 at 13:40)</a>:</h4>
<p>Thanks, can confirm using <code>.get</code> worked.</p>



<a name="292932174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292932174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292932174">(Aug 11 2022 at 13:42)</a>:</h4>
<p>Why would the explicit type ascription work if not the type just being itself?</p>



<a name="292932816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292932816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292932816">(Aug 11 2022 at 13:45)</a>:</h4>
<p>It now accepts multiple types there, so a <code>by</code> block won't work because the type is unconstrained</p>



<a name="292932961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292932961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292932961">(Aug 11 2022 at 13:46)</a>:</h4>
<p>Ah, that bit. Okay. Huh.</p>



<a name="292933012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292933012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292933012">(Aug 11 2022 at 13:47)</a>:</h4>
<p>If you give it a <code>Nat</code>, then it expects a proof to be supplied, if you give it <code>Fin _</code> then it doesn't need the proof</p>



<a name="292933066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292933066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292933066">(Aug 11 2022 at 13:47)</a>:</h4>
<p>Not even.. <code>u.data[by rw [u.correct_size] at i; exact (i : Fin _)]</code></p>



<a name="292933134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292933134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292933134">(Aug 11 2022 at 13:47)</a>:</h4>
<p>try <code>u.data[(by rw [u.correct_size] at i; exact i : Fin _)]</code></p>



<a name="292933216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292933216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292933216">(Aug 11 2022 at 13:48)</a>:</h4>
<p>Or <code>u.data[(by rw [u.correct_size] at i; exact i) : Fin _]</code></p>



<a name="292933298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292933298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292933298">(Aug 11 2022 at 13:48)</a>:</h4>
<p>Your suggestion worked.</p>



<a name="292933396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292933396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292933396">(Aug 11 2022 at 13:49)</a>:</h4>
<p>Means the .get is shortest. <em>shrug</em></p>



<a name="292934065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292934065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292934065">(Aug 11 2022 at 13:53)</a>:</h4>
<p>you could also do <code>u.data[i.1]'(by rw [u.correct_size] at i; exact i.2)</code> IIUC</p>



<a name="292934772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292934772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292934772">(Aug 11 2022 at 13:57)</a>:</h4>
<p>I tried a variant, with <code>.val</code> and <code>.isLt</code> which didn't work because the value is detached from the rewrite it seems.</p>



<a name="292935017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292935017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292935017">(Aug 11 2022 at 13:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">error</span><span class="o">:</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">i.isLt</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">Array.size</span> <span class="n">u.data</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">i</span><span class="bp">✝.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">Array.size</span> <span class="n">u.data</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="292935802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292935802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292935802">(Aug 11 2022 at 14:03)</a>:</h4>
<p>MWE?</p>



<a name="292936837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292936837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292936837">(Aug 11 2022 at 14:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">size</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">data</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Unit</span>
  <span class="n">size_proof</span> <span class="o">:</span> <span class="n">size</span> <span class="bp">=</span> <span class="n">data.size</span>

<span class="kd">def</span> <span class="n">wme</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">size</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">size</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">f.data</span><span class="o">[</span><span class="n">i.1</span><span class="o">]</span><span class="bp">'</span><span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">f.size_proof</span><span class="o">]</span> <span class="n">at</span> <span class="n">i</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">i.2</span><span class="o">)</span>
</code></pre></div>



<a name="292939160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292939160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292939160">(Aug 11 2022 at 14:22)</a>:</h4>
<p><code>f.data[i.1]'(by rw [← f.size_proof]; exact i.2)</code> is better in that case</p>



<a name="292939188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292939188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292939188">(Aug 11 2022 at 14:22)</a>:</h4>
<p>or just <code>f.data[i]'(f.size_proof ▸ i.2)</code></p>



<a name="292939673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292939673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292939673">(Aug 11 2022 at 14:25)</a>:</h4>
<p>Wait what, how? o.o</p>



<a name="292940047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292940047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292940047">(Aug 11 2022 at 14:27)</a>:</h4>
<p><code>i</code> coerces to <code>i.1</code>, which adds even more fun to this</p>



<a name="292940216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292940216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292940216">(Aug 11 2022 at 14:28)</a>:</h4>
<p>I'll go with <code>f.data.get (f.size_proof ▸ i)</code> given these options.</p>



<a name="292941216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292941216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292941216">(Aug 11 2022 at 14:33)</a>:</h4>
<p>How would you write <code>by have q := u.data.size_set i n; have s := u.size_proof ; rw [q.symm] at s; exact s</code> in this form?</p>



<a name="292941409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292941409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292941409">(Aug 11 2022 at 14:34)</a>:</h4>
<p>hard to say without MWE but probably <code>u.data.size_set i n \t u.size_proof</code></p>



<a name="292941597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292941597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292941597">(Aug 11 2022 at 14:34)</a>:</h4>
<p>Works, neat.</p>



<a name="292941610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292941610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292941610">(Aug 11 2022 at 14:34)</a>:</h4>
<p>Thanks</p>



<a name="292941715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292941715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292941715">(Aug 11 2022 at 14:35)</a>:</h4>
<p>I thought I tried this, guess I did it backwards. Also thought I needed a .symm in there.</p>



<a name="292945864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292945864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292945864">(Aug 11 2022 at 14:56)</a>:</h4>
<p>Re other proof writing issues. How does one<code>Fin k -&gt; Fin k.succ</code> ? I expect to see a lift function or something but do not.</p>



<a name="292945923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292945923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292945923">(Aug 11 2022 at 14:56)</a>:</h4>
<p>I want to check the generated code for the <code>arr.map Fin.lift'ish'or'whatever</code>.</p>



<a name="292946778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292946778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292946778">(Aug 11 2022 at 15:00)</a>:</h4>
<p>Oh even better. <code>u.data[u.size_proof ▸ i]</code> works. :)</p>



<a name="292953469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953469">(Aug 11 2022 at 15:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is <code>▸</code> defined anywhere _in lean_ ? I only see a builtin term parser named <code>subst</code>.</p>



<a name="292953509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953509">(Aug 11 2022 at 15:34)</a>:</h4>
<p>that is in lean?</p>



<a name="292953635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953635">(Aug 11 2022 at 15:35)</a>:</h4>
<p>Wait, I found it. Lean/Elab/BuiltinNotation.lean</p>



<a name="292953792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953792">(Aug 11 2022 at 15:36)</a>:</h4>
<p>I found the syntax definition but somehow missed the term elaborator for it.</p>



<a name="292953833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953833">(Aug 11 2022 at 15:36)</a>:</h4>
<p>what does goto def do?</p>



<a name="292953867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953867">(Aug 11 2022 at 15:36)</a>:</h4>
<p>Nothing. :(</p>



<a name="292953915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953915">(Aug 11 2022 at 15:36)</a>:</h4>
<p>I'll look into it</p>



<a name="292953940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953940">(Aug 11 2022 at 15:37)</a>:</h4>
<p>&lt;3</p>



<a name="292953995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292953995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292953995">(Aug 11 2022 at 15:37)</a>:</h4>
<p>I'm using the Helix editor, which integrates with the LSP out of the box.</p>



<a name="292954029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292954029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292954029">(Aug 11 2022 at 15:37)</a>:</h4>
<p>Normally gd/goto definition just works.</p>



<a name="292954159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292954159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292954159">(Aug 11 2022 at 15:38)</a>:</h4>
<p>Not on syntax it seems.</p>



<a name="292954484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292954484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292954484">(Aug 11 2022 at 15:40)</a>:</h4>
<p>I just tested on master and go to def goes to <code>elabSubst</code> while "go to declaration" goes to the <code>subst</code> syntax</p>



<a name="292954750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292954750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292954750">(Aug 11 2022 at 15:41)</a>:</h4>
<p>Ah. Go to "definition" and "implementation" don't go. To "type definition" goes to <code>Eq</code>.</p>



<a name="292954942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292954942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292954942">(Aug 11 2022 at 15:42)</a>:</h4>
<p>Go to "implementation" isn't even implemented in Lean's LSP, ironically.</p>



<a name="292955258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/UnionFind%20proof%20assistance/near/292955258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/UnionFind.20proof.20assistance.html#292955258">(Aug 11 2022 at 15:43)</a>:</h4>
<p>Odd, now that goto type definition goes to <code>Fin</code>. o.o</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/mathport.3Anumbers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html">mathport:numbers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="231530734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231530734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231530734">(Mar 23 2021 at 19:34)</a>:</h4>
<p>Currently, <code>mathport</code> detects Lean3 numerals (has_zero, has_one, bit0, bit1) and simply wraps them in <code>ofNat</code>. However, these are not the instances that would be found by Lean4's typeclass synthesis, which (assuming Mario's TC-construction suggestion will never be merged) will need to synthesize something like <a href="https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49">https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49</a> that will not compute in the kernel. It seems desirable to have a standard encoding, which would involve replacing the Lean3 numbers with this Lean4 encoding. However, Lean3 relies on some numeral operations computing in the kernel in a few places, e.g. to prove that <code>bit0 1 + bit0 1 = bit0 (bit0 1)</code>. How about backporting this never happening (i.e. using <code>norm_num</code> in a few additional places), so that <code>mathport</code> can replace numbers with the lean4-friendly <code>OfNat</code> instances?</p>



<a name="231532269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231532269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231532269">(Mar 23 2021 at 19:46)</a>:</h4>
<p>What is  the Lean4 way to define an <code>ofNat</code> instance for every additive monoid?</p>



<a name="231532327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231532327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231532327">(Mar 23 2021 at 19:46)</a>:</h4>
<p>Even if it will never happen in kernel, we'll definitely need this instance in <code>mathlib</code>.</p>



<a name="231532598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231532598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231532598">(Mar 23 2021 at 19:48)</a>:</h4>
<p>(then we'll probably have a diamond for <code>OfNat int _</code>)</p>



<a name="231533498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231533498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231533498">(Mar 23 2021 at 19:55)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> Can you please clarify? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kd">def</span> <span class="n">mk5</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">a</span><span class="o">]</span> <span class="o">:</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
<span class="c1">-- ^ error: failed to synthesize type class instance for ... has_one a</span>
</code></pre></div>



<a name="231533713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231533713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231533713">(Mar 23 2021 at 19:56)</a>:</h4>
<p>Shouldn't <code>add_monoid</code> only have <code>0</code>? I did not mention above but that is handled separately in the proposal, i.e.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">instZero2Nat</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">HasZero.zero</span><span class="o">⟩</span>
</code></pre></div>
<p>(<a href="https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L39">https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L39</a>)</p>



<a name="231533718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231533718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231533718">(Mar 23 2021 at 19:56)</a>:</h4>
<p>Sorry, I meant "add monoid with one". E.g.,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.defs</span>

<span class="kd">def</span> <span class="n">mk5</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">a</span><span class="o">]</span> <span class="o">:</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="231534035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231534035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231534035">(Mar 23 2021 at 19:59)</a>:</h4>
<p>I'm afraid that with <code>(5 : a)</code> depending on a typeclass instance we'll have two definitions of <code>(5 : int)</code>: one comes from the fact that <code>int</code> is a ring (and we definitely want numerals in any ring in <code>mathlib</code>), and the other is some default computationally efficient implementation.</p>



<a name="231534124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231534124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231534124">(Mar 23 2021 at 19:59)</a>:</h4>
<p>Then a user will see a goal <code>(5 : int) = (5 : int)</code> that is not a <code>rfl</code>.</p>



<a name="231535632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231535632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231535632">(Mar 23 2021 at 20:09)</a>:</h4>
<p>Even worse, we'll have two meanings of <code>(5 : Nat)</code>. Now we can have <code>(coe : nat → nat) 5 = 5</code> but it shows an up arrow in the goal view.</p>



<a name="231536008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231536008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231536008">(Mar 23 2021 at 20:11)</a>:</h4>
<p>For the latter case, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.cast_id">docs#nat.cast_id</a></p>



<a name="231536093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231536093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231536093">(Mar 23 2021 at 20:12)</a>:</h4>
<p>Probably we'll need to make sure that Lean4 parses <code>(5 : Nat)</code> using the generic <code>[AddMonoid Nat] [HasOne Nat]</code> definition and simplify the prelude instance <code>OfNat Nat n</code> (I guess, it is defined as the identity map) to the generic one.</p>



<a name="231536261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231536261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231536261">(Mar 23 2021 at 20:13)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> Of course, we can have a lemma "these two definitions are equal" but I want to apply a lemma about <code>[Semiring R] (5 : R)</code> to <code>(5 : Nat)</code> without converting between two instances of <code>OfNat</code>.</p>



<a name="231540532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231540532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231540532">(Mar 23 2021 at 20:42)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> Just to confirm, this is the issue you are concerned about:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">axiom</span> <span class="n">abstract_5_eq_0</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">theorem</span> <span class="n">elabAcceptsKernelRejects</span> <span class="o">:</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">abstract_5_eq_0</span> <span class="n">Nat</span>
<span class="c1">-- error: (kernel) declaration type mismatch, 'elabAcceptsKernelRejects' has type ...</span>
</code></pre></div>
<p>where the <code>OfNat</code> instances are not definitionally equal in both the elaborator and the kernel</p>



<a name="231541083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231541083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231541083">(Mar 23 2021 at 20:46)</a>:</h4>
<p>Yes.</p>



<a name="231541759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231541759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231541759">(Mar 23 2021 at 20:51)</a>:</h4>
<p>Zooming out, here are the proposals for numbers that I am aware of:</p>
<ol>
<li>write custom elab/delab for lean3-style numerals, possibly not even mapping <code>nat</code> -&gt; <code>Nat</code></li>
<li>extend Lean4 TC (on lean-community fork) with ability to post-process instances (<a href="https://github.com/dselsam/mathport/issues/17#issuecomment-781430391">https://github.com/dselsam/mathport/issues/17#issuecomment-781430391</a>)</li>
<li>some kind of <code>nat2bits</code> instance as in <a href="https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49">https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49</a> which would (once partial is replaced with WF) still use WF and so not compute reliabliy</li>
</ol>



<a name="231545431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231545431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231545431">(Mar 23 2021 at 21:17)</a>:</h4>
<p>My concern is not about porting of our lean 3 code but about Lean 4 mathlib that we want to have in future: should we somehow disable the default instance <code>OfNat Nat _</code>? If not, how should we deal with conflicting instances? I assume that we definitely want to have <code>instance (R : Type*) [Semiring R] (n : Nat) : OfNat R n</code>.</p>



<a name="231545725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231545725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231545725">(Mar 23 2021 at 21:20)</a>:</h4>
<p>It seems to me that something like <code>nat2bits</code> (probably with an override that uses better functions for <code>Nat</code> and <code>Int</code>) + disabling the default <code>OfNat</code> instances is the way to go. Am I wrong for some reason?</p>



<a name="231546252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231546252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231546252">(Mar 23 2021 at 21:24)</a>:</h4>
<p>Basically, this means replicating Lean 3 numerals on top of Lean 4. I would be happy to see a solution that (a) does not involve disabling the default <code>OfNat Nat n</code> instance; (b) does not create <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231540532">this</a> problem.</p>



<a name="231559375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231559375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231559375">(Mar 23 2021 at 23:26)</a>:</h4>
<p>I think we will need a typeclass <code>Numeric := \all n, OfNat Nat n</code>, and this will be mixed in to <code>Semiring</code> and other relevant classes. This is onerous for constructing instances of <code>Semiring</code> but lets individual types decide how best to implement it. Daniel's well founded instance looks like a "last resort" instance similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/uniform_space.of_core">docs#uniform_space.of_core</a></p>



<a name="231565319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231565319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231565319">(Mar 24 2021 at 00:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> How would <code>normNum</code> work in this proposal?</p>



<a name="231566206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231566206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231566206">(Mar 24 2021 at 00:44)</a>:</h4>
<p>We would need the <code>OfNat</code> instance to be coherent with the semiring structure, of course; one way would be to posit <code>ofNat R n + ofNat R m = ofNat R (n + m)</code> and similar axioms for the other operations. Then <code>normNum</code> would work by using these to rewrite operations on add and mul to primitive add and mul on nat, using kernel evaluation to finish the job</p>



<a name="231579651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231579651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231579651">(Mar 24 2021 at 04:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">class</span> <span class="n">Numeric</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="n">Numeric.OfNat</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">Numeric</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Numeric.ofNat</span> <span class="n">n</span><span class="o">⟩</span>

<span class="kd">class</span> <span class="n">Semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">Numeric</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">add_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">add_comm</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>
  <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">one_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">mul_one</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">zero_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">mul_zero</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">mul_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span>
  <span class="n">add_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span>
  <span class="n">ofNat_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ofNat</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ofNat</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">ofNat</span> <span class="n">b</span>
  <span class="n">ofNat_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ofNat</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ofNat</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">ofNat</span> <span class="n">b</span>

<span class="kd">instance</span> <span class="n">Semiring.OfNat</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">Semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">Numeric.OfNat</span> <span class="n">_</span> <span class="n">_</span>

<span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">normNum</span><span class="o">)</span> <span class="s2">"normNum"</span> <span class="o">:</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Meta</span> <span class="n">Elab</span> <span class="n">Tactic</span>

<span class="kd">def</span> <span class="n">mkOfNatLit</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Level</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">sα</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">Expr</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">inst</span> <span class="o">:=</span> <span class="n">mkApp3</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">`</span><span class="n">Semiring.OfNat</span> <span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="n">α</span> <span class="n">sα</span> <span class="n">n</span>
  <span class="n">mkApp3</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">`</span><span class="n">OfNat.ofNat</span> <span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="n">α</span> <span class="n">n</span> <span class="n">inst</span>

<span class="kn">namespace</span> <span class="n">NormNum</span>

<span class="kd">theorem</span> <span class="n">ofNat_add</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">Semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a'</span> <span class="n">b'</span> <span class="n">c</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">OfNat.ofNat</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">OfNat.ofNat</span> <span class="n">b'</span> <span class="bp">→</span> <span class="n">a'</span> <span class="bp">+</span> <span class="n">b'</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">OfNat.ofNat</span> <span class="n">c</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">Semiring.ofNat_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">theorem</span> <span class="n">ofNat_mul</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">Semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a'</span> <span class="n">b'</span> <span class="n">c</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">OfNat.ofNat</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">OfNat.ofNat</span> <span class="n">b'</span> <span class="bp">→</span> <span class="n">a'</span> <span class="bp">*</span> <span class="n">b'</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">OfNat.ofNat</span> <span class="n">c</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">Semiring.ofNat_mul</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="n">MetaM</span> <span class="o">(</span><span class="n">Expr</span> <span class="bp">×</span> <span class="n">Expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">e.withApp</span> <span class="k">fun</span> <span class="n">f</span> <span class="n">args</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">f.isConstOf</span> <span class="bp">`</span><span class="n">HAdd.hAdd</span> <span class="k">then</span>
    <span class="n">evalB</span> <span class="bp">`</span><span class="n">NormNum.ofNat_add</span> <span class="o">(</span><span class="bp">·+·</span><span class="o">)</span> <span class="n">args</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">f.isConstOf</span> <span class="bp">`</span><span class="n">HMul.hMul</span> <span class="k">then</span>
    <span class="n">evalB</span> <span class="bp">`</span><span class="n">NormNum.ofNat_mul</span> <span class="o">(</span><span class="bp">·*·</span><span class="o">)</span> <span class="n">args</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">f.isConstOf</span> <span class="bp">`</span><span class="n">OfNat.ofNat</span> <span class="k">then</span> <span class="n">pure</span> <span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mkEqRefl</span> <span class="n">e</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">throwError</span> <span class="s2">"fail"</span>
<span class="n">where</span>
  <span class="n">evalB</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="o">(</span><span class="n">args</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="o">(</span><span class="n">Expr</span> <span class="bp">×</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">if</span> <span class="k">let</span> <span class="bp">#</span><span class="o">[</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="bp">←</span> <span class="n">args</span> <span class="k">then</span>
      <span class="k">let</span> <span class="n">Level.succ</span> <span class="n">u</span> <span class="n">_</span> <span class="bp">←</span> <span class="n">getLevel</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">throwError</span> <span class="s2">"fail"</span>
      <span class="k">let</span> <span class="n">sα</span> <span class="bp">←</span> <span class="n">synthInstance</span> <span class="o">(</span><span class="n">mkApp</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">`</span><span class="n">Semiring</span> <span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="n">α</span><span class="o">)</span>
      <span class="k">let</span> <span class="o">(</span><span class="n">a'</span><span class="o">,</span> <span class="n">pa</span><span class="o">)</span> <span class="bp">←</span> <span class="n">eval</span> <span class="n">a</span>
      <span class="k">let</span> <span class="o">(</span><span class="n">b'</span><span class="o">,</span> <span class="n">pb</span><span class="o">)</span> <span class="bp">←</span> <span class="n">eval</span> <span class="n">b</span>
      <span class="k">let</span> <span class="n">la</span> <span class="o">:=</span> <span class="n">Expr.getRevArg</span><span class="bp">!</span> <span class="n">a'</span> <span class="mi">1</span>
      <span class="k">let</span> <span class="n">some</span> <span class="n">na</span> <span class="bp">←</span> <span class="n">la.natLit</span><span class="bp">?</span> <span class="bp">|</span> <span class="n">throwError</span> <span class="s2">"fail"</span>
      <span class="k">let</span> <span class="n">lb</span> <span class="o">:=</span> <span class="n">Expr.getRevArg</span><span class="bp">!</span> <span class="n">b'</span> <span class="mi">1</span>
      <span class="k">let</span> <span class="n">some</span> <span class="n">nb</span> <span class="bp">←</span> <span class="n">lb.natLit</span><span class="bp">?</span> <span class="bp">|</span> <span class="n">throwError</span> <span class="s2">"fail"</span>
      <span class="k">let</span> <span class="n">lc</span> <span class="o">:=</span> <span class="n">mkNatLit</span> <span class="o">(</span><span class="n">f</span> <span class="n">na</span> <span class="n">nb</span><span class="o">)</span>
      <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">mkOfNatLit</span> <span class="n">u</span> <span class="n">α</span> <span class="n">sα</span> <span class="n">lc</span>
      <span class="n">pure</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">mkApp10</span> <span class="o">(</span><span class="n">mkConst</span> <span class="n">name</span> <span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="n">α</span> <span class="n">sα</span> <span class="n">a</span> <span class="n">b</span> <span class="n">la</span> <span class="n">lb</span> <span class="n">lc</span> <span class="n">pa</span> <span class="n">pb</span> <span class="o">(</span><span class="bp">←</span> <span class="n">mkEqRefl</span> <span class="n">lc</span><span class="o">))</span>
    <span class="k">else</span> <span class="n">throwError</span> <span class="s2">"fail"</span>

<span class="kd">@[tactic normNum]</span> <span class="kd">def</span> <span class="n">evalNormNum</span> <span class="o">:</span> <span class="n">Tactic</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">stx</span> <span class="bp">=&gt;</span>
  <span class="n">liftMetaTactic</span> <span class="k">fun</span> <span class="n">g</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">some</span> <span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">matchEq</span><span class="bp">?</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getMVarType</span> <span class="n">g</span><span class="o">)</span> <span class="bp">|</span> <span class="n">throwError</span> <span class="s2">"fail"</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">lhs2</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="bp">←</span> <span class="n">NormNum.eval</span> <span class="n">lhs</span>
    <span class="n">unless</span> <span class="bp">←</span> <span class="n">isDefEq</span> <span class="n">lhs2</span> <span class="n">rhs</span> <span class="k">do</span> <span class="n">throwError</span> <span class="s2">"fail"</span>
    <span class="n">assignExprMVar</span> <span class="n">g</span> <span class="n">p</span>
    <span class="n">pure</span> <span class="o">[]</span>

<span class="kd">end</span> <span class="n">NormNum</span>

<span class="kd">set_option</span> <span class="n">trace.Meta.debug</span> <span class="n">true</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">Semiring</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">normNum</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">7</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">12</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">normNum</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">70</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">33</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2450</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">normNum</span>
</code></pre></div>



<a name="231683771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231683771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231683771">(Mar 24 2021 at 18:19)</a>:</h4>
<p>Probably it suffices to require <code>ofNat 0 = 0</code> and <code>ofNat (n + 1) = ofNat n + 1</code></p>



<a name="231684028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231684028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231684028">(Mar 24 2021 at 18:21)</a>:</h4>
<p>The solution with <code>Numeric</code> typeclass looks very nice.</p>



<a name="231718938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231718938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231718938">(Mar 24 2021 at 22:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> Constructing terms in this <code>normNum</code> port is super painful. Is there a trick I'm missing? Both matching terms and constructing terms using expr quotations are sorely missing here</p>



<a name="231719269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231719269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231719269">(Mar 24 2021 at 22:23)</a>:</h4>
<p>Also double backtick name quotations don't seem to work properly</p>



<a name="231719970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231719970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231719970">(Mar 24 2021 at 22:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231719269">said</a>:</p>
<blockquote>
<p>Also double backtick name quotations don't seem to work properly</p>
</blockquote>
<p>In what way?</p>



<a name="231720057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231720057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231720057">(Mar 24 2021 at 22:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231718938">said</a>:</p>
<blockquote>
<p>Is there a trick I'm missing?</p>
</blockquote>
<p>I don't think so, it's just a kind of program no-one else has written in Lean 4 before</p>



<a name="231720267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231720267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231720267">(Mar 24 2021 at 22:33)</a>:</h4>
<p>Ah, nvm about double backtick name quotations, I think there were just less things in scope than I thought</p>



<a name="231720531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231720531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231720531">(Mar 24 2021 at 22:35)</a>:</h4>
<p>Would it be possible to have <code>(·+·)</code> expand to <code>HAdd.hAdd</code> instead of <code>fun x y =&gt; x + y</code>? I think that will eventually turn into a mathport issue</p>



<a name="231720683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/231720683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#231720683">(Mar 24 2021 at 22:37)</a>:</h4>
<p>It looks like expr quotations like <code> `((·+·) : Nat → Nat → Nat).subst a</code> don't work anymore</p>



<a name="232699778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/232699778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#232699778">(Apr 01 2021 at 03:48)</a>:</h4>
<p>(I was offline for a few days) <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I like this approach for Lean4. It would be extremely ambitious to try to automate this change in mathport though. Will you be able to backport it?</p>
<p>EDIT: Actually, I am not sure yet how hard it would be to autoport this change. I will think more about it.</p>



<a name="232712294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/232712294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#232712294">(Apr 01 2021 at 06:58)</a>:</h4>
<p>Which part? The <code>normNum</code> implementation was intended to be a lean 4 tactic; it would be hard to backport it since it relies on primitive nats</p>



<a name="232774547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/232774547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#232774547">(Apr 01 2021 at 15:17)</a>:</h4>
<p>The main thing that mathport certainly cannot do automatically is guess the desired <code>Semiring</code> instances. If you backport the change to <code>semiring</code>, then even if you don't connect the <code>ofNat</code> to anything else, it may be feasible for mathport to detect old numerals and replace them with new numerals, and detect old <code>norm_num</code> proofs and replace them with <code>normNum</code> proofs.</p>



<a name="232774802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/232774802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#232774802">(Apr 01 2021 at 15:17)</a>:</h4>
<p>Also, it would be nice if <code>norm_num</code> wrapped its proofs with <code>idNormNum</code>.</p>



<a name="233859771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233859771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233859771">(Apr 09 2021 at 17:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> What do you think about backporting the <code>semiring</code> change?</p>



<a name="233860086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233860086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233860086">(Apr 09 2021 at 17:21)</a>:</h4>
<p>We don't need it to make mathlib work, right? I think it would be better to do as a refactor on lean 4 mathlib</p>



<a name="233860407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233860407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233860407">(Apr 09 2021 at 17:23)</a>:</h4>
<p>Yes, it could be a future refactor in Lean4, after the <code>.lean</code> files have been manually resurrected.</p>



<a name="233860589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233860589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233860589">(Apr 09 2021 at 17:25)</a>:</h4>
<p>It will solve some defeq diamond issues but those are second order concerns</p>



<a name="233860626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233860626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233860626">(Apr 09 2021 at 17:25)</a>:</h4>
<p>In the meantime, we will still need to be able to implement a <code>normNum</code> that works for both auto-ported terms and newly-elaborated terms. The three options for now are still roughly <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231541759">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231541759</a></p>



<a name="233860878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233860878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233860878">(Apr 09 2021 at 17:27)</a>:</h4>
<p>I don't know, it sounds like running before we can walk. We still need the mathlib tactic suite</p>



<a name="233861069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233861069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233861069">(Apr 09 2021 at 17:28)</a>:</h4>
<p>it makes more sense for <code>normNum</code> to just deal with lean 4 numerals expressed the way we want them to be expressed</p>



<a name="233861285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233861285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233861285">(Apr 09 2021 at 17:30)</a>:</h4>
<p>if it's not possible to get mathport to do the translation, a tactic on the lean 4 side can also simplify numerals and other lean 3 cruft</p>



<a name="233861882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233861882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233861882">(Apr 09 2021 at 17:34)</a>:</h4>
<p>Are you suggesting option (3)? We define a generic <code>nat2bits</code> non-computing instance, and then have <code>normNum</code> use <code>semiring</code> lemmas in terms of these instances? Then once <code>semiring</code> adds <code>Numeric</code>, we can just change the instances to ones that compute (when applicable)?</p>



<a name="233862008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233862008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233862008">(Apr 09 2021 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/233860878">said</a>:</p>
<blockquote>
<p>I don't know, it sounds like running before we can walk. We still need the mathlib tactic suite</p>
</blockquote>
<p>I am not sure I follow your line of thought here -- <code>normNum</code> is a core part of the mathlib tactic suite with few dependencies</p>



<a name="233862819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233862819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233862819">(Apr 09 2021 at 17:41)</a>:</h4>
<p>Perhaps, but it depends a lot on how the library is set up and it's not particularly hard to write otherwise. I would like to see us get the infrastructure so that we can actually port basic files. I tried doing a nontrivial lean 4 proof a few days ago and I hit a whole bunch of issues that made it pretty hard even for non-mathlib proofs (aside from just missing lemmas). Right now no one is actually trying to prove theorems with lean 4 and getting the rough edges polished there is a higher priority IMO</p>



<a name="233863420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233863420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233863420">(Apr 09 2021 at 17:46)</a>:</h4>
<p>Do you think needing to build a custom lean is prohibitive for would-be tinkerers? If so, I can look into the VSCode-docker setup. </p>
<p>EDIT: oh you mean playing with Lean4 independent of mathport</p>



<a name="233873943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233873943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233873943">(Apr 09 2021 at 19:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/233862819">said</a>:</p>
<blockquote>
<p>...I tried doing a nontrivial lean 4 proof a few days ago and I hit a whole bunch of issues that made it pretty hard even for non-mathlib proofs (aside from just missing lemmas). Right now no one is actually trying to prove theorems with lean 4 and getting the rough edges polished there is a higher priority IMO</p>
</blockquote>
<p>Out of curiosity, could you mention some of the current limitations to doing non-trivial proofs in Lean 4 (ignoring the lack of existing lemmas etc to build off of)?</p>



<a name="233875023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233875023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233875023">(Apr 09 2021 at 19:07)</a>:</h4>
<p><span class="user-mention" data-user-id="243102">@Brandon Brown</span> In my own experience doing mini-experiments on top of mathport, there are a few open Lean4 issues that are painful (e.g. <a href="https://github.com/leanprover/lean4/issues/382">https://github.com/leanprover/lean4/issues/382</a>), a bunch of somewhat-annoying loose-ends (e.g. some name clashes, can't use dot notation for aligned types), but for basic stuff the elaborator works well. And all the lemmas are there and usable. There isn't much that can be proved without <code>normNum</code>, <code>ring</code>, etc. though.</p>



<a name="233875579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233875579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233875579">(Apr 09 2021 at 19:10)</a>:</h4>
<p>I have not played around much with tactics either way though, so I don't know how dense the rough edges are still in the lean4 built-in tactics.</p>



<a name="233878757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233878757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233878757">(Apr 09 2021 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/233862819">said</a>:</p>
<blockquote>
<p>I hit a whole bunch of issues</p>
</blockquote>
<p>Can you tell us more?</p>



<a name="233922432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Anumbers/near/233922432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Anumbers.html#233922432">(Apr 10 2021 at 03:43)</a>:</h4>
<p>I'll make another topic for it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
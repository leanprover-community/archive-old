---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/mutual.20inductive.20and.20def.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html">mutual inductive and def</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279365480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279365480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279365480">(Apr 19 2022 at 05:36)</a>:</h4>
<p>Hello. I am trying to create a few mutually recursive definitions, but one of the definitions is a def, not an inductive. I think there is some way to translate this such that it'll work but I haven't been able to figure out the magic words.</p>
<p>It might be better to avoid the mutual dependencies...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Cover</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">done</span>  <span class="o">:</span> <span class="n">Cover</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">left</span>  <span class="o">:</span> <span class="n">Cover</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">right</span> <span class="o">:</span> <span class="n">Cover</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="n">x</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">both</span>  <span class="o">:</span> <span class="n">Cover</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">z</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Ty</span>
<span class="bp">|</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">func</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">)</span>
<span class="n">deriving</span> <span class="n">Inhabited</span>

<span class="kd">mutual</span>
    <span class="kd">inductive</span> <span class="n">Stlc</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">lift</span> <span class="o">:</span> <span class="n">t.type</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ₁</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ₂</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ₁</span> <span class="bp">Γ₂</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="bp">Γ</span>

    <span class="kd">inductive</span> <span class="n">Closure</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Closure</span> <span class="n">a</span> <span class="n">b</span>

    <span class="kd">def</span> <span class="n">Ty.type</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">unit</span> <span class="bp">=&gt;</span> <span class="n">Unit</span>
    <span class="bp">|</span> <span class="n">nat</span> <span class="bp">=&gt;</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="n">bool</span> <span class="bp">=&gt;</span> <span class="n">Bool</span>
    <span class="bp">|</span> <span class="n">func</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">Closure</span> <span class="n">a</span> <span class="n">b</span>

    <span class="kd">inductive</span> <span class="n">Env</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">term</span> <span class="o">:</span> <span class="n">Env</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">t.type</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279365613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279365613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279365613">(Apr 19 2022 at 05:39)</a>:</h4>
<p>Can replace the Closure indirection with <code>Stlc b (a :: Γ) × Env Γ</code>.</p>



<a name="279365754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279365754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279365754">(Apr 19 2022 at 05:43)</a>:</h4>
<p>Maybe something like this? But still invalid...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>
    <span class="kd">inductive</span> <span class="n">Stlc</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="c1">-- universe level of lift is too big</span>
    <span class="bp">|</span> <span class="n">lift</span> <span class="o">:</span> <span class="n">Lift</span> <span class="n">t</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ₁</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ₂</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ₁</span> <span class="bp">Γ₂</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="bp">Γ</span>

    <span class="kd">inductive</span> <span class="n">Lift</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">u</span> <span class="o">:</span> <span class="n">Lift</span> <span class="bp">.</span><span class="n">unit</span> <span class="n">Unit</span>
    <span class="bp">|</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Lift</span> <span class="bp">.</span><span class="n">nat</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Lift</span> <span class="bp">.</span><span class="n">bool</span> <span class="n">Bool</span>
<span class="c1">-- another issue.. unexpected constructor resulting type..?</span>
<span class="c1">--  | f : lift (.func a b) (Stlc b (a :: Γ) × Env Γ)</span>

    <span class="kd">inductive</span> <span class="n">Env</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">term</span> <span class="o">:</span> <span class="n">Env</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">Lift</span> <span class="n">t</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279366011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279366011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279366011">(Apr 19 2022 at 05:49)</a>:</h4>
<p>Universe level problem with Lift. Suspect a <code>Lift.(u)</code> magic but don't see how to apply it here...</p>



<a name="279366800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279366800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279366800">(Apr 19 2022 at 06:03)</a>:</h4>
<p>For context I am trying to adapt this Agda to Lean 4. I have previously tried this and had different issues.</p>
<p><a href="https://repository.tudelft.nl/islandora/object/uuid:f0312839-3444-41ee-9313-b07b21b59c11">https://repository.tudelft.nl/islandora/object/uuid:f0312839-3444-41ee-9313-b07b21b59c11</a></p>



<a name="279366875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279366875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279366875">(Apr 19 2022 at 06:04)</a>:</h4>
<p>I will eventually translate this from STLC to DTLC, so the <code>Ty</code> and <code>Stlc</code> will be merged into <code>Dtlc</code>.</p>



<a name="279377491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279377491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279377491">(Apr 19 2022 at 08:21)</a>:</h4>
<p>The magic word is "induction-recursion" which Lean unfortunately does not support.</p>



<a name="279377808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279377808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279377808">(Apr 19 2022 at 08:24)</a>:</h4>
<p>Hmm. Is that an open issue to fix or a design limitation?</p>



<a name="279378154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279378154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279378154">(Apr 19 2022 at 08:28)</a>:</h4>
<p>Induction-recursion without "bumping" the universe is a foundational decision, so it's a design limitation. Compiling inductive-recursive down to features Lean supports could be a nice future project.</p>



<a name="279378190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279378190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279378190">(Apr 19 2022 at 08:28)</a>:</h4>
<p>Your second snippet can be fixed by having all the three type families live in the second universe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>
    <span class="kd">inductive</span> <span class="n">Stlc</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="c1">-- universe level of lift is too big</span>
    <span class="bp">|</span> <span class="n">lift</span> <span class="o">:</span> <span class="n">Lift</span> <span class="n">t</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ₁</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ₂</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ₁</span> <span class="bp">Γ₂</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="bp">Γ</span>

    <span class="kd">inductive</span> <span class="n">Lift</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">u</span> <span class="o">:</span> <span class="n">Lift</span> <span class="bp">.</span><span class="n">unit</span> <span class="n">Unit</span>
    <span class="bp">|</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Lift</span> <span class="bp">.</span><span class="n">nat</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Lift</span> <span class="bp">.</span><span class="n">bool</span> <span class="n">Bool</span>
<span class="c1">-- another issue.. unexpected constructor resulting type..?</span>
<span class="c1">--  | f : lift (.func a b) (Stlc b (a :: Γ) × Env Γ)</span>

    <span class="kd">inductive</span> <span class="n">Env</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">term</span> <span class="o">:</span> <span class="n">Env</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">Lift</span> <span class="n">t</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279378770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279378770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279378770">(Apr 19 2022 at 08:34)</a>:</h4>
<p>I also get an <code>Error: index out of bounds</code> in your example though, which is definitely a bug in Lean /cc <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span></p>



<a name="279379258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279379258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279379258">(Apr 19 2022 at 08:39)</a>:</h4>
<p>And the constructor you commented out seems to be harder to realize, since the universe bump prevents the circular dependency.</p>



<a name="279380234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380234">(Apr 19 2022 at 08:48)</a>:</h4>
<p>Which version of lean did you use? I do not get such an error. <code>nightly-2022-03-21</code>.</p>



<a name="279380235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380235">(Apr 19 2022 at 08:48)</a>:</h4>
<p>Thanks for the patch. Any idea about the commented line?</p>



<a name="279380299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380299">(Apr 19 2022 at 08:49)</a>:</h4>
<p>(Disconnected -&gt; messages out of order.)</p>
<p>Harder indeed... not just me. :)</p>



<a name="279380539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380539">(Apr 19 2022 at 08:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279380234">said</a>:</p>
<blockquote>
<p>Which version of lean did you use? I do not get such an error. <code>nightly-2022-03-21</code>.</p>
</blockquote>
<p><code>nightly-2022-04-12</code></p>



<a name="279380634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380634">(Apr 19 2022 at 08:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279380235">said</a>:</p>
<blockquote>
<p>Thanks for the patch. Any idea about the commented line?</p>
</blockquote>
<p>There is nothing to lift in this case, so it looks like you should use a separate constructor</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="kd">inductive</span> <span class="n">Env</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">term</span> <span class="o">:</span> <span class="n">Env</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">Lift</span> <span class="n">t</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons_f</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">Env</span> <span class="o">(</span><span class="bp">.</span><span class="n">func</span> <span class="n">a</span> <span class="n">b</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span>
</code></pre></div>



<a name="279380771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380771">(Apr 19 2022 at 08:54)</a>:</h4>
<p>Hmm. Interesting suggestion.</p>



<a name="279380973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279380973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279380973">(Apr 19 2022 at 08:56)</a>:</h4>
<p>Thanks.</p>



<a name="279381654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279381654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279381654">(Apr 19 2022 at 09:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279378770">said</a>:</p>
<blockquote>
<p>I also get an <code>Error: index out of bounds</code> in your example though, which is definitely a bug in Lean /cc <span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span></p>
</blockquote>
<p>Filed an <a href="https://github.com/leanprover/lean4/issues/1112">issue</a></p>



<a name="279381860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279381860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279381860">(Apr 19 2022 at 09:04)</a>:</h4>
<p>Better still to encapsulate <code>Lift t y -&gt; y -&gt; ...</code> in a new type, I think. But I haven't really thought through your design as a whole yet, e.g. how <code>Stlc.lam</code> and <code>Stlc.val (Val.clo ..)</code> should relate.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>
  <span class="kd">inductive</span> <span class="n">Stlc</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">val</span> <span class="o">:</span> <span class="n">Val</span> <span class="n">t</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ₁</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ₂</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ₁</span> <span class="bp">Γ₂</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="bp">Γ</span>

  <span class="kd">inductive</span> <span class="n">Val</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">u</span> <span class="o">:</span> <span class="n">Val</span> <span class="bp">.</span><span class="n">unit</span>
    <span class="bp">|</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Val</span> <span class="bp">.</span><span class="n">nat</span>
    <span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="n">Val</span> <span class="bp">.</span><span class="n">bool</span>
    <span class="bp">|</span> <span class="n">clo</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">Val</span> <span class="o">(</span><span class="bp">.</span><span class="n">func</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

  <span class="kd">inductive</span> <span class="n">Env</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">term</span> <span class="o">:</span> <span class="n">Env</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">Val</span> <span class="n">t</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279382084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279382084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279382084">(Apr 19 2022 at 09:06)</a>:</h4>
<p>When writing the evaluator for the <code>Stlc</code> language, I need to lift the closure as the result of evaluation. So it would be ideal to keep the closure inside Val.</p>



<a name="279382840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279382840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279382840">(Apr 19 2022 at 09:15)</a>:</h4>
<p>Hmm.. In the evaluator, I'm reaching for the split contexts. How should I access these?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Stlc</span>
    <span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="n">ctx</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="n">ctx</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">val</span> <span class="n">x</span><span class="o">,</span> <span class="bp">.</span><span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">lam</span> <span class="n">f</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">xs</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">app</span> <span class="n">f</span> <span class="n">x</span> <span class="n">c</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span>
<span class="kd">end</span> <span class="n">Stlc</span>
</code></pre></div>
<p>(Edit: Is it idiomatic to use the dot-notation to avoid accidentally binding with a wildcard?)</p>



<a name="279383301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279383301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279383301">(Apr 19 2022 at 09:20)</a>:</h4>
<p>The "covering" is the Co-De Bruijn partitioning of the context. Thus values have an empty context, variables have a singleton context, and applications may split or share terms, but each term must be used at least once.</p>



<a name="279383605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279383605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279383605">(Apr 19 2022 at 09:24)</a>:</h4>
<p>Ah! The issue I had with the commented out lifting code was <code>lift</code> vs. <code>Lift</code>. !!</p>



<a name="279387435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279387435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279387435">(Apr 19 2022 at 09:58)</a>:</h4>
<p>You can use named arguments to bind specific implicit parameters, though you cannot currently mix them with the dot notation</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="bp">Γ₁</span> <span class="o">:=</span> <span class="bp">Γ₁</span><span class="o">)</span> <span class="n">f</span> <span class="n">x</span> <span class="n">c</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="279387633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279387633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279387633">(Apr 19 2022 at 09:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279382840">said</a>:</p>
<blockquote>
<p>(Edit: Is it idiomatic to use the dot-notation to avoid accidentally binding with a wildcard?)</p>
</blockquote>
<p>The notation is still quite new, but that sounds reasonable to me (except in the case I just mentioned). But it really only matters for parameter-less constructors, all others should lead to an error when typoed.</p>



<a name="279387802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279387802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279387802">(Apr 19 2022 at 10:00)</a>:</h4>
<p>Makes sense. Thanks. &lt;3</p>



<a name="279388167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279388167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279388167">(Apr 19 2022 at 10:03)</a>:</h4>
<p>Actually I don't think I need the <code>Γ1/Γ2</code>, I need to split the environment based on <code>c</code>. Either way that is nice to know. :)</p>



<a name="279392349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279392349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279392349">(Apr 19 2022 at 10:50)</a>:</h4>
<p>Hmm. Seem to have an issue with <code>Prop</code> vs. <code>Type</code> now. Cover was a <code>Prop</code>, but I guess I need to make it a <code>Type</code> but... I get universe level troubles again. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Env</span>
    <span class="kd">def</span> <span class="n">partition</span> <span class="o">:</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ</span><span class="mi">1</span> <span class="bp">Γ</span><span class="mi">2</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="bp">Γ</span><span class="mi">1</span> <span class="bp">×</span> <span class="n">Env</span> <span class="bp">Γ</span><span class="mi">2</span>
    <span class="c1">-- Cover.casesOn can only eliminate into Prop.</span>
    <span class="bp">|</span> <span class="n">term</span><span class="o">,</span> <span class="bp">.</span><span class="n">done</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">term</span><span class="o">,</span> <span class="n">term</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">xs</span><span class="o">,</span> <span class="bp">.</span><span class="n">left</span> <span class="n">c</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition</span> <span class="n">xs</span> <span class="n">c</span>
        <span class="o">(</span><span class="n">cons</span> <span class="n">v</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">xs</span><span class="o">,</span> <span class="bp">.</span><span class="n">right</span> <span class="n">c</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition</span> <span class="n">xs</span> <span class="n">c</span>
        <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">xs</span><span class="o">,</span> <span class="bp">.</span><span class="n">both</span> <span class="n">c</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition</span> <span class="n">xs</span> <span class="n">c</span>
        <span class="o">(</span><span class="n">cons</span> <span class="n">v</span> <span class="n">l</span><span class="o">,</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span>
<span class="kd">end</span> <span class="n">Env</span>
</code></pre></div>



<a name="279392975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279392975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279392975">(Apr 19 2022 at 10:56)</a>:</h4>
<p>Nevermind, seems I typo'd <code>a</code> for <code>α</code> when elaborating the type for Cover when converting it to Type with universe levels.</p>



<a name="279394108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279394108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279394108">(Apr 19 2022 at 11:08)</a>:</h4>
<p>Okay... I think I have everything except for.... the termination proof.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">Cover</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">List.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span>
  <span class="bp">|</span> <span class="n">done</span>  <span class="o">:</span> <span class="n">Cover</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">left</span>  <span class="o">:</span> <span class="n">Cover</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">z</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">right</span> <span class="o">:</span> <span class="n">Cover</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="n">x</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">z</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">both</span>  <span class="o">:</span> <span class="n">Cover</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">z</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Ty</span>
  <span class="bp">|</span> <span class="n">unit</span>
  <span class="bp">|</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">bool</span>
  <span class="bp">|</span> <span class="n">func</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">)</span>
<span class="n">deriving</span> <span class="n">Inhabited</span>

<span class="kd">mutual</span>
  <span class="kd">inductive</span> <span class="n">Stlc</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">val</span> <span class="o">:</span> <span class="n">Val</span> <span class="n">t</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="o">(</span><span class="n">Ty.func</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span> <span class="bp">Γ₁</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ₂</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ₁</span> <span class="bp">Γ₂</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">u</span> <span class="bp">Γ</span>

  <span class="kd">inductive</span> <span class="n">Val</span> <span class="o">:</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">u</span> <span class="o">:</span> <span class="n">Val</span> <span class="bp">.</span><span class="n">unit</span>
    <span class="bp">|</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="bp">.</span><span class="n">nat</span>
    <span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="bp">.</span><span class="n">bool</span>
    <span class="bp">|</span> <span class="n">clo</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="o">(</span><span class="bp">.</span><span class="n">func</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

  <span class="kd">inductive</span> <span class="n">Env</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
    <span class="bp">|</span> <span class="n">term</span> <span class="o">:</span> <span class="n">Env</span> <span class="o">[]</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">Val</span> <span class="n">t</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="n">xs</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="o">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kn">namespace</span> <span class="n">Env</span>
    <span class="kd">def</span> <span class="n">partition</span> <span class="o">:</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Cover</span> <span class="bp">Γ₁</span> <span class="bp">Γ₂</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="bp">Γ₁</span> <span class="bp">×</span> <span class="n">Env</span> <span class="bp">Γ₂</span>
    <span class="bp">|</span> <span class="n">term</span><span class="o">,</span> <span class="bp">.</span><span class="n">done</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">term</span><span class="o">,</span> <span class="n">term</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">xs</span><span class="o">,</span> <span class="bp">.</span><span class="n">left</span>  <span class="n">c</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition</span> <span class="n">xs</span> <span class="n">c</span><span class="bp">;</span> <span class="o">(</span><span class="n">cons</span> <span class="n">v</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">xs</span><span class="o">,</span> <span class="bp">.</span><span class="n">right</span> <span class="n">c</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition</span> <span class="n">xs</span> <span class="n">c</span><span class="bp">;</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">xs</span><span class="o">,</span> <span class="bp">.</span><span class="n">both</span>  <span class="n">c</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition</span> <span class="n">xs</span> <span class="n">c</span><span class="bp">;</span> <span class="o">(</span><span class="n">cons</span> <span class="n">v</span> <span class="n">l</span><span class="o">,</span> <span class="n">cons</span> <span class="n">v</span> <span class="n">r</span><span class="o">)</span>
<span class="kd">end</span> <span class="n">Env</span>

<span class="kn">namespace</span> <span class="n">Stlc</span>
  <span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="n">ctx</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="n">ctx</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span><span class="o">,</span> <span class="bp">.</span><span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="bp">.</span><span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="n">f</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">xs</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="n">f</span> <span class="n">x</span> <span class="n">c</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">xs.partition</span> <span class="n">c</span>
        <span class="k">let</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">eval</span> <span class="n">f</span> <span class="n">l</span>
        <span class="n">eval</span> <span class="n">f</span> <span class="o">(</span><span class="n">l.cons</span> <span class="o">(</span><span class="n">eval</span> <span class="n">x</span> <span class="n">r</span><span class="o">))</span>
<span class="kd">end</span> <span class="n">Stlc</span>
</code></pre></div>



<a name="279394646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279394646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279394646">(Apr 19 2022 at 11:15)</a>:</h4>
<p>Actually no, not just termination proof. Type mismatch in .. something in eval. o.o</p>



<a name="279402887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279402887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279402887">(Apr 19 2022 at 12:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279381654">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279378770">said</a>:</p>
<blockquote>
<p>I also get an <code>Error: index out of bounds</code> in your example though, which is definitely a bug in Lean /cc <span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span></p>
</blockquote>
<p>Filed an <a href="https://github.com/leanprover/lean4/issues/1112">issue</a></p>
</blockquote>
<p>Pushed a fix for this.</p>



<a name="279408111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279408111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279408111">(Apr 19 2022 at 13:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">././</span><span class="n">Stlc.lean</span><span class="o">:</span><span class="mi">51</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">fail</span> <span class="n">to</span> <span class="k">show</span> <span class="n">termination</span> <span class="n">for</span>
  <span class="n">Stlc.eval</span>
<span class="k">with</span> <span class="n">errors</span>
<span class="n">argument</span> <span class="bp">#</span><span class="mi">3</span> <span class="n">was</span> <span class="n">not</span> <span class="n">used</span> <span class="n">for</span> <span class="n">structural</span> <span class="n">recursion</span>
  <span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
    <span class="bp">@</span><span class="n">Stlc.brecOn</span> <span class="o">(</span><span class="k">fun</span> <span class="o">{</span><span class="n">t</span><span class="o">}</span> <span class="o">{</span><span class="bp">Γ</span><span class="o">}</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">Val</span> <span class="n">t</span><span class="o">)</span> <span class="n">t</span>
  <span class="n">argument</span>
    <span class="n">t</span>
  <span class="n">has</span> <span class="n">type</span>
    <span class="n">Ty</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
    <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Val</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u_1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">argument</span> <span class="bp">#</span><span class="mi">4</span> <span class="n">was</span> <span class="n">not</span> <span class="n">used</span> <span class="n">for</span> <span class="n">structural</span> <span class="n">recursion</span>
  <span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
    <span class="bp">@</span><span class="n">Env.brecOn</span> <span class="k">fun</span> <span class="o">{</span><span class="bp">Γ</span><span class="o">}</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">Val</span> <span class="n">t</span>
  <span class="n">argument</span>
    <span class="k">fun</span> <span class="o">{</span><span class="bp">Γ</span><span class="o">}</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">Val</span> <span class="n">t</span>
  <span class="n">has</span> <span class="n">type</span>
    <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u_1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
    <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Ty</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Stlc</span> <span class="n">a</span> <span class="n">a_1</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u_1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">argument</span> <span class="bp">#</span><span class="mi">1</span> <span class="n">was</span> <span class="n">not</span> <span class="n">used</span> <span class="n">for</span> <span class="n">structural</span> <span class="n">recursion</span>
  <span class="n">failed</span> <span class="n">to</span> <span class="n">eliminate</span> <span class="n">recursive</span> <span class="n">application</span>
    <span class="n">eval</span> <span class="n">f</span> <span class="n">l</span>

<span class="n">argument</span> <span class="bp">#</span><span class="mi">2</span> <span class="n">was</span> <span class="n">not</span> <span class="n">used</span> <span class="n">for</span> <span class="n">structural</span> <span class="n">recursion</span>
  <span class="n">failed</span> <span class="n">to</span> <span class="n">eliminate</span> <span class="n">recursive</span> <span class="n">application</span>
    <span class="n">eval</span> <span class="n">f</span> <span class="n">l</span>

<span class="n">structural</span> <span class="n">recursion</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span>

<span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">termination</span><span class="o">,</span> <span class="n">use</span> <span class="bp">`</span><span class="n">termination_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">well</span><span class="bp">-</span><span class="n">founded</span> <span class="n">relation</span>

<span class="n">error</span><span class="o">:</span> <span class="n">Error</span><span class="o">:</span> <span class="n">index</span> <span class="n">out</span> <span class="n">of</span> <span class="n">bounds</span>
</code></pre></div>



<a name="279411798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279411798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279411798">(Apr 19 2022 at 13:53)</a>:</h4>
<p>Looking over the types. It seems that everything returns <code>Val t</code> except for the lambda case, which returns <code>Val (Ty.func a b)</code>. Is this the problem? If so, how do I unify the type with <code>Val t</code>?</p>



<a name="279415695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279415695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279415695">(Apr 19 2022 at 14:23)</a>:</h4>
<p>Replacing its result with <code>sorry</code> does not resolve the type mismatch. <strong>shrugs</strong></p>



<a name="279415716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279415716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279415716">(Apr 19 2022 at 14:23)</a>:</h4>
<p>Very confused with this error.</p>



<a name="279427573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279427573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279427573">(Apr 19 2022 at 15:46)</a>:</h4>
<p><span class="user-mention" data-user-id="455721">@Sofia</span> We will try to clarify the error message in the future. The application type mismatches are not in your code. They were generated when Lean tried different ways to prove termination by structural recursion. If you use the <code>termination_by</code> annotation, you will get a better error message. Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span><span class="o">,</span> <span class="bp">.</span><span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="bp">.</span><span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="n">f</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">xs</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="n">f</span> <span class="n">x</span> <span class="n">c</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">xs.partition</span> <span class="n">c</span>
        <span class="k">let</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">eval</span> <span class="n">f</span> <span class="n">l</span>
        <span class="n">eval</span> <span class="n">f</span> <span class="o">(</span><span class="n">l.cons</span> <span class="o">(</span><span class="n">eval</span> <span class="n">x</span> <span class="n">r</span><span class="o">))</span>
  <span class="n">termination_by</span> <span class="n">eval</span> <span class="n">s</span> <span class="n">env</span> <span class="bp">=&gt;</span> <span class="n">sizeOf</span> <span class="n">s</span>
</code></pre></div>
<p>You can make the error message clearer by avoiding the variable shadowing at <code>let .clo f l := eval f l</code>.</p>



<a name="279428907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279428907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279428907">(Apr 19 2022 at 15:55)</a>:</h4>
<p>BTW, I defined an arbitrary well-founded relation in the example above (i.e., <code>sizeOf s</code>), but you will not be able to prove termination using it. The goal was just to get a better error message.</p>



<a name="279433068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279433068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279433068">(Apr 19 2022 at 16:23)</a>:</h4>
<p>Noted. I had later renamed those and applied a few other similar cleanups. I first tried to add <code>partial</code> to skip the termination proof, but Lean wasn't happy with that either.</p>



<a name="279433252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279433252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279433252">(Apr 19 2022 at 16:24)</a>:</h4>
<p>Due to the lack of Inhabited instance on Val. Which I could add. Would be better to prove the termination of course.</p>



<a name="279433540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279433540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279433540">(Apr 19 2022 at 16:26)</a>:</h4>
<p>The tricky bit is the inhabited instance for <code>Val.clo</code>.</p>



<a name="279434064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279434064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279434064">(Apr 19 2022 at 16:30)</a>:</h4>
<p>I really need to figure out the details of the termination proofs... Tend to get stuck here a lot. :/</p>



<a name="279434112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279434112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279434112">(Apr 19 2022 at 16:30)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> . I should call the night here. Take care. o/</p>



<a name="279435213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279435213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279435213">(Apr 19 2022 at 16:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> <a href="#narrow/stream/270676-lean4/topic/mutual.20inductive.20and.20def/near/279433540">said</a>:</p>
<blockquote>
<p>The tricky bit is the inhabited instance for <code>Val.clo</code>.</p>
</blockquote>
<p>You can simplify the problem a bit by writing the <code>Stlc.val</code> constructor as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="bp">|</span> <span class="n">val</span> <span class="o">:</span> <span class="n">Val</span> <span class="n">t</span> <span class="bp">-&gt;</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ</span>
</code></pre></div>
<p>Then, you can show that <code>Val ty</code> is inhabited using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Ty.someValue</span> <span class="o">:</span> <span class="o">(</span><span class="n">ty</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Val</span> <span class="n">ty</span>
   <span class="bp">|</span> <span class="bp">.</span><span class="n">unit</span>     <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">u</span>
   <span class="bp">|</span> <span class="bp">.</span><span class="n">nat</span>      <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">n</span> <span class="mi">0</span>
   <span class="bp">|</span> <span class="bp">.</span><span class="n">bool</span>     <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">b</span> <span class="n">false</span>
   <span class="bp">|</span> <span class="bp">.</span><span class="n">func</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">clo</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:=</span> <span class="o">[])</span> <span class="o">(</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">someValue</span> <span class="n">b</span><span class="o">))</span> <span class="bp">.</span><span class="n">term</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">Val</span> <span class="n">ty</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="n">ty.someValue</span>
</code></pre></div>
<p>You will also have to change the <code>| val x, .term =&gt; x</code> case at <code>eval</code> to <code>| val x, _ =&gt; x</code>.<br>
After these changes <code>partial</code> will work.<br>
If you hit similar issues in the future where it is not feasible to show the type is inhabited, then another option is to use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Stlc</span> <span class="n">t</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Env</span> <span class="bp">Γ</span> <span class="bp">-&gt;</span> <span class="n">Val</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">var</span><span class="o">,</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">x</span> <span class="bp">.</span><span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="n">lam</span> <span class="n">f</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">xs</span>
    <span class="bp">|</span> <span class="n">app</span> <span class="n">f</span> <span class="n">x</span> <span class="n">c</span><span class="o">,</span> <span class="n">xs</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">xs.partition</span> <span class="n">c</span>
        <span class="k">let</span> <span class="bp">.</span><span class="n">clo</span> <span class="n">f</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">eval</span> <span class="n">f</span> <span class="n">l</span>
        <span class="n">eval</span> <span class="n">f</span> <span class="o">(</span><span class="n">l.cons</span> <span class="o">(</span><span class="n">eval</span> <span class="n">x</span> <span class="n">r</span><span class="o">))</span>
  <span class="n">decreasing_by</span> <span class="gr">sorry</span>
</code></pre></div>
<p>This is equivalent to telling Lean "trust me this function does terminate, and I am willing to compromise soundness if it does not".</p>



<a name="279435772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mutual%20inductive%20and%20def/near/279435772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mutual.20inductive.20and.20def.html#279435772">(Apr 19 2022 at 16:42)</a>:</h4>
<p>That val needs to be empty, not arbitrary. Otherwise a helpful tip. I guess I will have to lie about the decreasing proof for now. Thanks again. I'm off for the night for real this time. :)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
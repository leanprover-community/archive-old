---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Mutual.20inductive.20rec.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html">Mutual inductive rec</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="249587937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249587937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249587937">(Aug 16 2021 at 13:26)</a>:</h4>
<p>Why are recursors for mutual inductive types the way they are? And how are they to be used?</p>
<p>I've had a <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Use.20recursor.20within.20inductive.20def/near/248810473">previous discussion</a> about some mutual inductive types. Fundamentally, all of the types I had to define were structures. But since it isn't possible to directly declare structures in a <code>mutual</code> block, I'm trying to add the niceties of structures manually.<br>
My problem now is that I have to use the recursors of those types, which (e.g.) look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Component.MutationOutput.rec</span> <span class="o">:</span> <span class="o">((</span><span class="n">prtVals</span> <span class="o">:</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
      <span class="o">(</span><span class="n">newCns</span> <span class="n">delCns</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="bp">?</span><span class="n">m.534</span> <span class="bp">×</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">))</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">newRtrs</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Component.Reactor</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">))</span> <span class="bp">→</span>
          <span class="o">(</span><span class="n">delRtrs</span> <span class="o">:</span> <span class="n">Finset</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">)</span> <span class="bp">→</span>
            <span class="bp">?</span><span class="n">m.540</span> <span class="n">newRtrs</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.536</span> <span class="o">(</span><span class="n">Component.MutationOutput.mk</span> <span class="n">prtVals</span> <span class="n">state</span> <span class="n">newCns</span> <span class="n">delCns</span> <span class="n">newRtrs</span> <span class="n">delRtrs</span><span class="o">))</span> <span class="bp">→</span>
  <span class="o">((</span><span class="n">deps</span> <span class="o">:</span> <span class="n">Ports.Role</span> <span class="bp">→</span> <span class="n">Finset</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">)</span> <span class="bp">→</span>
      <span class="o">(</span><span class="n">triggers</span> <span class="o">:</span> <span class="n">Finset</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">body</span> <span class="o">:</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span> <span class="bp">→</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span> <span class="bp">→</span> <span class="n">Component.MutationOutput</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
          <span class="o">(</span><span class="n">tsSubInDeps</span> <span class="o">:</span> <span class="n">triggers</span> <span class="bp">⊆</span> <span class="n">deps</span> <span class="n">Ports.Role.in</span><span class="o">)</span> <span class="bp">→</span>
            <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.536</span> <span class="o">(</span><span class="n">body</span> <span class="n">a</span> <span class="n">a_1</span><span class="o">))</span> <span class="bp">→</span>
              <span class="bp">?</span><span class="n">m.537</span> <span class="o">(</span><span class="n">Component.Mutation.mk</span> <span class="n">deps</span> <span class="n">triggers</span> <span class="n">body</span> <span class="n">tsSubInDeps</span><span class="o">))</span> <span class="bp">→</span>
    <span class="o">((</span><span class="n">ports</span> <span class="o">:</span> <span class="n">Ports.Role</span> <span class="bp">→</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
          <span class="o">(</span><span class="n">rcns</span> <span class="n">muts</span> <span class="o">:</span> <span class="n">Finmap</span> <span class="bp">?</span><span class="n">m.534</span> <span class="o">(</span><span class="n">Component.Mutation</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">))</span> <span class="bp">→</span>
            <span class="o">(</span><span class="n">nest</span> <span class="o">:</span> <span class="n">Component.Network</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
              <span class="bp">?</span><span class="n">m.541</span> <span class="n">rcns</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.541</span> <span class="n">muts</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.539</span> <span class="n">nest</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.538</span> <span class="o">(</span><span class="n">Component.Reactor.mk</span> <span class="n">ports</span> <span class="n">state</span> <span class="n">rcns</span> <span class="n">muts</span> <span class="n">nest</span><span class="o">))</span> <span class="bp">→</span>
      <span class="o">([</span><span class="n">l</span> <span class="o">:</span> <span class="n">LGraph.Edge</span> <span class="o">(</span><span class="n">NetworkEdge</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">)</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">]</span> <span class="bp">→</span>
          <span class="o">(</span><span class="n">nodes</span> <span class="o">:</span> <span class="n">Finmap</span> <span class="bp">?</span><span class="n">m.534</span> <span class="o">(</span><span class="n">Component.Reactor</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">))</span> <span class="bp">→</span>
            <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">Finset</span> <span class="o">(</span><span class="n">NetworkEdge</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.542</span> <span class="n">nodes</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.539</span> <span class="o">(</span><span class="n">Component.Network.mk</span> <span class="n">nodes</span> <span class="n">edges</span><span class="o">))</span> <span class="bp">→</span>
        <span class="bp">?</span><span class="n">m.540</span> <span class="o">[]</span> <span class="bp">→</span>
          <span class="o">((</span><span class="n">head</span> <span class="o">:</span> <span class="n">Component.Reactor</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span>
              <span class="o">(</span><span class="n">tail</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Component.Reactor</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.538</span> <span class="n">head</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.540</span> <span class="n">tail</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.540</span> <span class="o">(</span><span class="n">head</span> <span class="o">::</span> <span class="n">tail</span><span class="o">))</span> <span class="bp">→</span>
            <span class="o">((</span><span class="n">map</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">Component.Mutation</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">))</span> <span class="bp">→</span>
                <span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">Set.finite</span> <span class="o">(</span><span class="n">Set.image</span> <span class="n">map</span> <span class="n">Set.univ</span><span class="o">))</span> <span class="bp">→</span>
                  <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.543</span> <span class="o">(</span><span class="n">map</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.541</span> <span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">map</span><span class="o">,</span> <span class="n">finite</span> <span class="o">:=</span> <span class="n">finite</span> <span class="o">})</span> <span class="bp">→</span>
              <span class="o">((</span><span class="n">map</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">Component.Reactor</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">))</span> <span class="bp">→</span>
                  <span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">Set.finite</span> <span class="o">(</span><span class="n">Set.image</span> <span class="n">map</span> <span class="n">Set.univ</span><span class="o">))</span> <span class="bp">→</span>
                    <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.534</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.544</span> <span class="o">(</span><span class="n">map</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.542</span> <span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">map</span><span class="o">,</span> <span class="n">finite</span> <span class="o">:=</span> <span class="n">finite</span> <span class="o">})</span> <span class="bp">→</span>
                <span class="bp">?</span><span class="n">m.543</span> <span class="n">none</span> <span class="bp">→</span>
                  <span class="o">((</span><span class="n">val</span> <span class="o">:</span> <span class="n">Component.Mutation</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.537</span> <span class="n">val</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.543</span> <span class="o">(</span><span class="n">some</span> <span class="n">val</span><span class="o">))</span> <span class="bp">→</span>
                    <span class="bp">?</span><span class="n">m.544</span> <span class="n">Option.none</span> <span class="bp">→</span>
                      <span class="o">((</span><span class="n">val</span> <span class="o">:</span> <span class="n">Component.Reactor</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.538</span> <span class="n">val</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.544</span> <span class="o">(</span><span class="n">Option.some</span> <span class="n">val</span><span class="o">))</span> <span class="bp">→</span>
                        <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Component.MutationOutput</span> <span class="bp">?</span><span class="n">m.534</span> <span class="bp">?</span><span class="n">m.535</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.536</span> <span class="n">t</span>
</code></pre></div>
<p>This is the recursor for the following type (without showing the related mutual inductives):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">MutationOutput</span> <span class="o">(</span><span class="n">ι</span> <span class="n">υ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">prtVals</span> <span class="o">:</span> <span class="n">Ports</span> <span class="n">ι</span> <span class="n">υ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">state</span>   <span class="o">:</span> <span class="n">StateVars</span> <span class="n">ι</span> <span class="n">υ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">newCns</span>  <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">×</span> <span class="n">ι</span><span class="o">))</span>
    <span class="o">(</span><span class="n">delCns</span>  <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">×</span> <span class="n">ι</span><span class="o">))</span>
    <span class="o">(</span><span class="n">newRtrs</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Reactor</span> <span class="n">ι</span> <span class="n">υ</span><span class="o">))</span>
    <span class="o">(</span><span class="n">delRtrs</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span><span class="o">)</span>
</code></pre></div>
<p>I was trying to write a simple accessor for <code>prtVals</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">MutationOutput.prtVals</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">MutationOutput</span> <span class="n">ι</span> <span class="n">υ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ports</span> <span class="n">ι</span> <span class="n">υ</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>But I don't know how to apply that wall of a recursor here.</p>



<a name="249703546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249703546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249703546">(Aug 17 2021 at 11:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Mutual.20inductive.20rec/near/249696211">said</a>:</p>
<blockquote>
<p>Note that termination checking for mutually recursive functions is not implemented yet, and neither is well-founded recursion. So you can only use the equation compiler for <code>partial</code> functions. If you want a function about which you can prove things, you need to use the recursor for now, and even then the function will be noncomputable (since the recursor is currently noncomputable). So my advice would be to avoid mutual inductives at all cost.</p>
</blockquote>
<p>Hmm, I don't really understand what you're saying yet. What's different about using the recursor vs. the equation compiler?</p>



<a name="249703612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249703612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249703612">(Aug 17 2021 at 11:12)</a>:</h4>
<p>And can't I do well-founded recursion manually?</p>



<a name="249703628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249703628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249703628">(Aug 17 2021 at 11:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> has marked this topic as unresolved.</p>



<a name="249704565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249704565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249704565">(Aug 17 2021 at 11:24)</a>:</h4>
<p>Take a look at this example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>
  <span class="kd">inductive</span> <span class="n">A</span>
    <span class="bp">|</span> <span class="n">base</span> <span class="o">:</span> <span class="n">A</span>
    <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span>

  <span class="kd">inductive</span> <span class="n">B</span>
    <span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span>
<span class="kd">end</span>

<span class="kd">mutual</span>
  <span class="kd">def</span> <span class="n">constructorCountA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="n">A.base</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
    <span class="bp">|</span> <span class="n">A.mk</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">constructorCountB</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span>

  <span class="kd">def</span> <span class="n">constructorCountB</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="n">B.mk</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">constructorCountA</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kd">end</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">constructorCountA₂</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">A.rec</span> <span class="o">(</span><span class="n">motive_1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">motive_2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">rec</span> <span class="bp">=&gt;</span> <span class="n">rec</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">rec</span> <span class="bp">=&gt;</span> <span class="n">rec</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>The <code>mutual</code> block does not compile. <code>constructorCountA₂</code> does not compile unless marked <code>noncomputable</code> (and I guess if marked <code>noncomputable</code>, it doesn't compile in a different sense). If you try to use wfrec, you'll notice (a) that all the definitions in <code>Init/WF.lean</code> are noncomputable and (b) that whatever well-founded relation you'd like to use may need to be defined by recursion itself. (Not sure about the last point.)</p>



<a name="249704902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249704902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249704902">(Aug 17 2021 at 11:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> <a href="#narrow/stream/270676-lean4/topic/Mutual.20inductive.20rec/near/249704565">said</a>:</p>
<blockquote>
<p><code>constructorCountA₂</code> does not compile unless marked <code>noncomputable</code> (and I guess if marked <code>noncomputable</code>, it doesn't compile in a different sense).</p>
</blockquote>
<p><code>constructorCountA₂</code> compiles fine for me.</p>



<a name="249704940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249704940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249704940">(Aug 17 2021 at 11:29)</a>:</h4>
<p>Oh, that's what you mean by "doesn't compile in a different sense".</p>



<a name="249705015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249705015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249705015">(Aug 17 2021 at 11:30)</a>:</h4>
<p>So if I'm fine with noncomputability, then the recursor approach is fine, isn't it?</p>



<a name="249707752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249707752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249707752">(Aug 17 2021 at 11:59)</a>:</h4>
<p>I think so, yes, if you can stomach the resulting ugliness.</p>



<a name="249771900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249771900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249771900">(Aug 17 2021 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> <a href="#narrow/stream/270676-lean4/topic/Mutual.20inductive.20rec/near/249587937">said</a>:</p>
<blockquote>
<p>Fundamentally, all of the types I had to define were structures. But since it isn't possible to directly declare structures in a <code>mutual</code> block, I'm t</p>
</blockquote>
<p>If you just have mutual nested structure, It is important to note that you can get away with avoiding <code>mutual</code> blocks altogether by making your types parametrized by the mutual type. See this <a href="#narrow/stream/270676-lean4/topic/Breaking.20up.20large.20mutual.20inductives/near/246507699">Zulip thread</a> for an example of how this works.</p>



<a name="249773372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249773372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249773372">(Aug 17 2021 at 20:18)</a>:</h4>
<p>For example, your mutual block from <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Use.20recursor.20within.20inductive.20def/near/248813293">here</a> could have been written like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">BaseMutationOutput</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">prtVals</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span>
  <span class="n">state</span>   <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span>
  <span class="n">newCns</span>  <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">×</span> <span class="n">ι</span><span class="o">)</span>
  <span class="n">newRcns</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">BaseMutation</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">deps</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span>
  <span class="n">body</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">BaseMutationOutput</span> <span class="n">R</span> <span class="n">ι</span>
  <span class="n">outPrtValsDepOnly</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">s</span> <span class="o">{</span><span class="n">o</span><span class="o">},</span> <span class="o">(</span><span class="n">o</span> <span class="bp">∉</span> <span class="n">deps</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">body</span> <span class="n">i</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">prtVals.nth</span> <span class="n">o</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Reaction</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">core</span> <span class="o">:</span> <span class="n">BaseMutation</span> <span class="o">(</span><span class="n">Reaction</span> <span class="n">ι</span><span class="o">)</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">noNewCns</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">core.body</span> <span class="n">i</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">newCns</span> <span class="bp">=</span> <span class="o">[])</span>

<span class="n">abbrev</span> <span class="n">MutationOutput</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">BaseMutationOutput</span> <span class="o">(</span><span class="n">Reaction</span> <span class="n">ι</span><span class="o">)</span> <span class="n">ι</span>
<span class="n">abbrev</span> <span class="n">Mutation</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">BaseMutation</span> <span class="o">(</span><span class="n">Reaction</span> <span class="n">ι</span><span class="o">)</span> <span class="n">ι</span>
</code></pre></div>



<a name="249814803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249814803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249814803">(Aug 18 2021 at 07:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Mutual.20inductive.20rec/near/249771900">said</a>:</p>
<blockquote>
<p>If you just have mutual nested structure, It is important to note that you can get away with avoiding <code>mutual</code> blocks altogether by making your types parametrized by the mutual type.</p>
</blockquote>
<p>Nice, that worked pretty well for the most part! I just have one case again where I'm getting an error that I don't understand:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Network</span> <span class="o">(</span><span class="n">ι</span> <span class="n">ρ</span><span class="o">)</span> <span class="n">where</span>
  <span class="o">(</span><span class="n">nodes</span> <span class="o">:</span> <span class="n">Finmap</span> <span class="n">ι</span> <span class="n">ρ</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Reactor</span> <span class="o">(</span><span class="n">ι</span> <span class="n">υ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">nest</span> <span class="o">:</span> <span class="n">Network</span> <span class="n">ι</span> <span class="o">(</span><span class="n">Reactor</span> <span class="n">ι</span> <span class="n">υ</span><span class="o">))</span>
</code></pre></div>
<p>Gives:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">kernel</span><span class="o">)</span> <span class="n">arg</span> <span class="bp">#</span><span class="mi">3</span> <span class="n">of</span> <span class="bp">'</span><span class="n">_nested.C.Network_1.mk'</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">non</span> <span class="n">valid</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="n">the</span> <span class="n">datatypes</span> <span class="n">being</span> <span class="n">declared</span>
</code></pre></div>
<p>And removing the <code>nodes</code> from <code>Network</code> resolves the error.</p>
<hr>
<p>Context for MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Set.finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">structure</span> <span class="n">Finmap</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">map</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Option</span> <span class="n">β</span>
  <span class="n">finite</span> <span class="o">:</span> <span class="o">(</span><span class="n">Set.univ.image</span> <span class="n">map</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span>
</code></pre></div>



<a name="249815017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249815017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249815017">(Aug 18 2021 at 07:10)</a>:</h4>
<p>Ok I just noticed that the <code>sorry</code> might actually be the problem.</p>



<a name="249819500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249819500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249819500">(Aug 18 2021 at 08:11)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span>  What's the benefit of using the parameter-based approach? Because (e.g.) the recursor that I get for <code>Reactor</code> that way is still</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Reactor.rec</span> <span class="o">:</span> <span class="o">((</span><span class="n">ports</span> <span class="o">:</span> <span class="n">Role</span> <span class="bp">→</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span>
      <span class="o">(</span><span class="n">rcns</span> <span class="n">muts</span> <span class="o">:</span> <span class="n">Finmap</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="o">(</span><span class="n">Mutation</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)))</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">prios</span> <span class="o">:</span> <span class="n">PartialOrder</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">)</span> <span class="bp">→</span>
          <span class="o">(</span><span class="n">nest</span> <span class="o">:</span> <span class="n">Network</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span>
            <span class="bp">?</span><span class="n">m.11185</span> <span class="n">rcns</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11185</span> <span class="n">muts</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11186</span> <span class="n">nest</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11184</span> <span class="o">(</span><span class="n">Reactor.mk</span> <span class="n">ports</span> <span class="n">state</span> <span class="n">rcns</span> <span class="n">muts</span> <span class="n">prios</span> <span class="n">nest</span><span class="o">))</span> <span class="bp">→</span>
  <span class="o">((</span><span class="n">map</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">Mutation</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)))</span> <span class="bp">→</span>
      <span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">Set.finite</span> <span class="o">(</span><span class="n">Set.image</span> <span class="n">map</span> <span class="n">Set.univ</span><span class="o">))</span> <span class="bp">→</span>
        <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11187</span> <span class="o">(</span><span class="n">map</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11185</span> <span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">map</span><span class="o">,</span> <span class="n">finite</span> <span class="o">:=</span> <span class="n">finite</span> <span class="o">})</span> <span class="bp">→</span>
    <span class="o">((</span><span class="n">nodes</span> <span class="o">:</span> <span class="n">Finmap</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">Finset</span> <span class="o">(</span><span class="n">Connection</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11188</span> <span class="n">nodes</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11186</span> <span class="o">{</span> <span class="n">nodes</span> <span class="o">:=</span> <span class="n">nodes</span><span class="o">,</span> <span class="n">edges</span> <span class="o">:=</span> <span class="n">edges</span> <span class="o">})</span> <span class="bp">→</span>
      <span class="bp">?</span><span class="n">m.11187</span> <span class="n">none</span> <span class="bp">→</span>
        <span class="o">((</span><span class="n">val</span> <span class="o">:</span> <span class="n">Mutation</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11189</span> <span class="n">val</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11187</span> <span class="o">(</span><span class="n">some</span> <span class="n">val</span><span class="o">))</span> <span class="bp">→</span>
          <span class="o">((</span><span class="n">map</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">→</span> <span class="n">Option</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span>
              <span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">Set.finite</span> <span class="o">(</span><span class="n">Set.image</span> <span class="n">map</span> <span class="n">Set.univ</span><span class="o">))</span> <span class="bp">→</span>
                <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11190</span> <span class="o">(</span><span class="n">map</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11188</span> <span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">map</span><span class="o">,</span> <span class="n">finite</span> <span class="o">:=</span> <span class="n">finite</span> <span class="o">})</span> <span class="bp">→</span>
            <span class="o">((</span><span class="n">deps</span> <span class="o">:</span> <span class="n">Role</span> <span class="bp">→</span> <span class="n">Finset</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">)</span> <span class="bp">→</span>
                <span class="o">(</span><span class="n">triggers</span> <span class="o">:</span> <span class="n">Finset</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">)</span> <span class="bp">→</span>
                  <span class="o">(</span><span class="n">body</span> <span class="o">:</span>
                      <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span> <span class="bp">→</span>
                        <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span> <span class="bp">→</span> <span class="n">MutationOutput</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span>
                    <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11191</span> <span class="o">(</span><span class="n">body</span> <span class="n">a</span> <span class="n">a_1</span><span class="o">))</span> <span class="bp">→</span>
                      <span class="bp">?</span><span class="n">m.11189</span> <span class="o">{</span> <span class="n">deps</span> <span class="o">:=</span> <span class="n">deps</span><span class="o">,</span> <span class="n">triggers</span> <span class="o">:=</span> <span class="n">triggers</span><span class="o">,</span> <span class="n">body</span> <span class="o">:=</span> <span class="n">body</span> <span class="o">})</span> <span class="bp">→</span>
              <span class="bp">?</span><span class="n">m.11190</span> <span class="n">Option.none</span> <span class="bp">→</span>
                <span class="o">((</span><span class="n">val</span> <span class="o">:</span> <span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11184</span> <span class="n">val</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11190</span> <span class="o">(</span><span class="n">Option.some</span> <span class="n">val</span><span class="o">))</span> <span class="bp">→</span>
                  <span class="o">((</span><span class="n">prtVals</span> <span class="o">:</span> <span class="n">Ports</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span>
                      <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">StateVars</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span>
                        <span class="o">(</span><span class="n">newCns</span> <span class="n">delCns</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="bp">?</span><span class="n">m.11182</span> <span class="bp">×</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">))</span> <span class="bp">→</span>
                          <span class="o">(</span><span class="n">newRtrs</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span>
                            <span class="o">(</span><span class="n">delRtrs</span> <span class="o">:</span> <span class="n">Finset</span> <span class="bp">?</span><span class="n">m.11182</span><span class="o">)</span> <span class="bp">→</span>
                              <span class="bp">?</span><span class="n">m.11192</span> <span class="n">newRtrs</span> <span class="bp">→</span>
                                <span class="bp">?</span><span class="n">m.11191</span>
                                  <span class="o">{</span> <span class="n">prtVals</span> <span class="o">:=</span> <span class="n">prtVals</span><span class="o">,</span> <span class="n">state</span> <span class="o">:=</span> <span class="n">state</span><span class="o">,</span> <span class="n">newCns</span> <span class="o">:=</span> <span class="n">newCns</span><span class="o">,</span> <span class="n">delCns</span> <span class="o">:=</span> <span class="n">delCns</span><span class="o">,</span>
                                    <span class="n">newRtrs</span> <span class="o">:=</span> <span class="n">newRtrs</span><span class="o">,</span> <span class="n">delRtrs</span> <span class="o">:=</span> <span class="n">delRtrs</span> <span class="o">})</span> <span class="bp">→</span>
                    <span class="bp">?</span><span class="n">m.11192</span> <span class="o">[]</span> <span class="bp">→</span>
                      <span class="o">((</span><span class="n">head</span> <span class="o">:</span> <span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span>
                          <span class="o">(</span><span class="n">tail</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">))</span> <span class="bp">→</span>
                            <span class="bp">?</span><span class="n">m.11184</span> <span class="n">head</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11192</span> <span class="n">tail</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11192</span> <span class="o">(</span><span class="n">head</span> <span class="o">::</span> <span class="n">tail</span><span class="o">))</span> <span class="bp">→</span>
                        <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Reactor</span> <span class="bp">?</span><span class="n">m.11182</span> <span class="bp">?</span><span class="n">m.11183</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m.11184</span> <span class="n">t</span>
</code></pre></div>



<a name="249819733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249819733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249819733">(Aug 18 2021 at 08:15)</a>:</h4>
<p>the benefit is that the structures are structures, and you get the usual niceties of field projections and structure instances</p>



<a name="249819831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249819831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249819831">(Aug 18 2021 at 08:16)</a>:</h4>
<p>"structure instances"?</p>



<a name="249819850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual%20inductive%20rec/near/249819850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Mutual.20inductive.20rec.html#249819850">(Aug 18 2021 at 08:17)</a>:</h4>
<p><code>{foo := 1, bar := 2}</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html">Segfault due to mutual recursion?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="255330019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255330019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255330019">(Sep 29 2021 at 02:03)</a>:</h4>
<p>I'm on the LEAN4 nightly, and I've encountered a segfault when implementing a custom <code>Parser</code> monad to write a hand written recursive-descent parser. <a href="https://gist.github.com/bollu/a4badaa83659860fdc953245b85a8d1e#running">Here's a full gist with the repro</a>. I'm on LEAN4 commit <code>f4759c9a223f</code></p>
<p>I've pasted the program here for ease-of-use:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Maybe</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">ok</span><span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">err</span><span class="o">:</span> <span class="n">Maybe</span> <span class="n">a</span>

<span class="kd">structure</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
   <span class="n">runP</span><span class="o">:</span> <span class="n">String</span> <span class="bp">-&gt;</span> <span class="n">Maybe</span> <span class="o">(</span><span class="n">String</span> <span class="bp">×</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">ppure</span> <span class="o">{</span><span class="n">a</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">a</span><span class="o">):</span> <span class="n">P</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">runP</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Maybe.ok</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">pbind</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">pa</span><span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">a2pb</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">b</span><span class="o">):</span> <span class="n">P</span> <span class="n">b</span> <span class="o">:=</span>
   <span class="o">{</span> <span class="n">runP</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">s</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">pa.runP</span> <span class="n">s</span> <span class="k">with</span>
            <span class="bp">|</span> <span class="n">Maybe.ok</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">a2pb</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">runP</span>  <span class="n">s'</span>
            <span class="bp">|</span> <span class="n">Maybe.err</span> <span class="bp">=&gt;</span> <span class="n">Maybe.err</span>
   <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Monad</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">pure</span> <span class="o">:=</span> <span class="n">ppure</span><span class="o">,</span> <span class="n">bind</span> <span class="o">:=</span> <span class="n">pbind</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">pfail</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">runP</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span>  <span class="bp">=&gt;</span> <span class="n">Maybe.err</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="n">where</span> <span class="n">default</span> <span class="o">:=</span> <span class="n">pfail</span>

<span class="kd">mutual</span>
<span class="n">partial</span> <span class="kd">def</span> <span class="n">pregion</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Unit</span> <span class="o">:=</span>  <span class="k">do</span>
  <span class="n">pblock</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">pop</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">pregion</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">pblock</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
   <span class="n">pop</span>
<span class="kd">end</span>  <span class="c1">-- end mutual</span>

<span class="kd">def</span> <span class="n">main</span><span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">return</span> <span class="o">()</span>
</code></pre></div>
<p>Am I violating some contract that causes this program to crash? I currently suspect that the <code>mutual</code> block I have somehow violates something. However, it's dead code (<code>main</code> doesn't invoke it!) so I'm not sure what the actual problem is.</p>



<a name="255330248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255330248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255330248">(Sep 29 2021 at 02:06)</a>:</h4>
<p>I would suspect the problem is the combination of <code>mutual</code> and <code>partial</code>. You should be using one or the other, not both.</p>



<a name="255330328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255330328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255330328">(Sep 29 2021 at 02:07)</a>:</h4>
<p>What if I do really need both? (mutually recursive functions whose termination is too complicated to prove, and are hence <code>partial</code> for practical purposes.)</p>
<p>Also, is this a bug?</p>



<a name="255330516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255330516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255330516">(Sep 29 2021 at 02:10)</a>:</h4>
<p><span class="user-mention" data-user-id="130575">@Siddharth Bhat</span> partial definitions can already be written in a mutual recursive manner but just unpacking them. The <code>partial</code> definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">bar</span>
</code></pre></div>
<p>is essentially equivalent to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unsafe</span> <span class="kd">def</span> <span class="n">fooImpl</span> <span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">bar</span>
<span class="kd">@[implementedBy fooImpl]</span> <span class="kd">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">T</span>
</code></pre></div>



<a name="255330751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255330751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255330751">(Sep 29 2021 at 02:13)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> I don't understand how to extend this to a definition of <code>bar</code> that depends on <code>foo</code>. I naively tried:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unsafe</span> <span class="kd">def</span> <span class="n">fooImpl</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">bar</span>
<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">barImpl</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">foo</span>
<span class="kd">@[implementedBy fooImpl]</span> <span class="kd">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Unit</span>
<span class="kd">@[implementedBy barImpl]</span> <span class="kd">constant</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">Unit</span>
</code></pre></div>
<p>which doesn't work. Could you please show me how? :)</p>



<a name="255330886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255330886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255330886">(Sep 29 2021 at 02:15)</a>:</h4>
<p>This should work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Unit</span>
<span class="kd">constant</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">Unit</span>

<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">fooImpl</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">bar</span>
<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">barImpl</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">foo</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">implementedBy</span> <span class="n">fooImpl</span><span class="o">]</span> <span class="n">foo</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">implementedBy</span> <span class="n">barImpl</span><span class="o">]</span> <span class="n">bar</span>
</code></pre></div>



<a name="255331104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255331104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255331104">(Sep 29 2021 at 02:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130575">Siddharth Bhat</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255330328">said</a>:</p>
<blockquote>
<p>Also, is this a bug?</p>
</blockquote>
<p>Yes. Lean should not be segfaulting. My point was that you are doing something that is likely very unexpected (combining <code>mutual</code> and <code>partial</code>) and thus it was probably not well tested (resulting in said segfault).</p>



<a name="255331266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255331266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255331266">(Sep 29 2021 at 02:21)</a>:</h4>
<p>Interesting, the suggested change fixes the segfault :) Thanks <span class="user-mention" data-user-id="315577">@Mac</span> , I'll file a bug report and use the workaround for now.</p>



<a name="255331784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255331784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255331784">(Sep 29 2021 at 02:28)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> I filed an issue: <a href="https://github.com/leanprover/lean4/issues/697">https://github.com/leanprover/lean4/issues/697</a></p>



<a name="255338701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255338701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255338701">(Sep 29 2021 at 04:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255331104">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="130575">Siddharth Bhat</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255330328">said</a>:</p>
<blockquote>
<p>Also, is this a bug?</p>
</blockquote>
<p>Yes. Lean should not be segfaulting. My point was that you are doing something that is likely very unexpected (combining <code>mutual</code> and <code>partial</code>) and thus it was probably not well tested (resulting in said segfault).</p>
</blockquote>
<p>I have used partial and mutual together many times without issue. All definitions in the block must be all-<code>partial</code> or all not, but otherwise it works just as you would expect.</p>



<a name="255338866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255338866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255338866">(Sep 29 2021 at 04:07)</a>:</h4>
<p>The fact that the recursion is completely unguarded here might be an issue though (mutual functions are usually functions with at least one argument), and my guess is that it is hitting an internal evaluation limit when constructing the closed terms <code>pregion</code>, <code>pop</code>, <code>pblock</code></p>



<a name="255340888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255340888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255340888">(Sep 29 2021 at 04:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255338701">said</a>:</p>
<blockquote>
<p>I have used partial and mutual together many times without issue. All definitions in the block must be all-<code>partial</code> or all not, but otherwise it works just as you would expect.</p>
</blockquote>
<p>In that case, would it make more sense for <code>parital</code> to be a modifier to <code>mutual</code> in such cases rather than part of each <code>def</code>?</p>



<a name="255341039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341039">(Sep 29 2021 at 04:40)</a>:</h4>
<p>There are several features of the declarations of the mutual block that could arguably be moved to the header. That was the lean 3 design. My understanding is that the lean 4 design is intended to make mutual defs read just like regular defs, and enable more flexibility in the way the individual definitions are constructed</p>



<a name="255341198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341198">(Sep 29 2021 at 04:43)</a>:</h4>
<p>My reason for saying this is that <code>mutual</code> tends to imply a lot of complex kernel type checking  to make sure the recursion is valid. With all partial definitions, all that is skipped. The only thing the block is doing at that point is allowing for forward reference. Right?</p>



<a name="255341260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341260">(Sep 29 2021 at 04:44)</a>:</h4>
<p>The heavy distinction there feels like it should be clearer.</p>



<a name="255341266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341266">(Sep 29 2021 at 04:44)</a>:</h4>
<p>The elaboration of <code>partial</code> and non-<code>partial</code> mutual defs is the same</p>



<a name="255341299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341299">(Sep 29 2021 at 04:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> What do you mean by that?</p>



<a name="255341330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341330">(Sep 29 2021 at 04:45)</a>:</h4>
<p>The definitions are typechecked in the same context, with the same things in scope</p>



<a name="255341337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341337">(Sep 29 2021 at 04:45)</a>:</h4>
<p>the only difference is in the backend compilation in the kernel</p>



<a name="255341390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341390">(Sep 29 2021 at 04:46)</a>:</h4>
<p>they also produce the same compiled code</p>



<a name="255341409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341409">(Sep 29 2021 at 04:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255341337">said</a>:</p>
<blockquote>
<p>the only difference is in the backend compilation in the kernel</p>
</blockquote>
<p>which is why I defined the difference as "complex kernel type checking"</p>



<a name="255341430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341430">(Sep 29 2021 at 04:47)</a>:</h4>
<p>I'm not sure I understand your suggestion</p>



<a name="255341475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341475">(Sep 29 2021 at 04:48)</a>:</h4>
<p>Do you think that <code>unsafe</code> should be divorced from the line with the <code>def</code> as well?</p>



<a name="255341543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341543">(Sep 29 2021 at 04:48)</a>:</h4>
<p>If it's a large mutual block, it might not be obvious that the def is in a block at all, in which case the displaced <code>partial</code> could be confusing</p>



<a name="255341667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341667">(Sep 29 2021 at 04:50)</a>:</h4>
<p>That is a weird argument, if its a large mutual block that one has forgotten is mutual, it might be just as confusing where the recursive functions come from (as one normally assume they are defined earlier in the file rather than later).</p>



<a name="255341782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341782">(Sep 29 2021 at 04:52)</a>:</h4>
<p>My view was simply that as the termination checking occurs w.r.t.  the entire <code>mutual</code> block and <code>partial</code> essentially means 'don't do termination checking', it seems most logica; (to me) to apply that to the <code>mutual</code> which is doing said checking as opposed to the <code>def</code> which is not.</p>



<a name="255341929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341929">(Sep 29 2021 at 04:54)</a>:</h4>
<p>The application of <code>partial</code>, or <code>unsafe</code>, is restricted to apply to a block at a time, which is why all defs in a block have to have the same <code>partial</code>/<code>unsafe</code> setting</p>



<a name="255341930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341930">(Sep 29 2021 at 04:54)</a>:</h4>
<p>For instance, the new <code>termination_by</code> statement for wf recursion will apply to the end of the <code>mutual</code> block instead of at each <code>def</code> -- so for consistency it makes sense to apply the <code>partial</code> (its opposite, essentially) to the block as well.</p>



<a name="255341958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341958">(Sep 29 2021 at 04:55)</a>:</h4>
<p>The fact that it is written on a def is only for convenience / style</p>



<a name="255341989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255341989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255341989">(Sep 29 2021 at 04:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think it would be hard to argue that repeating <code>partial</code> multiple times is more 'convenient' than doing it once.</p>



<a name="255342044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342044">(Sep 29 2021 at 04:56)</a>:</h4>
<p>Perhaps you might not feel the same way if you have used lean 3 mutual defs</p>



<a name="255342074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342074">(Sep 29 2021 at 04:57)</a>:</h4>
<p>how so?</p>



<a name="255342164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342164">(Sep 29 2021 at 04:58)</a>:</h4>
<p>It also violates a common adage of CS: don't repeat yourself (DRY).</p>



<a name="255342200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342200">(Sep 29 2021 at 04:59)</a>:</h4>
<p>Also, Lean is already quite fond of this in other places -- i.e., DRY is what things like <code>universe</code> and <code>variable</code> are for (which also apply to the whole block).</p>



<a name="255342313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342313">(Sep 29 2021 at 05:00)</a>:</h4>
<p>Like I said, lean 3 mutual defs don't repeat anything: <code>meta</code>/<code>noncomputable</code> shows up only once, in the mutual header, as well as parameters that aren't participating in the recursion. It is followed by a list of <code>with</code> defs that give the body of the definitions. In actual use, <code>with</code> has an unfortunate status as not quite a def; it means that you have to learn a different syntax for defs and you can't use other commands in the block</p>



<a name="255342419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342419">(Sep 29 2021 at 05:01)</a>:</h4>
<p>Keep in mind, when proposing to change this, that this is literally what lean 4 changed away from</p>



<a name="255342442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342442">(Sep 29 2021 at 05:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255342313">said</a>:</p>
<blockquote>
<p>as well as parameters that aren't participating in the recursion.</p>
</blockquote>
<p>I can definitely see why this would be annoying</p>



<a name="255342524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342524">(Sep 29 2021 at 05:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Also, fyi, I did use Lean 3 myself. <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>  I don't remember having a problem with <code>mutual</code> there.</p>



<a name="255342547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342547">(Sep 29 2021 at 05:02)</a>:</h4>
<p>Lean 4 also does the parameter thing differently when you call a function recursively, even without <code>mutual</code> - you need to repeat parameters in the function call</p>



<a name="255342565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342565">(Sep 29 2021 at 05:02)</a>:</h4>
<p>the lean 3 way is DRY but also confusing</p>



<a name="255342571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342571">(Sep 29 2021 at 05:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Yeah I am quite with that. That always tripped me up in Lean 3.</p>



<a name="255342606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342606">(Sep 29 2021 at 05:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255342565">said</a>:</p>
<blockquote>
<p>the lean 3 way is DRY but also confusing</p>
</blockquote>
<p>There is also the fact that it just wouldn't work with partial defs at all.</p>



<a name="255342619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342619">(Sep 29 2021 at 05:03)</a>:</h4>
<p>how so?</p>



<a name="255342694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342694">(Sep 29 2021 at 05:04)</a>:</h4>
<p>A partial def has no delineation between recursive and non-recursive parameters so the idea wouldn't really apply there, right?</p>



<a name="255342695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342695">(Sep 29 2021 at 05:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">n</span>
</code></pre></div>



<a name="255342721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342721">(Sep 29 2021 at 05:05)</a>:</h4>
<p>How does <code>meta</code> know that I don't want to recur on both arguments?</p>



<a name="255342736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342736">(Sep 29 2021 at 05:05)</a>:</h4>
<p>because only one is right of the colon</p>



<a name="255342788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342788">(Sep 29 2021 at 05:06)</a>:</h4>
<p>that's how the rule goes in lean 3</p>



<a name="255342800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342800">(Sep 29 2021 at 05:06)</a>:</h4>
<p>Yeah, it ties pattern matching with recursion, which I think is the bigger problem there.</p>



<a name="255342861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342861">(Sep 29 2021 at 05:07)</a>:</h4>
<p>you don't have to do any actual pattern matching though</p>



<a name="255342943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342943">(Sep 29 2021 at 05:08)</a>:</h4>
<p>Yes but it ties the pattern-matching syntax with recursion, which is weird. And it would make writing most <code>partial</code> functions (which tend to be structure in normal CS style) very weird.</p>



<a name="255342977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255342977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255342977">(Sep 29 2021 at 05:09)</a>:</h4>
<p>As the boilerplate of <code>partial def foo : a -&gt; b -&gt; c | a, b =&gt;</code> would be  quite common.</p>



<a name="255343063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343063">(Sep 29 2021 at 05:10)</a>:</h4>
<p>Furthermore, <code>def</code> alternates in Lean 4 are equivalent to an internal <code>match</code> (which also makes me quite happy), this style of delineating recursion wouldn't even be logical anymore in Lean 4.</p>



<a name="255343203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343203">(Sep 29 2021 at 05:12)</a>:</h4>
<p>My point being that the parameter part of old <code>mutual</code> is much more than just DRY it also encapsulates/demands more information than one might wish to provide (and, as you said, breaks consistency).</p>



<a name="255343236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343236">(Sep 29 2021 at 05:13)</a>:</h4>
<p>On the other hand <code>partial</code> is a modifier, and some modifiers already only work in certain circumstances, so there is much less consistency to break (if any).</p>



<a name="255343334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343334">(Sep 29 2021 at 05:14)</a>:</h4>
<p>Note that you can still have "parameters" in lean 4 style recursion, by using <code>variable</code>. I haven't decided whether this is a good thing or inconsistent yet</p>



<a name="255343438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343438">(Sep 29 2021 at 05:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">n</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
<span class="n">partial</span> <span class="kd">def</span> <span class="n">foo'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">foo'</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">foo'</span> <span class="n">n</span>
</code></pre></div>



<a name="255343446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343446">(Sep 29 2021 at 05:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Personally, if I were writing a style guide, I would ban explicit binders in <code>variable</code>, as it makes the parameters one needs to specify of  a <code>def</code> (and there order) hard to figure out.</p>



<a name="255343582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343582">(Sep 29 2021 at 05:18)</a>:</h4>
<p>Especially if the <code>def</code> is far removed from the <code>variable</code>.</p>



<a name="255343607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343607">(Sep 29 2021 at 05:19)</a>:</h4>
<p>looking at lean 4 itself it seems like about 1/3 of <code>variable</code> lines violate your style guide</p>



<a name="255343619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343619">(Sep 29 2021 at 05:19)</a>:</h4>
<p>I am aware. :(</p>



<a name="255343634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343634">(Sep 29 2021 at 05:19)</a>:</h4>
<p>It has caused me much pain.</p>



<a name="255343715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343715">(Sep 29 2021 at 05:20)</a>:</h4>
<p>And in mathlib3 there are at least 1400 occurrences. :-)</p>



<a name="255343729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343729">(Sep 29 2021 at 05:20)</a>:</h4>
<p>My only exception to this rule would be the the binder meant to be used with dot notation (which I would demand be named <code>self</code>).</p>



<a name="255343752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343752">(Sep 29 2021 at 05:21)</a>:</h4>
<p>Regarding determining the parameters of a <code>def</code>, I use <code>#print</code> for that</p>



<a name="255343941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343941">(Sep 29 2021 at 05:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> while I like Lean's interactivity, having to go right a <code>#print</code> statement while deep in a function is not fun.</p>



<a name="255343979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343979">(Sep 29 2021 at 05:24)</a>:</h4>
<p>And is also impossible when I am viewing Lean code in a non-interactive manner.</p>



<a name="255343989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255343989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255343989">(Sep 29 2021 at 05:25)</a>:</h4>
<p>well, one day we will have <code>#print</code> at expression/tactic scope</p>



<a name="255344016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344016">(Sep 29 2021 at 05:25)</a>:</h4>
<p>Honestly, I would much prefer to see it at an editor level through a command.</p>



<a name="255344029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344029">(Sep 29 2021 at 05:25)</a>:</h4>
<p>hover already fills that niche to a great extent</p>



<a name="255344079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344079">(Sep 29 2021 at 05:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> not when there are elaboration errors in your code. :(</p>



<a name="255344100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344100">(Sep 29 2021 at 05:26)</a>:</h4>
<p>which is quite common when writing a function.</p>



<a name="255344128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344128">(Sep 29 2021 at 05:27)</a>:</h4>
<p>and  even more common when said error is the thing you are trying to fix by verifying types/defs.  XD</p>



<a name="255344195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344195">(Sep 29 2021 at 05:28)</a>:</h4>
<p>usually if lean has enough understanding to give you a type error at a function application, it will be able to give you a hover on the function</p>



<a name="255344305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344305">(Sep 29 2021 at 05:30)</a>:</h4>
<p>yeah, but such types are generally less than useful as they are some intermediate output of the inference engine (i.e., with metavariables and dependent types) and thus unreadable to my unexpert eyes.</p>



<a name="255344344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344344">(Sep 29 2021 at 05:30)</a>:</h4>
<p>also, if the problem is syntactic hovers may not even exist.</p>



<a name="255344465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344465">(Sep 29 2021 at 05:32)</a>:</h4>
<p>when I hover on a constant name, the output looks like the original type of the constant, before unification</p>



<a name="255344506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344506">(Sep 29 2021 at 05:33)</a>:</h4>
<p>although I would <em>really</em> like hovering on the name of a definition to also work and act just like hovering on a use of that definition</p>



<a name="255344512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344512">(Sep 29 2021 at 05:33)</a>:</h4>
<p>that would solve your parameters issue pretty well</p>



<a name="255344519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344519">(Sep 29 2021 at 05:33)</a>:</h4>
<p>Oh, you mean the actual function itself, in that case, yeah, but that is rarely my problem.</p>



<a name="255344591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344591">(Sep 29 2021 at 05:34)</a>:</h4>
<p>as in, if you are looking at some <code>def foo</code> that picks up some unknown set of variables above, you can hover on <code>foo</code> to find out the actual type</p>



<a name="255344594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344594">(Sep 29 2021 at 05:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255344512">said</a>:</p>
<blockquote>
<p>that would solve your parameters issue pretty well</p>
</blockquote>
<p>I think you greatly underestimate how much Lean code I read on GitHub.</p>



<a name="255344611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344611">(Sep 29 2021 at 05:34)</a>:</h4>
<p>Also, I have been having major problems getting Lean to properly find definitions when browsing its source at all.</p>



<a name="255344612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344612">(Sep 29 2021 at 05:34)</a>:</h4>
<p>I gave up on reading proof assistants from raw code long ago</p>



<a name="255344619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344619">(Sep 29 2021 at 05:34)</a>:</h4>
<p>Most of my go-to-defs find nothing.</p>



<a name="255344655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344655">(Sep 29 2021 at 05:35)</a>:</h4>
<p>can you <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="255344660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344660">(Sep 29 2021 at 05:35)</a>:</h4>
<p>Note that this is only when browsing the cloned repo, not in the distribution acquired through <code>elan</code>.</p>



<a name="255344715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344715">(Sep 29 2021 at 05:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> How does one <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> an interactivity issue?</p>



<a name="255344729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344729">(Sep 29 2021 at 05:36)</a>:</h4>
<p>there are interactive tests</p>



<a name="255344743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344743">(Sep 29 2021 at 05:36)</a>:</h4>
<p>I suspect this may be due to the fact I often update the code without rebuilding it. Since rebuilding still takes a good 15-30mins on my machine.</p>



<a name="255344762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255344762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255344762">(Sep 29 2021 at 05:36)</a>:</h4>
<p>but the usual way to do it here is to set up something reproducible and describe what you are doing and what you see</p>



<a name="255345029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345029">(Sep 29 2021 at 05:40)</a>:</h4>
<p>Okay, just to demonstrate how this works for me (and how I don't understand interactivity <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>):</p>
<ul>
<li>I open up my local copy of the <code>lean4</code> repo in VSCode</li>
<li>I open up <code>src/Lean/Parser.lean</code></li>
<li>Wait for elaboration to finish</li>
<li>Hover over <code>Parenthesizer</code> in <code>ident.parenthesizer</code></li>
<li>Right-click 'Go to Definition'</li>
<li>Get "no definition found for 'Parenthesize'"</li>
</ul>



<a name="255345337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345337">(Sep 29 2021 at 05:45)</a>:</h4>
<p>That works for me (go-to-definition takes me to <code>Parenthesizer</code>); I have vscode, just updated to master, never built, vscode-lean4 v0.0.33</p>



<a name="255345414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345414">(Sep 29 2021 at 05:46)</a>:</h4>
<p>Does it work if you have an older build with the proper settings for <code>elan</code>? That is my case.</p>



<a name="255345487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345487">(Sep 29 2021 at 05:47)</a>:</h4>
<p>I have my <code>elan</code> set up in the folder as described here: <a href="https://leanprover.github.io/lean4/doc/dev/index.html#dev-setup-using-elan">https://leanprover.github.io/lean4/doc/dev/index.html#dev-setup-using-elan</a></p>



<a name="255345538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345538">(Sep 29 2021 at 05:48)</a>:</h4>
<p>I just ran <code>elan update leanprover/lean4:nightly</code>, still works</p>



<a name="255345575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345575">(Sep 29 2021 at 05:48)</a>:</h4>
<p>I meant having overrides set for the  repo root and <code>src</code> dirs</p>



<a name="255345584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345584">(Sep 29 2021 at 05:48)</a>:</h4>
<p>I have elan set up to use nightly, not master</p>



<a name="255345604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345604">(Sep 29 2021 at 05:49)</a>:</h4>
<p>The dev setup for <code>lean4</code> is suppose to look like the following (as described <a href="https://leanprover.github.io/lean4/doc/dev/index.html#dev-setup-using-elan">here</a>):</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code><span class="c1"># in the Lean rootdir</span>
elan toolchain link lean4 build/release/stage1
elan toolchain link lean4-stage0 build/release/stage0
<span class="c1"># make `lean` etc. point to stage1 in the rootdir and subdirs</span>
elan override <span class="nb">set</span> lean4
<span class="nb">cd</span> src
<span class="c1"># make `lean` etc. point to stage0 anywhere inside `src`</span>
elan override <span class="nb">set</span> lean4-stage0
</code></pre></div>



<a name="255345712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345712">(Sep 29 2021 at 05:50)</a>:</h4>
<p>I haven't actually built lean 4, the stage 0 stuff scares me off</p>



<a name="255345720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345720">(Sep 29 2021 at 05:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255343446">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> Personally, if I were writing a style guide, I would ban explicit binders in <code>variable</code>, as it makes the parameters one needs to specify of  a <code>def</code> (and there order) hard to figure out.</p>
</blockquote>
<p>I think there are many places where it explicit binders in <code>variables</code> can be reasonably defended.</p>
<p>Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">base_class1</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">base_class2</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">base_class3</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mixin1</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mixin2</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mixin3</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">API_lemma_1</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">API_lemma_2</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">API_lemma_3</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">API_lemma_4</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="c1">-- make `X` explicit (but don't repeat all the typeclass assumptions, DRY)</span>

<span class="kd">def</span> <span class="n">cool_construction</span> <span class="o">[</span><span class="n">mixin4</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">foobar</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">somestuff</span> <span class="n">involving</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">and</span> <span class="n">API_lemma_4</span> <span class="k">from</span> <span class="n">above.</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="c1">-- from now on `X` can be implicit again</span>
</code></pre></div>



<a name="255345745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345745">(Sep 29 2021 at 05:51)</a>:</h4>
<p>This pattern is pretty common in mathlib, I think.</p>



<a name="255345825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255345825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255345825">(Sep 29 2021 at 05:52)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  wouldn't the following just be better? (if it was supported)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">base_class1</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">base_class2</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">base_class3</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mixin1</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mixin2</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">mixin3</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">API_lemma_1</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">API_lemma_2</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">API_lemma_3</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">API_lemma_4</span> <span class="o">:</span> <span class="n">blabla</span> <span class="n">x</span>

<span class="c1">-- modify the binder in the def for just this def</span>
<span class="kd">def</span> <span class="n">cool_construction</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">[</span><span class="n">mixin4</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">foobar</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">somestuff</span> <span class="n">involving</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">and</span> <span class="n">API_lemma_4</span> <span class="k">from</span> <span class="n">above.</span>
</code></pre></div>



<a name="255346015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255346015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255346015">(Sep 29 2021 at 05:54)</a>:</h4>
<p>If that were supported, that would be quite useful. But somehow it has to work together with introducing fresh variables that can typically shadow names that were introduced by <code>variables</code> before. I don't have a good sense for how that would work. (Because I don't know anything about language design at all.)</p>
<p>And nevertheless. Sometimes you want to make <code>X</code> explicit for 8 declarations in a row, so you put those in a <code>section</code> and add <code>variables (X)</code> to that section.</p>



<a name="255346058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255346058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255346058">(Sep 29 2021 at 05:55)</a>:</h4>
<p>Note that there are also very reasonable situations where you want to make write <code>variables (R A B M N)</code> and make 5 variables explicit for the next 7 declarations.</p>



<a name="255346190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255346190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255346190">(Sep 29 2021 at 05:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255346015">said</a>:</p>
<blockquote>
<p>hat can typically shadow names that were introduced by <code>variables</code> before.</p>
</blockquote>
<p>I know that is how it currently but I think being able to shadow a binder from <code>variable</code> is just more confusing. I view the idea behind <code>variable</code> being that, within, this section <code>x</code> is <code>X</code>. If that is not the case, I don't really feel like the <code>def</code> should be in the  same section.</p>



<a name="255346436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255346436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255346436">(Sep 29 2021 at 06:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255346058">said</a>:</p>
<blockquote>
<p>write <code>variables (R A B M N)</code> and make 5 variables explicit for the next 7 declarations.</p>
</blockquote>
<p>Where? Having  multiple functions with the same 5 explicit variables (and 5 explicit arguments in the first place) is a bit concerning. Generally, if a function is taking that many explicit parameters, you should probably be passing a struct with said fields instead.</p>
<p>Though I guess one reasonable exception / use case I can imagine would be explicit binders with defaults that are meant to be used only by named argument syntax.  In such cases, the order is unimportant and you can still use the function without specifying them (so shares more in common with an inferred binder than with other explicit binders) . However, unfortunately, since <code>variable</code> as its arguments at the start this is usually not possible.</p>
<p>Even if it were, though, I don't wouldn't the fact that you can't tell from the definition which arguments are to be specify to it and which it infers or otherwise inherits from the surrounding scope. But I would be less opinionated on such cases.</p>



<a name="255346866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255346866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255346866">(Sep 29 2021 at 06:05)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span>, for context, there are many examples in mathlib where we change many variables binders at once, e.g. <a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/lie/tensor_product.lean#L77">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/lie/tensor_product.lean#L77</a></p>



<a name="255346988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255346988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255346988">(Sep 29 2021 at 06:07)</a>:</h4>
<p>(That one appears to be a record, but there are lots where we change 3 or 4 at a time.)</p>



<a name="255347032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347032">(Sep 29 2021 at 06:07)</a>:</h4>
<p>The expression <code>lift R L M N P f (m ⊗ₜ n)</code> just hurts me.</p>



<a name="255347199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347199">(Sep 29 2021 at 06:09)</a>:</h4>
<p>However, I suspect this has more to do with the nature of mathlib. I suspect that you rarely actually do apply those arguments explicitly and instead apply them through notation.</p>



<a name="255347289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347289">(Sep 29 2021 at 06:10)</a>:</h4>
<p>Three modules, a ring, a lie algebra, a linear map, and two vectors! Just maths. :-)</p>



<a name="255347298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347298">(Sep 29 2021 at 06:10)</a>:</h4>
<blockquote>
<p>you should probably be passing a struct with said fields instead.</p>
</blockquote>
<p>but without eta for records, this can cause defeq issues down the road, rigth? (just one objection)<br>
Also, this might be nice while setting up the API for that particular theory, but when applying it, users would constantly have to bundled up random types into a record, instead of just passing them directly to the functions.<br>
In 50% of the applications, unification can figure out the types, so you just write an <code>_</code>. But for those other 50%, we're really happy that the argument has explicit binding.</p>



<a name="255347366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347366">(Sep 29 2021 at 06:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255347199">said</a>:</p>
<blockquote>
<p>However, I suspect this has more to do with the nature of mathlib. I suspect that you rarely actually do apply those arguments explicitly and instead apply them through notation.</p>
</blockquote>
<p>I'm not so sure. Things like <code>lift R L M N P f</code> or very similar things are certainly not an uncommon thing in mathlib</p>



<a name="255347452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347452">(Sep 29 2021 at 06:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255347298">said</a>:</p>
<blockquote>
<p>In 50% of the applications, unification can figure out the types, so you just write an <code>_</code>. But for those other 50%, we're really happy that the argument has explicit binding.</p>
</blockquote>
<p>In that case, wouldn't those arguments work better as implicit arguments (that are some times specified by name)? Since Lean 3 lacked named arguments, maybe that is why such formulations were so popular?</p>



<a name="255347508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347508">(Sep 29 2021 at 06:13)</a>:</h4>
<p>I agree that this is now a new feature that is quite exciting. And we'll have to do experiments to find out what the right balance is in using it.</p>



<a name="255347538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347538">(Sep 29 2021 at 06:13)</a>:</h4>
<p><code>_</code> is really short, so it makes "a bit too much explicit variables" really cheap.</p>



<a name="255347598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347598">(Sep 29 2021 at 06:14)</a>:</h4>
<p>If something is implicit, and 50% of the time you have to write <code>(base_ring := R)</code>, this will quickly make me wish that <code>R</code> was explicit.</p>



<a name="255347645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347645">(Sep 29 2021 at 06:15)</a>:</h4>
<p>But certainly, named variables provide a new potential!</p>



<a name="255347781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347781">(Sep 29 2021 at 06:16)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Also, I think my rules are more geared towards CS than theorem proving. In theorem proving you are likely to have <strong>a lot</strong> of parameters, whereas in CS, you tend to have relatively few.</p>



<a name="255347823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347823">(Sep 29 2021 at 06:17)</a>:</h4>
<p>Sure, I guess we can different variations in style guide for different areas</p>



<a name="255347910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347910">(Sep 29 2021 at 06:18)</a>:</h4>
<p>For instance, there are many places <code>variable</code> is used for <code>def</code>s that have one or two parameters, and thus it makes it hard to distinguish them from <code>def</code>s with none (and the same would be true in end-user code).</p>



<a name="255347967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255347967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255347967">(Sep 29 2021 at 06:19)</a>:</h4>
<p>Just for the record: here is how you say "let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> be a manifold with corners" in mathlib-speak:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uι</span><span class="o">}</span>
<span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uE</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">E</span><span class="o">]</span>
<span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uH</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">H</span><span class="o">]</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="n">model_with_corners</span> <span class="n">ℝ</span> <span class="n">E</span> <span class="n">H</span><span class="o">}</span>
<span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uM</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">charted_space</span> <span class="n">H</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">smooth_manifold_with_corners</span> <span class="n">I</span> <span class="n">M</span><span class="o">]</span>
</code></pre></div>



<a name="255348085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255348085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255348085">(Sep 29 2021 at 06:20)</a>:</h4>
<p>This is why I feel such explicit binders are not really explicit binders in theorem proving. They are things that on a paper proof would be implicit, but are made explicit mostly due to the limitations / requirements of the formalization.</p>



<a name="255348150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255348150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255348150">(Sep 29 2021 at 06:21)</a>:</h4>
<p>Thus it makes much more since for them to be tossed in a <code>variable</code> header (as that is how it would appear in the paper proof).</p>



<a name="255348502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Segfault%20due%20to%20mutual%20recursion%3F/near/255348502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F.html#255348502">(Sep 29 2021 at 06:25)</a>:</h4>
<p>In CS, on the other hand, the explicit binders are what you are expecting to see in the compiled functions signature. Thus, I think it is reasonable to expect to see them in signature of the <code>def</code> being compiled. The implicit / synthetic binders, however, are abstract fluff that is (usually) compiled away and therefore not part of the signature. Thus, it makes sense to stick them in some <code>variable</code> header (as they have to do with the abstraction that section is dealing with).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
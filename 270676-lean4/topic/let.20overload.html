---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/let.20overload.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html">let overload</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246067128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246067128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246067128">(Jul 15 2021 at 08:45)</a>:</h4>
<p>There's something about this combination of let-shadowing and typeclass resolution that Lean seems to be rejecting, though it's very close (nightly 7-14). Some other testing confirms that this sort of shadowing works with almost any other combination of elements. If the element being returned by if/else doesn't reference p, this works fine. Is this a bridge too far? For clarity, the expectation is that <code>p := Point 1 0</code> in the if-then-else.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point</span> <span class="n">where</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span> <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p.x</span> <span class="bp">-</span> <span class="n">p.y</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">p.x</span> <span class="k">then</span> <span class="n">p</span> <span class="k">else</span> <span class="n">p</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">(kernel) declaration has metavariables 'Point.compute'</span>

<span class="cm">synthesized type class instance type is not definitionally equal to expected type, synthesized</span>
<span class="cm">  Nat.decLt p.x (p.x - p.y)</span>
<span class="cm">has type</span>
<span class="cm">  Decidable (p.x &lt; p.x - p.y)</span>
<span class="cm">expected</span>
<span class="cm">  let p : ?m.1960 p✝¹ := ?m.1988 p✝¹;</span>
<span class="cm">  let p : Point := ?m.1990 p✝¹ p;</span>
<span class="cm">  Decidable (p.x - p.y &gt; p.x)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="246067453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246067453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246067453">(Jul 15 2021 at 08:49)</a>:</h4>
<p>Maybe this variation is more interesting since it's even closer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span> <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p.x</span> <span class="bp">-</span> <span class="n">p.y</span><span class="o">)</span> <span class="bp">&lt;=</span> <span class="n">p.x</span> <span class="k">then</span> <span class="n">p</span> <span class="k">else</span> <span class="n">p</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">synthesized type class instance type is not definitionally equal to expected type, synthesized</span>
<span class="cm">  Nat.decLe (p.x - p.y) p.x</span>
<span class="cm">has type</span>
<span class="cm">  Decidable (p.x - p.y ≤ p.x)</span>
<span class="cm">expected</span>
<span class="cm">  let p : ?m.1955 p✝¹ := ?m.1983 p✝¹;</span>
<span class="cm">  let p : Point := ?m.1985 p✝¹ p;</span>
<span class="cm">  Decidable (p.x - p.y ≤ p.x)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="246086065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246086065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246086065">(Jul 15 2021 at 12:24)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span> <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p.x</span> <span class="bp">-</span> <span class="n">p.y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">p.x</span> <span class="k">then</span> <span class="n">p</span> <span class="k">else</span> <span class="n">p</span>
</code></pre></div>



<a name="246100929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246100929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246100929">(Jul 15 2021 at 14:21)</a>:</h4>
<p>Is all this fixed if you don't over-use p? It's hard to have sympathy with someone who uses p to mean three different things and then something with p in doesn't work</p>



<a name="246101288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246101288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246101288">(Jul 15 2021 at 14:23)</a>:</h4>
<p>The shadowing is a red herring, this fails as well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point</span> <span class="n">where</span>
  <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">q</span> <span class="k">with</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span> <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">r.x</span> <span class="bp">-</span> <span class="n">r.y</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">r.x</span> <span class="k">then</span> <span class="n">r</span> <span class="k">else</span> <span class="n">r</span>
</code></pre></div>



<a name="246101315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246101315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246101315">(Jul 15 2021 at 14:23)</a>:</h4>
<p>Oh ok!</p>



<a name="246110559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246110559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246110559">(Jul 15 2021 at 15:26)</a>:</h4>
<p>Those are both interesting examples, thanks. I guess anything that doesn't make the Point constructor explicit at least once  doesn't given enough information about the metavariables.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- fails</span>
<span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">q.x</span><span class="o">,</span> <span class="mi">0</span><span class="o">⟩</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">r.x</span> <span class="bp">-</span> <span class="n">r.y</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">r.x</span> <span class="k">then</span> <span class="n">r</span> <span class="k">else</span> <span class="n">r</span>

<span class="c1">-- succeeds</span>
<span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">Point.mk</span> <span class="n">q.x</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">r.x</span> <span class="bp">-</span> <span class="n">r.y</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">r.x</span> <span class="k">then</span> <span class="n">r</span> <span class="k">else</span> <span class="n">r</span>

<span class="c1">-- succeeds</span>
<span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">Point.mk</span> <span class="mi">1</span> <span class="n">p.y</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">q</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span> <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">r.x</span> <span class="bp">-</span> <span class="n">r.y</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">r.x</span> <span class="k">then</span> <span class="n">r</span> <span class="k">else</span> <span class="n">r</span>
</code></pre></div>



<a name="246151019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246151019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246151019">(Jul 15 2021 at 20:30)</a>:</h4>
<p>doesn't <code>{ p with x := 1 }</code> get the type <code>Point</code> because <code>p : Point</code>?</p>



<a name="246153004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153004">(Jul 15 2021 at 20:47)</a>:</h4>
<p>One would have thought. It's also interesting that the error text suggests that Lean wasn't able to figure out the metavariables, but hovering over each let binding says <code>q</code> and <code>r</code> are unambiguously of type <code>Point</code>.</p>



<a name="246153165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153165">(Jul 15 2021 at 20:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Interesting, looks like no:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point2D</span> <span class="n">where</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">Point3D</span> <span class="n">where</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Point2D</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Point3D</span> <span class="o">:=</span> <span class="o">{</span><span class="n">p</span> <span class="k">with</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">}</span>
</code></pre></div>



<a name="246153319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153319">(Jul 15 2021 at 20:50)</a>:</h4>
<p>Whoah how does that work</p>



<a name="246153336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153336">(Jul 15 2021 at 20:50)</a>:</h4>
<p>Same as in lean 3 I would guess</p>



<a name="246153391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153391">(Jul 15 2021 at 20:50)</a>:</h4>
<p>still, it should use the original type as a hint if it doesn't have more explicit typing like this</p>



<a name="246153467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153467">(Jul 15 2021 at 20:51)</a>:</h4>
<p>I'm on an old version of Lean 4, but this is what <code>#print q</code> shows for me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Point3D</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">src</span> <span class="o">:</span> <span class="n">Point2D</span> <span class="o">:=</span> <span class="n">p</span><span class="bp">;</span>
<span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">src.x</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">src.y</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">3</span> <span class="o">}</span>
</code></pre></div>



<a name="246153524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153524">(Jul 15 2021 at 20:52)</a>:</h4>
<p>it uses the names of the fields to line things up</p>



<a name="246153583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153583">(Jul 15 2021 at 20:52)</a>:</h4>
<p>in mathlib we do this a lot to transfer things between old structures</p>



<a name="246153616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153616">(Jul 15 2021 at 20:52)</a>:</h4>
<p>Does <code>with</code> subsume the <code>...</code> syntax?</p>



<a name="246153630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153630">(Jul 15 2021 at 20:52)</a>:</h4>
<p>no, it's the other way around</p>



<a name="246153662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153662">(Jul 15 2021 at 20:53)</a>:</h4>
<p><code>..s</code> can have multiple, <code>s with</code> can't</p>



<a name="246153702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153702">(Jul 15 2021 at 20:53)</a>:</h4>
<p>Oh, I meant "does <code>with</code> replace <code>..</code> in Lean 4" (even if it doesn't do exactly the same thing)</p>



<a name="246153705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153705">(Jul 15 2021 at 20:53)</a>:</h4>
<p>I'm not really sure why the devs didn't go for it but I'm going to have to write it myself in mathlib4 if not</p>



<a name="246153821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153821">(Jul 15 2021 at 20:54)</a>:</h4>
<p>Note that lean 3 structinst has both <code>s with</code> and <code>..s</code></p>



<a name="246153843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153843">(Jul 15 2021 at 20:54)</a>:</h4>
<p>but mathlib style uses only <code>..s</code></p>



<a name="246153874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153874">(Jul 15 2021 at 20:54)</a>:</h4>
<p>the <code>..s</code> was a late lean 3 addition</p>



<a name="246153878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153878">(Jul 15 2021 at 20:54)</a>:</h4>
<p>That's pretty neat, I didn't know you could do that transfer thing. What do you mean by '.. can have multiple'?</p>



<a name="246153972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246153972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246153972">(Jul 15 2021 at 20:55)</a>:</h4>
<p><code>def foo (a : A) (b : B) (c : C) : D := { a with d := 1, ..b, ..c }</code></p>



<a name="246154002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154002">(Jul 15 2021 at 20:55)</a>:</h4>
<p>Oh I see, thanks.</p>



<a name="246154057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154057">(Jul 15 2021 at 20:56)</a>:</h4>
<p>here <code>D</code> has fields <code>a,b,c,d</code> and <code>A,B,C</code> have one field each</p>



<a name="246154165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154165">(Jul 15 2021 at 20:57)</a>:</h4>
<p>In lean 3 the <code>..s</code> have to go at the end, although I'm not really sure why that syntactic restriction exists</p>



<a name="246154224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154224">(Jul 15 2021 at 20:57)</a>:</h4>
<p>I think it has something to do with the order in which fields are replaced</p>



<a name="246154330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154330">(Jul 15 2021 at 20:58)</a>:</h4>
<p>lean 4 finishes parsing before starting elaboration so I think that wouldn't be an issue</p>



<a name="246154483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154483">(Jul 15 2021 at 20:59)</a>:</h4>
<p>Personally, I think that <code>a with</code> should be restricted to non-type-changing struct update and leave that for the splay args</p>



<a name="246154619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246154619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246154619">(Jul 15 2021 at 21:00)</a>:</h4>
<p>the restriction to only one <code>with</code> argument makes more sense in that context</p>



<a name="246158731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246158731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246158731">(Jul 15 2021 at 21:26)</a>:</h4>
<p>There's other syntax available for specifying the type of a "structure instance":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point</span> <span class="n">where</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">Point.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">}</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="k">with</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">Point</span> <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p.x</span> <span class="bp">-</span> <span class="n">p.y</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="n">p.x</span> <span class="k">then</span> <span class="n">p</span> <span class="k">else</span> <span class="n">p</span>
</code></pre></div>
<p>Found this by reading through <a href="https://github.com/leanprover/lean4/blob/7dc3e72bcb079f552fdce5aa5657ace9857283e2/stage0/src/Lean/Elab/StructInst.lean">https://github.com/leanprover/lean4/blob/7dc3e72bcb079f552fdce5aa5657ace9857283e2/stage0/src/Lean/Elab/StructInst.lean</a></p>



<a name="246158915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246158915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246158915">(Jul 15 2021 at 21:28)</a>:</h4>
<p>I also found that you can put <code>..</code> in a structure instance:<code>{ p with y := 0 .. }</code> or <code>{ p with y := 0 .. : Point }</code>.  I wasn't able to figure out whether <code>..</code> did anything, though.</p>



<a name="246159469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246159469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246159469">(Jul 15 2021 at 21:33)</a>:</h4>
<p>Oh, <code>..</code> is supposed to indicate that the remaining fields of the struct are implicit -- the "invalid structure instance <code>with</code> and <code>..</code> cannot be used together" error message suggests these shouldn't be allowed.</p>



<a name="246161575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246161575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246161575">(Jul 15 2021 at 21:55)</a>:</h4>
<p>The <code>..</code> argument in structinst means the same in lean 4 as it does in lean 3 (yes, you can do <code>{ a := 1, .. }</code>)</p>



<a name="246161624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246161624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246161624">(Jul 15 2021 at 21:56)</a>:</h4>
<p>it puts <code>:= _</code> on all remaining unfilled fields</p>



<a name="246161643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246161643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246161643">(Jul 15 2021 at 21:56)</a>:</h4>
<p>which is usually an error, but is especially useful in tactic proofs with <code>refine</code></p>



<a name="246161912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246161912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246161912">(Jul 15 2021 at 21:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/let.20overload/near/246159469">said</a>:</p>
<blockquote>
<p>the "invalid structure instance <code>with</code> and <code>..</code> cannot be used together" error message suggests these shouldn't be allowed.</p>
</blockquote>
<p>This error message also makes me think that the devs are only considering the same-type use case for <code>s with</code>, because that error message doesn't make sense if you have <code>{ (s:Point2D) with .. : Point3D }</code></p>



<a name="246200770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246200770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246200770">(Jul 16 2021 at 09:13)</a>:</h4>
<p>Yes, the Lean 4 structure notation is simpler than the Lean 3 one, which frankly was too complicated to really make robust and maintainable (guess who wrote it <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span> ). And it does use the "source" type when the expected type is unavailable, which its simpler, non-nominal semantics allow it to do: <a href="https://github.com/leanprover/lean4/blob/7dc3e72bcb079f552fdce5aa5657ace9857283e2/stage0/src/Lean/Elab/StructInst.lean#L169-L170">https://github.com/leanprover/lean4/blob/7dc3e72bcb079f552fdce5aa5657ace9857283e2/stage0/src/Lean/Elab/StructInst.lean#L169-L170</a></p>



<a name="246200979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246200979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246200979">(Jul 16 2021 at 09:15)</a>:</h4>
<p>Do you know why it isn't working here then?</p>



<a name="246201114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246201114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246201114">(Jul 16 2021 at 09:17)</a>:</h4>
<p>I think it is also a better fit for the "new-style structures" (the only kind of structures in Lean 4): you <em>can</em> set entire subobjects with <code>{ z := ..., toPoint2D := ... }</code>. Having said that, if someone wrote an extended structure command to simulate diamond inheritance, it might also make sense to write an extended structure instance notation that allows multiple, overlapping sources like in Lean 3.</p>



<a name="246201209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246201209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246201209">(Jul 16 2021 at 09:18)</a>:</h4>
<p>I've opened an issue for this at <a href="https://github.com/dselsam/mathport/issues/9">dselsam/mathport#9</a> . That's going to be a requirement for the port</p>



<a name="246201249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246201249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246201249">(Jul 16 2021 at 09:19)</a>:</h4>
<p>That said, it's not clear to me to what extent it's possible to actually override all this structure stuff in userland</p>



<a name="246201422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246201422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246201422">(Jul 16 2021 at 09:21)</a>:</h4>
<p>I also opened a bunch of issues at <a href="https://github.com/dselsam/mathport/issues">https://github.com/dselsam/mathport/issues</a> to track features of lean 3 that have no obvious analogues in lean 4, which are starting to become more immediate issues as the porting tool matures. Some of this stuff can be implemented in userland (and I encourage anyone who wants to take a shot at them to do so in mathlib4)</p>



<a name="246201975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246201975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246201975">(Jul 16 2021 at 09:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/let.20overload/near/246200979">said</a>:</p>
<blockquote>
<p>Do you know why it isn't working here then?</p>
</blockquote>
<p>It's a more general elaboration order issue I believe. The structure notations are visited first, but are then postponed because the expected type is not available yet. This is correct even if the source type is available since, as <span class="user-mention" data-user-id="306601">@Kyle Miller</span> showed, the two do not have to be equal. So in order to be deterministic, we should always inspect the expected type first.<br>
This postponing creates synthetic metavariables, which typeclass inference later chokes on as shown in the error message. Now the actual issue, I believe, is that this error is considered fatal instead of postponing typeclass inference as well until those metavariables are solved. Thus elaboration fails.</p>



<a name="246202366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246202366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246202366">(Jul 16 2021 at 09:32)</a>:</h4>
<p>Do you have any opinion on removing the type changing / nominal typing behavior of <code>s with</code>? As you point out, lean 4's structures are trying to stick to compositional inheritance, which means that you should be able to use <code>{ toPoint2D := p, z := ... }</code> when extending a structure and reject Kyle's example (where <code>Point2D</code> is not a parent of <code>Point3D</code>)</p>



<a name="246202679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246202679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246202679">(Jul 16 2021 at 09:37)</a>:</h4>
<p>Mmh, I would be open to it at least. What would be the advantage, purely to simplify elaboration ordering?</p>



<a name="246202727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246202727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246202727">(Jul 16 2021 at 09:37)</a>:</h4>
<p>I don't like that it's currently half-assed nominal typing. It should either allow multiple <code>with</code> args or not do the splay thing</p>



<a name="246203013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246203013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246203013">(Jul 16 2021 at 09:40)</a>:</h4>
<p>I think, if you take that part out, structure inheritance shouldn't be anything more than composition, except for the fact that you can use <code>field := ...</code> instead of <code>toParent.field := ...</code> in structure instances (and even this seems a little borderline from a rust perspective)</p>



<a name="246203039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246203039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246203039">(Jul 16 2021 at 09:41)</a>:</h4>
<p>maybe I'm just arguing against <code>extends</code> altogether <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="246203216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246203216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246203216">(Jul 16 2021 at 09:43)</a>:</h4>
<p>well, I'm no stakeholder here since I fully intend to replace it with a full nominal typing <code>structure</code> extension in mathlib, so limitations of lean 4 core structures aren't likely to be an issue for me</p>



<a name="246246586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246246586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246246586">(Jul 16 2021 at 16:31)</a>:</h4>
<p>How complicated would it be to change structure instances so that there are splays? Sorry if this has been discussed before -- I'm just curious about the difficulties.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="s2">"{"</span> <span class="bp">&gt;&gt;</span> <span class="n">optional</span> <span class="o">(</span><span class="n">atomic</span> <span class="o">(</span><span class="n">termParser</span> <span class="bp">&gt;&gt;</span> <span class="s2">" with "</span><span class="o">))</span>
          <span class="bp">&gt;&gt;</span> <span class="n">manyIndent</span> <span class="o">(</span><span class="n">group</span> <span class="o">((</span><span class="n">structInstFieldAbbrev</span> <span class="bp">&lt;|&gt;</span> <span class="n">structInstField</span> <span class="bp">&lt;|&gt;</span> <span class="n">structInstSplay</span><span class="o">)</span> <span class="bp">&gt;&gt;</span> <span class="n">optional</span> <span class="s2">", "</span><span class="o">))</span>
          <span class="bp">&gt;&gt;</span> <span class="n">optEllipsis</span>
          <span class="bp">&gt;&gt;</span> <span class="n">optional</span> <span class="o">(</span><span class="s2">" : "</span> <span class="bp">&gt;&gt;</span> <span class="n">termParser</span><span class="o">)</span>
          <span class="bp">&gt;&gt;</span> <span class="s2">" }"</span>

<span class="kd">def</span> <span class="n">structInstSplay</span> <span class="o">:=</span> <span class="s2">".."</span> <span class="bp">&gt;&gt;</span> <span class="n">termParser</span>
</code></pre></div>
<p>Then <code>{s with foo}</code> could mean "update <code>s</code>, don't change the type" and <code>{..s}</code> could effectively be the nominally typed version.</p>
<p>Also <code>optEllipsis</code> could probably be rolled into <code>structInstSplay</code>, and an empty splay would mean "insert holes for the remaining fields".</p>



<a name="246246938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246246938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246246938">(Jul 16 2021 at 16:34)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib4/blob/1fd1cdc64b9a968e302ebd34af228b40cc05eb04/Mathlib/Tactic/Spread.lean">https://github.com/leanprover-community/mathlib4/blob/1fd1cdc64b9a968e302ebd34af228b40cc05eb04/Mathlib/Tactic/Spread.lean</a></p>



<a name="246246958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246246958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246246958">(Jul 16 2021 at 16:34)</a>:</h4>
<blockquote>
<p>This adds support for structure instance spread syntax.</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">__</span> <span class="o">:=</span> <span class="n">instSomething</span> <span class="c1">-- include fields from `instSomething`</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">__</span> <span class="o">:=</span> <span class="n">instSomething</span> <span class="c1">-- include fields from `instSomething`</span>
<span class="o">}</span>
</code></pre></div>



<a name="246254717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/let%20overload/near/246254717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/let.20overload.html#246254717">(Jul 16 2021 at 17:35)</a>:</h4>
<p>(deleted -- wrong thread)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
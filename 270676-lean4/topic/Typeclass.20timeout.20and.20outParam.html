---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html">Typeclass timeout and outParam</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265452460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265452460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265452460">(Dec 19 2021 at 00:43)</a>:</h4>
<p>I'm getting an odd timeout on typeclass resolution, it is a mix of addition on product type and usage of <code>outParam</code>. I don't really understand what is going on here, especially I do not understand what exactly <code>outParam</code> is doing but it is necessary here to allow the nice and simple notation <code>⟪x,y⟫</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">R</span>

<span class="kd">notation</span> <span class="s2">"⟪"</span> <span class="n">x</span> <span class="s2">", "</span> <span class="n">y</span> <span class="s2">"⟫"</span> <span class="bp">=&gt;</span> <span class="n">SemiInner.semiInner</span> <span class="n">x</span> <span class="n">y</span>

<span class="c1">-- This is here to demonstrate the need of `outParam` in the `R` parameter</span>
<span class="kd">class</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">X</span><span class="o">,</span> <span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_inner</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">semiInner</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span><span class="o">,</span><span class="n">y'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span><span class="n">x'</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span><span class="n">y'</span><span class="bp">⟫</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="n">q.1</span><span class="o">,</span> <span class="n">p.2</span> <span class="bp">+</span> <span class="n">q.2</span><span class="o">)⟩</span>

<span class="c1">-- This works</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">infer_instance</span>

<span class="c1">-- This does not ... why?</span>
<span class="kd">set_option</span> <span class="n">trace.Meta.synthInstance</span> <span class="n">true</span> <span class="k">in</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">AddSemigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span><span class="o">:=</span> <span class="kd">by</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>How can I change the setup such that the last class inference works but I can still use the notation <code>⟪x,y⟫</code> without specifying the type <code>R</code>?</p>



<a name="265453368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265453368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265453368">(Dec 19 2021 at 01:08)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> ypur code gives me an "unknown metavariable '?_uniq.1543'" error, which feels like a Lean bug to me.</p>



<a name="265453599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265453599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265453599">(Dec 19 2021 at 01:15)</a>:</h4>
<p>Which version of are you running? Mine is nightly-12-15.</p>



<a name="265453741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265453741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265453741">(Dec 19 2021 at 01:20)</a>:</h4>
<p>For me it gets stuck at an infinite loop, synthesizing instances of <code>Add (USize × ... × USize)</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="o">[</span><span class="n">Meta.synthInstance.resume</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="bp">?</span><span class="n">m.1642</span><span class="o">)</span> <span class="bp">&lt;==</span> <span class="n">Add</span> <span class="n">USize</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.resume</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">2</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span> <span class="bp">&lt;==</span> <span class="n">Add</span> <span class="n">USize</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.newAnswer</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">2</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.newAnswer</span><span class="o">]</span> <span class="n">val</span><span class="o">:</span> <span class="n">instAddProd</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.resume</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span> <span class="bp">&lt;==</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.newAnswer</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">4</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.newAnswer</span><span class="o">]</span> <span class="n">val</span><span class="o">:</span> <span class="n">instAddProd</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.resume</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span> <span class="bp">&lt;==</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.newAnswer</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span><span class="o">,</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.newAnswer</span><span class="o">]</span> <span class="n">val</span><span class="o">:</span> <span class="n">instAddProd</span>
    <span class="o">[</span><span class="n">Meta.synthInstance.resume</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">8</span><span class="o">,</span> <span class="n">Add</span>
      <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span> <span class="bp">&lt;==</span> <span class="n">Add</span> <span class="o">(</span><span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span> <span class="bp">×</span> <span class="n">USize</span><span class="o">)</span>
<span class="bp">...</span>
</code></pre></div>



<a name="265453952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265453952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265453952">(Dec 19 2021 at 01:27)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> I'm on <code>Lean (version 4.0.0-nightly-2021-12-17, commit e65f3fe81032, Release)</code>.</p>



<a name="265453956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265453956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265453956">(Dec 19 2021 at 01:27)</a>:</h4>
<p>Hmm, now I'm getting the unknown metavariable too. Not sure what changed but the trace still shows the infinite loop of synthesizing longer and longer versions of <code>Add (USize × ... × USize)</code></p>



<a name="265454018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265454018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265454018">(Dec 19 2021 at 01:29)</a>:</h4>
<p>I have tried nigtly 11-12, 12-15, 12-19 and all give the same error.</p>



<a name="265454135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265454135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265454135">(Dec 19 2021 at 01:32)</a>:</h4>
<p>You get the timeout error when you turn of the tracing.</p>



<a name="265460626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265460626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265460626">(Dec 19 2021 at 04:28)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> after looking at the trace,  I figured out the problem is that the <code>Add R</code> instance comes first, when it should come last in the the parameter list. That is, the following modified mwe works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">R</span>

<span class="kd">notation</span> <span class="s2">"⟪"</span> <span class="n">x</span> <span class="s2">", "</span> <span class="n">y</span> <span class="s2">"⟫"</span> <span class="bp">=&gt;</span> <span class="n">SemiInner.semiInner</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">class</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">X</span><span class="o">,</span> <span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_inner</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span>

<span class="c1">-- The `Add R` being at the end here is important</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span><span class="o">,</span><span class="n">y'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span><span class="n">x'</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span><span class="n">y'</span><span class="bp">⟫</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="n">q.1</span><span class="o">,</span> <span class="n">p.2</span> <span class="bp">+</span> <span class="n">q.2</span><span class="o">)⟩</span>

<span class="c1">-- This works</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>

<span class="c1">-- This works too now</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">AddSemigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>
</code></pre></div>
<p>The problem is that add instance synthesis is defaulting <code>R</code> to something other than the natural <code>outParam</code> result which is then causing problems in synthesis.</p>



<a name="265460788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265460788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265460788">(Dec 19 2021 at 04:33)</a>:</h4>
<p>Instance synthesis works in parameter order (e.g., from left to right). If the <code>outParam</code> class comes first, it fixes <code>R</code> for the coming <code>Add</code> synthesis (as desired). If <code>Add R</code> comes first instead, it may try to choose an <code>R</code> itself for future synthesis (which you do not want).</p>



<a name="265467820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265467820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265467820">(Dec 19 2021 at 08:04)</a>:</h4>
<p>Thanks a lot! I have encountered this problem before, where I had to reorder the typeclass parameters, but didn't realize that is the problem here again.<br>
Would be nice to detect a dangerous order automatically and give a warning.</p>



<a name="265476903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265476903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265476903">(Dec 19 2021 at 12:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> has marked this topic as unresolved.</p>



<a name="265477038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265477038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265477038">(Dec 19 2021 at 12:06)</a>:</h4>
<p>I'm having more issues, I also want to define product on <code>SemiHilbert</code> there you cannot move <code>Add R</code> after <code>SemiHilbert</code> arguments. I'm getting timeout error again:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">R</span>

<span class="kd">notation</span> <span class="s2">"⟪"</span> <span class="n">x</span> <span class="s2">", "</span> <span class="n">y</span> <span class="s2">"⟫"</span> <span class="bp">=&gt;</span> <span class="n">SemiInner.semiInner</span> <span class="n">x</span> <span class="n">y</span>

<span class="c1">-- The `Add R` being at the end here is important</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span><span class="o">,</span><span class="n">y'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span><span class="n">x'</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span><span class="n">y'</span><span class="bp">⟫</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="n">q.1</span><span class="o">,</span> <span class="n">p.2</span> <span class="bp">+</span> <span class="n">q.2</span><span class="o">)⟩</span>

<span class="kd">class</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">outParam</span> <span class="bp">$</span> <span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">X</span><span class="o">,</span> <span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_inner</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add_inner</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="o">}</span>

<span class="c1">-- Here I'm getting timeout again</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">AddSemigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>
</code></pre></div>
<p>It does not happen when <code>R</code> is not marked as <code>outParam</code> in the definition of <code>SemiHilbert</code>, but I want it there as I often want <code>R</code> to be automatically inferred.</p>



<a name="265478328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265478328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265478328">(Dec 19 2021 at 12:41)</a>:</h4>
<p>The reason why I need the <code>outParam</code> under the <code>R</code> parameter in <code>SemiHilbert</code> is that I then want to define class Prop <code>HasAdjoint</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HasAdjoint</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">hasAdjoint</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">f'</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="bp">⟫</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">HasAdjoint</span> <span class="n">f</span><span class="o">]</span>

<span class="k">#check</span> <span class="n">f</span>
</code></pre></div>
<p>and without the <code>outParam</code> the  <code>[HasAdjoint f]</code> can't figure out what <code>R</code> is.</p>



<a name="265491079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265491079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265491079">(Dec 19 2021 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> here is a working example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">R</span>

<span class="kd">notation</span> <span class="s2">"⟪"</span> <span class="n">x</span> <span class="s2">", "</span> <span class="n">y</span> <span class="s2">"⟫"</span> <span class="bp">=&gt;</span> <span class="n">SemiInner.semiInner</span> <span class="n">x</span> <span class="n">y</span>

<span class="c1">-- The `Add R` being at the end here is important</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span><span class="o">,</span><span class="n">y'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span><span class="n">x'</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span><span class="n">y'</span><span class="bp">⟫</span>

<span class="c1">-- We set this to priority low so every other `Add` instance is tried first</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">low</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="n">q.1</span><span class="o">,</span> <span class="n">p.2</span> <span class="bp">+</span> <span class="n">q.2</span><span class="o">)⟩</span>

<span class="kd">class</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">outParam</span> <span class="bp">$</span> <span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">X</span><span class="o">,</span> <span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_inner</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span>

<span class="c1">-- Same here</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">low</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_inner</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- This comes after `SemiHilbert` because we want to try the `AddSemogroup.toAdd` instance before the `SemiHilbert.toAdd` one</span>
<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="c1">-- This now works</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">AddSemigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>

<span class="kd">class</span> <span class="n">HasAdjoint</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">hasAdjoint</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">f'</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="bp">⟫</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">HasAdjoint</span> <span class="n">f</span><span class="o">]</span>

<span class="k">#check</span> <span class="n">f</span>
</code></pre></div>



<a name="265491514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265491514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265491514">(Dec 19 2021 at 17:51)</a>:</h4>
<p>However, the man problem here that I find suspicious is that Lean's typeclass synthesis doesn't try to synthesize <code>SemiHilbert (X × Y) R</code>(i.e., the desired instance) first, but instead immediately tries <code>SemiHilbert (X × Y) ?m.1657</code>(i.e., with an metavariable output -- a produce of the <code>outParam</code>) which is a major cause of all this trouble.</p>
<p>I feel like it should try to synthesize <code>SemiHilbert (X × Y) R</code> first and only when that fails try <code>SemiHilbert (X × Y) ?m.1657</code>, but that may just be an uniformed opinion.</p>



<a name="265493622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265493622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265493622">(Dec 19 2021 at 18:40)</a>:</h4>
<p><code>[outParam $ Add R]</code> seems to express two contradictory intents: one that the argument should be synthesized by TC instance search, the other that it should be determined by the <code>SemiHilbert</code> instance.</p>



<a name="265493657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265493657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265493657">(Dec 19 2021 at 18:41)</a>:</h4>
<p>I wonder whether this interaction of features has been properly thought through (certainly it hasn't been by me).</p>



<a name="265493709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265493709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265493709">(Dec 19 2021 at 18:42)</a>:</h4>
<p>I would be inclined to try <code>{}</code> binders for the <code>Add R</code> in the <code>SemiHilbert</code> class and instances.</p>



<a name="265495239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265495239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265495239">(Dec 19 2021 at 19:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> but <code>[outParam $ Add R]</code> wasn't the problem here?</p>



<a name="265495270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265495270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265495270">(Dec 19 2021 at 19:15)</a>:</h4>
<p>I think it is the core issue though--you don't want to try synthesizing <code>Add R</code> ever</p>



<a name="265495343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265495343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265495343">(Dec 19 2021 at 19:16)</a>:</h4>
<p>Instead, you want to learn it from the <code>SemiHilbert</code> instance</p>



<a name="265496116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265496116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265496116">(Dec 19 2021 at 19:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  true, an alternative way to structure this would be something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_X</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span>
  <span class="n">add_R</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span>
  <span class="n">add_inner</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">add_X</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="n">add_R</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">SemiHilbert.add_X</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">SemiHilbert.add_R</span> <span class="o">(</span><span class="n">X</span> <span class="o">:=</span> <span class="n">X</span><span class="o">)⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">low</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">add_X</span> <span class="o">:=</span> <span class="n">Add.add</span>
  <span class="n">add_R</span> <span class="o">:=</span> <span class="n">Add.add</span>
  <span class="n">add_inner</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">AddSemigroup</span> <span class="n">R</span><span class="o">]</span>  <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>
</code></pre></div>



<a name="265496700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265496700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265496700">(Dec 19 2021 at 19:45)</a>:</h4>
<p>This looks awkward though because in the actual instances, you probably want to use existing <code>Add</code> instances for <code>real</code> etc.</p>



<a name="265496746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265496746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265496746">(Dec 19 2021 at 19:46)</a>:</h4>
<p>And</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">R</span>
</code></pre></div>
<p>looks very dubious as there is no way to determine <code>X</code></p>



<a name="265499031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265499031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265499031">(Dec 19 2021 at 20:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> very true, there is not really a silver bullet here, because Lean does not, afaik, provide a neat way to force <code>Add R</code> use the instance and <code>R</code> that come from <code>SemiHilbert</code>. <code>[outParam $ Add R]</code> is closest approximation, but it has the problems you mentioned.</p>



<a name="265502136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265502136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265502136">(Dec 19 2021 at 21:55)</a>:</h4>
<p>Here is my solution using utility classes <code>Trait X</code> and <code>Trait₂ X Y</code> that fetch <code>R</code> based on <code>X</code> or <code>X Y</code> and there is an instance of <code>Trait</code> whenever there is an instance of <code>SemiInner</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">R</span>

<span class="kd">notation</span> <span class="s2">"⟪"</span> <span class="n">x</span> <span class="s2">", "</span> <span class="n">y</span> <span class="s2">"⟫"</span> <span class="bp">=&gt;</span> <span class="n">SemiInner.semiInner</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">class</span> <span class="n">Trait</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="kd">class</span> <span class="n">Trait₂</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span> <span class="n">Trait.R</span> <span class="n">Trait₂.R</span>

<span class="kd">@[reducible]</span> <span class="kd">instance</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">Trait</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">R</span><span class="o">⟩</span>
<span class="kd">@[reducible]</span> <span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">Trait</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">Trait₂</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Trait.R</span> <span class="n">X</span><span class="o">⟩</span>
<span class="kd">@[reducible]</span> <span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">Trait</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">Trait₂</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Trait.R</span> <span class="n">Y</span><span class="o">⟩</span>

<span class="c1">-- The `Add R` being at the end here is important</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiInner</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiInner</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="n">where</span>
  <span class="n">semiInner</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span><span class="o">,</span><span class="n">y'</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span><span class="n">x'</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span><span class="n">y'</span><span class="bp">⟫</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">add_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="n">q.1</span><span class="o">,</span> <span class="n">p.2</span> <span class="bp">+</span> <span class="n">q.2</span><span class="o">)⟩</span>

<span class="kd">class</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">outParam</span> <span class="bp">$</span> <span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">SemiInner</span> <span class="n">X</span> <span class="n">R</span><span class="o">,</span> <span class="n">Add</span> <span class="n">X</span> <span class="n">where</span>
  <span class="n">add_inner</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="bp">⟫</span>

<span class="c1">-- The important bit here is that `R` is fetched with the utility class Trait and not spelled out explicitely</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">Trait₂</span> <span class="n">X</span> <span class="n">Y</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="o">(</span><span class="n">Trait₂.R</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="o">(</span><span class="n">Trait₂.R</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="o">(</span><span class="n">Trait₂.R</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)]</span>
  <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">Trait₂.R</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add_inner</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">AddSemigroup</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">inferInstance</span>

<span class="kd">class</span> <span class="n">HasAdjoint</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">hasAdjoint</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">f'</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="bp">⟫</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">shy</span> <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">HasAdjoint</span> <span class="n">f</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">Trait₂.R</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">⟪</span><span class="n">x</span><span class="o">,</span> <span class="n">x'</span><span class="bp">⟫</span> <span class="bp">+</span> <span class="n">r</span>  <span class="c1">-- This works because `Trait₂.R` is reducible</span>
</code></pre></div>



<a name="265502218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265502218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265502218">(Dec 19 2021 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam/near/265491079">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> here is a working example:</p>
</blockquote>
<p>Nice! I was fiddling with priorities quite a bit and was unable to get it working.</p>



<a name="265507610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265507610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265507610">(Dec 19 2021 at 23:56)</a>:</h4>
<p>Arghhh, the approach with <code>Trait</code> is also problematic. The <code>SemiHilbert</code> instance on product type causes a timeout error on</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>As it does not fail properly it completely messes up other type class inferences.</p>



<a name="265509202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass%20timeout%20and%20outParam/near/265509202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Typeclass.20timeout.20and.20outParam.html#265509202">(Dec 20 2021 at 00:26)</a>:</h4>
<p>Adding <code>[Trait₂ X Y]</code> at the beginning of the instance of <code>SemiHilbert (X × Y) R</code> seems to solve the above problem. The value <code>[Trait₂ X Y]</code> is not used at all, but is there just to safe guard a misuse of  instance.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">Trait₂</span> <span class="n">X</span> <span class="n">Y</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">X</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">SemiHilbert</span> <span class="n">Y</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">:</span> <span class="n">SemiHilbert</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span><span class="o">)</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">add_inner</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="o">}</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Commenting.20tactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html">Commenting tactic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="292168114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292168114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292168114">(Aug 05 2022 at 15:19)</a>:</h4>
<p>I'm still doing meta-programming exercises with a view towards teaching. It would be nice to have tactics that react to the tactic state using some prerecorded reactions (stored in an environment extension say).  The teacher would write somewhere</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">RegisterMessage</span> <span class="n">exercise1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="s2">"Congratulations on introducing variables"</span>
</code></pre></div>
<p>and in the student would write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exercise1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">comment</span> <span class="c1">-- Nothing happens</span>
  <span class="n">intros</span> <span class="n">k</span> <span class="n">l</span>
  <span class="n">comment</span> <span class="c1">-- triggers `logInfo "Congratulations on introducing variables"`</span>
</code></pre></div>
<p>Ideally the <code>comment</code> tactic would be invoked automatically after each tactic invocation.  I know how to register a simple environment extension, and I can parse the syntax of my RegisterMessage command. But then I'm stuck when I try to create a metavariable context that I could compare to the main goal in the <code>comment</code> tactic. Note that this comparison is also a non-trivial question since I don't want the order of declarations or the user facing names of free variables to be considered relevant. But this comparison question comes after understanding how to create a metavariable with a context outside of a proving context (I know this sentence isn't clear but I'm indeed confused about what needs to be done).  I tried to read the definition of the <code>def</code> command but there are too many layers and too much generality and I got lost.</p>



<a name="292168383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292168383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292168383">(Aug 05 2022 at 15:21)</a>:</h4>
<p>so basically you want to have a map from current tactic state =&gt; String (per theorem) and use the comment tactic to access that map and print a message about the current state if there is one registered yes?</p>



<a name="292168651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292168651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292168651">(Aug 05 2022 at 15:22)</a>:</h4>
<p>Using strings would be easy but you would miss lots of cases. Notice that in my example I carefully chose stupid variable names in my <code>intro</code> line so that matching strings wouldn't work (the <code>RegisterMessage</code> command uses <code>n</code> and <code>m</code> but I introduce <code>k</code> and <code>l</code>).</p>



<a name="292168802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292168802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292168802">(Aug 05 2022 at 15:23)</a>:</h4>
<p>No no I mean a map from the tactic state to strings (i.e. your messages) so that you can give it your current tactic state, it will try to look it up in said map and if it finds an entry print the string that is associated with the state.</p>



<a name="292169057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292169057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292169057">(Aug 05 2022 at 15:25)</a>:</h4>
<p>Yes, except that, AFAIK there is no data structure called "tactic state". I'm stuck one creating such a synthetic tactic state in my <code>RegisterMessage</code> command.</p>



<a name="292169457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292169457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292169457">(Aug 05 2022 at 15:28)</a>:</h4>
<p>Yes I'm talking about a logical concept such as a tactic state, although one could argue that a meta variable + its context essentially <em>is</em> the tactic state sind it consists of the free variables + the type of the meta variable.</p>
<p>Either way I do not know how to do this from the top of my head but iirc there were efforts to produce a tactic testing framework back in the ICERM22 after party right? They must have implemented a function that can compare tactic states already (since the test framework tests the tactic state before and after a tactic was run) so I would suggest you could try to look into how it was done there maybe.</p>



<a name="292169558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292169558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292169558">(Aug 05 2022 at 15:29)</a>:</h4>
<p>Maybe I don't need to create such a synthetic tactic state, simply store the Syntax elements given to the registering command and then compare the actual tactic state to this data.</p>



<a name="292169727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292169727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292169727">(Aug 05 2022 at 15:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Commenting.20tactic/near/292169457">said</a>:</p>
<blockquote>
<p>Yes I'm talking about a logical concept such as a tactic state, although one could argue that a meta variable + its context essentially <em>is</em> the tactic state sind it consists of the free variables + the type of the meta variable.</p>
</blockquote>
<p>Do you know how to create such a pair "meta variable + its context" out of nowhere?</p>



<a name="292170720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292170720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292170720">(Aug 05 2022 at 15:39)</a>:</h4>
<p>I'm not sure you'll want to carry around a metavar context between commands. After elaborating the <code>RegisterMessage</code> arguments, you can pack them into an <code>Expr</code> as in <code>∀ (n : Nat) (m : Nat), n + m = m + n</code> alongside the information that the first two binders are the context.</p>



<a name="292171135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292171135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292171135">(Aug 05 2022 at 15:42)</a>:</h4>
<p>Oh that's clever. I thought about reverting all variables but I didn't want to loose the information about what was introduced.</p>



<a name="292171183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292171183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292171183">(Aug 05 2022 at 15:42)</a>:</h4>
<p>Lean does something like that in a lot of places internally :)</p>



<a name="292171534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292171534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292171534">(Aug 05 2022 at 15:45)</a>:</h4>
<p>Are there any API functions supporting this?</p>



<a name="292174097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292174097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292174097">(Aug 05 2022 at 16:04)</a>:</h4>
<p>You'll want <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mkForallFVars#doc">docs4#mkForallFVars</a> and <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=forallBoundedTelescope#doc">docs4#forallBoundedTelescope</a> in the other direction</p>



<a name="292313991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292313991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292313991">(Aug 07 2022 at 11:14)</a>:</h4>
<p>I returned to this idea but, unsurprisingly, I'm having issues. Reproducing is a bit painful because you need to create the environment extension in a different file. In order to reproduce that issue I don't know an easier solution than creating a lake project. You can do <code>mkdir messages &amp;&amp; cd messages &amp;&amp; echo "leanprover/lean4:nightly-2022-08-06" &gt; lean-toolchain &amp;&amp; lake init messages &amp;&amp; mkdir Messages</code>and create a file <code>messages/Messages/EnvExtensions.lean</code> containing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kn">open</span> <span class="n">Lean</span>

<span class="sd">/-- A goal message is a string indexed by a level name, an expression and a number of necessary intros. -/</span>
<span class="kd">def</span> <span class="n">GoalMessageEntry</span> <span class="o">:=</span> <span class="n">Name</span> <span class="bp">×</span> <span class="n">Expr</span> <span class="bp">×</span> <span class="n">Nat</span> <span class="bp">×</span> <span class="n">String</span>

<span class="sd">/-- Environment extension supporting goal driven messages. -/</span>
<span class="n">initialize</span> <span class="n">goalMessageExt</span> <span class="o">:</span> <span class="n">SimplePersistentEnvExtension</span> <span class="n">GoalMessageEntry</span> <span class="o">(</span><span class="n">Array</span> <span class="n">GoalMessageEntry</span><span class="o">)</span> <span class="bp">←</span>
  <span class="n">registerSimplePersistentEnvExtension</span> <span class="o">{</span>
    <span class="n">name</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">goal_message</span>
    <span class="n">addEntryFn</span> <span class="o">:=</span> <span class="n">Array.push</span>
    <span class="n">addImportedFn</span> <span class="o">:=</span> <span class="n">Array.concatMap</span> <span class="n">id</span>
  <span class="o">}</span>
</code></pre></div>
<p>and a file <code>messages/Messages/Issue.lean</code> containing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kn">import</span> <span class="n">Messages.EnvExtensions</span>

<span class="kd">set_option</span> <span class="n">autoImplicit</span> <span class="n">false</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Meta</span> <span class="n">Elab</span> <span class="n">Command</span> <span class="n">Term</span>

<span class="n">declare_syntax_cat</span> <span class="n">mydecl</span>
<span class="n">syntax</span> <span class="s2">"("</span> <span class="n">ident</span> <span class="s2">":"</span> <span class="n">term</span> <span class="s2">")"</span> <span class="o">:</span> <span class="n">mydecl</span>

<span class="kd">def</span> <span class="n">getIdent</span> <span class="o">:</span> <span class="n">TSyntax</span> <span class="bp">`</span><span class="n">mydecl</span> <span class="bp">→</span> <span class="n">Ident</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">mydecl</span><span class="bp">|</span> <span class="o">(</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span> <span class="o">:</span> <span class="bp">$</span><span class="n">_t</span><span class="o">:</span><span class="n">term</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">default</span>

<span class="kd">def</span> <span class="n">getType</span> <span class="o">:</span> <span class="n">TSyntax</span> <span class="bp">`</span><span class="n">mydecl</span> <span class="bp">→</span> <span class="n">Term</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">mydecl</span><span class="bp">|</span> <span class="o">(</span><span class="bp">$</span><span class="n">_n</span><span class="o">:</span><span class="n">ident</span> <span class="o">:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">default</span>

<span class="kd">def</span> <span class="n">mkGoalSyntax</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Term</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Ident</span> <span class="bp">×</span> <span class="n">Term</span><span class="o">)</span> <span class="bp">→</span> <span class="n">MacroM</span> <span class="n">Term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">t</span><span class="o">)::</span><span class="n">tail</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="n">return</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="bp">∀</span> <span class="bp">$</span><span class="n">n</span> <span class="o">:</span> <span class="bp">$</span><span class="n">t</span><span class="o">,</span> <span class="bp">$</span><span class="o">(</span><span class="bp">←</span> <span class="n">mkGoalSyntax</span> <span class="n">s</span> <span class="n">tail</span><span class="o">)))</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">return</span> <span class="n">s</span>


<span class="kd">def</span> <span class="n">mkGoalExpr</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Name</span> <span class="bp">×</span> <span class="n">Expr</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">t</span><span class="o">)::</span><span class="n">tail</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">forallE</span> <span class="n">n</span> <span class="n">t</span> <span class="o">(</span><span class="n">mkGoalExpr</span> <span class="n">e</span> <span class="n">tail</span><span class="o">)</span> <span class="n">BinderInfo.default</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">e</span>


<span class="n">elab</span> <span class="s2">"Message"</span> <span class="n">decls</span><span class="o">:</span><span class="n">mydecl</span><span class="bp">*</span> <span class="s2">":"</span> <span class="n">goal</span><span class="o">:</span><span class="n">term</span> <span class="s2">"=&gt;"</span> <span class="n">msg</span><span class="o">:</span><span class="n">str</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">g</span> <span class="bp">←</span> <span class="n">liftMacroM</span> <span class="bp">$</span> <span class="n">mkGoalSyntax</span> <span class="n">goal</span> <span class="o">(</span><span class="n">decls.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">decl</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">getIdent</span> <span class="n">decl</span><span class="o">,</span> <span class="n">getType</span> <span class="n">decl</span><span class="o">)))</span><span class="bp">.</span><span class="n">toList</span>
  <span class="k">let</span> <span class="n">g</span> <span class="bp">←</span> <span class="n">liftTermElabM</span> <span class="n">none</span> <span class="bp">$</span> <span class="n">elabTerm</span> <span class="n">g</span> <span class="n">none</span>
  <span class="n">modifyEnv</span> <span class="o">(</span><span class="n">goalMessageExt.addEntry</span> <span class="bp">·</span> <span class="o">((</span><span class="bp">←</span> <span class="n">getCurrNamespace</span><span class="o">),</span> <span class="n">g</span><span class="o">,</span> <span class="n">decls.size</span><span class="o">,</span> <span class="n">msg.getString</span><span class="o">))</span>


<span class="n">Message</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="s2">"Well done!"</span>


<span class="kn">open</span>  <span class="n">Tactic</span>

<span class="sd">/-- Get the list of free variables occuring in the expression (with repetitions). -/</span>
<span class="kd">def</span> <span class="n">Lean.Expr.getFVars</span> <span class="o">:</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">FVarId</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">app</span> <span class="n">fn</span> <span class="n">arg</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">getFVars</span> <span class="n">fn</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">getFVars</span> <span class="n">arg</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">fvar</span> <span class="n">Id</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">Id</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">lam</span> <span class="n">_</span> <span class="n">bt</span> <span class="n">body</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">getFVars</span> <span class="n">bt</span> <span class="bp">++</span> <span class="n">getFVars</span> <span class="n">body</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">forallE</span> <span class="n">_</span> <span class="n">bt</span> <span class="n">body</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">getFVars</span> <span class="n">bt</span> <span class="bp">++</span> <span class="n">getFVars</span> <span class="n">body</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">letE</span> <span class="n">_</span> <span class="n">t</span> <span class="n">v</span> <span class="n">b</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">getFVars</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">getFVars</span> <span class="n">v</span> <span class="bp">++</span> <span class="n">getFVars</span> <span class="n">b</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">mdata</span> <span class="n">_</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">getFVars</span> <span class="n">e</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">proj</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">getFVars</span> <span class="n">e</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">[]</span>


<span class="sd">/-- Returns the type of the goal after reverting all free variables in the order</span>
<span class="sd">where they appear in the goal type. -/</span>
<span class="kd">def</span> <span class="n">normalizedRevertExpr</span> <span class="o">(</span><span class="n">goal</span> <span class="o">:</span> <span class="n">MVarId</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="n">Expr</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">new</span><span class="o">)</span> <span class="bp">←</span> <span class="n">goal.revert</span> <span class="o">(</span><span class="bp">←</span> <span class="n">goal.getType</span><span class="o">)</span><span class="bp">.</span><span class="n">getFVars.toArray</span> <span class="n">true</span>
  <span class="n">return</span> <span class="o">(</span><span class="bp">←</span> <span class="n">new.getType</span><span class="o">)</span>

<span class="n">elab</span> <span class="s2">"comment"</span> <span class="o">:</span> <span class="n">tactic</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">tgt</span> <span class="bp">←</span> <span class="n">getMainGoal</span>
  <span class="k">let</span> <span class="n">tgt_ctx_size</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">←</span> <span class="n">tgt.getDecl</span><span class="o">)</span><span class="bp">.</span><span class="n">lctx.size</span>
  <span class="k">let</span> <span class="n">normalized_tgt</span> <span class="bp">←</span> <span class="n">normalizedRevertExpr</span> <span class="n">tgt</span>
  <span class="n">for</span> <span class="o">(</span><span class="n">_name</span><span class="o">,</span> <span class="n">msg_goal</span><span class="o">,</span> <span class="n">nb</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">in</span> <span class="n">goalMessageExt.getEntries</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">msg_mvar</span> <span class="bp">←</span> <span class="n">mkFreshExprMVar</span> <span class="n">msg_goal</span> <span class="n">MetavarKind.syntheticOpaque</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">msg_mvar</span><span class="o">)</span> <span class="bp">←</span> <span class="n">msg_mvar.mvarId</span><span class="bp">!.</span><span class="n">introNP</span> <span class="n">nb</span>
    <span class="k">let</span> <span class="n">msg_ctx_size</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">←</span> <span class="n">msg_mvar.getDecl</span><span class="o">)</span><span class="bp">.</span><span class="n">lctx.size</span>
    <span class="k">if</span> <span class="n">tgt_ctx_size</span> <span class="bp">≠</span> <span class="n">msg_ctx_size</span> <span class="k">then</span> <span class="n">continue</span>
    <span class="k">let</span> <span class="n">normalized_msg</span> <span class="bp">←</span> <span class="n">normalizedRevertExpr</span> <span class="n">msg_mvar</span>
    <span class="k">if</span> <span class="o">(</span><span class="bp">←</span> <span class="n">isDefEq</span> <span class="n">normalized_tgt</span> <span class="n">normalized_msg</span><span class="o">)</span> <span class="k">then</span> <span class="n">logInfo</span> <span class="n">d</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">comment</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span>
  <span class="n">revert</span> <span class="n">n</span>
  <span class="n">revert</span> <span class="n">m</span>
  <span class="n">intros</span> <span class="n">m</span> <span class="n">n</span>
  <span class="n">comment</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_comm</span><span class="o">]</span>
</code></pre></div>



<a name="292314138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292314138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292314138">(Aug 07 2022 at 11:18)</a>:</h4>
<p>Recall the goal is to be able to recognize a tactic state even if the free variables are permuted in the context. In the example above, the goal is to recognize the context <code>n m : Nat ⊢ n + m = m + n</code> even if it appears as <code>m n : Nat ⊢ n + m = m + n</code> (note the free variables order). The comparison should also discard free variable names differences, so <code>k l : Nat ⊢ k + l = l + k</code> should match as well. My idea to compare to such contexts is to list all free variables in the target expression, here <code>n + m = m + n</code> and revert all those variables <em>in the order they appear</em> then I test whether the resulting goals are defeq. In the above code I first do a cheap check comparing the context sizes to fail the comparison early in case they don't match.</p>



<a name="292314154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292314154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292314154">(Aug 07 2022 at 11:19)</a>:</h4>
<p>It sort of works except that all those manipulation actually alter the goal and the above example has an error on the last line saying there is no remaining goal to solve.</p>



<a name="292314233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292314233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292314233">(Aug 07 2022 at 11:21)</a>:</h4>
<p>Note that I'm interested in both a fix to my code and a completely different much better way to achieve my goal.</p>



<a name="292314389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292314389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292314389">(Aug 07 2022 at 11:24)</a>:</h4>
<p>the easy fix to the fact that your manipulations alter the goal is to roll back the state once you're done</p>



<a name="292314432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292314432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292314432">(Aug 07 2022 at 11:25)</a>:</h4>
<p>wrap the whole thing in <code>withoutModifyingState</code></p>



<a name="292315584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292315584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292315584">(Aug 07 2022 at 11:53)</a>:</h4>
<p>Do you mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">elab</span> <span class="s2">"comment"</span> <span class="o">:</span> <span class="n">tactic</span> <span class="bp">=&gt;</span> <span class="k">do</span>
<span class="n">withoutModifyingState</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">tgt</span> <span class="bp">←</span> <span class="n">getMainGoal</span>
  <span class="k">let</span> <span class="n">tgt_ctx_size</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">←</span> <span class="n">tgt.getDecl</span><span class="o">)</span><span class="bp">.</span><span class="n">lctx.size</span>
  <span class="k">let</span> <span class="n">normalized_tgt</span> <span class="bp">←</span> <span class="n">normalizedRevertExpr</span> <span class="n">tgt</span>
  <span class="n">for</span> <span class="o">(</span><span class="n">_name</span><span class="o">,</span> <span class="n">msg_goal</span><span class="o">,</span> <span class="n">nb</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">in</span> <span class="n">goalMessageExt.getEntries</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">msg_mvar</span> <span class="bp">←</span> <span class="n">mkFreshExprMVar</span> <span class="n">msg_goal</span> <span class="n">MetavarKind.syntheticOpaque</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">msg_mvar</span><span class="o">)</span> <span class="bp">←</span> <span class="n">msg_mvar.mvarId</span><span class="bp">!.</span><span class="n">introNP</span> <span class="n">nb</span>
    <span class="k">let</span> <span class="n">msg_ctx_size</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">←</span> <span class="n">msg_mvar.getDecl</span><span class="o">)</span><span class="bp">.</span><span class="n">lctx.size</span>
    <span class="k">if</span> <span class="n">tgt_ctx_size</span> <span class="bp">≠</span> <span class="n">msg_ctx_size</span> <span class="k">then</span> <span class="n">continue</span>
    <span class="k">let</span> <span class="n">normalized_msg</span> <span class="bp">←</span> <span class="n">normalizedRevertExpr</span> <span class="n">msg_mvar</span>
    <span class="k">if</span> <span class="o">(</span><span class="bp">←</span> <span class="n">isDefEq</span> <span class="n">normalized_tgt</span> <span class="n">normalized_msg</span><span class="o">)</span> <span class="k">then</span> <span class="n">logInfo</span> <span class="n">d</span>
</code></pre></div>
<p>This indeed suppresses the error message but it also suppresses the success message <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="292315732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292315732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292315732">(Aug 07 2022 at 11:57)</a>:</h4>
<p>You can have the body return the list of messages you want to report, and then do them outside the <code>withoutModifyingState</code>. Alternatively, you could try using <code>saveState</code> and <code>restore</code> directly</p>



<a name="292316248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292316248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292316248">(Aug 07 2022 at 12:06)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">elab</span> <span class="s2">"comment"</span> <span class="o">:</span> <span class="n">tactic</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">saveState</span>
  <span class="k">let</span> <span class="n">tgt</span> <span class="bp">←</span> <span class="n">getMainGoal</span>
  <span class="k">let</span> <span class="n">tgt_ctx_size</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">←</span> <span class="n">tgt.getDecl</span><span class="o">)</span><span class="bp">.</span><span class="n">lctx.size</span>
  <span class="k">let</span> <span class="n">normalized_tgt</span> <span class="bp">←</span> <span class="n">normalizedRevertExpr</span> <span class="n">tgt</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">messages</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="n">for</span> <span class="o">(</span><span class="n">_name</span><span class="o">,</span> <span class="n">msg_goal</span><span class="o">,</span> <span class="n">nb</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">in</span> <span class="n">goalMessageExt.getEntries</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">msg_mvar</span> <span class="bp">←</span> <span class="n">mkFreshExprMVar</span> <span class="n">msg_goal</span> <span class="n">MetavarKind.syntheticOpaque</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">msg_mvar</span><span class="o">)</span> <span class="bp">←</span> <span class="n">msg_mvar.mvarId</span><span class="bp">!.</span><span class="n">introNP</span> <span class="n">nb</span>
    <span class="k">let</span> <span class="n">msg_ctx_size</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">←</span> <span class="n">msg_mvar.getDecl</span><span class="o">)</span><span class="bp">.</span><span class="n">lctx.size</span>
    <span class="k">if</span> <span class="n">tgt_ctx_size</span> <span class="bp">≠</span> <span class="n">msg_ctx_size</span> <span class="k">then</span> <span class="n">continue</span>
    <span class="k">let</span> <span class="n">normalized_msg</span> <span class="bp">←</span> <span class="n">normalizedRevertExpr</span> <span class="n">msg_mvar</span>
    <span class="k">if</span> <span class="o">(</span><span class="bp">←</span> <span class="n">isDefEq</span> <span class="n">normalized_tgt</span> <span class="n">normalized_msg</span><span class="o">)</span> <span class="k">then</span>
      <span class="n">messages</span> <span class="o">:=</span> <span class="n">messages.push</span> <span class="n">d</span>
  <span class="n">s.restore</span>
  <span class="n">for</span> <span class="n">d</span> <span class="k">in</span> <span class="n">messages</span> <span class="k">do</span> <span class="n">logInfo</span> <span class="n">d</span>
</code></pre></div>
<p>I'm not sure why <code>s.restore</code> is backtracking the trace state; the documentation says it shouldn't</p>



<a name="292316645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292316645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292316645">(Aug 07 2022 at 12:16)</a>:</h4>
<p>Diagnostic messages are not part of the trace state, if you mean that</p>



<a name="292319147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292319147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292319147">(Aug 07 2022 at 13:12)</a>:</h4>
<p>Thank you very much Mario! Do you have other comment about my approach? Do you see a better way to do it? I know I should store a normalized version in the environment extension instead of recomputing it endlessly, but I didn't want to optimize this before having a working version.</p>



<a name="292319446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292319446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292319446">(Aug 07 2022 at 13:19)</a>:</h4>
<p>Actually precomputing the normalized expression is not as easy as I thought because there is no <code>MonadLiftT MetaM CommandElabM</code>.</p>



<a name="292319699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292319699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292319699">(Aug 07 2022 at 13:24)</a>:</h4>
<p>I still have issues navigating the monads of meta-programming in Lean 4. Do we have a cheat-sheet displaying all relations between them? I mean both extension relations and lifting capabilities.</p>



<a name="292319789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292319789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292319789">(Aug 07 2022 at 13:26)</a>:</h4>
<p>There must be a way to go from <code>CommandElabM Unit</code> to <code>MetaM</code> since declaration commands can state and prove theorems.</p>



<a name="292320772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292320772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292320772">(Aug 07 2022 at 13:46)</a>:</h4>
<p>Its not as easy as you think though, CommandElabM has no direct way to execute a MetaM computation since it can only access an Environment and doesn't have all the other stuff MetaM needs included. The MetaM executing elaborators basically create new either empty or customly filled states and contexts for the MetaM monad. </p>
<p>Since it is not entirely obvious what these initial states and contexts should be though (at least not generally for all use cases) these MonadLift instances do not exist.</p>
<p>You can see this yourself if you go through the definitions of the monad stack, a CommandElabM does not have all the info a MetaM needs</p>



<a name="292320943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292320943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292320943">(Aug 07 2022 at 13:50)</a>:</h4>
<p>I understand that, but the <code>def</code> and <code>theorem</code> commands somehow do this, right?</p>



<a name="292320964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292320964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292320964">(Aug 07 2022 at 13:50)</a>:</h4>
<p>I guess we're back to the question that started this thread: how to create an artificial context for a goal outside a proving context?</p>



<a name="292321771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292321771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292321771">(Aug 07 2022 at 14:08)</a>:</h4>
<p><code>MetaM.run'</code> defaults to an empty local and mvar context, which I assume is what you want in this case. Then you're in <code>CoreM</code>, which you can lift with <code>Command.liftCoreM</code>.</p>



<a name="292322063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292322063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292322063">(Aug 07 2022 at 14:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <br>
The <code>def</code> and <code>theorem</code> commands are implemented using<br>
<code>runTermElabM</code>. I added documentation and examples for <code>liftTermElabM</code> and <code>runTermElabM</code>:<br>
<a href="https://github.com/leanprover/lean4/commit/e236eeba870c64178805c2d5a4d6727f9b329fcb">https://github.com/leanprover/lean4/commit/e236eeba870c64178805c2d5a4d6727f9b329fcb</a></p>



<a name="292322132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292322132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292322132">(Aug 07 2022 at 14:17)</a>:</h4>
<p>Here is where <code>runTermElabM</code> is used to implement <code>def</code> and <code>theorem</code>:<br>
<a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/MutualDef.lean#L876">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/MutualDef.lean#L876</a></p>



<a name="292322509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292322509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292322509">(Aug 07 2022 at 14:25)</a>:</h4>
<p>BTW, I will remove the unnecessary <code>declName?</code> parameter. New commit coming soon.</p>



<a name="292322950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292322950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292322950">(Aug 07 2022 at 14:35)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/commit/413db56b89459d7328cee7abd669f9b99e7f4b37">https://github.com/leanprover/lean4/commit/413db56b89459d7328cee7abd669f9b99e7f4b37</a></p>



<a name="292322990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292322990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292322990">(Aug 07 2022 at 14:36)</a>:</h4>
<p>Thank you very much for all this!</p>



<a name="292323125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323125">(Aug 07 2022 at 14:39)</a>:</h4>
<p>I can confirm that <code>liftTermElab</code> works for me.</p>



<a name="292323253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323253">(Aug 07 2022 at 14:41)</a>:</h4>
<p>Would it be an option to make it a <code>liftM</code> instance now? Or is that being deliberately avoided because of the dummy state issues</p>



<a name="292323741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323741">(Aug 07 2022 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think it is problematic because</p>
<ul>
<li>The lift is not a cheap operation</li>
<li>It matters where the lift is inserted. Example:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Meta</span> <span class="n">Elab</span> <span class="n">Command</span> <span class="n">Term</span>

<span class="kd">def</span> <span class="n">ex1</span> <span class="o">:</span> <span class="n">CommandElabM</span> <span class="n">Expr</span> <span class="o">:=</span> <span class="n">liftTermElabM</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">x</span> <span class="bp">←</span> <span class="n">mkFreshTypeMVar</span>
  <span class="n">inferType</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">ex2</span> <span class="o">:</span> <span class="n">CommandElabM</span> <span class="n">Expr</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">x</span> <span class="bp">←</span> <span class="n">liftTermElabM</span> <span class="bp">&lt;|</span> <span class="n">mkFreshTypeMVar</span>
  <span class="n">liftTermElabM</span> <span class="bp">&lt;|</span> <span class="n">inferType</span> <span class="n">x</span>

<span class="k">#eval</span> <span class="n">ex1</span> <span class="c1">-- Ok</span>
<span class="k">#eval</span> <span class="n">ex2</span> <span class="c1">-- Error unknown metavariable</span>
</code></pre></div>



<a name="292323797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323797">(Aug 07 2022 at 14:54)</a>:</h4>
<p>does liftM prefer the second interpretation? (EDIT: yes)</p>



<a name="292323924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323924">(Aug 07 2022 at 14:58)</a>:</h4>
<p>The names <code>liftTermElabM</code> and <code>runTermElabM</code> are not very clearly different though. I wouldn't be able to guess which is which without looking them up</p>



<a name="292323969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323969">(Aug 07 2022 at 14:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Commenting.20tactic/near/292323924">said</a>:</p>
<blockquote>
<p>The names <code>liftTermElabM</code> and <code>runTermElabM</code> are not very clearly different though. I wouldn't be able to guess which is which without looking them up</p>
</blockquote>
<p>We now have the docstrings :)</p>



<a name="292323991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292323991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292323991">(Aug 07 2022 at 14:59)</a>:</h4>
<p><code>liftTermElabM</code> has (now) the same signature of other <code>liftM</code> methods.</p>



<a name="292324072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292324072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292324072">(Aug 07 2022 at 15:01)</a>:</h4>
<p>How about <code>runTermElabMWithContext</code>?</p>



<a name="292324133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292324133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292324133">(Aug 07 2022 at 15:02)</a>:</h4>
<p>and renaming <code>liftTermElabM</code> to <code>runTermElabM</code></p>



<a name="292324148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292324148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292324148">(Aug 07 2022 at 15:03)</a>:</h4>
<p>I didn't like the new names <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="292324150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292324150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292324150">(Aug 07 2022 at 15:03)</a>:</h4>
<p>Although the signature of <code>liftTermElabM</code> is like other <code>liftM</code>s, I am convinced by your argument that it's not really a lift</p>



<a name="292324169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Commenting%20tactic/near/292324169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Commenting.20tactic.html#292324169">(Aug 07 2022 at 15:04)</a>:</h4>
<p>especially <code>liftTermElabM (a &gt;&gt; b) != liftTermElabM a &gt;&gt; liftTermElabM b</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
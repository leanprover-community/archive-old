---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Custom.20default.20recursors.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Custom.20default.20recursors.3F.html">Custom default recursors?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281558802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Custom%20default%20recursors%3F/near/281558802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Custom.20default.20recursors.3F.html#281558802">(May 07 2022 at 20:20)</a>:</h4>
<p>When declaring an inductive type the recursor generated by Lean doesn't use common notation. Indeed, these always come after the inductive definition. For example, with <code>Nat</code>, the induction tactic does this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span> <span class="c1">-- goal: Nat.zero + 1 - 1 = Nat.zero</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span> <span class="c1">-- goal: Nat.succ n + 1 - 1 = Nat.succ n</span>
</code></pre></div>
<p>In such cases, I add a custom recursor like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">Nat.recAux.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">t</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">zero</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">succ</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.recAux</span> <span class="n">zero</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="n">using</span> <span class="n">Nat.recAux</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span> <span class="c1">-- goal: 0 + 1 - 1 = 0</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span> <span class="c1">-- goal: n + 1 + 1 - 1 = n + 1</span>
</code></pre></div>
<p>Once <code>recAux</code> and friends are available, there is not much further uses for the original <code>rec</code>. It would be nice to be able to customize the default recursor to so we can use <code>recAux</code> without specifying <code>induction ... using ...</code>. (The original recursor would still be available by <code>using</code> the original recursor.) The main drawback is that the exact form of <code>rec</code> can be deduced from the inductive definition but this is not true for custom default recursors.</p>
<p>It would also be nice to be able to specify default recursors to use for double induction. For example, I often use this diagonal recursor:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">Nat.recDiag.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">(</span><span class="n">zero_zero</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">0</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">succ_zero</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">zero_succ</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="mi">0</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">motive</span> <span class="mi">0</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="n">succ_succ</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>It doesn't necessarily make sense to make this a global default for double induction, but it would be useful as a local default in some cases.</p>
<p>All these examples are about <code>Nat</code> but there are other use cases.</p>
<p>So, I ask:</p>
<ul>
<li>Is this something that other people would use?</li>
<li>Would this be easy or hard to implement?</li>
</ul>



<a name="281559074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Custom%20default%20recursors%3F/near/281559074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Custom.20default.20recursors.3F.html#281559074">(May 07 2022 at 20:26)</a>:</h4>
<p>Another place this comes up is for cases when a definition is changed to something equivalent but with a different built in recursor (eg consider someone changing <code>int</code> to be the quotient definition that Kevin talks about); it would be nice to be able to provide a custom recursor equivalent to the old one, and make it the default so that downstream inductions don't break</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
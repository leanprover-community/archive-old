---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html">Implementing a tactic modifier</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281055906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Implementing%20a%20tactic%20modifier/near/281055906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html#281055906">(May 03 2022 at 18:23)</a>:</h4>
<p>I was thinking about implementing a "tactic modifier" like <code>clean tac</code> that would run the tactic <code>tac</code> with some additional cleanup afterwards to get rid of common crud (e.g, superfluous lambdas, <code>Nat.add</code> instead of <code>+</code>, etc.). I got a partial implementation working using macros but I'm struggling with some desirable features. Here is the most desirable feature that I don't have a clue how to do.</p>
<p>Here's the base case macro I'm using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">clean</span><span class="o">)</span> <span class="s2">"clean "</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">location</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">tactic</span>
<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">clean</span> <span class="bp">$</span><span class="n">tac</span><span class="o">:</span><span class="n">tactic</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">:</span><span class="n">location</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">clean</span><span class="o">]</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span>
</code></pre></div>
<p>where <code>clean</code> is a simp attribute for this task. (It doesn't matter what <code>clean</code> does, so replace with <code>simp only []</code> if you want to experiment on your own machine.)</p>
<p>The first issue that I'm running into is that I need to write <code>clean rw [blah] at h at h</code> instead of just <code>clean rw [blah] at h</code> where <code>clean</code> would somehow detect that the rewrite has a location parameter and only clean at that location. Is there a way to do that?</p>



<a name="281069258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Implementing%20a%20tactic%20modifier/near/281069258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Keizer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html#281069258">(May 03 2022 at 20:05)</a>:</h4>
<p>What's happening is that the location parameter is "consumed" by <code>clean</code> with a higher precedence, so <code>clean rw[x] at h</code> is parsed as <code>clean (rw[x]) at h</code>, i.e., <code>$tac = rw[x]</code>. You want to somehow pass that location parameter onto the tactic you're executing.</p>



<a name="281069719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Implementing%20a%20tactic%20modifier/near/281069719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html#281069719">(May 03 2022 at 20:09)</a>:</h4>
<p>I think they are aware of what is happening, the question is how to do this. I guess one could have parenthesis around the tactic and if a location modifier is passed to the <code>clean</code> one also pass it to the parenthesized tactic.</p>



<a name="281070845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Implementing%20a%20tactic%20modifier/near/281070845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Keizer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html#281070845">(May 03 2022 at 20:18)</a>:</h4>
<p>One way is by having an explicit case for each tactic with a location you want to support, with the downside of it being a bit brittle, you have to duplicate the syntax of every such location-bearing tactic <br>
Something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">Lean.Parser.Tactic</span> <span class="o">(</span><span class="n">location</span><span class="o">)</span>
<span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">clean</span><span class="o">)</span> <span class="s2">"clean "</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">location</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">tactic</span>
<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">clean</span> <span class="n">rw</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">cfg</span><span class="o">:</span><span class="n">config</span><span class="o">]</span><span class="bp">?</span> <span class="bp">$</span><span class="n">rw</span><span class="o">:</span><span class="n">rwRuleSeq</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">:</span><span class="n">location</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">rw</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">cfg</span><span class="o">]</span><span class="bp">?</span> <span class="bp">$</span><span class="n">rw</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">]</span><span class="bp">?;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">clean</span><span class="o">]</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">clean</span> <span class="bp">$</span><span class="n">tac</span><span class="o">:</span><span class="n">tactic</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">:</span><span class="n">location</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">clean</span><span class="o">]</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span>
</code></pre></div>



<a name="281104454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Implementing%20a%20tactic%20modifier/near/281104454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html#281104454">(May 04 2022 at 02:42)</a>:</h4>
<p>It's actually the opposite: <code>clean rw [blah] at h</code> parses as <code>clean (rw [blah] at h)</code> Anyway, I got something working! (It's funny how often merely asking for help leads to a sudden breakthrough!)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">clean</span><span class="o">)</span> <span class="s2">"clean "</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">location</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">tactic</span>
<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">clean</span> <span class="bp">$</span><span class="n">tac</span><span class="o">:</span><span class="n">tactic</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">tac.find</span><span class="bp">?</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s.getKind</span> <span class="bp">==</span> <span class="bp">``</span><span class="n">location</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">loc</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[]</span> <span class="bp">$</span><span class="n">loc</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">clean</span> <span class="bp">$</span><span class="n">tac</span><span class="o">:</span><span class="n">tactic</span> <span class="bp">$</span><span class="n">loc</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[]</span> <span class="bp">$</span><span class="n">loc</span><span class="o">)</span>
</code></pre></div>
<p>Right now this doesn't do exactly the right thing for <code>clean (rw [foo] at h1; rw [bar] at h2)</code> because it only finds the location <code>at h1</code>.</p>
<p>Is there an analogue of <code>Syntax.find?</code> that returns a list of all occurrences? (I'll roll my own if necessary but I generally try to avoid yet another implementation of the wheel.)</p>
<p>The next issue is how to correctly unify locations. Maybe there's a neat trick for that?</p>



<a name="281112972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Implementing%20a%20tactic%20modifier/near/281112972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Implementing.20a.20tactic.20modifier.html#281112972">(May 04 2022 at 05:38)</a>:</h4>
<p>I've solved it! Improvements are welcome!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- could be a useful addition to Prelude.lean</span>
<span class="n">partial</span> <span class="kd">def</span> <span class="n">Lean.Syntax.filter</span> <span class="o">(</span><span class="n">stx</span> <span class="o">:</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Syntax</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Syntax</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">stx</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">stx</span><span class="bp">@</span><span class="o">(</span><span class="n">Syntax.node</span> <span class="n">_</span> <span class="n">_</span> <span class="n">args</span><span class="o">)</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">as</span> <span class="o">:=</span> <span class="n">args.concatMap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">stx</span> <span class="bp">=&gt;</span> <span class="n">filter</span> <span class="n">stx</span> <span class="n">p</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="n">stx</span> <span class="k">then</span> <span class="n">as.push</span> <span class="n">stx</span> <span class="k">else</span> <span class="n">as</span>
  <span class="bp">|</span> <span class="n">stx</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">p</span> <span class="n">stx</span> <span class="k">then</span> <span class="bp">#</span><span class="o">[</span><span class="n">stx</span><span class="o">]</span> <span class="k">else</span> <span class="bp">#</span><span class="o">[]</span>

<span class="c1">-- could be a useful addition to Lean/Elab/Tactic/Location.lean</span>
<span class="kd">def</span> <span class="n">Lean.Elab.Tactic.joinLocation</span> <span class="o">:</span> <span class="n">Location</span> <span class="bp">→</span> <span class="n">Location</span> <span class="bp">→</span> <span class="n">Location</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">wildcard</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">wildcard</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">.</span><span class="n">wildcard</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">wildcard</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">targets</span> <span class="n">hs₁</span> <span class="n">g₁</span><span class="o">,</span> <span class="bp">.</span><span class="n">targets</span> <span class="n">hs₂</span> <span class="n">g₂</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">targets</span> <span class="o">(</span><span class="n">hs₁</span> <span class="bp">++</span> <span class="n">hs₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g₁</span> <span class="bp">||</span> <span class="n">g₂</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Lean.Parser.Tactic</span> <span class="o">(</span><span class="n">location</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">Lean.Elab.Tactic</span> <span class="o">(</span><span class="n">Location</span> <span class="n">expandLocation</span> <span class="n">joinLocation</span><span class="o">)</span>

<span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">clean</span><span class="o">)</span> <span class="s2">"clean "</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">location</span><span class="o">)</span><span class="bp">?</span> <span class="o">:</span> <span class="n">tactic</span>

<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">clean</span> <span class="bp">$</span><span class="n">tac</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">loc</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">loc</span> <span class="o">:</span> <span class="n">Location</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">loc</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">loc</span> <span class="bp">=&gt;</span> <span class="n">expandLocation</span> <span class="n">loc</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">targets</span> <span class="bp">#</span><span class="o">[]</span> <span class="n">false</span>
  <span class="n">for</span> <span class="n">stx</span> <span class="k">in</span> <span class="n">tac.filter</span> <span class="k">fun</span> <span class="n">stx</span> <span class="bp">=&gt;</span> <span class="n">stx.getKind</span> <span class="bp">==</span> <span class="bp">``</span><span class="n">location</span> <span class="k">do</span>
    <span class="n">loc</span> <span class="o">:=</span> <span class="n">joinLocation</span> <span class="n">loc</span> <span class="o">(</span><span class="n">expandLocation</span> <span class="n">stx</span><span class="o">)</span>
  <span class="k">match</span> <span class="n">loc</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">wildcard</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">clean</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">targets</span> <span class="n">hs</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">$</span><span class="n">tac</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">clean</span><span class="o">]</span> <span class="n">at</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">hs</span><span class="o">]</span><span class="bp">*</span> <span class="bp">⊢</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
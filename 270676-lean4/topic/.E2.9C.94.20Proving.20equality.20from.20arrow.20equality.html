---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html">✔ Proving equality from arrow equality</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="254329484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254329484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254329484">(Sep 22 2021 at 08:00)</a>:</h4>
<p>I'm having some trouble to show a unique typing property of some typed expressions I defined and can't seem to prove it. In the end it boils down to this little theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">=</span> <span class="n">R</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>it holds just fine propositionally, when <code>{P Q R : Sort 0}</code>. Any ideas?</p>



<a name="254329853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254329853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254329853">(Sep 22 2021 at 08:03)</a>:</h4>
<p>(deleted)</p>



<a name="254329954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254329954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254329954">(Sep 22 2021 at 08:04)</a>:</h4>
<p>Just saw that you assume <code>P</code> to be nonempty, sorry...</p>



<a name="254330036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254330036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254330036">(Sep 22 2021 at 08:05)</a>:</h4>
<p>what was your option without that assumption?</p>



<a name="254330195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254330195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254330195">(Sep 22 2021 at 08:06)</a>:</h4>
<p>It's wrong without the assumption, with <code>P = Empty</code>, <code>Q = PUnit</code> and <code>R = PBool</code></p>



<a name="254330213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254330213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254330213">(Sep 22 2021 at 08:06)</a>:</h4>
<p>ah great, thx.</p>



<a name="254330569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254330569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254330569">(Sep 22 2021 at 08:10)</a>:</h4>
<p>I see. I think that is the crux then. Most likely I'm trying to prove something too strong. thx.</p>



<a name="254330652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254330652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254330652">(Sep 22 2021 at 08:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235513">Daniel Fabian</span> has marked this topic as resolved.</p>



<a name="254330939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254330939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254330939">(Sep 22 2021 at 08:14)</a>:</h4>
<p>It's definitely not provable without UIP</p>



<a name="254333795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254333795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254333795">(Sep 22 2021 at 08:40)</a>:</h4>
<p>I don't think UIP is relevant, you just can't prove interesting theorems about equality of types, like this kind of type former injectivity. It should be true as a metatheorem, that if you can prove <code>(A -&gt; B) = (C -&gt; D)</code> (with B, D types), then you could also prove <code>A = C</code> and <code>B = D</code>, but I think you can't "internalise" this</p>



<a name="254334808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254334808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254334808">(Sep 22 2021 at 08:50)</a>:</h4>
<p>Oh, you definitely have to fix either the domain, or the codomain. The set model justifies <code>(1 → 4) = (2 → 2)</code>.</p>



<a name="254335976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254335976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254335976">(Sep 22 2021 at 08:59)</a>:</h4>
<p>Right, but the point is you can't prove it in Lean</p>



<a name="254397141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254397141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254397141">(Sep 22 2021 at 16:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254333795">said</a>:</p>
<blockquote>
<p>It should be true as a metatheorem, that if you can prove <code>(A -&gt; B) = (C -&gt; D)</code> (with B, D types), then you could also prove <code>A = C</code> and <code>B = D</code>, but I think you can't "internalise" this</p>
</blockquote>
<p>What do you mean by this? First, in Lean, equality is homogenous, so you can't even write  <code>(A -&gt; B) = (C -&gt; D)</code> where A and C or B and D are distinct types. You would get a type error. Second,  I'm not even sure what it means for functions of heterogenous types to be the equal. Does it mean the have same definition? For example, consider the following functions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">botInt</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="n">abbrev</span> <span class="n">botNat</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
</code></pre></div>
<p>I would think it  could be reasonable to say that <code>botInt = botNat</code>, but that certainly wouldn't imply <code>Int = Nat</code>. So I am just very confused as to what you are getting at.</p>



<a name="254415729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254415729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254415729">(Sep 22 2021 at 18:32)</a>:</h4>
<p>Surely the statement is only a type error if <code>ABCD</code> have incompatible universes?</p>



<a name="254418781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254418781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254418781">(Sep 22 2021 at 18:51)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Weel <code>Int</code>, <code>Nat</code>, and <code>Bool</code> are all in <code>Type</code> (i.e., the same universe) and the statement <code>botInt = botNat</code> produces a type error, so I don't think so?</p>



<a name="254419025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254419025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254419025">(Sep 22 2021 at 18:53)</a>:</h4>
<p>Though I guess I should be looking at <code>(Int -&gt; Bool) = (Nat -&gt; Bool)</code>, which does not, in fact, produce a type error.</p>



<a name="254419302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254419302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254419302">(Sep 22 2021 at 18:54)</a>:</h4>
<p>Though, in that case, I am still very confused as to what <code>(Int -&gt; Bool) = (Nat -&gt; Bool)</code> (or any statement of the form <code>(A-&gt; B) = (C -&gt; D)</code>) would even mean. Equality doesn't seem intuitively meaningful for arrows.</p>



<a name="254419935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254419935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254419935">(Sep 22 2021 at 18:58)</a>:</h4>
<p>Outside, I guess, <em>maybe</em> bare-bones syntactic equality, but equality in Lean is generally a richer concept than that.</p>



<a name="254420326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254420326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254420326">(Sep 22 2021 at 19:01)</a>:</h4>
<p>The cardinality model violates the theorem when <code>P = Nat</code>, <code>Q = Nat</code> and <code>R = Nat -&gt; Nat</code></p>



<a name="254420331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254420331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254420331">(Sep 22 2021 at 19:01)</a>:</h4>
<p>Also, as somewhat expected, Lean makes no attempt to make such equalities meaningful even simple examples like the following aren't provable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="bp">=</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- Error</span>
</code></pre></div>



<a name="254420365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254420365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254420365">(Sep 22 2021 at 19:01)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> , you have the precedence wrong</p>



<a name="254420403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254420403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254420403">(Sep 22 2021 at 19:01)</a>:</h4>
<p>Ah</p>



<a name="254420524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254420524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254420524">(Sep 22 2021 at 19:02)</a>:</h4>
<p>Yep that does fix it -- Lean happily proves it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">Int</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Int</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="254421158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254421158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254421158">(Sep 22 2021 at 19:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> is correct, this theorem is independent of lean. The standard model of lean validates it, and the cardinality model falsifies it</p>



<a name="254421452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254421452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254421452">(Sep 22 2021 at 19:09)</a>:</h4>
<p>But maybe a better question <span class="user-mention" data-user-id="235513">@Daniel Fabian</span> is how did you get here? What are those typed expressions you defined? It's usually possible to modify the inductive type to avoid this impasse</p>



<a name="254500863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254500863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254500863">(Sep 23 2021 at 08:37)</a>:</h4>
<p>ok, here's the full context: I was trying to generalize Leo's technique to use <code>rfl</code> to prove permutations of AC operators are indeed equal.</p>
<p><a href="https://github.com/leanprover/lean4/blob/master/tests/lean/run/ac_expr.lean">https://github.com/leanprover/lean4/blob/master/tests/lean/run/ac_expr.lean</a></p>
<p>In this technique, he uses a single type and a single operator. I was trying to generalize it to multiple operators.</p>
<p>What you do is define an expression type on which you can define some sort order and then you use a <code>denote</code> function to link the expression back to a real value.</p>
<p>This works quite easily when you only have a single type, because the <code>denote</code> function can be typed as <code>denote : Expr -&gt; a</code>. </p>
<p>However, if you allow for expressions that are closer to the kinds of expressions, we'd like to use it with, <code>denote</code> would become different. Something like <code>denote : (e : Expr) -&gt;  exprType e</code>. But even defining <code>exprType</code> becomes value-dependent, just one universe higher.</p>
<p>I've managed to define <code>denote</code> as an inductive predicate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Expr</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">app</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">comm</span>
    <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">assoc_comm</span>
    <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
    <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Denote</span> <span class="o">:</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="n">σ</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="o">{</span><span class="n">value</span><span class="o">}</span> <span class="o">:</span> <span class="n">Denote</span> <span class="o">(</span><span class="n">Expr.var</span> <span class="n">value</span><span class="o">)</span> <span class="n">α</span> <span class="n">value</span>
  <span class="bp">|</span> <span class="n">app</span>
    <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
    <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
    <span class="o">{</span><span class="n">f₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span>
    <span class="o">{</span><span class="n">x₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
    <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">Denote</span> <span class="n">f₁</span> <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="n">f₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Denote</span> <span class="n">x₁</span> <span class="n">α</span> <span class="n">x₂</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">Denote</span> <span class="o">(</span><span class="n">Expr.app</span> <span class="n">f₁</span> <span class="n">x₁</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="n">x₂</span><span class="o">)</span> <span class="o">(</span><span class="n">f₂</span> <span class="n">x₂</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">comm</span> <span class="o">{</span><span class="n">op</span> <span class="n">h</span><span class="o">}</span> <span class="o">:</span> <span class="n">Denote</span> <span class="o">(</span><span class="n">Expr.comm</span> <span class="n">op</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">op</span>
  <span class="bp">|</span> <span class="n">assoc_comm</span> <span class="o">{</span><span class="n">op</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">}</span>
    <span class="o">:</span> <span class="n">Denote</span> <span class="o">(</span><span class="n">Expr.assoc_comm</span> <span class="n">op</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">op</span>
</code></pre></div>
<p>but then I can't really prove anything interesting about it.</p>
<p>Maybe there's a better way of doing it... Crucially, in order to write down a <code>denote</code> function to turn an <code>Expr</code> into a value, we need to restrict the <code>Expr</code> to such <code>Expr</code> objects that are well-typed. This is obviously trivially true, if your expr is always of one type.</p>
<p>From an even bigger distance, in order to work on the AC rewrites I'm looking into, I need to normalize terms modulo AC. The paper has a bunch of inference rules but they go under the assumption, that the terms are in <em>canonical form</em>. This entails sorting and flattening all operators before the algorithm can be applied.</p>



<a name="254506114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254506114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254506114">(Sep 23 2021 at 09:25)</a>:</h4>
<p>You could try to put the actual operator functions into the <code>Context</code> (from Leo's file) and represent them with 'operator names' (indexes into the <code>Context</code>'s list of operators) in the <code>Expr</code> tree.</p>
<p>More generally, though, I think you're right that this technique (proof by reflection) becomes much harder to implement once your expression language is typed (i.e. not all <code>Expr</code>s denote a value of the same type). Then you have two options:</p>
<ol>
<li>Bite the bullet and make <code>Expr</code> a typed language. If it is at least simply-typed, you can get away with intrinsic typing: <code>Expr: Ty -&gt; Type</code> where <code>Ty</code> is a syntactic representation of the types you care about (possibly as indexes into the <code>Context</code> again). If <code>Expr</code> is not simply-typed, you can define a typing judgment <code>HasTy : Expr -&gt; Ty -&gt; Prop</code> with <code>denote : (e : Expr) -&gt; HasTy e t -&gt; denoteTy t</code> or something. But none of this is exactly pleasant.</li>
<li>Make <code>denote</code> partial: <code>denote : (t : Ty) -&gt; Expr -&gt; Option (denoteTy t)</code>. Then <code>denote</code> basically acts as a type checker as well. It's not clear to me whether this is simpler than the first option or whether it just shuffles the complexity around.</li>
</ol>
<p>I once gave up on a reflective prover for a very small fragment of category theory, where <code>Expr</code> becomes dependently typed once you want to talk about functors. So if you manage to get somewhere, I'd be very interested.</p>



<a name="254507856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254507856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254507856">(Sep 23 2021 at 09:40)</a>:</h4>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span>, I was trying to do the option 1, where I had a typing judgement. However, I ran into trouble, that your types are effectively also expressions, just one universe higher up. In other words, now I can't type the function's  type. So this technique could at best work for a subset of Lean's type system, I think.</p>
<p>As for putting things into the <code>Context</code>, I'm not so sure it helps much. That was my initial approach, but now you need to enforce some well-typedness rule about the expression anyway, otherwise you can't look up the operator in the context and it has the correct type.</p>
<p>When I tried putting it into the <code>Context</code>, the list of operators became a heterogeneous list because each operator has a different type. So you look up the operator by index and you need to make sure that the operator is compatible with the operand. And that's only type correct if the expression is type correct, i.e. you need a well-formedness predicate. Didn't seem to help much, so I made it intrinsic for a while.</p>
<p>As for the partial function approach, I was thinking about it. But Couldn't imagine how to do that? You more or less want to write something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">if</span> <span class="n">f.typeOf</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span> <span class="n">and</span> <span class="n">x.typeOf</span> <span class="bp">=</span> <span class="n">a</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">f.denote</span> <span class="n">x.denote</span><span class="o">)</span> <span class="k">else</span> <span class="n">none</span>
</code></pre></div>
<p>But obviously you can't ask a type if it's equal. So now types themselves have to become some kind of type expression objects. And if we're not careful, we just end up shifting the problem one universe up...</p>



<a name="254508356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254508356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254508356">(Sep 23 2021 at 09:44)</a>:</h4>
<p>Wouldn't it helpf if you didn't use <code>Type</code> but some inductive type <code>Ty</code>?</p>



<a name="254508685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254508685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254508685">(Sep 23 2021 at 09:48)</a>:</h4>
<p>The question then becomes how do you denote Ty into an actual Lean type. Because mind you, you need the return type of the <code>denote</code> function be something like <code>denoteTy Ty</code>. But obviously in Lean, <code>Ty</code> itself can be arbitrarily complex.</p>



<a name="254508915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254508915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254508915">(Sep 23 2021 at 09:49)</a>:</h4>
<p>one crazy approach might be to try and <code>denote</code> the actual lean <code>Expr</code> type.</p>



<a name="254508977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254508977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254508977">(Sep 23 2021 at 09:50)</a>:</h4>
<p>Could also be <code>{Int, Nat} : set (Type u)</code>, that's got decidable equality?</p>



<a name="254509084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509084">(Sep 23 2021 at 09:51)</a>:</h4>
<p>Ah yes, that one. Then your types involved in the context are <code>List Type u</code> and equality = index into the set.</p>



<a name="254509121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509121">(Sep 23 2021 at 09:51)</a>:</h4>
<p>Tried that one as well. At least we can lift all the types into some universe that's higher than any one concrete expression.</p>



<a name="254509189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509189">(Sep 23 2021 at 09:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235513">Daniel Fabian</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254507856">said</a>:</p>
<blockquote>
<p>However, I ran into trouble, that your types are effectively also expressions, just one universe higher up. In other words, now I can't type the function's  type. So this technique could at best work for a subset of Lean's type system, I think.</p>
</blockquote>
<p>Yes, you need the types to be represented syntactically, i.e. with their own <code>Ty</code> inductive like Jakob says. Otherwise you're inevitably running into the problem that started this thread, namely that you can't prove anything about <code>Type</code>. You're also right that supporting all Lean types this way is extremely hard; then your <code>Expr</code> language becomes dependently-typed and you run into all the issues associated with that. This is why I think if you need  dependent types, proof by reflection is just bad. If you can restrict to a simple subset of Lean, that should work.</p>
<blockquote>
<p>When I tried putting it into the <code>Context</code>, the list of operators became a heterogeneous list because each operator has a different type. So you look up the operator by index and you need to make sure that the operator is compatible with the operand. And that's only type correct if the expression is type correct, i.e. you need a well-formedness predicate. Didn't seem to help much, so I made it intrinsic for a while.</p>
</blockquote>
<p>Yes, you need to make sure that the context has objects of the right types for the expression. I think this is inevitable, but not sure.</p>
<p>Btw, if you need to handle types at different universes, that's a whole other can of worms.</p>



<a name="254509306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509306">(Sep 23 2021 at 09:53)</a>:</h4>
<p>different universe levels don't bother me <em>that</em> much, because I think we can at least lift them  into max u.</p>



<a name="254509427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509427">(Sep 23 2021 at 09:54)</a>:</h4>
<p>Possibly. I had major trouble with this when I tried it, but I don't remember exactly what the issue was.</p>



<a name="254509459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509459">(Sep 23 2021 at 09:55)</a>:</h4>
<p>So let's take a step back and think for a moment what we'd like to do...</p>



<a name="254509566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509566">(Sep 23 2021 at 09:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">exists</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span> <span class="n">or</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="254509575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509575">(Sep 23 2021 at 09:56)</a>:</h4>
<p>say this is the goal.</p>



<a name="254509588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509588">(Sep 23 2021 at 09:56)</a>:</h4>
<p>the normal form would ideally be e.g.</p>



<a name="254509627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509627">(Sep 23 2021 at 09:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">exists</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="n">or</span> <span class="o">(</span><span class="n">z</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="254509649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509649">(Sep 23 2021 at 09:57)</a>:</h4>
<p>i.e. I think it'd be really nice to see through binders.</p>



<a name="254509691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509691">(Sep 23 2021 at 09:57)</a>:</h4>
<p>and function applications, etc.</p>



<a name="254509809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254509809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254509809">(Sep 23 2021 at 09:58)</a>:</h4>
<p>in the presence of binders it gets dependently typed pretty quickly, doesn't it?</p>



<a name="254510135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510135">(Sep 23 2021 at 10:01)</a>:</h4>
<p>I wonder if you could just ignore the typing completely?</p>



<a name="254510223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510223">(Sep 23 2021 at 10:02)</a>:</h4>
<p>intriguing. You probably can for purposes of sorting.</p>



<a name="254510253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510253">(Sep 23 2021 at 10:02)</a>:</h4>
<p>but I have no idea, how we'd turn an expression into a value in the term language.</p>



<a name="254510428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510428">(Sep 23 2021 at 10:04)</a>:</h4>
<p>The new term still has the broad structure of the input term, that could help</p>



<a name="254510459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510459">(Sep 23 2021 at 10:04)</a>:</h4>
<p>also, I just had an idea...</p>



<a name="254510508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510508">(Sep 23 2021 at 10:05)</a>:</h4>
<p>what if we had something like <code>Expr u</code> where <code>u</code> is the max universe of subexpressions.</p>



<a name="254510645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510645">(Sep 23 2021 at 10:06)</a>:</h4>
<p>then <code>exprTy : Expr u -&gt; Sort (u + 1)</code> and <code>denote : (e : Expr u) -&gt; exprTy e</code></p>



<a name="254510654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254510654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254510654">(Sep 23 2021 at 10:06)</a>:</h4>
<p>or something like that anyway</p>



<a name="254511129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254511129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254511129">(Sep 23 2021 at 10:10)</a>:</h4>
<p>If you just want to go under binders etc, I would do that with a metaprogram. You have to write one anyway, to convert Lean <code>Expr</code> into your <code>Expr</code>. This metaprogram can easily(TM) construct the necessary boilerplate to go from <code>2 + z = z + 2</code> and <code>1 + z + 1 = z + 1 + 1</code>,  which are the outputs of your reflective solver, to your original goal.</p>



<a name="254511236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254511236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254511236">(Sep 23 2021 at 10:11)</a>:</h4>
<p>yeah, we would combine it with the simplifier to go through binders.</p>



<a name="254511306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254511306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254511306">(Sep 23 2021 at 10:12)</a>:</h4>
<p>so what? a quantifier-free subset of lean?</p>



<a name="254511454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254511454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254511454">(Sep 23 2021 at 10:13)</a>:</h4>
<p>otoh, function symbols in lean surely can be dependently typed.</p>



<a name="254511574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254511574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254511574">(Sep 23 2021 at 10:14)</a>:</h4>
<p>but then again AC operators aren't.</p>



<a name="254511928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254511928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254511928">(Sep 23 2021 at 10:18)</a>:</h4>
<p>If you want only AC reasoning, I would restrict to:</p>
<ul>
<li>a finite collection of types <code>α, β, ...</code></li>
<li>a finite collection of operators <code>f : α -&gt; α -&gt; α, g : γ -&gt; γ -&gt; γ, ...</code></li>
<li>a finite collection of values <code>x : α, y : γ, ...</code></li>
</ul>
<p>Then your expressions are simply-typed. Setting this up is still not trivial because you have typed expressions and a typed context. But that should be doable.</p>



<a name="254512001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254512001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254512001">(Sep 23 2021 at 10:19)</a>:</h4>
<p>ok, cool, I'll try to do that. It'd make the proof certificates much shorter and more elegant!</p>



<a name="254513449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254513449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254513449">(Sep 23 2021 at 10:33)</a>:</h4>
<p>just a question, though <span class="user-mention" data-user-id="256311">@Jannis Limperg</span> if you say types <code>\alpha, \beta, ...</code>what do you want to do with them? If you allow arbitrary types, then function application would still be dependently typed. If you only allow applying the operators, how would you move from <code>\alpha</code> to <code>\gamma</code>? What am I missing?</p>



<a name="254513656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254513656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254513656">(Sep 23 2021 at 10:35)</a>:</h4>
<p>or are you proposing that you allow functions which are closed under (non-dependent) arrows?</p>



<a name="254516133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516133">(Sep 23 2021 at 10:58)</a>:</h4>
<p>I think this can be done, but I'm unclear on what you actually want to do. AC reasoning is inherently unityped, unless you have a family of related operators with rules like <code>f x (g y z) = i (h x y) z</code></p>



<a name="254516333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516333">(Sep 23 2021 at 11:00)</a>:</h4>
<p>What is the "type signature" of the problem statement?</p>



<a name="254516444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516444">(Sep 23 2021 at 11:01)</a>:</h4>
<p>But I also think that this is a bad idea and a metaprogram will be faster to build a proof, faster to check, and simpler to understand.</p>



<a name="254516589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516589">(Sep 23 2021 at 11:02)</a>:</h4>
<p>the big goal is to integrate reasoning modulo AC with the Lean simplifier.</p>



<a name="254516738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516738">(Sep 23 2021 at 11:03)</a>:</h4>
<p>the problem statement is really anything we want it to be. As we are successful if <code>simp</code> can handle AC rewriting. We could build the entire proof completely from scratch by manually applying the AC lemmas. But that would make the proof substantially bigger.</p>



<a name="254516923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516923">(Sep 23 2021 at 11:05)</a>:</h4>
<p>this whole rfl-based proof certificate is just one bit of the bigger picture. If we can prove that the canonical form is equal to the one that is in the context, that's useful. Since constructing the proof for the permutation using reflection is easy.</p>



<a name="254516936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516936">(Sep 23 2021 at 11:05)</a>:</h4>
<p>But ultimately it's not a hard requirement.</p>



<a name="254516980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254516980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254516980">(Sep 23 2021 at 11:05)</a>:</h4>
<p>I think you should just sort the atoms and defer the proof until you know you need to produce it</p>



<a name="254517078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517078">(Sep 23 2021 at 11:06)</a>:</h4>
<p>A heavy <code>rfl</code> is not a short proof</p>



<a name="254517086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517086">(Sep 23 2021 at 11:06)</a>:</h4>
<p>it just prints like one</p>



<a name="254517146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517146">(Sep 23 2021 at 11:07)</a>:</h4>
<p>and you'd keep carrying around exactly what operations you did to the expr whilst sorting so you can reconstruct a proof?</p>



<a name="254517265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517265">(Sep 23 2021 at 11:08)</a>:</h4>
<p>You can, but you don't need to, if you know they are permutations (and you can quickly work out what the permutation is) you can reconstruct the proof</p>



<a name="254517323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517323">(Sep 23 2021 at 11:09)</a>:</h4>
<p>If the atoms are almost-defeq then determining the permutation might be expensive, so you probably want to make that part symbolic</p>



<a name="254517395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517395">(Sep 23 2021 at 11:09)</a>:</h4>
<p>but that's all in the internal workings of the tactic, it's something like a <code>List (Nat x Expr)</code> to represent the permutation</p>



<a name="254517440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517440">(Sep 23 2021 at 11:10)</a>:</h4>
<p>or I guess <code>List Nat</code> with a <code>List Expr</code> on the side</p>



<a name="254517460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517460">(Sep 23 2021 at 11:10)</a>:</h4>
<p>the AC axioms only let us swap 2 operands at a time, right? So you effectively have to do a bubble sort.</p>



<a name="254517513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517513">(Sep 23 2021 at 11:10)</a>:</h4>
<p>Incidentally, I <a href="https://cs.stackexchange.com/questions/105250/minimum-number-of-tree-operations-to-normalize-a-labeled-tree">asked a question</a> about this some time ago, with exactly this application in mind. It can be done in O(n log n)</p>



<a name="254517925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517925">(Sep 23 2021 at 11:14)</a>:</h4>
<p>interesting</p>



<a name="254517952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254517952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254517952">(Sep 23 2021 at 11:15)</a>:</h4>
<p>But more importantly, you want to make sure that the cost for small n (say n = 3 to 5) is small, and here the proof directly from AC axioms is shorter than reflection, even if you consider <code>rfl</code> a short proof</p>



<a name="254518460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254518460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254518460">(Sep 23 2021 at 11:21)</a>:</h4>
<p>for 3-5 bubble sort is probably close to as good as the algorithm in the example, no?</p>



<a name="254518500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254518500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254518500">(Sep 23 2021 at 11:21)</a>:</h4>
<p>In general, the tree of course wouldn't be a perfect tree, but rather something inbalanced</p>



<a name="254518664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254518664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254518664">(Sep 23 2021 at 11:23)</a>:</h4>
<p>for matching purposes, we could also define an internal representation to find an appropriate AC substitution and then try to prove equivalence.</p>



<a name="254518684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254518684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254518684">(Sep 23 2021 at 11:23)</a>:</h4>
<p>if we did that, the sorting would be just done on top of that data structure.</p>



<a name="254518706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254518706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254518706">(Sep 23 2021 at 11:23)</a>:</h4>
<p>Essentially a multi-set per AC operator, or something similar.</p>



<a name="254519275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254519275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254519275">(Sep 23 2021 at 11:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235513">Daniel Fabian</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254513449">said</a>:</p>
<blockquote>
<p>just a question, though <span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> if you say types <code>\alpha, \beta, ...</code>what do you want to do with them? If you allow arbitrary types, then function application would still be dependently typed. If you only allow applying the operators, how would you move from <code>\alpha</code> to <code>\gamma</code>? What am I missing?</p>
</blockquote>
<p>Oh right, the whole thing is actually unityped. Then everything is very simple. (This is what they always show in proof by reflection tutorials. :))</p>



<a name="254519506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254519506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254519506">(Sep 23 2021 at 11:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235513">Daniel Fabian</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254518460">said</a>:</p>
<blockquote>
<p>for 3-5 bubble sort is probably close to as good as the algorithm in the example, no?</p>
</blockquote>
<p>I think that bubble sort / any obvious sort is fine for the near term. It's a relatively self contained thing and the issues only come in extreme examples, so improvements over a baseline implementation are a low priority</p>



<a name="254519764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254519764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254519764">(Sep 23 2021 at 11:34)</a>:</h4>
<p>IIRC lean 3 simp does it just by doing ordered rewrite with <code>add_comm, add_assoc, add_left_comm</code></p>



<a name="254519807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Proving%20equality%20from%20arrow%20equality/near/254519807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality.html#254519807">(Sep 23 2021 at 11:35)</a>:</h4>
<p>which I think results in insertion sort</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
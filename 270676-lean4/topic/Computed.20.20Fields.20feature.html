---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Computed.20.20Fields.20feature.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html">Computed  Fields feature</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="289258950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289258950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289258950">(Jul 11 2022 at 22:43)</a>:</h4>
<p>We have merged the "Computed Fields" PR. It is an amazing new feature. See release notes for additional details: <a href="https://github.com/leanprover/lean4/blob/master/RELEASES.md">https://github.com/leanprover/lean4/blob/master/RELEASES.md</a><br>
The following Lean types are using this feature: <code>Lean.Expr</code>, <code>Lean.Level</code>, and <code>Lean.Name</code>. So,  it is quite disruptive for meta-programmers that use these types. Please update your projects, and thanks for your patience.</p>



<a name="289259092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289259092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289259092">(Jul 11 2022 at 22:44)</a>:</h4>
<p>Many thanks to <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> for developing this feature!</p>



<a name="289259165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289259165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Mullins <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289259165">(Jul 11 2022 at 22:45)</a>:</h4>
<blockquote>
<p>The notation a[i] is not defined as follows</p>
</blockquote>
<p>Is this a typo for <code>now</code>?</p>



<a name="289259167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289259167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289259167">(Jul 11 2022 at 22:45)</a>:</h4>
<p>In the release notes, I guess that</p>
<blockquote>
<p>The notation <code>a[i]</code> is not defined as follows</p>
</blockquote>
<p>is meant to be</p>
<blockquote>
<p>The notation <code>a[i]</code> is <em>now</em> defined as follows</p>
</blockquote>



<a name="289259242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289259242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289259242">(Jul 11 2022 at 22:46)</a>:</h4>
<p>Thanks!</p>



<a name="289259248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289259248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289259248">(Jul 11 2022 at 22:46)</a>:</h4>
<p>I will fix it.</p>



<a name="289262289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289262289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289262289">(Jul 11 2022 at 23:26)</a>:</h4>
<p>Nice!  I used this sort of thing a lot in Scala case classes (which are like inductive types).  In Scala could define say <code>Expr.hash</code> in three different ways: (1) as a method which was recomputed every time, (2) as a value which was computed on creation of the object, (3) as a lazy value which was computed and cached only the first time it was called which was good for some expensive calculations.  All three were called the same way <code>e.hash</code> which made refactoring easy.</p>



<a name="289265979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289265979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289265979">(Jul 12 2022 at 00:26)</a>:</h4>
<p>What are the common use cases for this feature?</p>



<a name="289266345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289266345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289266345">(Jul 12 2022 at 00:34)</a>:</h4>
<p>Any kind of O(1) precomputed information which is structurally recursive on the term, like the size of a subtree</p>



<a name="289266418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289266418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289266418">(Jul 12 2022 at 00:35)</a>:</h4>
<p>The obvious immediate application is the <code>Data</code> field of <code>Expr</code>, <code>Name</code>, <code>Level</code> which was an ergonomic wart compared to the lean 3 implementation of these types (which cheated by having a custom implementation which stored the computed field where lean couldn't reach it)</p>



<a name="289266521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289266521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289266521">(Jul 12 2022 at 00:37)</a>:</h4>
<p>This technique of "augmented trees" is very common in data structures</p>



<a name="289266640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289266640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289266640">(Jul 12 2022 at 00:39)</a>:</h4>
<p>Here's a whole lecture on it: <a href="https://www.youtube.com/watch?v=xVka6z1hu-I">https://www.youtube.com/watch?v=xVka6z1hu-I</a></p>
<div class="youtube-video message_inline_image"><a data-id="xVka6z1hu-I" href="https://www.youtube.com/watch?v=xVka6z1hu-I"><img src="https://uploads.zulipusercontent.net/fc0e73920efd77bd56a4579f2aae7dd4b976072f/68747470733a2f2f692e7974696d672e636f6d2f76692f78566b61367a3168752d492f64656661756c742e6a7067"></a></div>



<a name="289267410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267410">(Jul 12 2022 at 00:55)</a>:</h4>
<p>Very cool! Is the reason for taking <code>BinderInfo</code> out of <code>Data</code> basically that <code>BinderInfo</code> is "actual" data rather than a pure function of the rest of the <code>Expr</code>?</p>



<a name="289267595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267595">(Jul 12 2022 at 00:58)</a>:</h4>
<p>yes, this doesn't work if it's not a pure function</p>



<a name="289267698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267698">(Jul 12 2022 at 01:00)</a>:</h4>
<p>it would be cool if we could bit-pack those together but that sounds difficult given lean's uniform ABI</p>



<a name="289267791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267791">(Jul 12 2022 at 01:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Computed.20.20Fields.20feature/near/289267698">said</a>:</p>
<blockquote>
<p>it would be cool if we could bit-pack those together but that sounds difficult given lean's uniform ABI</p>
</blockquote>
<p>Yeah, there is now a new <code>BinderInfo</code> field in <code>Expr.lam/forallE</code> with (I am guessing) some small memory overhead.</p>



<a name="289267816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267816">(Jul 12 2022 at 01:03)</a>:</h4>
<p>An interesting side effect of the change is that <code>letE</code> no longer has <code>BinderInfo</code>. Not that this made much sense, so maybe the side effect is really a bug fix. However there is a mysterious <code>Bool</code> field in <code>| letE    : Name → Expr → Expr → Expr → Bool → Expr</code> -- is that the <code>nonDepLet</code> flag?</p>



<a name="289267874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267874">(Jul 12 2022 at 01:04)</a>:</h4>
<p>that sounds like it should be a computed field</p>



<a name="289267916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289267916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289267916">(Jul 12 2022 at 01:05)</a>:</h4>
<p>Oh okay, it is. In the <code>data</code> computation we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="bp">|</span> <span class="bp">.</span><span class="n">letE</span> <span class="n">_x</span> <span class="n">t</span> <span class="n">v</span> <span class="n">b</span> <span class="n">nonDep</span> <span class="bp">=&gt;</span>
     <span class="bp">...</span>
      <span class="n">mkDataForLet</span> <span class="bp">...</span> <span class="n">nonDep</span>
</code></pre></div>
<p>which is both stored and computed.</p>



<a name="289268013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289268013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289268013">(Jul 12 2022 at 01:07)</a>:</h4>
<p>It is an input in <code>mkLet</code>, so it seems like it's not actually a computed field. Not sure what the story is there</p>



<a name="289268096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289268096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289268096">(Jul 12 2022 at 01:08)</a>:</h4>
<p>I mean, the data in <code>Expr.data</code> is not sufficient to determine whether a given variable in fact appears in the body, so even though it is a pure function of the expr inputs it would be computationally expensive to determine it</p>



<a name="289268112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289268112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289268112">(Jul 12 2022 at 01:09)</a>:</h4>
<p>I am assuming: previously, <code>Data</code> was a mix of stored and computed fields; now, we have an actual computed field; but, for backwards compatibility, we still expose the stored parts (binder infos and the non-dep let flag) within <code>Data</code>.</p>



<a name="289285054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289285054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289285054">(Jul 12 2022 at 06:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="128280">Wojciech Nawrocki</span> <a href="#narrow/stream/270676-lean4/topic/Computed.20.20Fields.20feature/near/289267816">said</a>:</p>
<blockquote>
<p>An interesting side effect of the change is that <code>letE</code> no longer has <code>BinderInfo</code>. Not that this made much sense, so maybe the side effect is really a bug fix. However there is a mysterious <code>Bool</code> field in <code>| letE    : Name → Expr → Expr → Expr → Bool → Expr</code> -- is that the <code>nonDepLet</code> flag?</p>
</blockquote>
<p>The <code>nonDepInfo</code> flag is purely a placeholder for a future possible optimization in the compiler.  It doesn't have any effect at the moment, but it is very much a flag and cannot be (purely) computed from the expression since it depends on type checking.  The idea is that <code>nonDepLet := true</code> flags let-expressions which do not require ζ-reduction, that is, which could be replaced by a <code>let_fun</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="o">(</span><span class="n">nonDep</span> <span class="o">:=</span> <span class="n">false</span><span class="o">)</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Nat</span><span class="bp">;</span> <span class="o">(</span><span class="n">id</span> <span class="n">Nat.zero</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="c1">-- type checks</span>
<span class="k">let</span> <span class="o">(</span><span class="n">nonDep</span> <span class="o">:=</span> <span class="n">true</span><span class="o">)</span>  <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Nat</span><span class="bp">;</span> <span class="o">(</span><span class="n">id</span> <span class="n">Nat.zero</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="c1">-- doesn't type check</span>
</code></pre></div>
<p>(Purely hypothetical, of course.  To reiterate, the flag is completely unused at the moment.)</p>



<a name="289285460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289285460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289285460">(Jul 12 2022 at 06:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="128280">Wojciech Nawrocki</span> <a href="#narrow/stream/270676-lean4/topic/Computed.20.20Fields.20feature/near/289268112">said</a>:</p>
<blockquote>
<p>I am assuming: previously, <code>Data</code> was a mix of stored and computed fields; now, we have an actual computed field; but, for backwards compatibility, we still expose the stored parts (binder infos and the non-dep let flag) within <code>Data</code>.</p>
</blockquote>
<p>I tried to keep the diff minimal for the Expr-refactoring.  There are indeed a lot of parts that can be cleaned up or changed now (without affecting the API and without big refactorings, which is the whole point of the feature).  For example the <code>nonDepLet</code> and <code>binderInfo</code> bits in <code>Data</code> are indeed vestigial and can be removed.  With the extra 4 bits we could support 1048575 bound variables instead of 65535 (one can dream).  We could also split the hash, the bitmask, the approximate depth, and the loose variable bound into different fields.  (Maybe allowing four billion bound variables. <span aria-label="heart eyes" class="emoji emoji-1f60d" role="img" title="heart eyes">:heart_eyes:</span>)</p>



<a name="289285806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289285806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289285806">(Jul 12 2022 at 06:56)</a>:</h4>
<blockquote>
<p>it would be cool if we could bit-pack those together but that sounds difficult given lean's uniform ABI</p>
</blockquote>
<p>There's nothing in Lean's ABI that prevents bit-packing of fields in a constructor (uniformity only means we can't pack <code>Bool × Bool</code> etc.)</p>



<a name="289293431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289293431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289293431">(Jul 12 2022 at 08:36)</a>:</h4>
<p>If I have a <code>List Nat</code> and I compute length with this new feature, am I doubling memory consumption? I.e. does every tail store its length?</p>



<a name="289294025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/289294025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#289294025">(Jul 12 2022 at 08:42)</a>:</h4>
<p>It would indeed store the length in every cons cell, but that's only a 33% increase per cons cell (which is 24 bytes at the moment if I'm not mistaken).  The impact on the total memory consumption is less since not everything is a cons cell.</p>



<a name="290040112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/290040112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#290040112">(Jul 19 2022 at 00:24)</a>:</h4>
<p>Is the definition of the function also exposed for proof purposes? I was doing some backflips before to cache these values -- super useful feature :)</p>



<a name="290066279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/290066279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#290066279">(Jul 19 2022 at 08:10)</a>:</h4>
<p>It's just a regular function on the datatype from the kernel's PoV</p>



<a name="290147485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/290147485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#290147485">(Jul 19 2022 at 19:16)</a>:</h4>
<p>Can this be used with structures and/or classes, or am I thinking about this incorrectly? I think the other alternative is to make it a def and use the caching offered by <code>Thunk</code>?</p>
<p>For instance replacing <code>sum</code> and <code>h_sum</code> with a computed field:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">X</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">sum</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_sum</span> <span class="o">:</span> <span class="n">sum</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="290147592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/290147592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#290147592">(Jul 19 2022 at 19:17)</a>:</h4>
<p>Note that <code>Thunk</code> is different: <code>Thunk</code> is lazy while the computed fields for inductives are strict.</p>



<a name="290148231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/290148231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#290148231">(Jul 19 2022 at 19:23)</a>:</h4>
<p>The reason computed fields are not implemented (yet) for structures is twofold: 1) structures are a bit more work since you need to override the projections as well, and 2) it's much less urgent for structures since you can simulate most of the feature:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Cached</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">cached</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">cached</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">EmptyCollection</span> <span class="o">(</span><span class="n">Cached</span> <span class="n">a</span><span class="o">)</span> <span class="n">where</span> <span class="n">emptyCollection</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">Cached</span> <span class="n">a</span><span class="o">)</span> <span class="n">where</span> <span class="n">default</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Subsingleton</span> <span class="o">(</span><span class="n">Cached</span> <span class="n">a</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">allEq</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">subst</span> <span class="n">hb</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">hc</span><span class="bp">;</span> <span class="n">rfl</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">DecidableEq</span> <span class="o">(</span><span class="n">Cached</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">isTrue</span> <span class="o">(</span><span class="n">Subsingleton.allEq</span> <span class="bp">..</span><span class="o">)</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Hashable</span> <span class="o">(</span><span class="n">Cached</span> <span class="n">a</span><span class="o">)</span> <span class="n">where</span> <span class="n">hash</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">structure</span> <span class="n">A</span> <span class="n">where</span>
  <span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">hash</span> <span class="o">:</span> <span class="n">Cached</span> <span class="o">(</span><span class="n">Hashable.hash</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{}</span>
  <span class="n">deriving</span> <span class="n">DecidableEq</span><span class="o">,</span> <span class="n">Hashable</span>


<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">eq_of_subsingleton</span> <span class="o">[</span><span class="n">Subsingleton</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">True</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Subsingleton.allEq</span> <span class="n">a</span> <span class="n">b</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">A.extIff</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a.a</span> <span class="bp">=</span> <span class="n">b.a</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">subst</span> <span class="n">h</span><span class="bp">;</span> <span class="n">rfl</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">a</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">b</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">simp</span><span class="o">⟩</span>
</code></pre></div>
<p>The only downside of this simulation is that you get extra fields.  But you don't get any exotic terms where the extra fields have the wrong value.</p>



<a name="300819928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/300819928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> cognivore <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#300819928">(Sep 26 2022 at 13:57)</a>:</h4>
<p>(Deleted unreproducible bug report)</p>



<a name="300820040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/300820040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> cognivore <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#300820040">(Sep 26 2022 at 13:58)</a>:</h4>
<p>(Deleted irrelevant version details)</p>



<a name="300820212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/300820212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> cognivore <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#300820212">(Sep 26 2022 at 13:59)</a>:</h4>
<p>It's interesting that <code>computedField</code> doesn't seem to be used neither in lean4 nor in mathlib. Is there a reason? Am I just bad at <code>grepping</code>?</p>



<a name="300830247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/300830247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#300830247">(Sep 26 2022 at 14:45)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rg</span> <span class="bp">'\</span><span class="o">[</span><span class="n">computedField'</span> <span class="n">src</span>
<span class="n">src</span><span class="bp">/</span><span class="n">Lean</span><span class="bp">/</span><span class="n">Level.lean</span>
<span class="mi">97</span><span class="o">:</span>  <span class="kd">@[computedField]</span> <span class="n">data</span> <span class="o">:</span> <span class="n">Level</span> <span class="bp">→</span> <span class="n">Data</span>

<span class="n">src</span><span class="bp">/</span><span class="n">Lean</span><span class="bp">/</span><span class="n">Expr.lean</span>
<span class="mi">469</span><span class="o">:</span>  <span class="kd">@[computedField, extern c inline "lean_ctor_get_uint64(#1, lean_ctor_num_objs(#1)*sizeof(void*))"]</span>

<span class="n">src</span><span class="bp">/</span><span class="n">Init</span><span class="bp">/</span><span class="n">Prelude.lean</span>
<span class="mi">3299</span><span class="o">:</span>  <span class="kd">@[computedField]</span> <span class="n">hash</span> <span class="o">:</span> <span class="n">Name</span> <span class="bp">→</span> <span class="n">UInt64</span>

<span class="n">src</span><span class="bp">/</span><span class="n">Lean</span><span class="bp">/</span><span class="n">Elab</span><span class="bp">/</span><span class="n">ComputedFields.lean</span>
<span class="mi">38</span><span class="o">:</span>      <span class="n">throwError</span> <span class="s2">"The @[computedField] attribute can only be used in the with-block of an inductive"</span>
<span class="mi">202</span><span class="o">:</span>        <span class="n">logError</span> <span class="n">m</span><span class="bp">!</span><span class="s2">"'{computedFieldName}' must be tagged with @[computedField]"</span>
</code></pre></div>



<a name="300830970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Computed%20%20Fields%20feature/near/300830970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> cognivore <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Computed.20.20Fields.20feature.html#300830970">(Sep 26 2022 at 14:49)</a>:</h4>
<p>Funny. Sorry, I don't think I had my terminals straight today.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html">Isn't Fin a bad type for safe array lookup?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265291111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265291111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265291111">(Dec 17 2021 at 12:49)</a>:</h4>
<p>Hello everyone)</p>
<p>As from a dependently typed general-purpose language, I expect from <code>Lean4</code> ability for writing programs with provable correctness, but the implicit behavior of <code>Fin</code> could break safe array access. In some cases <code>Lean4</code> loses in safety even compared with <code>C++</code> (the latter has at least warnings and runtime checks) and produce total code with undesired behavior:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib</span>

<span class="kd">def</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">2</span>

<span class="c1">-- silent truncation of a constant value</span>
<span class="kd">def</span> <span class="n">val_4</span><span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">4</span>
<span class="k">#eval</span> <span class="n">val_4</span> <span class="c1">-- output: 0</span>

<span class="c1">-- silent overflow</span>
<span class="kd">def</span> <span class="n">val_1</span><span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">overflowed_value</span><span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">val_1</span> <span class="bp">+</span> <span class="n">val_1</span>
<span class="k">#eval</span> <span class="n">overflowed_value</span> <span class="c1">-- output: 0</span>

<span class="c1">-- silent underflow</span>
<span class="kd">def</span> <span class="n">val_0</span><span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">underflowed_value</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">val_0</span> <span class="bp">-</span> <span class="n">val_1</span>
<span class="k">#eval</span> <span class="n">underflowed_value</span> <span class="c1">-- output: 1</span>

<span class="c1">-- Array becomes a circular buffer</span>
<span class="kd">def</span> <span class="n">msgs</span><span class="o">:</span> <span class="n">Array</span> <span class="n">String</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[</span>
  <span class="s2">"It's not even a runtime error!"</span><span class="o">,</span>
  <span class="s2">"Lean is a functional programming language that makes it easy to write correct and maintainable code"</span>
<span class="o">]</span>
<span class="k">#eval</span> <span class="n">msgs.get</span> <span class="o">(</span><span class="n">val_1</span> <span class="bp">+</span> <span class="n">val_1</span><span class="o">)</span> <span class="c1">-- output: "It's not even a runtime error!"</span>
<span class="k">#eval</span> <span class="n">msgs.get</span> <span class="o">(</span><span class="n">val_0</span> <span class="bp">-</span> <span class="n">val_1</span><span class="o">)</span> <span class="c1">-- output: "Lean is a functional programming language that makes it easy to write correct and maintainable code"</span>

<span class="kn">section</span> <span class="c1">-- with Mathlib4 imported</span>

  <span class="c1">-- silent downcast</span>
  <span class="kd">def</span> <span class="n">val_n_plus_1</span><span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
  <span class="kd">def</span> <span class="n">downcasted_val_n_plus_1</span><span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">val_n_plus_1</span>
  <span class="k">#eval</span> <span class="n">downcasted_val_n_plus_1</span> <span class="c1">-- output: 0</span>

  <span class="c1">-- explicit negative index</span>
  <span class="k">#eval</span> <span class="n">msgs.get</span> <span class="o">(</span><span class="bp">-</span><span class="n">val_1</span><span class="o">)</span>  <span class="c1">-- output: "Lean is a functional programming language that makes it easy to write correct and maintainable code"</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="c1">// MSVC with EnableAllWarnings (/Wall) and Debug configuration</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">val_256</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"val_256 = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">+</span><span class="n">val_256</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// warning C4305: 'initializing': truncation from 'int' to 'uint8_t'</span>
<span class="w">                                                   </span><span class="c1">// warning C4309: 'initializing': truncation of constant value</span>
<span class="w">                                                   </span><span class="c1">// output: val_256 = 0</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">val_255</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="n">val_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">overflowed_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val_255</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">val_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"(val_255 + val_1) = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">+</span><span class="n">overflowed_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// output: (val_255 + val_1) = 0</span>

<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">val_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">underflowed_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val_0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">val_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"(val_0 - val_1) = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">+</span><span class="n">underflowed_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// output: (val_0 - val_1) = 255</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">msgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="s">"It's not even a runtime error!"</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">"Lean is a functional programming language that makes it easy to write correct and maintainable code"</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"msgs[val_1 + val_1] = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msgs</span><span class="p">[</span><span class="n">val_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">val_1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// warning C4365: 'argument': conversion from 'int' to 'std::array&lt;std::string,2&gt;::size_type', signed/unsigned mismatch</span>
<span class="w">                                                                          </span><span class="c1">// runtime exception: 'array subscript out of range'</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"msgs[val_0 - val_1] = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msgs</span><span class="p">[</span><span class="n">val_0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">val_1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// warning C4365: 'argument': conversion from 'int' to 'std::array&lt;std::string,2&gt;::size_type', signed/unsigned mismatch</span>
<span class="w">                                                                          </span><span class="c1">// runtime exception: 'array subscript out of range'</span>

<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">val_257</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">257</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">downcasted_val_257</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val_257</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"downcasted_val_257 = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">+</span><span class="n">downcasted_val_257</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// warning C4244: 'initializing': conversion from 'uint16_t' to 'uint8_t', possible loss of data</span>
<span class="w">                                                                         </span><span class="c1">// output: downcasted_val_257 = 1</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"msgs[- val_1] = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msgs</span><span class="p">[</span><span class="o">-</span><span class="w"> </span><span class="n">val_1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"> </span><span class="c1">// warning C4365: 'argument': conversion from 'int' to 'std::array&lt;std::string,2&gt;::size_type', signed/unsigned mismatch</span>
<span class="w">                                                              </span><span class="c1">// runtime exception: 'array subscript out of range'</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>I wouldn't imagine someones expecting their indexes silently overflowing/underflowing/truncating modulo size of a container, except for circular buffers, and almost all arrays aren't circular buffers.</p>
<p>Wouldn't that be better to have another one bounded <code>Nat</code> type without modular arithmetic?</p>



<a name="265291782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265291782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265291782">(Dec 17 2021 at 12:57)</a>:</h4>
<p>What structure <code>fin</code> should have on it is a contentious topic. Like you I am not a fan of all this extra stuff -- in Lean 3 + mathlib <code>fin n</code> has an addition (which wraps) and it wouldn't surprise me if someone put a multiplication on it too. In mathematics there is a structure <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord mathbb">Z</span></span></span></span> which is a ring, so has wrapping addition and multiplication and all the behaviour being exhibited by <code>Fin</code> in your snippet.</p>



<a name="265293507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265293507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265293507">(Dec 17 2021 at 13:13)</a>:</h4>
<p>I'm not claiming that <code>Fin</code> is broken in some sense, just that it may doesn't fit the role of array index type.</p>



<a name="265293983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265293983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265293983">(Dec 17 2021 at 13:17)</a>:</h4>
<p>Well it depends what do you mean by safe array access. It prevents you from out of bound memory access but it does not prevent you from accidentally accessing the incorrect element. To prevent this issue you can abandon Fin and use Int64 together with Array.uget to access elements.</p>
<p>I agree that this behavior of Fin might be confusing if you do not think about it as Z/nZ as Kevin described. In my code, I actually use this structure all the time and I'm quite happy with it.</p>
<p>I think that the main question is, what should be the default interface for Array. For example the notation <code>a[i]</code> uses Array.get! where <code>i</code> is Nat and out of bound access returns default value of what ever the array is holding. You get another set of unexpected behaviour then using Fin and Array.get</p>



<a name="265294746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265294746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265294746">(Dec 17 2021 at 13:24)</a>:</h4>
<p>Ohh, I didn't read the question in title properly. What would you suggest to use instead of Fin? </p>
<p>I see two options</p>
<ol>
<li>Ditch algebraic structure on Fin.</li>
<li>Use Nat or Int and always provide proof of valid index.</li>
</ol>
<p>I find both options clunky to use and rather accept this sometimes unintuitive behavior of Fin.</p>



<a name="265295009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295009">(Dec 17 2021 at 13:27)</a>:</h4>
<p>And honestly, the only unexpected case is the <code>val_4</code> evaluating to 0 instead of 1, as <code>4=1 mod 3</code>.</p>



<a name="265295151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295151">(Dec 17 2021 at 13:28)</a>:</h4>
<p>my mistake) it's really 1</p>



<a name="265295372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295372">(Dec 17 2021 at 13:30)</a>:</h4>
<p>Uff, I was almost about to report a bug :)</p>



<a name="265295415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295415">(Dec 17 2021 at 13:31)</a>:</h4>
<p>I've come across this before and even tried to come up with a Fin that would not allow this behavior for constants, however there is an issue I stumbled upon while doing this. In Lean 4 the number notation is controlled by a type class, if you want to allow a number literal <code>n</code> to be converted to your type <code>T</code> you have to implement <code>OfNat T n</code>. You can of course also universally quantify over the <code>n</code> here to allow any literal to be converted as is for example done for the natural numbers:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[defaultInstance 100]</span> <span class="c">/-</span><span class="cm"> low prio -/</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">Nat</span> <span class="n">n</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">n</span>
</code></pre></div>
<p>And similarly also for <code>Fin</code>,  and I tried to come up with an OfNat instance that would fail type class resolution if this happens like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">decide</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">NFin</span> <span class="o">(</span><span class="n">no_index</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="n">i</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">NFin.mk</span> <span class="n">i</span> <span class="n">h</span>

<span class="k">#check</span> <span class="o">(</span><span class="mi">12</span> <span class="o">:</span> <span class="n">NFin</span> <span class="mi">13</span><span class="o">)</span>
</code></pre></div>
<p>but this does not work because if we check the definition of <code>autoParam</code> (which is the name of the feature used to generate <code>h</code>) we find that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">  Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses</span>
<span class="sd">  the given tactic.</span>
<span class="sd">  Like `optParam`, this gadget only affects elaboration.</span>
<span class="sd">  For example, the tactic will *not* be invoked during type class resolution. -/</span>
</code></pre></div>
<p>and this is where I didn't know how to proceed anymore.</p>



<a name="265295574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295574">(Dec 17 2021 at 13:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265294746">said</a>:</p>
<blockquote>
<p>Ohh, I didn't read the question in title properly. What would you suggest to use instead of Fin? </p>
<p>I see two options</p>
<ol>
<li>Ditch algebraic structure on Fin.</li>
<li>Use Nat or Int and always provide proof of valid index.</li>
</ol>
<p>I find both options clunky to use and rather accept this sometimes unintuitive behavior of Fin.</p>
</blockquote>
<p>I think bounded <code>Nat</code> type with safe arithmetic operations and sugar and without implicit truncation would be enough.</p>



<a name="265295722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295722">(Dec 17 2021 at 13:34)</a>:</h4>
<p>What is 'safe arithmetics+without implicit truncation'?</p>



<a name="265295796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295796">(Dec 17 2021 at 13:34)</a>:</h4>
<p>You have saturating addition, which gives you a valid monoid.</p>



<a name="265295970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295970">(Dec 17 2021 at 13:36)</a>:</h4>
<p>And multiplication still makes sense, in that it's iterated addition. So distributivity still works and you get a semiring.</p>



<a name="265295986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265295986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265295986">(Dec 17 2021 at 13:36)</a>:</h4>
<p>Cool, I wasn't aware of saturation arithmetics. That looks like a very reasonable path to take.</p>



<a name="265296049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265296049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265296049">(Dec 17 2021 at 13:37)</a>:</h4>
<p>But it shouldn't be called Fin. Because that's a choice that's been argued over many times, and it's probably easier to just have a new type.</p>



<a name="265296316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265296316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265296316">(Dec 17 2021 at 13:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265295722">said</a>:</p>
<blockquote>
<p>What is 'safe arithmetics+without implicit truncation'?</p>
</blockquote>
<p>I mean checked addition/subtraction without modular arithmetic.</p>



<a name="265296572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265296572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265296572">(Dec 17 2021 at 13:43)</a>:</h4>
<p>Evgeniy, is 10 - 6, when operating in Index 5, 4 or 0?</p>



<a name="265297052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265297052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265297052">(Dec 17 2021 at 13:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265296572">said</a>:</p>
<blockquote>
<p>Evgeniy, is 10 - 6, when operating in Index 5, 4 or 0?</p>
</blockquote>
<p>Didn't you think both 10 and 6 should be unrepresentable in Index 5?</p>



<a name="265297745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265297745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265297745">(Dec 17 2021 at 13:54)</a>:</h4>
<p>I am trying to figure out our specification. If a user provides the syntax "10 - 6" to represent a term of index 5, we have several options. Runtime error is always possible. Another is to interpret that whole syntax as a term of nat, and then truncate, which gives 4. Or to interpret the subtraction as happening in Index 5, then interpret each numerical syntax as terms in index 5, which gives 4 - 4 = 0.</p>



<a name="265297825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265297825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265297825">(Dec 17 2021 at 13:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407798">Evgeniy Kuznetsov</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265296316">said</a>:</p>
<blockquote>
<p>I mean checked addition/subtraction without modular arithmetic.</p>
</blockquote>
<p>Checked by proof or at runtime? <br>
If by proof then the go to access function should probably be <code>Array.uget</code> and maybe having <code>a[i]</code> expand to <code>a.uget i (by linarith)</code>. I would be interested if that would work in practice or <code>linarith</code>(or any other appropriate tactic) would fail anytime the index operations would get a bit more involved.<br>
At runtime, you would be breaking the purity of the code and would have to embed everything in a monad.</p>



<a name="265300084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265300084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265300084">(Dec 17 2021 at 14:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265297825">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="407798">Evgeniy Kuznetsov</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265296316">said</a>:</p>
<blockquote>
<p>I mean checked addition/subtraction without modular arithmetic.</p>
</blockquote>
<p>Checked by proof or at runtime? <br>
If by proof then the go to access function should probably be <code>Array.uget</code> and maybe having <code>a[i]</code> expand to <code>a.uget i (by linarith)</code>. I would be interested if that would work in practice or <code>linarith</code>(or any other appropriate tactic) would fail anytime the index operations would get a bit more involved.<br>
At runtime, you would be breaking the purity of the code and would have to embed everything in a monad.</p>
</blockquote>
<p>By proof. <br>
I agree with you that in comparison with <code>Array.get</code> and <code>Array.get!</code>  functions <code>Array.uget</code> and <code>Array.get?</code> are more predictable.  <br>
I just had a thought that one time in a docs will appear a chapter "Avoid Array.get" how it was already happened with <a href="https://wiki.haskell.org/Avoiding_partial_functions">partial functions in haskell</a></p>



<a name="265302322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265302322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265302322">(Dec 17 2021 at 14:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265297745">said</a>:</p>
<blockquote>
<p>I am trying to figure out our specification. If a user provides the syntax "10 - 6" to represent a term of index 5, we have several options. Runtime error is always possible. Another is to interpret that whole syntax as a term of nat, and then truncate, which gives 4. Or to interpret the subtraction as happening in Index 5, then interpret each numerical syntax as terms in index 5, which gives 4 - 4 = 0.</p>
</blockquote>
<p>Perhaps implicit coercion from <code>Nat</code> should be prohibited, except for very primitive scenarios like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="mi">5</span> <span class="o">:=</span> <span class="mi">4</span>
</code></pre></div>
<p>when it 'obvious' for elaborator</p>



<a name="265302978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265302978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265302978">(Dec 17 2021 at 14:35)</a>:</h4>
<blockquote>
<p>By proof.</p>
</blockquote>
<p>I would be interested in yours and others experience with proving correctness of arrays indices.</p>
<p>I got soo fed up with it and gave up on proving it, it was slowing me too much to get anything meaningful done. I ended up defining a macro:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span><span class="o">:</span><span class="n">max</span> <span class="s2">"!"</span> <span class="n">noWs</span> <span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(⟨</span><span class="bp">$</span><span class="n">t</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩)</span>
</code></pre></div>
<p>that allows me to write <code>a.get  !i</code> that converts <code>i : Nat</code> to <code>Fin a.size</code> by omitting the proof. I will come back to these proofs once I start debugging my program.</p>



<a name="265303787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265303787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265303787">(Dec 17 2021 at 14:41)</a>:</h4>
<p>Tomas, you're asking for a runtime proof generator for propositions of inequalities. That's what norm_num does in mathlib3</p>



<a name="265344685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265344685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265344685">(Dec 17 2021 at 19:07)</a>:</h4>
<p>I may be missing something, but I'm not sure how saturation as opposed to wrapping is going to solve the issue of getting the wrong element or having unexpected results from coercions. If you have an array of length 10, and you try to get the <code>4+8</code>th element, returning the last element using saturating addition  is generally going to be just as wrong as returning the element you'd get by wrapping. </p>
<p>I know almost nothing about C++, but the comparison seems kind of apples to oranges since the array size is part of the type, and the indices are constants.</p>



<a name="265345116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265345116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265345116">(Dec 17 2021 at 19:11)</a>:</h4>
<p>Or more realistically, if you are comparing elements <code>i</code> and <code>i+1</code> of an array for each <code>i</code>, you probably don't want to compare the last element to the first element or to itself.</p>



<a name="265345303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265345303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265345303">(Dec 17 2021 at 19:12)</a>:</h4>
<p>Maybe an idea is rather than saturation, have, basically, <code>Option (Fin n)</code> where values that go outside the range become <code>None</code>.</p>
<p>An efficient implementation for array access might be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Fin but where arithmetic operations going outside range become invalid values,</span>
<span class="sd">and values are represented as `USize`. -/</span>
<span class="kd">def</span> <span class="n">SFin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Quot</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≥</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span>
</code></pre></div>
<p>This uses all values outside the range as equivalent sentinel values.</p>



<a name="265348422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265348422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265348422">(Dec 17 2021 at 19:33)</a>:</h4>
<p>fwiw Mathlib4 does provide checked arithmetic for <code>Fin n</code> that ends up in <code>Option (Fin n)</code>; there's also a method pattern taken from rust where you get <code>(Bool x Fin n)</code> back, returning the result and a flag for over/underflow: <a href="https://github.com/leanprover-community/mathlib4/blob/6276f24a77e6d7d8caa0c0a3f82e2ccf9a7e4289/Mathlib/Data/Fin/Basic.lean#L127">https://github.com/leanprover-community/mathlib4/blob/6276f24a77e6d7d8caa0c0a3f82e2ccf9a7e4289/Mathlib/Data/Fin/Basic.lean#L127</a></p>



<a name="265368851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265368851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265368851">(Dec 17 2021 at 22:22)</a>:</h4>
<p><span class="user-mention" data-user-id="407798">@Evgeniy Kuznetsov</span> One think that it might help to remember is that <code>Fin</code> is used in the Lean core to implement native unsigned integers (e.g, <code>UInt8</code>/<code>UInt32</code>/<code>USize</code>), so it is important that <code>Fin</code> shares their behavior. Since such things do silently overflow and underflow at runtime, <code>Fin</code> needs to do so as well.</p>
<p>To handle array indices in a safe manner, I think <span class="user-mention" data-user-id="306601">@Kyle Miller</span>'s suggestion is great alternative.</p>



<a name="265498302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265498302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265498302">(Dec 19 2021 at 20:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F/near/265368851">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="407798">Evgeniy Kuznetsov</span> One think that it might help to remember is that <code>Fin</code> is used in the Lean core to implement native unsigned integers (e.g, <code>UInt8</code>/<code>UInt32</code>/<code>USize</code>), so it is important that <code>Fin</code> shares their behavior. Since such things do silently overflow and underflow at runtime, <code>Fin</code> needs to do so as well.</p>
</blockquote>
<p>I don't see why this follows, since e.g. <code>USize</code> is a structure wrapper around <code>Fin</code>.</p>



<a name="265499265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265499265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265499265">(Dec 19 2021 at 20:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> yes, but they just directly inherit the Lean-level implementations of operations (e.g., <code>add</code>, <code>mul</code>, etc.)  from <code>Fin</code>. The wrapper is merely for the code generator.</p>



<a name="265499275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265499275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265499275">(Dec 19 2021 at 20:47)</a>:</h4>
<p>but anyways surely the correct approach is to first decide what behavior we want, then adjust the implementation to match?</p>



<a name="265499406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265499406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265499406">(Dec 19 2021 at 20:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <code>UInt8</code>/<code>UInt32</code>/<code>USize</code>/etc. have a fixed native behavior, <code>Fin</code> is the Lean abstraction of this behavior (so that the modulo arithmetic does not have to be copied to each of <code>UInt8</code>/<code>UInt32</code>/<code>USize</code>/etc.). I don't think there is any behavior there that is changeable (but I may be wrong).</p>



<a name="265499514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265499514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265499514">(Dec 19 2021 at 20:53)</a>:</h4>
<p>One thing that could be done though is to leave the name <code>Fin</code> for mathematics and use something like <code>APNat</code>/<code>APInt</code> for the codegen version.</p>



<a name="265510794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Isn%27t%20Fin%20a%20bad%20type%20for%20safe%20array%20lookup%3F/near/265510794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn't.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html#265510794">(Dec 20 2021 at 00:59)</a>:</h4>
<p>I think the lean 4 definition of fin does not agree with the lean 3 definition? Maybe this was because of mathematicians?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
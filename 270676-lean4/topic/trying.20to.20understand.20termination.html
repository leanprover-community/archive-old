---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/trying.20to.20understand.20termination.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html">trying to understand termination</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="269224201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269224201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alice Laroche <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269224201">(Jan 25 2022 at 08:40)</a>:</h4>
<p>So, i really want to understand how termination work, so i writed this function</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">blah</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span>    <span class="o">,</span> <span class="n">m</span>  <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
</code></pre></div>
<p>My natural language proof of this terminating is something like </p>
<p>let's prove that for all n m, <code>blah n m</code> terminate and is equal 0, by induction on n<br>
if n equal 0 , then <code>blah 0 m</code> equal 0, so <code>blah 0 m</code> terminate and is equal 0<br>
Let's assume <code>blah n m</code> terminate and is equal 0 for all m<br>
So <code>blah n (n + 1)</code> terminate and is equal 0 and so does <code>blah n (m + 1)</code><br>
So <code>blah (n + 1) m</code> is equal to  <code>blah 0 0</code> which terminate and is equal 0<br>
By induction, for all n m <code>blah n m</code> terminate and is equal 0</p>
<p>But i dn't know how to put this in lean, or if it it's how it's done to begin with</p>



<a name="269261239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269261239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269261239">(Jan 25 2022 at 14:08)</a>:</h4>
<p>Your definition is especially tricky because in proving that a function with that definition exists (i.e. that it terminates). In the process of proving termination however, we do know that all the expressions involved are well-typed and this is something we can work with. </p>
<p>Instead of returning a natural number we're going to return a subtype: a natural number with the proof that it is always equal to zero:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">JustZero</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">//</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">JustZero.property</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">JustZero</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x.val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">Subtype.property</span> <span class="n">x</span>
</code></pre></div>
<p>then your function definition becomes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">blah</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">JustZero</span>
<span class="bp">|</span> <span class="mi">0</span>    <span class="o">,</span> <span class="n">m</span>  <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="n">termination_by</span>
  <span class="n">blah</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">n</span>
</code></pre></div>
<p>but Lean still needs a bit of help with proving that this actually decreases so we add:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">decreasing_by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">JustZero.property</span><span class="o">]</span> <span class="bp">&lt;;&gt;</span>
  <span class="n">first</span>
  <span class="bp">|</span> <span class="n">apply</span> <span class="n">Nat.zero_lt_succ</span>
  <span class="bp">|</span> <span class="n">apply</span> <span class="n">Nat.lt_succ_self</span>
</code></pre></div>



<a name="269261376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269261376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269261376">(Jan 25 2022 at 14:09)</a>:</h4>
<p>My <code>decreasing_by</code> is not as polished as I'd like but I'm still getting familiar with the construct. Any comments on improving it would be welcome</p>



<a name="269266290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269266290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269266290">(Jan 25 2022 at 14:45)</a>:</h4>
<p>A common pattern is to use <code>decreasing_by assumption</code> (or leave it out entirely).  You then write the termination proof directly next to the recursive call:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="bp">...</span>
<span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
</code></pre></div>



<a name="269268493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269268493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269268493">(Jan 25 2022 at 14:59)</a>:</h4>
<p>Nice thanks! For some reason I didn't think of trying the Lean 3 approach. </p>
<p>The definition now becomes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">blah</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">JustZero</span>
<span class="bp">|</span> <span class="mi">0</span>    <span class="o">,</span> <span class="n">m</span>  <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">m</span> <span class="bp">=&gt;</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
    <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">JustZero.property</span><span class="o">,</span> <span class="n">Nat.zero_lt_succ</span><span class="o">]</span>
  <span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>

<span class="n">termination_by</span>
  <span class="n">blah</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">n</span>
</code></pre></div>



<a name="269276249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269276249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269276249">(Jan 25 2022 at 15:49)</a>:</h4>
<p>Doesn't this defeat the purpose of the recursive function?</p>
<blockquote>
<p><code>def JustZero := { i : Nat // i = 0 }</code></p>
</blockquote>
<p>You could just write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">blah</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span>  <span class="bp">=&gt;</span> <span class="mi">0</span>
</code></pre></div>
<p>What if you can't simplify the function? I think the proper way would be to use <code>termination_by</code> to prove that it terminates for any <code>m</code> when <code>n = 0</code> and then prove that if it terminates for some <code>n</code>, then it terminates for <code>n + 1</code>.</p>
<p>I don't know how it is supposed to be done in Lean 4, but in Isabelle/HOL you can prove termination partially and then use induction to prove termination for the rest of the cases. Maybe Lean 4 can implement a similar mechanism.</p>



<a name="269277672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269277672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alice Laroche <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269277672">(Jan 25 2022 at 15:58)</a>:</h4>
<p>Well this function has no purpose anyway, it's just a tool for learning.<br>
This construction is actually useful for me, but you're right I would like to do it the way you present</p>



<a name="269277767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269277767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269277767">(Jan 25 2022 at 15:59)</a>:</h4>
<p>You can make that work with mathlib's <code>roption</code> type actually. </p>
<p>As for defeating the purpose, I think you need to take a step back and see that this is a minimized example. You can make it work with <code>JustZero</code> or with any other subtype you like.</p>



<a name="269278827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269278827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269278827">(Jan 25 2022 at 16:05)</a>:</h4>
<p>BTW, <code>roption</code> is called <code>part</code> now.</p>



<a name="269278833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269278833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alice Laroche <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269278833">(Jan 25 2022 at 16:05)</a>:</h4>
<p>(deleted)</p>



<a name="269278915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269278915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269278915">(Jan 25 2022 at 16:05)</a>:</h4>
<p>Thanks! That's a better name, I'm glad the change was made</p>



<a name="269279323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269279323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269279323">(Jan 25 2022 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/270676-lean4/topic/trying.20to.20understand.20termination/near/269276249">said</a>:</p>
<blockquote>
<p>I don't know how it is supposed to be done in Lean 4, but in Isabelle/HOL you can prove termination partially and then use induction to prove termination for the rest of the cases. Maybe Lean 4 can implement a similar mechanism.</p>
</blockquote>
<p>Can you point me to some Isabelle code to see how this looks?</p>



<a name="269286415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269286415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269286415">(Jan 25 2022 at 16:54)</a>:</h4>
<blockquote>
<p>Can you point me to some Isabelle code to see how this looks?</p>
</blockquote>
<p>See section 8.1 of <a href="https://isabelle.in.tum.de/dist/Isabelle2021-1/doc/functions.pdf">https://isabelle.in.tum.de/dist/Isabelle2021-1/doc/functions.pdf</a>. After defining equations, but before proving termination, Isabelle automatically defines a partial function constrained to the domain where the actual function terminates. We can then inductively build the domain of the function, eventually proving that the domain covers all valid inputs.</p>
<p>It is much harder to do in Lean. Consider this function (in Lean 3):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>
<p>How would you prove that it terminates, without modifying the type of the function or defining new functions? In Isabelle, you can simply prove that <code>(m, 0)</code> is in the domain for all <code>m</code> and prove that if <code>(m, n)</code> is in the domain, then <code>(n, m)</code> is also in the domain, and then you can prove that <code>n &lt; n + 1</code> to finish the termination proof.</p>



<a name="269288105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269288105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alice Laroche <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269288105">(Jan 25 2022 at 17:03)</a>:</h4>
<p>Actually this one is easy, because (n + m) reduce every step<br>
So you can do (in Lean 4)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">helper1</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">n</span>
   <span class="n">rw</span> <span class="o">[</span><span class="n">succ_add</span><span class="o">,</span> <span class="n">Nat.add_comm</span><span class="o">]</span>
   <span class="n">apply</span> <span class="n">Nat.succ_le_succ</span>
   <span class="n">apply</span> <span class="n">Nat.le_refl</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">,</span> <span class="mi">0</span>       <span class="bp">=&gt;</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">helper1</span> <span class="n">m</span> <span class="n">n</span>
                 <span class="n">f</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="n">termination_by</span> <span class="n">f</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>
</code></pre></div>



<a name="269296063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269296063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269296063">(Jan 25 2022 at 17:54)</a>:</h4>
<p>Fair enough. But my point was that Lean 4 should have a mechanism to inductively build the domain of a function and also allow users to use partial function until they prove it's total.</p>



<a name="269296828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269296828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alice Laroche <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269296828">(Jan 25 2022 at 17:59)</a>:</h4>
<p>Oh you're completely right, I just wanted to train actually</p>



<a name="269297336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269297336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> František Silváši <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269297336">(Jan 25 2022 at 18:01)</a>:</h4>
<p>Somewhat unrelated, I was trying to think of where I've seen that before and then it hit me. There's a 'standard' example  of a function that alternates elements of two sequences,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alternate</span> <span class="o">(</span><span class="n">l₁</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">h₂</span> <span class="o">::</span> <span class="n">t₂</span> <span class="bp">=&gt;</span> <span class="n">h₂</span> <span class="o">::</span> <span class="n">alternate</span> <span class="n">t₂</span> <span class="n">l₁</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">l₁</span>
<span class="n">termination_by</span> <span class="n">alternate</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">=&gt;</span> <span class="n">l₁.length</span> <span class="bp">+</span> <span class="n">l₂.length</span>
<span class="n">decreasing_by</span> <span class="bp">...</span>
</code></pre></div>
<p>where this 'argument swap' has semantics beyond 'f', which I reckon makes it much clearer what the termination criterion is. (This of course is besides the point in more than one way.)</p>



<a name="269357790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269357790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269357790">(Jan 26 2022 at 03:24)</a>:</h4>
<p>I had a related question: I had a function that makes three recursive calls to itself. Is there a good way to use <code>termination_by</code> for such a situation. I used an auxiliary bound. For concreteness, I mean something similar to the below definitions.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">gcd0</span><span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">Nat</span><span class="o">):</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">a</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="k">then</span> <span class="n">gcd</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span> <span class="bp">%</span> <span class="n">b</span><span class="o">)</span> <span class="k">else</span> <span class="n">gcd</span> <span class="o">(</span><span class="n">b</span> <span class="bp">%</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">gcd1</span><span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)(</span><span class="n">wa</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)(</span><span class="n">wb</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">):</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- the total definition with some work</span>
</code></pre></div>



<a name="269365000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365000">(Jan 26 2022 at 05:17)</a>:</h4>
<p><span class="user-mention" data-user-id="266304">@Siddhartha Gadgil</span> In that case, you could use <code>a + b</code> as a termination measure</p>



<a name="269365275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365275">(Jan 26 2022 at 05:22)</a>:</h4>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span> I proposed something along those lines early in lean 4, and the response I got was that <code>partial</code> is a MVP to make writing general recursive functions possible, and making something more suitable for proofs was a low priority. We have since gained <code>termination_by</code> which helps with a lot of these types of proofs, but I still think that an automatic domain predicate is possible (I have a general idea of how to do the desugaring, although dependent types complicate matters), and there are some kinds of functions that can't be proven to terminate using only <code>termination_by</code> (like Alice's original <code>blah</code> function before Simon changed the codomain to <code>JustZero</code>) but can be proven with an external domain predicate.</p>



<a name="269365299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365299">(Jan 26 2022 at 05:23)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> . <br>
My actual case is more complicated - the recursive calls are to the tail of a list and the two pieces of a list strictly before and strictly after some element in the list. All can be proved shorter than the original list, so the auxiliary bound method works. I was wondering if there is some <code>termination_by</code> approach for this.</p>



<a name="269365313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365313">(Jan 26 2022 at 05:23)</a>:</h4>
<p>You should not need to add another argument</p>



<a name="269365355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365355">(Jan 26 2022 at 05:24)</a>:</h4>
<p>in fact I would advise against it since this affects code generation</p>



<a name="269365365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365365">(Jan 26 2022 at 05:24)</a>:</h4>
<p>could you give an example?</p>



<a name="269365385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365385">(Jan 26 2022 at 05:24)</a>:</h4>
<p>The code with <code>partial def</code> is at <a href="https://github.com/siddhartha-gadgil/Polylean/blob/main/Polylean/LengthBound.lean">https://github.com/siddhartha-gadgil/Polylean/blob/main/Polylean/LengthBound.lean</a>.</p>



<a name="269365394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365394">(Jan 26 2022 at 05:25)</a>:</h4>
<p>It sounds like you want to use <code>l.length</code> as the termination measure</p>



<a name="269365408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365408">(Jan 26 2022 at 05:25)</a>:</h4>
<p>It is short enough that I can paste it here (eliminating some extraneous measure).</p>



<a name="269365468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365468">(Jan 26 2022 at 05:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Letter</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">α</span> <span class="o">:</span> <span class="n">Letter</span>
  <span class="bp">|</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Letter</span>
  <span class="bp">|</span> <span class="n">α</span><span class="bp">!</span> <span class="o">:</span> <span class="n">Letter</span>
  <span class="bp">|</span> <span class="n">β</span><span class="bp">!</span> <span class="o">:</span> <span class="n">Letter</span>
  <span class="n">deriving</span> <span class="n">DecidableEq</span><span class="o">,</span> <span class="n">Repr</span><span class="o">,</span> <span class="n">Hashable</span>

<span class="kd">def</span> <span class="n">Letter.inv</span> <span class="o">:</span> <span class="n">Letter</span> <span class="bp">→</span> <span class="n">Letter</span>
  <span class="bp">|</span> <span class="n">α</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="bp">!</span>
  <span class="bp">|</span> <span class="n">β</span>  <span class="bp">=&gt;</span> <span class="n">β</span><span class="bp">!</span>
  <span class="bp">|</span> <span class="n">α</span><span class="bp">!</span> <span class="bp">=&gt;</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">β</span><span class="bp">!</span> <span class="bp">=&gt;</span> <span class="n">β</span>

<span class="kd">postfix</span><span class="o">:</span><span class="n">max</span> <span class="s2">"⁻¹"</span> <span class="bp">=&gt;</span> <span class="n">Letter.inv</span>

<span class="n">abbrev</span> <span class="n">Word</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">Letter</span>

<span class="c1">-- split a word into parts before and after each occurrence of a letter `l`</span>
<span class="kd">def</span> <span class="n">splits</span><span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Letter</span><span class="o">)</span> <span class="o">:</span> <span class="n">Word</span> <span class="bp">→</span> <span class="n">List</span> <span class="o">(</span><span class="n">Word</span> <span class="bp">×</span> <span class="n">Word</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">tailSplits</span> <span class="o">:=</span> <span class="o">(</span><span class="n">splits</span> <span class="n">l</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">))</span>
    <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">l</span> <span class="k">then</span> <span class="o">([],</span> <span class="n">ys</span><span class="o">)</span> <span class="o">::</span> <span class="n">tailSplits</span> <span class="k">else</span> <span class="n">tailSplits</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">Word</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">base</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys</span><span class="o">)</span>
    <span class="k">let</span> <span class="n">derived</span> <span class="o">:=</span> <span class="o">(</span><span class="n">splits</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">length</span> <span class="n">fst</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">snd</span><span class="o">)</span>
    <span class="n">derived.foldl</span> <span class="n">min</span> <span class="n">base</span> <span class="c1">-- minimum of base and elements of derived</span>
</code></pre></div>



<a name="269365835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269365835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269365835">(Jan 26 2022 at 05:33)</a>:</h4>
<p>I think I understand. when I paste <code>termination_by length l =&gt; l.length</code> I get an error that assumption failed to prove <code>List.length fst &lt; Nat.succ (List.length ys)</code>. But following the idea mentioned by <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I should give proofs <code>have ...</code> with bounds for these just before <code>termination_by</code>.</p>
<p>I have to prove the bounds anyway, so I use them this way instead of with an auxiliary parameter. I will work on this.</p>



<a name="269366115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269366115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269366115">(Jan 26 2022 at 05:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- split a word into parts before and after each occurrence of a letter `l`</span>
<span class="kd">def</span> <span class="n">splits</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Letter</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">Word</span><span class="o">)</span> <span class="bp">→</span> <span class="n">List</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">Word</span> <span class="bp">×</span> <span class="n">Word</span> <span class="bp">//</span> <span class="n">p.1.length</span> <span class="bp">+</span> <span class="n">p.2.length</span> <span class="bp">&lt;</span> <span class="n">w.length</span><span class="o">}</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">tailSplits</span> <span class="o">:=</span> <span class="o">(</span><span class="n">splits</span> <span class="n">l</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="k">fun</span> <span class="o">⟨(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">),</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=&gt;</span>
      <span class="o">⟨(</span><span class="n">x</span> <span class="o">::</span> <span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">),</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Nat.succ_add</span><span class="o">,</span> <span class="n">Nat.succ_lt_succ</span> <span class="n">h</span><span class="o">]⟩</span>
    <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">l</span> <span class="k">then</span> <span class="o">⟨([],</span> <span class="n">ys</span><span class="o">),</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Nat.lt_succ_self</span><span class="o">]⟩</span> <span class="o">::</span> <span class="n">tailSplits</span> <span class="k">else</span> <span class="n">tailSplits</span>

<span class="kd">def</span> <span class="n">length</span> <span class="o">:</span> <span class="n">Word</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">base</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys</span><span class="o">)</span>
    <span class="k">let</span> <span class="n">derived</span> <span class="o">:=</span> <span class="o">(</span><span class="n">splits</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="k">fun</span> <span class="o">⟨(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">),</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=&gt;</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">Nat.lt_trans</span> <span class="n">h</span> <span class="o">(</span><span class="n">Nat.lt_succ_self</span> <span class="n">_</span><span class="o">)</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">Nat.lt_of_le_of_lt</span> <span class="o">(</span><span class="n">Nat.le_add_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">Nat.lt_of_le_of_lt</span> <span class="o">(</span><span class="n">Nat.le_add_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span>
      <span class="n">length</span> <span class="n">fst</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">snd</span>
    <span class="n">derived.foldl</span> <span class="n">min</span> <span class="n">base</span> <span class="c1">-- minimum of base and elements of derived</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">l.length</span>
</code></pre></div>



<a name="269367035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269367035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269367035">(Jan 26 2022 at 05:55)</a>:</h4>
<p>That's very nice. Thanks a lot. it shows me how to use sub-types effectively too (instead of custom types I have been using).</p>



<a name="269381427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269381427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alice Laroche <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269381427">(Jan 26 2022 at 09:18)</a>:</h4>
<p>So, i was trying to apply my new knowledge about subtypes on more intricated functions, and the i got into this : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Inf</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">//</span> <span class="n">n'</span> <span class="bp">&lt;=</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">blah</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Inf</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="o">,</span> <span class="n">m</span>       <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">Nat.zero_le</span> <span class="n">_</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="mi">0</span>       <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">Nat.le.refl</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
                        <span class="kd">by</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span>
                           <span class="n">apply</span> <span class="n">Nat.le_trans</span> <span class="n">h</span>
                           <span class="n">apply</span> <span class="n">Nat.le_succ</span>
                      <span class="o">⟩</span>
<span class="n">termination_by</span> <span class="n">blah</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>Here the subtypes say that <code>blah n (n + 1)</code> is inferior or equal to (n + 1)<br>
But lean can't infer that  ((blah n (n + 1).val , m) &lt; (n + 1, m + 1)</p>



<a name="269481507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/trying%20to%20understand%20termination/near/269481507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/trying.20to.20understand.20termination.html#269481507">(Jan 26 2022 at 21:00)</a>:</h4>
<p>It works if you parametrize <code>Inf</code> with the first argument instead of the second:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Inf</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">//</span> <span class="n">n'</span> <span class="bp">&lt;=</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">blah</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Inf</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>      <span class="o">,</span> <span class="n">m</span>       <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">Nat.zero_le</span> <span class="n">_</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="mi">0</span>       <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">Nat.zero_le</span> <span class="n">_</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
                        <span class="n">cases</span> <span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
                        <span class="n">apply</span> <span class="n">Nat.lt_succ_of_le</span>
                        <span class="n">assumption</span>
                      <span class="o">⟨(</span><span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
                        <span class="kd">by</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">blah</span> <span class="o">(</span><span class="n">blah</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span>
                           <span class="n">apply</span> <span class="n">Nat.le_trans</span> <span class="n">h</span>
                           <span class="n">apply</span> <span class="n">Nat.le_of_lt</span>
                           <span class="n">assumption</span> <span class="o">⟩</span>
<span class="n">termination_by</span> <span class="n">blah</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/type.20mismatch.20error.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html">type mismatch error</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225226077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225226077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225226077">(Feb 04 2021 at 21:33)</a>:</h4>
<p>Trying to feel out some simple things in Lean 4, I'm not able to get this Lean 3 theorem to work, but I'm not sure why. Is there an easy way to get more information out of the <code>?m.166</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Lean 3 version</span>
<span class="kd">structure</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">PointExt_lean3</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="n">q</span><span class="o">),</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">Point.rec_on</span> <span class="n">p</span> <span class="bp">$</span>
<span class="k">fun</span> <span class="n">z1</span> <span class="n">q</span><span class="o">,</span> <span class="n">Point.rec_on</span> <span class="n">q</span> <span class="bp">$</span>
<span class="k">fun</span> <span class="n">z2</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z2</span><span class="o">)),</span> <span class="n">congr_arg</span> <span class="n">Point.mk</span> <span class="n">hA</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">PointExt_lean4</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="n">q</span><span class="o">),</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">Point.recOn</span> <span class="n">p</span> <span class="bp">$</span>
<span class="k">fun</span> <span class="n">z1</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="n">Point.recOn</span> <span class="n">q</span> <span class="bp">$</span>
<span class="k">fun</span> <span class="n">z2</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z2</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="n">congrArg</span> <span class="n">Point.mk</span> <span class="n">hA</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch</span>
<span class="cm">  Point.recOn p</span>
<span class="cm">    fun (z1 : Int) (q : Point) =&gt;</span>
<span class="cm">      Point.recOn q fun (z2 : Int) (hA : { x := z1 }.x = { x := z2 }.x) =&gt; congrArg Point.mk hA</span>
<span class="cm">has type</span>
<span class="cm">  ?m.166 p p</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  (q : Point) → p.x = q.x → p = q</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="225227325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225227325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225227325">(Feb 04 2021 at 21:41)</a>:</h4>
<p>I think this is because the <code>elab_as_eliminator</code> elaboration strategy doesn't exist anymore</p>



<a name="225227483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225227483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225227483">(Feb 04 2021 at 21:42)</a>:</h4>
<p>which means that using <code>recOn</code> directly is always going to be painful</p>



<a name="225227531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225227531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225227531">(Feb 04 2021 at 21:43)</a>:</h4>
<p>The alternative is to use <code>induction using</code></p>



<a name="225228675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225228675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225228675">(Feb 04 2021 at 21:51)</a>:</h4>
<p>Here's a version using match:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Int</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">PointExt_lean4</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p.x</span> <span class="bp">=</span> <span class="n">q.x</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">p</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">z1</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="k">fun</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">z2</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z2</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="n">congrArg</span> <span class="n">Point.mk</span> <span class="n">hA</span>
</code></pre></div>



<a name="225228686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225228686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225228686">(Feb 04 2021 at 21:51)</a>:</h4>
<p>Thanks, I wasn't aware of how much work <code>elab_as_eliminator</code> was doing in the garden-variety case. The lean 4 version does work if I specify the motive.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">PointExt_lean4</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="n">q</span><span class="o">),</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">Point.recOn</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">hp</span> <span class="bp">=&gt;</span> <span class="k">forall</span> <span class="n">hq</span> <span class="o">(</span><span class="n">hh</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="n">hp</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="n">hq</span><span class="o">),</span> <span class="n">hp</span> <span class="bp">=</span> <span class="n">hq</span><span class="o">)</span> <span class="n">p</span> <span class="bp">$</span>
<span class="k">fun</span> <span class="n">z1</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="n">Point.recOn</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">Point.x</span> <span class="bp">$</span> <span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Point.x</span> <span class="n">_x</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">_x</span><span class="o">))</span> <span class="n">q</span> <span class="bp">$</span>
<span class="k">fun</span> <span class="n">z2</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z2</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="n">congrArg</span> <span class="n">Point.mk</span> <span class="n">hA</span>
</code></pre></div>



<a name="225228721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225228721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225228721">(Feb 04 2021 at 21:51)</a>:</h4>
<p>We will not support <code>elab_as_eliminator</code>. Users should use <code>match ... with ...</code> or tactics such as <code>induction</code> and <code>cases</code>.<br>
If <code>match ... with ...</code> is not applicable, and you want to keep working in term mode, you can write a macro that "switches" to tactic mode and back into term mode.</p>



<a name="225229010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229010">(Feb 04 2021 at 21:53)</a>:</h4>
<p>Thanks to both of you. That match example is nice. I'll take a closer look at the new version induction.</p>



<a name="225229053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229053">(Feb 04 2021 at 21:53)</a>:</h4>
<p>Is there a way to use <code>match</code> and/or <code>induction</code> such that we can be sure that <code>recOn</code> is getting called (as opposed to some more complicated <code>below</code> compilation or such)?</p>



<a name="225229324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229324">(Feb 04 2021 at 21:56)</a>:</h4>
<p><span class="user-mention" data-user-id="228466">@Chris B</span> Note that writing <code>: forall (q : Point) ...</code> is a trick to make Lean3 <code>elam_as_eliminator</code> + <code>recOn</code> work. You don't need this kind of trick when using <code>match</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Int</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">PointExt_lean4</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">h1</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">h1</span> <span class="bp">=&gt;</span> <span class="n">congrArg</span> <span class="n">Point.mk</span> <span class="n">h1</span>

<span class="kd">theorem</span> <span class="n">PointExt_lean4'</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">p</span>
  <span class="n">cases</span> <span class="n">q</span>
  <span class="n">exact</span> <span class="n">congrArg</span> <span class="n">Point.mk</span> <span class="n">h1</span>
</code></pre></div>



<a name="225229403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229403">(Feb 04 2021 at 21:56)</a>:</h4>
<p>Here's a proof using <code>induction using</code>, which I think should get the term right:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Int</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">PointExt_lean4</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p.x</span> <span class="bp">=</span> <span class="n">q.x</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">induction</span> <span class="n">p</span> <span class="n">using</span> <span class="n">Point.recOn</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="n">z1</span> <span class="bp">=&gt;</span> <span class="n">intro</span> <span class="n">q</span><span class="bp">;</span> <span class="n">induction</span> <span class="n">q</span> <span class="n">using</span> <span class="n">Point.recOn</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="n">z2</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="k">fun</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Point.x</span> <span class="o">(</span><span class="n">Point.mk</span> <span class="n">z2</span><span class="o">))</span> <span class="bp">=&gt;</span> <span class="n">congrArg</span> <span class="n">Point.mk</span> <span class="n">hA</span>
</code></pre></div>



<a name="225229551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229551">(Feb 04 2021 at 21:57)</a>:</h4>
<p>(of course there are much easier ways to write this expression, like Leo's version)</p>



<a name="225229565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229565">(Feb 04 2021 at 21:57)</a>:</h4>
<p>Wow, Lean Zulip really coming through on this one</p>



<a name="225229740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229740">(Feb 04 2021 at 21:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225229053">said</a>:</p>
<blockquote>
<p>Is there a way to use <code>match</code> and/or <code>induction</code> such that we can be sure that <code>recOn</code> is getting called (as opposed to some more complicated <code>below</code> compilation or such)?</p>
</blockquote>
<p>The <code>induction</code> tactic by default uses <code>rec</code>. <code>recOn</code> is just a simple wrapper on top of <code>rec</code> that puts the major premise before minor premises.</p>



<a name="225229962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225229962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225229962">(Feb 04 2021 at 22:00)</a>:</h4>
<p><code>rec</code> works too. I'm just thinking about those examples where lean 3's compilation strategy either results in a term that is slow to kernel-compute or doesn't support something like small eliminating inductive predicates</p>



<a name="225230039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225230039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225230039">(Feb 04 2021 at 22:01)</a>:</h4>
<p>I would usually either use <code>rec</code>/<code>rec_on</code> or <code>induction</code> to construct the term in those cases</p>



<a name="225230378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225230378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225230378">(Feb 04 2021 at 22:04)</a>:</h4>
<p>here's the golf version</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">PointExt_lean4</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p.x</span> <span class="bp">=</span> <span class="n">q.x</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">z</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
</code></pre></div>



<a name="225232115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225232115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225232115">(Feb 04 2021 at 22:16)</a>:</h4>
<p>Nice to see that the <code>rfl</code> trick still works :-)</p>



<a name="225232330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225232330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225232330">(Feb 04 2021 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> </p>
<blockquote>
<p>I'm just thinking about those examples where lean 3's compilation strategy either results in a term that is slow to kernel-compute </p>
</blockquote>
<p>I'm not concerned about this case. We don't rely on kernel-compute that much. Have you measured the overhead of <code>brecOn</code> vs <code>rec</code> in real examples?</p>
<blockquote>
<p>doesn't support something like small eliminating inductive predicates</p>
</blockquote>
<p>Yes, this one is a real problem. I have seen many examples where using equations would be much nicer.<br>
Right now, the best option is to switch to the tactic mode and use <code>induction</code>. In Lean 4, this is not as bad as in Lean 3 since the <code>induction</code> tactic notation is nicer. </p>
<p>I know you have been asking for this feature for ages, but it will not come anytime soon. The "equation compiler" decouples dependent pattern matching from termination checking. The code is more modular, the dependent pattern matching uses the <code>casesOn</code> recursor, and structural termination checker uses <code>brecOn</code>. Moreover, we can add new termination strategies (e.g., well-founded recursion) without even touching the dependent pattern matching modulo. To support <code>rec</code>/<code>recOn</code>, we would have to implement yet another strategy that does a bit of both: patter matching and termination checking. It will be implemented one day, but don't hold your breath :)</p>



<a name="225232586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225232586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225232586">(Feb 04 2021 at 22:21)</a>:</h4>
<blockquote>
<p>I'm not concerned about this case. We don't rely on kernel-compute that much. Have you measured the overhead of brecOn vs rec in real examples?</p>
</blockquote>
<p>These are lean 3 concerns. I'm sure that the calculus in lean 4 is completely different, but that's just an example of why I would want to do something as masochistic as using recursors directly instead of the many bits of sugar on top.</p>



<a name="225232760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225232760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225232760">(Feb 04 2021 at 22:22)</a>:</h4>
<blockquote>
<p>These are lean 3 concerns. I'm sure that the calculus in lean 4 is completely different, but that's just an example of why I would want to do something as masochistic as using recursors directly instead of the many bits of sugar on top.</p>
</blockquote>
<p>Do you have examples where you had to use <code>rec</code> manually because of a performance problem in Lean 3? How much faster was it when you switched from <code>brec_on</code> to <code>rec</code>/<code>rec_on</code>?</p>



<a name="225232788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225232788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225232788">(Feb 04 2021 at 22:23)</a>:</h4>
<p>Is <code>decTrivial</code> still a thing in lean 4? That's the main place where kernel compute comes up in mathlib, although I think it also shows up in code with a different style in third party lean 3 projects</p>



<a name="225232943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225232943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225232943">(Feb 04 2021 at 22:24)</a>:</h4>
<p>Profiling kernel computation in lean 3 is very difficult, it doesn't show up with <code>set_option profiler true</code>, so my judgment on these matters is a little coarse-grained</p>



<a name="225233235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233235">(Feb 04 2021 at 22:27)</a>:</h4>
<blockquote>
<p>Right now, the best option is to switch to the tactic mode and use induction. In Lean 4, this is not as bad as in Lean 3 since the induction tactic notation is nicer. </p>
</blockquote>
<p>I think this is fine, I have enough experience doing just this in lean 3</p>



<a name="225233282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233282">(Feb 04 2021 at 22:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225232788">said</a>:</p>
<blockquote>
<p>Is <code>decTrivial</code> still a thing in lean 4? That's the main place where kernel compute comes up in mathlib, although I think it also shows up in code with a different style in third party lean 3 projects</p>
</blockquote>
<p>Yes, it is. We have a macro called <code>decide!</code>.</p>



<a name="225233388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233388">(Feb 04 2021 at 22:28)</a>:</h4>
<p>A similar example where the kernel term is more or less unwritable in lean 3 is <code>eq.rec</code>, where it's worth it to use tactic mode just to use <code>rw</code> even if nothing else is in tactic mode</p>



<a name="225233622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233622">(Feb 04 2021 at 22:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225233388">said</a>:</p>
<blockquote>
<p>A similar example where the kernel term is more or less unwritable in lean 3 is <code>eq.rec</code>, where it's worth it to use tactic mode just to use <code>rw</code> even if nothing else is in tactic mode</p>
</blockquote>
<p>We have a custom elaborator for generating <code>Eq.rec</code> applications in term mode.<br>
The notation is also available in Lean 3  <code>h ▸ e</code>. However, the Lean 4 elaborator for this notation is supposed to be better.</p>



<a name="225233678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233678">(Feb 04 2021 at 22:31)</a>:</h4>
<p>But supposing the user wanted to have a syntax like applying a term, I guess it wouldn't be too bad to add a macro like <code>elim!(Foo.rec_on) x ...</code> which either calls <code>induction</code> internals or just reimplements the <code>elab_as_eliminator</code> magic itself</p>



<a name="225233769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233769">(Feb 04 2021 at 22:32)</a>:</h4>
<p>(that should be implementable outside the core, I think?)</p>



<a name="225233917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233917">(Feb 04 2021 at 22:33)</a>:</h4>
<p>Yeah, <code> h ▸ e</code> does show up in mathlib occasionally, but it fails in a lot of situations where <code>by rw h; exact e</code> works - I think the main reason is metavariables in the expected type</p>



<a name="225233926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225233926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225233926">(Feb 04 2021 at 22:33)</a>:</h4>
<p>Yes, if one wants to add support to <code>elab_as_eliminator</code>. I think the one to go is to add a macro such as <code>elim! ...</code>.</p>
<blockquote>
<p>(that should be implementable outside the core, I think?)</p>
</blockquote>
<p>Yes, and if I had to do it, I would do it on top of the <code>induction</code> tactic.</p>



<a name="225234401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225234401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225234401">(Feb 04 2021 at 22:37)</a>:</h4>
<p>Do we still need <code>recOn</code> at all in lean 4? As I understand it the main reason is to make it easier to write these term proofs, since it's more natural to put the scrutinee first, but if users can't really write it anymore then it doesn't seem necessary to have it at all</p>



<a name="225234830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225234830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225234830">(Feb 04 2021 at 22:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Returning to <code>brecOn</code> vs <code>rec</code>, it would be very useful if you could get numbers for <code>dec_trivial</code> in mathlib with <code>rec</code> and <code>brecOn</code>. We have been assuming the difference is not big. If it is big, then we have a problem because the generated code for definitions using <code>rec</code> sucks. That is, one may speed up kernel reduction using <code>rec</code>, but they are also slowing down the generated C code.</p>



<a name="225235075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225235075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225235075">(Feb 04 2021 at 22:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225234401">said</a>:</p>
<blockquote>
<p>Do we still need <code>recOn</code> at all in lean 4? As I understand it the main reason is to make it easier to write these term proofs, since it's more natural to put the scrutinee first, but if users can't really write it anymore then it doesn't seem necessary to have it at all</p>
</blockquote>
<p>We needed it while transitioning from the old to the new frontend, but it is now a "leftover". We may still have code that depends on it though. It is also useful to keep it for Daniel's porting tool. Otherwise, he will have to add support for converting <code>rec_on</code> applications into <code>rec</code>.</p>



<a name="225235105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225235105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225235105">(Feb 04 2021 at 22:43)</a>:</h4>
<p>I don't think the difference is big, but it is one of the things on my list of "how to optimize code for kernel computation". The fact that optimizing for kernel computation vs VM computation is often in opposition is a long standing problem that I hope lean 4's <code>implementedBy</code> will solve</p>



<a name="225235161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225235161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225235161">(Feb 04 2021 at 22:44)</a>:</h4>
<p>I will see if I can come up with an example</p>



<a name="225236086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225236086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225236086">(Feb 04 2021 at 22:51)</a>:</h4>
<blockquote>
<p>I hope lean 4's implementedBy will solve</p>
</blockquote>
<p>Unfortunately, it doesn't solve this problem since it only requires the two definitions to have the same type. <br>
When we use <code>@[implementedBy f] def g ...</code>, we are telling the code generator: "trust me,  it is safe to replace <code>g</code> with <code>f</code>".<br>
For solving the issue you raised, we can use another feature we are planning to add: simp lemmas for the compiler. The user provers an equation lemma and tells the compiler to use it as a rewriting rule to optimize code. Haskell has a similar feature, but the rewriting rules come without proof.</p>



<a name="225237082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225237082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225237082">(Feb 04 2021 at 23:00)</a>:</h4>
<blockquote>
<p>It is also useful to keep it for Daniel's porting tool. Otherwise, he will have to add support for converting <code>rec_on</code> applications into <code>rec</code>.</p>
</blockquote>
<p>FYI I am not currently aligning <code>rec_on</code> to <code>recOn</code>.</p>



<a name="225238049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225238049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225238049">(Feb 04 2021 at 23:09)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span>  What about <code>noConfusion</code>, <code>casesOn</code>, and <code>brecOn</code>?</p>



<a name="225238866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225238866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225238866">(Feb 04 2021 at 23:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> I am not currently aligning any of them.</p>



<a name="225239054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225239054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225239054">(Feb 04 2021 at 23:19)</a>:</h4>
<p>I haven't even checked which ones are identical. For a pair that is identical, it is very easy to align.</p>



<a name="225239559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225239559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225239559">(Feb 04 2021 at 23:24)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> We need them. Otherwise, we will not be able to pattern match, use tactics such as <code>cases</code> and <code>injection</code>, use recursive equations, etc. If aligning is problematic, another option is to invoke the generators for <code>noConfusion</code>, <code>casesOn</code>, and <code>brecOn</code> from the porting tool.</p>



<a name="225239996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225239996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225239996">(Feb 04 2021 at 23:29)</a>:</h4>
<p>I will add.</p>



<a name="225242216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225242216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225242216">(Feb 04 2021 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> I just did a test using the primality test in <code>data.num.prime</code>, which has been optimized for kernel computation.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.num.prime</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">num.min_fac</span> <span class="mi">104729</span> <span class="bp">=</span> <span class="mi">104729</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>I tested replacements for three of the core functions in this computation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">pos_num.rec_on</span> <span class="n">a</span> <span class="n">succ</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">IH</span> <span class="n">b</span><span class="o">,</span> <span class="n">pos_num.cases_on</span> <span class="n">b</span> <span class="o">(</span><span class="n">bit0</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">IH</span> <span class="n">b</span><span class="o">)))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">IH</span> <span class="n">b</span><span class="o">)))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">IH</span> <span class="n">b</span><span class="o">,</span> <span class="n">pos_num.cases_on</span> <span class="n">b</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">IH</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">IH</span> <span class="n">b</span><span class="o">)))</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">pos_num</span><span class="o">)</span> <span class="o">:</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">pos_num.rec_on</span> <span class="n">b</span> <span class="n">a</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">IH</span><span class="o">,</span> <span class="n">pos_num.add</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">IH</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">IH</span><span class="o">,</span> <span class="n">bit0</span> <span class="n">IH</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">min_fac_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pos_num</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">nat.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">fuel</span> <span class="n">IH</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">k.bit1</span> <span class="bp">*</span> <span class="n">k.bit1</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">k.bit1</span> <span class="bp">∣</span> <span class="n">n</span> <span class="k">then</span> <span class="n">k.bit1</span> <span class="k">else</span>
  <span class="n">IH</span> <span class="n">k.succ</span><span class="o">)</span> <span class="n">k</span>
</code></pre></div>
<p>vs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span>
<span class="bp">|</span> <span class="mi">1</span>        <span class="n">b</span>        <span class="o">:=</span> <span class="n">succ</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">a</span>        <span class="mi">1</span>        <span class="o">:=</span> <span class="n">succ</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">pos_num</span><span class="o">)</span> <span class="o">:</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span>
<span class="bp">|</span> <span class="mi">1</span>        <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">mul</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">mul</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">min_fac_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">pos_num</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">pos_num</span> <span class="bp">→</span> <span class="n">pos_num</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fuel</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">k</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">k.bit1</span> <span class="bp">*</span> <span class="n">k.bit1</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">k.bit1</span> <span class="bp">∣</span> <span class="n">n</span> <span class="k">then</span> <span class="n">k.bit1</span> <span class="k">else</span>
  <span class="n">min_fac_aux</span> <span class="n">fuel</span> <span class="n">k.succ</span>
</code></pre></div>
<p>Since the built in profiler doesn't work, I used <code>rm test.olean; /usr/bin/time -f %U lean --make test.lean</code> to test, so the data is a bit noisy. For the equation compiler definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">13</span><span class="bp">.</span><span class="mi">89</span><span class="o">,</span> <span class="mi">13</span><span class="bp">.</span><span class="mi">82</span><span class="o">,</span> <span class="mi">14</span><span class="bp">.</span><span class="mi">02</span><span class="o">,</span> <span class="mi">13</span><span class="bp">.</span><span class="mi">64</span><span class="o">,</span> <span class="mi">13</span><span class="bp">.</span><span class="mi">71</span>
</code></pre></div>
<p>For the <code>rec</code> definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">10</span><span class="bp">.</span><span class="mi">76</span><span class="o">,</span> <span class="mi">10</span><span class="bp">.</span><span class="mi">59</span><span class="o">,</span> <span class="mi">10</span><span class="bp">.</span><span class="mi">66</span><span class="o">,</span> <span class="mi">10</span><span class="bp">.</span><span class="mi">51</span><span class="o">,</span> <span class="mi">10</span><span class="bp">.</span><span class="mi">60</span>
</code></pre></div>
<p>This suggests that the difference, while not large, is measurable, especially in hot functions like <code>add</code> and <code>mul</code> in this example, which should be called ~3,000,000 times in this test</p>



<a name="225242942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type%20mismatch%20error/near/225242942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/type.20mismatch.20error.html#225242942">(Feb 04 2021 at 23:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Thanks for testing it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
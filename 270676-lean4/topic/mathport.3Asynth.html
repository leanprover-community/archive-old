---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/mathport.3Asynth.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html">mathport:synth</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="231117451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117451">(Mar 20 2021 at 03:18)</a>:</h4>
<p>FYI I (temporarily) added support for irreducible, and tried re-synthesizing every class in every term+value auto-ported by <code>mathport</code>. The results are pretty encouraging:</p>
<p>Total: (499227 / 548358) = 0.91</p>
<div class="codehilite"><pre><span></span><code>       - success: 499227 (0.91)
        - failed:  18509 (0.03)
       - timeout:  26098 (0.05)
  - instExpected:   4524 (0.01)
</code></pre></div>

<p>Other details:</p>
<ul>
<li>50,000 synthInstance.maxHeartbeat</li>
<li>skipping any terms that took too long to infer the type of (with 1,000 maxHeartbeat)</li>
<li><code>instExpected</code> means a subgoal encountered during search is not known to be a class (since currently lean4 only unfolds reducibles in this context)</li>
</ul>
<p>I have much more detailed data about this experiment, which will hopefully help us track down the issues efficiently. In general, I think this kind of batch experiment is a pretty good way to proceed. We can do similar for all <code>simp</code> calls, or for trying to delaborate types and (non-proof) values.</p>



<a name="231117543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117543">(Mar 20 2021 at 03:20)</a>:</h4>
<p>If the lean 3 term contains something like <code>@foo _ _ (non_canonical_instance) ...</code> will this count as a failure?</p>



<a name="231117549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117549">(Mar 20 2021 at 03:20)</a>:</h4>
<p>no, it will succeed with the canonical instance, since the experiment script does not check definitional equality of the instances found</p>



<a name="231117644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117644">(Mar 20 2021 at 03:22)</a>:</h4>
<p>Was I wrong to assume that this happened rarely enough not to have a big effect on the numbers?</p>



<a name="231117659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117659">(Mar 20 2021 at 03:22)</a>:</h4>
<p>Well there might not be a canonical instance, for example if a local instance is being used</p>



<a name="231117675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117675">(Mar 20 2021 at 03:23)</a>:</h4>
<p>or <code>haveI</code></p>



<a name="231117686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117686">(Mar 20 2021 at 03:23)</a>:</h4>
<p>I think it happens enough that the 0.03% figure is not unreasonable</p>



<a name="231117698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117698">(Mar 20 2021 at 03:23)</a>:</h4>
<p>I would start from the assumption that all failures are due to something like this</p>



<a name="231117699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117699">(Mar 20 2021 at 03:23)</a>:</h4>
<p>3%, not 0.03%</p>



<a name="231117756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117756">(Mar 20 2021 at 03:24)</a>:</h4>
<p>I am confused though -- as long as the binder type is <code>instImplicit</code>, lean4 should add it to the local synth context</p>



<a name="231117764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117764">(Mar 20 2021 at 03:24)</a>:</h4>
<p><code>haveI</code> is a tactic for when that's not enough</p>



<a name="231117796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117796">(Mar 20 2021 at 03:25)</a>:</h4>
<p>Because lean3 froze the instances at the colon, right? Lean4 doesn't do that.</p>



<a name="231117801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117801">(Mar 20 2021 at 03:26)</a>:</h4>
<p>Actually I'm not sure what binder is used by <code>haveI</code>. Maybe it doesn't use a binder at all, and directly inserts the instance into the term</p>



<a name="231117879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117879">(Mar 20 2021 at 03:27)</a>:</h4>
<p>you might use <code>haveI</code> to introduce an instance coming from a <code>def</code>, which is not an instance because it makes the general instance search go crazy for one reason or another</p>



<a name="231117909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117909">(Mar 20 2021 at 03:28)</a>:</h4>
<p>Actually, lean4 doesn't even look at the binder-infos, it just checks if the type is a class: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Basic.lean#L838-L841">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Basic.lean#L838-L841</a></p>



<a name="231117963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117963">(Mar 20 2021 at 03:28)</a>:</h4>
<p>lean 3 does the same</p>



<a name="231117975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117975">(Mar 20 2021 at 03:29)</a>:</h4>
<p>binder info only tells it when to trigger a typeclass search when using the theorem</p>



<a name="231117984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231117984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231117984">(Mar 20 2021 at 03:29)</a>:</h4>
<p>hold on, I will read the <code>haveI</code> documentation</p>



<a name="231118033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118033">(Mar 20 2021 at 03:30)</a>:</h4>
<p>A very crude search found 5500 uses of <code>@foo</code></p>



<a name="231118066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118066">(Mar 20 2021 at 03:30)</a>:</h4>
<p>plus 637 <code>haveI</code> and 755 <code>letI</code></p>



<a name="231118093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118093">(Mar 20 2021 at 03:31)</a>:</h4>
<p>also 253 <code>classical,</code></p>



<a name="231118135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118135">(Mar 20 2021 at 03:32)</a>:</h4>
<p>Are you sure <code>haveI</code> isn't only necessary because the local-instances weren't getting updated whenever you went inside a binder? in Lean4, whenever you descend into a pi/lambda, if the binding-domain is a class, you add to the local-instances</p>



<a name="231118163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118163">(Mar 20 2021 at 03:33)</a>:</h4>
<p>You would actually use <code>resetI</code> or <code>exactI</code> if that's the only reason typeclass search is failing</p>



<a name="231118205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118205">(Mar 20 2021 at 03:33)</a>:</h4>
<p><code>haveI</code> is for adding typeclass instances to the context, it's equivalent to <code>have := not_an_instance, resetI</code></p>



<a name="231118286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118286">(Mar 20 2021 at 03:35)</a>:</h4>
<p>but since <code>have</code> doesn't add a binder it's likely that when replaying terms mathport will only see <code>not_an_instance</code> being used in places where instance search will either fail or find something else</p>



<a name="231118379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118379">(Mar 20 2021 at 03:36)</a>:</h4>
<p>So we are on the same page, this works in Lean4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Foo</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Foo.foo</span>

<span class="kd">theorem</span> <span class="n">noHaveI</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">⟨()⟩</span>
  <span class="n">foo</span> <span class="n">Unit</span>
</code></pre></div>



<a name="231118468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118468">(Mar 20 2021 at 03:38)</a>:</h4>
<p>Right, but I think that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">noHaveI</span> <span class="o">:</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">⟨()⟩,</span>
  <span class="n">exact</span> <span class="n">foo</span> <span class="o">()</span>
<span class="kd">end</span>
</code></pre></div>
<p>will produce the term <code>@foo unit ⟨()⟩</code> which would count as a failure in mathport because the typeclass search <code>⟨()⟩ : Foo unit</code> will fail since there are no Foo instances</p>



<a name="231118545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118545">(Mar 20 2021 at 03:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">noHaveI</span>
<span class="c1">-- theorem noHaveI : Unit := (fun (h : Foo Unit) =&gt; foo Unit) { foo := Unit.unit }</span>
</code></pre></div>



<a name="231118551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118551">(Mar 20 2021 at 03:40)</a>:</h4>
<p>If <code>haveI</code> produced the term <code>(\lam [h : Foo unit], @foo () h) ⟨()⟩</code> then lean 4 would probably pick it up and it would be counted as a success, but I'm pretty sure that's not how it gets compiled</p>



<a name="231118587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118587">(Mar 20 2021 at 03:41)</a>:</h4>
<p>I will test this, by creating a simple lean3 file, porting it, and running the experiment on it.</p>



<a name="231118590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118590">(Mar 20 2021 at 03:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">class</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Foo</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Foo.foo</span>

<span class="kd">theorem</span> <span class="n">noHaveI</span> <span class="o">:</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">⟨()⟩,</span>
  <span class="n">exact</span> <span class="n">foo</span> <span class="n">unit</span>
<span class="kd">end</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#print</span> <span class="n">noHaveI</span>
<span class="c1">-- @foo unit (@Foo.mk unit unit.star)</span>
</code></pre></div>



<a name="231118632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118632">(Mar 20 2021 at 03:42)</a>:</h4>
<p>wow...ok now I understand your concern</p>



<a name="231118660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118660">(Mar 20 2021 at 03:43)</a>:</h4>
<p><code>have</code> in term mode uses the lam-app trick, but <code>have</code> in tactic mode just creates a delayed substitution</p>



<a name="231118733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118733">(Mar 20 2021 at 03:44)</a>:</h4>
<p>It's interesting to ask which strategy is better - if terms are internally deduplicated then the delayed substitution approach is probably better, but it's liable to create very large tree terms so the system better be prepared to handle it</p>



<a name="231118766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118766">(Mar 20 2021 at 03:45)</a>:</h4>
<p>Incidentally, I would have filtered that one anyway. An experimental detail I hadn't thought to post: since <code>inferType</code> was taking a crazy-long time on some terms, I was only calling it after checking that the app-function was a global instance. But there could still be a non-instance-instance inside the term that would case a failure.</p>



<a name="231118861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118861">(Mar 20 2021 at 03:47)</a>:</h4>
<p>Also, this one decl was taking an extremely long time to <code>inferType</code> on one of its subterms, so I blacklisted it: <code>equiv.equiv_congr_refl_left</code>. I will investigate later but if there is something funky about this term I should be aware of, please let me know</p>



<a name="231118912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118912">(Mar 20 2021 at 03:48)</a>:</h4>
<p>As in, you can't handle the proof of this theorem, or you can't handle when this theorem appears in other proofs?</p>



<a name="231118933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231118933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231118933">(Mar 20 2021 at 03:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Asynth/near/231118660">said</a>:</p>
<blockquote>
<p><code>have</code> in term mode uses the lam-app trick, but <code>have</code> in tactic mode just creates a delayed substitution</p>
</blockquote>
<p>FYI in Lean4, we get the same term in the <code>noHaveI</code> example above when using tactic mode:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Foo</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Foo.foo</span>

<span class="kd">theorem</span> <span class="n">noHaveI</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">⟨()⟩</span>
  <span class="n">exact</span> <span class="n">foo</span> <span class="n">Unit</span>

<span class="k">#print</span> <span class="n">noHaveI</span>
<span class="c1">-- theorem noHaveI : Unit := (fun (h : Foo Unit) =&gt; foo Unit) { foo := Unit.unit }</span>
</code></pre></div>



<a name="231119002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119002">(Mar 20 2021 at 03:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Asynth/near/231118912">said</a>:</p>
<blockquote>
<p>As in, you can't handle the proof of this theorem, or you can't handle when this theorem appears in other proofs?</p>
</blockquote>
<p>I can't handle a subterm that appears either in the type or the proof of this theorem. Normally it would just heartbeat-timeout, but it must be triggering some rare, expensive computation that isn't checking heartbeats.</p>



<a name="231119180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119180">(Mar 20 2021 at 03:55)</a>:</h4>
<p>Another good milestone will be for <code>MetaM</code> to be able to type-check all of mathlib. It is much slower than the kernel, and much less performance-battle-tested.</p>



<a name="231119213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119213">(Mar 20 2021 at 03:55)</a>:</h4>
<p>Can you delaborate all of mathlib into lean 4 source files?</p>



<a name="231119359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119359">(Mar 20 2021 at 03:59)</a>:</h4>
<p>Naive delaboration of proofs is a non-starter. I think an ambitious goal for now would be to delaborate (and re-elaborate) definitions and theorem statements.</p>



<a name="231119365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119365">(Mar 20 2021 at 03:59)</a>:</h4>
<p>I don't see anything suspicious in <code>equiv.equiv_congr_refl_left</code> except perhaps</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u_1</span> <span class="n">u_2</span> <span class="n">u_3</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">(</span><span class="n">bg</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">coe_fn</span> <span class="o">(</span><span class="n">equiv</span> <span class="o">(</span><span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">equiv</span> <span class="n">α</span> <span class="n">γ</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">equiv.has_coe_to_fun</span> <span class="o">(</span><span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">equiv</span> <span class="n">α</span> <span class="n">γ</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">equiv.equiv_congr</span> <span class="n">α</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">(</span><span class="n">equiv.refl</span> <span class="n">α</span><span class="o">)</span> <span class="n">bg</span><span class="o">)</span>
  <span class="n">e</span>
</code></pre></div>
<p>which involves applying <code>coe_fn</code>, which is not obviously a function, to one too many arguments, so that typechecking it requires unfolding <code>equiv.has_coe_to_fun</code> to ensure that the first component is a function.</p>



<a name="231119407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119407">(Mar 20 2021 at 04:00)</a>:</h4>
<p>But this should come up whenever you use <code>coe_fn</code> at all</p>



<a name="231119507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119507">(Mar 20 2021 at 04:01)</a>:</h4>
<p>I haven't looked at the delaborator though, and Sebastian has (medium-term) plans to improve it. This is why I was thinking of instead experimenting with a heuristic proof-delaborator (trying to recover lets, rewrites, simps, ring, etc)</p>



<a name="231119508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119508">(Mar 20 2021 at 04:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Asynth/near/231119359">said</a>:</p>
<blockquote>
<p>Naive delaboration of proofs is a non-starter.</p>
</blockquote>
<p>Why is this? If the term is valid according to the lean 4 kernel, then it should be possible to delaborate, otherwise we will have the same issue as incompleteness of pp.all in lean 3</p>



<a name="231119572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119572">(Mar 20 2021 at 04:02)</a>:</h4>
<p>Heuristic delaboration should be built on a foundation of 100% reliable but ugly delaboration</p>



<a name="231119609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119609">(Mar 20 2021 at 04:03)</a>:</h4>
<p>Yes, we can do the experiment in-process, we just can't write them to files because the tree sizes will be too big.</p>



<a name="231119699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119699">(Mar 20 2021 at 04:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport.3Asynth/near/231119572">said</a>:</p>
<blockquote>
<p>Heuristic delaboration should be built on a foundation of 100% reliable but ugly delaboration</p>
</blockquote>
<p>There are a few modular sub-problems though -- if lean3 annotates with e.g. <code>idSimp</code> and <code>idRing</code>, then we can make sure we can delaborate these, ideally into a tiny bit of syntax that the eventually-reliable delaborator can make use of</p>



<a name="231119814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231119814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231119814">(Mar 20 2021 at 04:07)</a>:</h4>
<p>Thanks for your help tonight. I am going to sleep now.</p>



<a name="231120024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231120024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231120024">(Mar 20 2021 at 04:11)</a>:</h4>
<p>Maybe a good next step would be to backport <code>Expr.mdata</code> to lean 3, so that we can have general annotations on things without affecting tactics (for the most part). Right now all the annotation support is wrapped up in <code>MacroDef</code>, which is opaque to lean</p>



<a name="231120171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231120171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231120171">(Mar 20 2021 at 04:14)</a>:</h4>
<p>What are you doing with macros anyway? If you are unfolding them then perhaps we can do better by aligning the macros and not unfolding unless necessary.</p>



<a name="231151910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231151910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231151910">(Mar 20 2021 at 15:10)</a>:</h4>
<p>I found the source of the infinite loop in <code>equiv.equiv_congr_refl_left</code> -- the term has wild levels which exposed the following typo/bug: <a href="https://github.com/leanprover/lean4/pull/359">https://github.com/leanprover/lean4/pull/359</a></p>



<a name="231152088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231152088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231152088">(Mar 20 2021 at 15:14)</a>:</h4>
<p>I am unfolding all macros during the <code>tlean</code> export. I would prefer adding custom <code>id&lt;x&gt;</code> annotations, that may if necessary include additional arguments with special meta-data that I decode during mathport. Note: I already decode lean3 names during mathport for the <code>autoParam</code> translation.</p>



<a name="231152202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231152202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231152202">(Mar 20 2021 at 15:17)</a>:</h4>
<p>I think that before I even analyze the typeclass experiment, I will try to typecheck all of mathlib in MetaM, because any issues there could manifest in the synth experiment in more subtle ways.</p>



<a name="231153531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231153531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231153531">(Mar 20 2021 at 15:42)</a>:</h4>
<p>Interesting. Is that a soundness bug?</p>



<a name="231153621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231153621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231153621">(Mar 20 2021 at 15:44)</a>:</h4>
<p>No this is only in MetaM, nothing to do with the kernel</p>



<a name="231153644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231153644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231153644">(Mar 20 2021 at 15:45)</a>:</h4>
<p>Regarding <code>mdata</code>: using <code>id</code> only works if your metadata is an <code>expr</code>. Lean 4's <code>mdata</code> lets you attach strings and numbers and things like that as well</p>



<a name="231153719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231153719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231153719">(Mar 20 2021 at 15:46)</a>:</h4>
<p>Yes but we can decode structured data from expressions when we know the type, as I do to decode names for auto-param: <a href="https://github.com/dselsam/mathport/blob/master/MathPort/Util.lean#L165-L173">https://github.com/dselsam/mathport/blob/master/MathPort/Util.lean#L165-L173</a></p>



<a name="231153782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport%3Asynth/near/231153782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.3Asynth.html#231153782">(Mar 20 2021 at 15:47)</a>:</h4>
<p>I mean you can use <code>evalExpr</code> but that seems inefficient. I know typed user attributes have had issues along these lines</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
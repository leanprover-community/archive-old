---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html">code generator does not support recursor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="275601700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275601700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275601700">(Mar 17 2022 at 02:43)</a>:</h4>
<p>So; I want to generate functions using tactics, and the easiest way to do that is to use induction. Unfortunately; induction lowers to usage of the recursor, and therefore I get "code generator does not support recursor" errors; I do want my functions to be computable, so this is irritating. Is there anything in the way of the code generator supporting recursors for at least simple inductive types? I mean, it should be quite trivial to lower it to the appropriate recursive function, no?</p>



<a name="275601893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275601893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275601893">(Mar 17 2022 at 02:46)</a>:</h4>
<p>Posting some code might be helpful on this one</p>



<a name="275607593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275607593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275607593">(Mar 17 2022 at 04:58)</a>:</h4>
<p>I think the error message for this is "does not support recursor <em>yet</em>", I'm sure there's a reason why they haven't gotten around to this. You can use <code>match</code> in tactics which should be able to get you pretty close.</p>



<a name="275651196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275651196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275651196">(Mar 17 2022 at 13:23)</a>:</h4>
<p>match in tactics doesn't let me automate my cases properly, so that doesn't work. As for source code, something as simple as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">MyTree</span><span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">leaf</span><span class="o">:</span> <span class="n">MyTree</span>
<span class="bp">|</span> <span class="n">branch</span><span class="o">:</span> <span class="n">MyTree</span> <span class="bp">-&gt;</span> <span class="n">MyTree</span> <span class="bp">-&gt;</span> <span class="n">MyTree</span>

<span class="kd">def</span> <span class="n">count_leaves</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">MyTree</span><span class="o">):</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">leaf</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">branch</span> <span class="n">l</span> <span class="n">r</span> <span class="n">Il</span> <span class="n">Ir</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">Il</span> <span class="bp">+</span> <span class="n">Ir</span>
<span class="o">}</span>
</code></pre></div>
<p>gives the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">code</span> <span class="n">generator</span> <span class="n">does</span> <span class="n">not</span> <span class="n">support</span> <span class="n">recursor</span> <span class="bp">'</span><span class="n">MyTree.rec'</span> <span class="n">yet</span><span class="o">,</span> <span class="n">consider</span> <span class="n">using</span> <span class="bp">'</span><span class="k">match</span> <span class="bp">...</span> <span class="k">with</span><span class="bp">'</span> <span class="n">and</span><span class="bp">/</span><span class="n">or</span> <span class="n">structural</span> <span class="n">recursion</span>
</code></pre></div>
<p>Manual use of <code>MyTree.rec</code> yields the same error; but the recursor should be extremely easy to generate code for, no?</p>



<a name="275651735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275651735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275651735">(Mar 17 2022 at 13:27)</a>:</h4>
<p>Note that this works if I stick to <code>noncomputable def</code>, which is fine for now but irritating long-term, especially since it's infectious. Ofc I could manually implement this with partial recursion, but the whole reason why I want to use induction is to avoid writing out a massive 30-branch induction</p>



<a name="275653598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275653598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275653598">(Mar 17 2022 at 13:41)</a>:</h4>
<p>Kind of <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> but would something like this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">MyTree</span><span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">leaf</span><span class="o">:</span>   <span class="n">MyTree</span>
<span class="bp">|</span> <span class="n">branch</span><span class="o">:</span> <span class="n">MyTree</span> <span class="bp">→</span> <span class="n">MyTree</span> <span class="bp">→</span> <span class="n">MyTree</span>

<span class="kn">open</span> <span class="n">MyTree</span>

<span class="kd">def</span> <span class="n">MyTree.countLeaves</span> <span class="o">:</span> <span class="n">MyTree</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">leaf</span>       <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">branch</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">l.countLeaves</span> <span class="bp">+</span> <span class="n">r.countLeaves</span>

<span class="kd">def</span> <span class="n">treeEx</span> <span class="o">:</span> <span class="n">MyTree</span> <span class="o">:=</span>
  <span class="n">branch</span> <span class="n">leaf</span> <span class="n">leaf</span>

<span class="k">#eval</span> <span class="n">treeEx.countLeaves</span> <span class="c1">-- 2</span>
</code></pre></div>



<a name="275655355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275655355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275655355">(Mar 17 2022 at 13:53)</a>:</h4>
<p>I'm a new Lean user, but, to me, the strength of tactic mode is to provide an interface that helps you generate a term that type checks. For computations in which the generated term matters, I would just stick to functions</p>



<a name="275656707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275656707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275656707">(Mar 17 2022 at 14:02)</a>:</h4>
<p>Do you have a motivation to use tactics for your computation?</p>



<a name="275659166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275659166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275659166">(Mar 17 2022 at 14:17)</a>:</h4>
<p>In Lean 3 the big problem with using tactics to generate data is that it can become very difficult to prove anything about the data, because in general tactics are just designed to "get that proof term, no matter how" so it doesn't matter if they produce horrible code because it's all erased after. With data you don't know what you're getting with the <code>induction</code> tactic, whereas the equation compiler is specifically designed for this purpose.</p>



<a name="275669850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275669850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275669850">(Mar 17 2022 at 15:23)</a>:</h4>
<p>In lean 4 it is somewhat the other way around: using the <code>induction</code> tactic is the simplest / most reliable way to get a <code>foo.rec</code> term with no extra fluff (you can't easily write <code>foo.rec</code> directly because the motive is not inferred correctly because <code>@[elab_as_eliminator]</code> doesn't exist)</p>



<a name="275670149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275670149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275670149">(Mar 17 2022 at 15:24)</a>:</h4>
<p>I recently had to deal with this when writing an expression that needed to compute in the kernel. I did this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">hasEdge'</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="n">Bool</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">l</span><span class="o">,</span> <span class="n">b</span><span class="o">::</span><span class="n">r</span><span class="o">,</span> <span class="n">found</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="k">then</span> <span class="n">hasEdge'</span> <span class="n">l</span> <span class="n">r</span> <span class="n">found</span> <span class="n">n</span> <span class="k">else</span>
  <span class="n">bif</span> <span class="n">found</span> <span class="bp">||</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">==</span> <span class="mi">2</span> <span class="bp">||</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">then</span>
    <span class="n">n</span> <span class="bp">||</span> <span class="n">hasEdge'</span> <span class="n">l</span> <span class="n">r</span> <span class="n">true</span> <span class="n">true</span>
  <span class="k">else</span>
    <span class="n">hasEdge'</span> <span class="n">l</span> <span class="n">r</span> <span class="n">false</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span> <span class="bp">=&gt;</span> <span class="n">false</span>

<span class="kd">@[implementedBy hasEdge']</span> <span class="kd">def</span> <span class="n">hasEdge</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">l</span><span class="bp">;</span> <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">l</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">intro</span> <span class="n">r</span><span class="bp">;</span> <span class="n">induction</span> <span class="n">r</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
    <span class="bp">|</span> <span class="n">cons</span> <span class="n">b</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">exact</span>
      <span class="n">bif</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span> <span class="k">then</span> <span class="n">ih</span> <span class="n">r</span> <span class="k">else</span> <span class="k">fun</span> <span class="n">found</span> <span class="bp">=&gt;</span>
        <span class="n">bif</span> <span class="n">found</span> <span class="bp">||</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">==</span> <span class="mi">2</span> <span class="bp">||</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">then</span>
          <span class="k">fun</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">||</span> <span class="n">ih</span> <span class="n">r</span> <span class="n">true</span> <span class="n">true</span>
        <span class="k">else</span>
          <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="n">r</span> <span class="n">false</span> <span class="n">true</span>
</code></pre></div>



<a name="275670399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275670399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275670399">(Mar 17 2022 at 15:26)</a>:</h4>
<p>the first term is optimized for the compiler and the second one is optimized for the kernel</p>



<a name="275671324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275671324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275671324">(Mar 17 2022 at 15:31)</a>:</h4>
<p>The simple solution here is indeed to just implement <code>foo.rec</code> (and <code>foo.casesOn</code>) in the compiler. It should not be too hard, and I'm even thinking of trying my hand at it although the compiler is definitely in <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> 's jurisdiction</p>



<a name="275683665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275683665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275683665">(Mar 17 2022 at 16:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> The compiler already has support for <code>casesOn</code>. The support for <code>rec</code> will only happen after we port the parts of the compiler still written in C++ to Lean. Unfortunately, this port will not happen any time soon. It is a tough decision, we need to port this C++ code to Lean and fix many problems we have there, but we also have many higher priority tasks.  <br>
BTW,  I view the support for <code>rec</code> as a super low priority and it will benefit very few users.</p>



<a name="275684794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275684794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275684794">(Mar 17 2022 at 16:28)</a>:</h4>
<p>It is something I have run into a half dozen times so far, I'm working up the courage to do it myself since I'm aware it's a low priority</p>



<a name="275685249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275685249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275685249">(Mar 17 2022 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Are they all the same use-case? Could you explain it?</p>



<a name="275686182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275686182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275686182">(Mar 17 2022 at 16:33)</a>:</h4>
<p>The use case that appeared above was that I wanted a term that computes as efficiently as possible in the kernel because it is part of a large proof by reflection; I don't know how to get <code>casesOn</code> applications using <code>cases</code> but <code>induction</code> produces <code>rec</code> applications</p>



<a name="275686646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275686646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275686646">(Mar 17 2022 at 16:35)</a>:</h4>
<p>and then I wanted such a term to be sanity-checkable using the compiler</p>



<a name="275686729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275686729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275686729">(Mar 17 2022 at 16:35)</a>:</h4>
<p>as you can see above my workaround is to rewrite the whole term in compiler-friendly format</p>



<a name="275687257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275687257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275687257">(Mar 17 2022 at 16:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275686182">said</a>:</p>
<blockquote>
<p>The use case that appeared above was that I wanted a term that computes as efficiently as possible in the kernel because it is part of a large proof by reflection; I don't know how to get <code>casesOn</code> applications using <code>cases</code> but <code>induction</code> produces <code>rec</code> applications</p>
</blockquote>
<p>We are planning to improve the reduction engine in the kernel, and have better support for proofs by reflection. <br>
You will not need to use the trick above after we implement these improvements. I think you should avoid these tricks for now and try to survive with the current performance overhead. Is it bigger than 2x?</p>



<a name="275688568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275688568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275688568">(Mar 17 2022 at 16:42)</a>:</h4>
<p>I suspect it would be possible to write the <code>foo.rec</code> generator entirely in lean: you just have to call <code>compileDecl</code> on <code>foo.rec</code> with a term that looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Foo</span>
<span class="bp">|</span> <span class="n">two</span> <span class="o">:</span> <span class="n">Foo</span> <span class="bp">→</span> <span class="n">Foo</span>

<span class="kd">def</span> <span class="n">Foo.rec'.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">Foo</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">Foo.one</span> <span class="n">a</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">Foo.two</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">one</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">h1</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">two</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">h2</span> <span class="n">a</span> <span class="o">(</span><span class="n">rec'</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="275690418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275690418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275690418">(Mar 17 2022 at 16:49)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> Not 2x, but measurable. I have a proof of (the computational part of) the Keller conjecture counterexample in dimension 8, and without using bare terms the proof by reflection (essentially an enumeration of 2*16^2 possibilities) takes 10.65 s, with the optimizations it is 7.9 s. I can send you the file as a test case</p>



<a name="275690425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275690425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275690425">(Mar 17 2022 at 16:49)</a>:</h4>
<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>
In Lean 4, we also have extra complexity: mutual and nested inductives.</p>



<a name="275690887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275690887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275690887">(Mar 17 2022 at 16:50)</a>:</h4>
<p>One thing that I would like to see improved with this kind of stuff is better debugging support for kernel reduction. It is hard to tell whether a reduction is being cached or redone, for example</p>



<a name="275690890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275690890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275690890">(Mar 17 2022 at 16:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690418">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> Not 2x, but measurable. I have a proof of (the computational part of) the Keller conjecture counterexample in dimension 8, and without using bare terms the proof by reflection (essentially an enumeration of 2*16^2 possibilities) takes 10.65 s, with the optimizations it is 7.9 s. I can send you the file as a test case</p>
</blockquote>
<p>It would be great if you can survive with this overhead. The new reduction engine will make it way faster, and make the trick above obsolete.<br>
Yes, it would be great to have the file.</p>



<a name="275691202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275691202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275691202">(Mar 17 2022 at 16:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690887">said</a>:</p>
<blockquote>
<p>One thing that I would like to see improved with this kind of stuff is better debugging support for kernel reduction. It is hard to tell whether a reduction is being cached or redone, for example</p>
</blockquote>
<p>Yes, it would be great to have better profiling tools in the kernel as we embrace proofs-by-reflection more and more.</p>



<a name="275691341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275691341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275691341">(Mar 17 2022 at 16:52)</a>:</h4>
<p><a href="/user_uploads/3121/WmXo7NFIM0rYpT9WMnQ-ypfW/Keller.lean">Keller.lean</a></p>



<a name="275691397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275691397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275691397">(Mar 17 2022 at 16:52)</a>:</h4>
<p>Thanks.</p>



<a name="275691400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275691400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275691400">(Mar 17 2022 at 16:52)</a>:</h4>
<p>it has some minor dependencies on mathlib for the <code>List.Pairwise</code> decision procedure and <code>run_cmd</code></p>



<a name="275691785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275691785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275691785">(Mar 17 2022 at 16:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275691400">said</a>:</p>
<blockquote>
<p>it has some minor dependencies on mathlib</p>
</blockquote>
<p>Could you please remove them? <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span> <br>
It would be great to have them on our benchmark suite. <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> has a system for tracking progress over time. We have found many performance regression issues with this system.</p>



<a name="275692063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275692063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275692063">(Mar 17 2022 at 16:55)</a>:</h4>
<p><code>run_cmd</code> should totally be part of lean 4 anyway <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="275692362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275692362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275692362">(Mar 17 2022 at 16:57)</a>:</h4>
<p>Something I brought up recently is to add timing information to the traces. Together with lazy traces (because tracing the whole reduction would be counterproductive for benchmarking), that should give you a pretty quick idea on what parts are cached/exprensive, even without specific profiling support for reductions.</p>



<a name="275692537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275692537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275692537">(Mar 17 2022 at 16:58)</a>:</h4>
<p>Lazy traces are not really necessary for that as long as the trace classes are sufficiently granular</p>



<a name="275692635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275692635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275692635">(Mar 17 2022 at 16:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> We don't have trace messages in the kernel :(</p>



<a name="275692670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275692670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275692670">(Mar 17 2022 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275692063">said</a>:</p>
<blockquote>
<p><code>run_cmd</code> should totally be part of lean 4 anyway <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
</blockquote>
<p>Sure, do you want to submit a PR?</p>



<a name="275692737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275692737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275692737">(Mar 17 2022 at 16:59)</a>:</h4>
<p>Oops, I was purely thinking of reduction in the elaborator :)</p>



<a name="275693264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275693264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275693264">(Mar 17 2022 at 17:01)</a>:</h4>
<blockquote>
<p>@Sebastian Ullrich has a system for tracking progress over time. We have found many performance regression issues with this system.</p>
</blockquote>
<p>Now I am curious; what system are you using?</p>



<a name="275693416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275693416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275693416">(Mar 17 2022 at 17:02)</a>:</h4>
<p>Yet another PSE project of course :) <a href="http://speedcenter.informatik.kit.edu/velcom/home">http://speedcenter.informatik.kit.edu/velcom/home</a></p>



<a name="275694054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275694054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275694054">(Mar 17 2022 at 17:05)</a>:</h4>
<p>mathlib-free via copious inlining: <a href="/user_uploads/3121/zEIkO1_I3_v5nm2Ih0mGffvS/Keller.lean">Keller.lean</a></p>



<a name="275694092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275694092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275694092">(Mar 17 2022 at 17:05)</a>:</h4>
<p>Thanks.</p>



<a name="275694108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275694108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275694108">(Mar 17 2022 at 17:05)</a>:</h4>
<p>Uh, pretty. <code>rm -rf gipeda</code> :-)</p>



<a name="275694714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275694714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275694714">(Mar 17 2022 at 17:08)</a>:</h4>
<p>Oh, Java. <code>borg extract gipeda/</code>.</p>



<a name="275695208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275695208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275695208">(Mar 17 2022 at 17:10)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275692670">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275692063">said</a>:</p>
<blockquote>
<p><code>run_cmd</code> should totally be part of lean 4 anyway <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
</blockquote>
<p>Sure, do you want to submit a PR?</p>
</blockquote>
<p>In the process of inlining I found that it depends on two other, also useful features:</p>
<ul>
<li><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Util/Eval.lean">More convenient forms of <code>evalExpr</code></a>:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unsafe</span> <span class="kd">def</span> <span class="n">evalExpr</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">expectedType</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">(</span><span class="n">safety</span> <span class="o">:=</span> <span class="n">DefinitionSafety.safe</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="n">α</span>
<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">evalTerm</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">type</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">(</span><span class="n">safety</span> <span class="o">:=</span> <span class="n">DefinitionSafety.safe</span><span class="o">)</span> <span class="o">:</span> <span class="n">TermElabM</span> <span class="n">α</span>
</code></pre></div>
<ul>
<li><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Util/TermUnsafe.lean">term mode <code>unsafe</code></a>, as in <code>def cool := unsafe (unsafeCast () : Nat)</code></li>
</ul>
<p>Are you interested in receiving these as well, or should I extract just <code>run_cmd</code>?</p>



<a name="275696186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275696186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275696186">(Mar 17 2022 at 17:16)</a>:</h4>
<p>By the way, this is not the original proof I had for Keller dim 8. The first version used a naive clique check which is 256^2 tests; this is easy enough with <code>#eval</code> / <code>nativeDecide</code> but took longer than I had patience to wait for in <code>by decide</code>. The version here does a lot more reasoning to get the computational part to a feasible level, but perhaps if the reduction engine gets good enough the simpler version will work as a benchmark</p>



<a name="275696453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275696453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275696453">(Mar 17 2022 at 17:18)</a>:</h4>
<blockquote>
<p>Are you interested in receiving these as well, or should I extract just run_cmd?</p>
</blockquote>
<p>Sure.</p>



<a name="275696609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275696609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275696609">(Mar 17 2022 at 17:20)</a>:</h4>
<blockquote>
<p>The version here does a lot more reasoning to get the computational part to a feasible level, but perhaps if the reduction engine gets good enough the simpler version will work as a benchmark</p>
</blockquote>
<p>Whoa, we can try to make it fast, not sure we will be able to handle this one in the near future.</p>



<a name="275696885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275696885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275696885">(Mar 17 2022 at 17:21)</a>:</h4>
<p>Heh, there's always a bigger mountain. You don't want to see how much worse <a href="https://arxiv.org/abs/1910.03740">Keller dim 7</a> is</p>



<a name="275868380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275868380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275868380">(Mar 18 2022 at 22:05)</a>:</h4>
<p>I'm confused; <em>why</em> is it difficult for the code-generator to support recursors? Isn't it possible to simply (hackily) lower them to partial recursive functions for now?</p>



<a name="275999533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/275999533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#275999533">(Mar 21 2022 at 02:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690425">said</a>:</p>
<blockquote>
<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>
In Lean 4, we also have extra complexity: mutual and nested inductives.</p>
</blockquote>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> would it be possible to temporarily have this hack and later swap it out for something better? I believe that mutual/nested inductives could be taken care of very easily by just generating partial functions as the implementation. Would this be a good issue for a beginner to tackle?</p>



<a name="276006987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276006987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276006987">(Mar 21 2022 at 05:10)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690425">said</a>:</p>
<blockquote>
<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>
In Lean 4, we also have extra complexity: mutual and nested inductives.</p>
</blockquote>
<p>I missed this comment earlier. In what sense is this a hack? This is literally the meaning of <code>foo.rec</code> as a function. I'm not saying that we should <em>only</em> use these recursor functions, but when you use it directly then this is the behavior I would expect.</p>
<p>What alternatives are there? The fact that <code>nat.rec</code> will eagerly evaluate <code>motive 0</code> is not great, I agree, but it's hard to see what else to do. I suppose you could make that match definition <code>macroInline</code> which could recover some of the laziness...?</p>



<a name="276037356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276037356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276037356">(Mar 21 2022 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> </p>
<blockquote>
<p>I missed this comment earlier. In what sense is this a hack? This is literally the meaning of foo.rec as a function. I'm not saying that we should only use these recursor functions, but when you use it directly then this is the behavior I would expect.</p>
</blockquote>
<p>This is not the behavior users expect. It is also not consistent with the approach we use for <code>casesOn</code> where we use lazy semantics.<br>
BTW, in previous versions of Lean, we did generate a <code>rec</code> function, and users were confused when they realized it was not lazy.</p>
<blockquote>
<p>What alternatives are there? The fact that nat.rec will eagerly evaluate motive 0 is not great, I agree, but it's hard to see what else to do. I suppose you could make that match definition macroInline which could recover some of the laziness...?</p>
</blockquote>
<p>One possibility is to have special support for <code>rec</code> in the compiler,  similar to what we have for <code>casesOn</code>. </p>
<blockquote>
<p>I suppose you could make that match definition macroInline which could recover some of the laziness...?</p>
</blockquote>
<p>Not sure how far you can go using just <code>macroInline</code>, but some code transformation that replaces <code>rec</code> with <code>recLazy</code> should also. For example, <code>Nat.recLazy</code> would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Nat.recLazy</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="n">Unit</span> <span class="bp">→</span> <span class="n">motive</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span>   <span class="bp">=&gt;</span> <span class="n">hz</span> <span class="o">()</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">hs</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">recLazy</span> <span class="n">motive</span> <span class="n">hz</span> <span class="n">hs</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>
<p>Now, whenever we find code such as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">@</span><span class="n">Nat.rec</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="o">(</span><span class="n">dbg_trace</span> <span class="s2">"hz"</span><span class="bp">;</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">dbg_trace</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"hs: {n}"</span><span class="bp">;</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="mi">2</span><span class="bp">*</span> <span class="n">ih</span> <span class="k">else</span> <span class="mi">1</span><span class="o">)</span>
    <span class="mi">20</span>
</code></pre></div>
<p>We replace it with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">Nat.recLazy</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">_</span>    <span class="bp">=&gt;</span> <span class="n">dbg_trace</span> <span class="s2">"hz"</span><span class="bp">;</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">dbg_trace</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"hs: {n}"</span><span class="bp">;</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="mi">2</span><span class="bp">*</span> <span class="o">(</span><span class="n">ih</span> <span class="o">())</span> <span class="k">else</span> <span class="mi">1</span><span class="o">)</span>
    <span class="mi">20</span>
</code></pre></div>



<a name="276037799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276037799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276037799">(Mar 21 2022 at 11:41)</a>:</h4>
<p>Do you think that <code>recLazy</code> should actually exist and be used by users etc, or is this just a compiler internal thing that isn't in the environment?</p>



<a name="276038115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276038115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276038115">(Mar 21 2022 at 11:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461231">Jad Ghalayini</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275999533">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690425">said</a>:</p>
<blockquote>
<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>
In Lean 4, we also have extra complexity: mutual and nested inductives.</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> would it be possible to temporarily have this hack and later swap it out for something better? I believe that mutual/nested inductives could be taken care of very easily by just generating partial functions as the implementation. Would this be a good issue for a beginner to tackle?</p>
</blockquote>
<p>This kind of temporary hack is a headache for us because the proper solution is not a priority right now. <br>
Suppose we add the hack, then I am very confident another user will hit the unexpected behavior I described above and will file a bug report. Now, we have a bug report for a feature that we did not even consider important, and is usually misused by users. <br>
We do use hacks sometimes, but there are hacks for features we consider important.</p>
<blockquote>
<p>Would this be a good issue for a beginner to tackle?</p>
</blockquote>
<p>I would suggest you manually define your own <code>recLazy</code> function for the types you care about. Note that the tactic <code>induction</code> has the <code>using</code> modifier that allows us to specify a different elimination principle. That is, you can use <code>induction x using Nat.recLazy</code></p>



<a name="276038382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276038382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276038382">(Mar 21 2022 at 11:48)</a>:</h4>
<p>Perhaps a target that might be more accessible for newcomers interested in usefully contributing to this issue is to write a program to generate <code>recLazy</code> for an arbitrary inductive type</p>



<a name="276038421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276038421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276038421">(Mar 21 2022 at 11:49)</a>:</h4>
<p>and defer the question of how to integrate this with the compiler</p>



<a name="276038981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276038981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276038981">(Mar 21 2022 at 11:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276037799">said</a>:</p>
<blockquote>
<p>Do you think that <code>recLazy</code> should actually exist and be used by users etc, or is this just a compiler internal thing that isn't in the environment?</p>
</blockquote>
<p>I don't have a preference here. To be honest, I would prefer to have really good documentation explaining why we have <code>rec</code>, and why it should not be used directly in programs. Make it clear to the user that <code>rec</code> is just one of the tools we have to show termination. We could also explain <code>Nat.recLazy</code>, and why even this approach would produce suboptimal code.</p>



<a name="276039020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276039020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276039020">(Mar 21 2022 at 11:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276038382">said</a>:</p>
<blockquote>
<p>Perhaps a target that might be more accessible for newcomers interested in usefully contributing to this issue is to write a program to generate <code>recLazy</code> for an arbitrary inductive type</p>
</blockquote>
<p>Yes, this can be a fun project for newcomers.</p>



<a name="276039191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276039191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276039191">(Mar 21 2022 at 11:57)</a>:</h4>
<p>I think there is a tension with the fact that <code>rec</code> is a primitive of dependent type theory (and lean 4 doesn't change this). It feels like it should be the most efficient thing from one perspective, but for the compiler something like <code>match</code> is more primitive. Writing code that works well in both the compiler and the kernel is therefore tricky</p>



<a name="276039346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276039346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276039346">(Mar 21 2022 at 11:59)</a>:</h4>
<p>As a library writer, I want to write code that is good in all the ways, and that means reaching for <code>implementedBy</code> which is the best tool we have at the moment for this kind of thing</p>



<a name="276040678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276040678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276040678">(Mar 21 2022 at 12:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I agree the "kernel vs compiled" issue is annoying, and it will be fixed in the future. We will have better reduction engines in the kernel in the future, and you will not need to be concerned about this anymore. Recall the messages we exchanged in the other thread about the workaround you were using for this issue.</p>



<a name="276040916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276040916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276040916">(Mar 21 2022 at 12:14)</a>:</h4>
<p>Right, sorry to rehash the issue. External verifiers will probably still use the original reduction algorithm though, so I doubt it will ever become completely irrelevant</p>



<a name="276041025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276041025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276041025">(Mar 21 2022 at 12:15)</a>:</h4>
<p>Anyway I think we're on the same page for this issue. There are plans for this but they are all rather long term</p>



<a name="276041353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276041353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276041353">(Mar 21 2022 at 12:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276040916">said</a>:</p>
<blockquote>
<p>Right, sorry to rehash the issue. External verifiers will probably still use the original reduction algorithm though, so I doubt it will ever become completely irrelevant</p>
</blockquote>
<p>Yes, I care about external verifiers too. We want to make sure our developments can still be checked by relatively simple external verifiers. <br>
I believe one of the optimizations we are going to use is easy to implement in external verifiers.</p>



<a name="276084916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276084916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276084916">(Mar 21 2022 at 17:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276038981">said</a>:</p>
<blockquote>
<p>I don't have a preference here. To be honest, I would prefer to have really good documentation explaining why we have <code>rec</code>, and why it should not be used directly in programs. Make it clear to the user that <code>rec</code> is just one of the tools we have to show termination. We could also explain <code>Nat.recLazy</code>, and why even this approach would produce suboptimal code.</p>
</blockquote>
<p>Just seconding this -- I'd encountered the compiler error before, but had no idea why <code>rec</code> didn't compile until reading this thread (and now it makes sense). I'd be happy to help write something up if nobody else is taking it on.</p>
<p>The compiler error could even provide a link to the discussion, kinda like rustc does with common errors.</p>



<a name="276120691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276120691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276120691">(Mar 21 2022 at 22:11)</a>:</h4>
<blockquote>
<p>The compiler error could even provide a link to the discussion, kinda like rustc does with common errors</p>
</blockquote>
<p>This is a great suggestion.<br>
<span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> You once told me that the Zulip links are not very stable and may change if, for example, someone marks the topic as resolved. Should we use links to <a href="https://leanprover-community.github.io/archive/">https://leanprover-community.github.io/archive/</a> in error messages instead?</p>



<a name="276155134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276155134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276155134">(Mar 22 2022 at 08:20)</a>:</h4>
<p>There have been more recent changes to the way Zulip can be accessed by people who are not part of the community. They're still in beta though so perhaps they might change again.</p>



<a name="276155329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276155329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276155329">(Mar 22 2022 at 08:22)</a>:</h4>
<p>The archive was mostly intended as a stop-gap solution until it was implemented in Zulip itself.  As Kevin said, Zulip can now be accessed without an account.  Once it can be indexed by search engines as well, we might even retire the archive.</p>



<a name="276155517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/code%20generator%20does%20not%20support%20recursor/near/276155517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html#276155517">(Mar 22 2022 at 08:25)</a>:</h4>
<blockquote>
<p>You once told me that the Zulip links are not very stable and may change</p>
</blockquote>
<p>The Zulip team is slowly working on that.  Apparently links to <em>messages</em> are stable now, see the discussion at <a href="https://github.com/zulip/zulip/issues/21505">https://github.com/zulip/zulip/issues/21505</a> (not sure if the change referenced in that issue still needs to be deployed).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
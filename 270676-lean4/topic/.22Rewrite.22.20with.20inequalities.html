---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html">"Rewrite" with inequalities</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="283832497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283832497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283832497">(May 25 2022 at 03:10)</a>:</h4>
<p>While waiting for linarith, is there a clean way to "rewrite" a subterm of an inequality if you have an upper bound on it? Something like <code>x &lt;= f y</code> and <code>y &lt;= z</code> ==&gt; <code>x &lt;= f z</code> where <code>f</code> is only ring operations on <code>Nat</code>?</p>



<a name="283832523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283832523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283832523">(May 25 2022 at 03:11)</a>:</h4>
<p>(And I guess a tack-on question, how close is linarith to being available?)</p>



<a name="283921085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283921085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283921085">(May 25 2022 at 18:16)</a>:</h4>
<p>I don't see any tactic in Lean 3 that would do this either. Maybe linarith was always used in those cases. Would such a tactic be useful? Seems like a fun project to learn metaprogramming with :)</p>



<a name="283921690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283921690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283921690">(May 25 2022 at 18:21)</a>:</h4>
<p>I had a proof somewhere that a polynomial with coefficients in ℕ is always monotone and strictly monotone if nonconstant in Lean3.  I'm not sure if I PRed it, nor whether it would be useful for Lean4 at the moment...</p>



<a name="283921729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283921729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283921729">(May 25 2022 at 18:21)</a>:</h4>
<p>I can look it up again, but I'm not going to be at a computer again today.</p>



<a name="283935675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283935675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283935675">(May 25 2022 at 20:21)</a>:</h4>
<p>And then I would need a metaprogram that looks at the goal and extracts the polynomial function of the term</p>



<a name="283938291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283938291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283938291">(May 25 2022 at 20:46)</a>:</h4>
<p>Incidentally, I also wrote this, but again in Lean3 and this is certainly did not PR!</p>



<a name="283942106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283942106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283942106">(May 25 2022 at 21:21)</a>:</h4>
<p>Being in Lean3 is no problem, I'll figure out how to translate it to Lean 4. Send a gist of those two pieces when you get the chance. Thank you!</p>



<a name="283969222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283969222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283969222">(May 26 2022 at 04:37)</a>:</h4>
<p>Here is a proof that polynomials with coefficients in <code>ℕ</code> are monotone (and strictly monotone, when non-constant, that you probably do not need):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Lean 3</span>
<span class="kn">import</span> <span class="n">order.monotone</span>
<span class="kn">import</span> <span class="n">data.polynomial.eval</span>
<span class="kn">import</span> <span class="n">data.polynomial.inductions</span>

<span class="kn">open</span> <span class="n">polynomial</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>
<span class="kd">noncomputable theory</span>

<span class="kd">lemma</span> <span class="n">nat.polynomial_eval_mono</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f.eval</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">f.induction_on</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_nat_cast</span><span class="o">,</span> <span class="n">eval_nat_cast</span><span class="o">,</span> <span class="n">monotone_const</span><span class="o">,</span> <span class="n">forall_const</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">monotone.add</span><span class="o">]</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_nat_cast</span><span class="o">,</span> <span class="n">eval_mul</span><span class="o">,</span> <span class="n">eval_nat_cast</span><span class="o">,</span> <span class="n">nat.cast_id</span><span class="o">,</span> <span class="n">eval_pow</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_nat_cast</span><span class="o">,</span> <span class="n">eval_mul</span><span class="o">,</span> <span class="n">eval_nat_cast</span><span class="o">,</span> <span class="n">nat.cast_id</span><span class="o">,</span> <span class="n">eval_pow</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">pow_succ'</span><span class="o">,</span>
      <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">]</span> <span class="n">using</span> <span class="n">ha.mul</span> <span class="n">monotone_id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">)</span> <span class="n">nat.zero_le</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nat.polynomial_eval_strict_mono</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">]}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">f.nat_degree</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">strict_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f.eval</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">nat_degree_ne_zero_induction_on</span> <span class="n">hf</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">hf</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">strict_mono.const_add</span><span class="o">]</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">strict_mono.add</span><span class="o">]</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">a</span> <span class="n">a0</span> <span class="n">n0</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">eval_monomial</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">strict_mono.const_mul</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.pos_of_ne_zero</span> <span class="n">a0</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">n0</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">strict_mono_id</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">strict_mono_id.mul</span> <span class="o">(</span><span class="n">hn</span> <span class="n">n.succ_ne_zero</span><span class="o">)</span> <span class="n">nat.zero_le</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>I will now look for the conversion tool "polynomial" to "eval of a polynomial"!</p>



<a name="283993595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283993595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283993595">(May 26 2022 at 11:02)</a>:</h4>
<p>Ok, I found the conversion!  It probably needs quite a bit of further testing, but you can see an example where it works!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">expr.list_vars</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_add.add</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a.list_vars</span> <span class="bp">++</span> <span class="n">b.list_vars</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_mul.mul</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a.list_vars</span> <span class="bp">++</span> <span class="n">b.list_vars</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">bit0</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span>            <span class="o">:=</span> <span class="n">a.list_vars</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">bit1</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span>            <span class="o">:=</span> <span class="n">a.list_vars</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_one.one</span><span class="o">)</span>         <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_zero.zero</span><span class="o">)</span>       <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">^</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>           <span class="o">:=</span> <span class="n">a.list_vars</span>
<span class="bp">|</span> <span class="n">a</span>                      <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">to_poly</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_add.add</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">pa</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">a</span><span class="o">,</span> <span class="n">pb</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">mk_app</span> <span class="bp">`</span><span class="n">has_add.add</span> <span class="o">[</span><span class="n">pa</span><span class="o">,</span> <span class="n">pb</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_mul.mul</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">pa</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">a</span><span class="o">,</span> <span class="n">pb</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">mk_app</span> <span class="bp">`</span><span class="n">has_mul.mul</span> <span class="o">[</span><span class="n">pa</span><span class="o">,</span> <span class="n">pb</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">bit0</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span>            <span class="o">:=</span> <span class="k">do</span> <span class="n">pa</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">mk_app</span> <span class="bp">`</span><span class="n">bit0</span> <span class="o">[</span><span class="n">pa</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">bit1</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span>            <span class="o">:=</span> <span class="k">do</span> <span class="n">pa</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">mk_app</span> <span class="bp">`</span><span class="n">bit1</span> <span class="o">[</span><span class="n">pa</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">^</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>           <span class="o">:=</span> <span class="k">do</span> <span class="n">pa</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">mk_app</span> <span class="bp">`</span><span class="n">has_pow.pow</span> <span class="o">[</span><span class="n">pa</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_one.one</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">p1</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">has_one.one</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span> <span class="n">tt</span> <span class="n">ff</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">p1</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_zero.zero</span><span class="o">)</span>       <span class="o">:=</span> <span class="k">do</span> <span class="n">p0</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">has_zero.zero</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span> <span class="n">tt</span> <span class="n">ff</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">p0</span>
<span class="bp">|</span> <span class="n">a</span>                      <span class="o">:=</span> <span class="n">return</span> <span class="n">v</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">polynomialize_one</span> <span class="o">(</span><span class="n">tar</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
<span class="k">let</span> <span class="n">lv</span> <span class="o">:=</span> <span class="n">tar.list_vars.dedup</span><span class="o">,</span>
<span class="k">match</span> <span class="n">lv</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">[</span> <span class="o">]</span> <span class="o">:=</span> <span class="n">trace</span> <span class="s2">"not enough variables"</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">pX</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">polynomial.X</span> <span class="n">ℕ</span> <span class="n">_</span><span class="o">)</span> <span class="n">tt</span> <span class="n">ff</span><span class="o">,</span>
  <span class="n">pol</span> <span class="bp">←</span> <span class="n">to_poly</span> <span class="n">pX</span> <span class="n">tar</span><span class="o">,</span>
  <span class="n">epol</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">polynomial.eval</span> <span class="o">[</span><span class="n">v</span><span class="o">,</span> <span class="n">pol</span><span class="o">],</span>
  <span class="n">e_eq</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">tar</span><span class="o">,</span> <span class="n">epol</span><span class="o">],</span>
  <span class="n">n</span> <span class="bp">←</span> <span class="n">get_unused_name</span><span class="o">,</span>
  <span class="n">assert</span> <span class="n">n</span> <span class="n">e_eq</span><span class="o">,</span>
  <span class="c1">--  the list of simp-lemmas may expand.  Once it stabilizes, use `solve_aux` instead</span>
  <span class="bp">`</span><span class="o">[{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval_add</span><span class="o">,</span> <span class="n">eval_mul</span><span class="o">,</span> <span class="n">eval_bit0</span><span class="o">,</span> <span class="n">eval_one</span><span class="o">,</span> <span class="n">eval_pow</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">eval_bit1</span><span class="o">,</span> <span class="n">eval_one</span><span class="o">,</span>
        <span class="n">eval_zero</span><span class="o">],</span> <span class="n">done</span> <span class="o">}],</span>
  <span class="n">nn</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rewrite_target</span> <span class="n">nn</span><span class="o">,</span>
  <span class="n">tactic.clear</span> <span class="n">nn</span>
<span class="bp">|</span> <span class="n">_</span>   <span class="o">:=</span> <span class="n">trace</span> <span class="s2">"too many variables"</span>
<span class="kd">end</span>

<span class="kn">namespace</span> <span class="n">interactive</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">quick</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
<span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
<span class="k">match</span> <span class="n">tgt</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">rel</span> <span class="n">tl</span><span class="o">)</span> <span class="n">tr</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">polynomialize_one</span> <span class="n">tl</span><span class="o">,</span> <span class="n">polynomialize_one</span> <span class="n">tr</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"not supported"</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">interactive</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">xy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">quick</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat.polynomial_eval_mono</span> <span class="n">_</span> <span class="n">xy</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="283993653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/283993653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#283993653">(May 26 2022 at 11:02)</a>:</h4>
<p>If you convert it to Lean4, would you mind sharing the code?  I am trying to learn Lean 4, and this could be a good Rosetta stone for me!</p>



<a name="284092114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/284092114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#284092114">(May 27 2022 at 05:02)</a>:</h4>
<p>Will do :D the proof should be pretty quick, but I don't know any metaprogramming yet so that might have to be a joint learning effort :)</p>



<a name="284093224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%22Rewrite%22%20with%20inequalities/near/284093224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.22Rewrite.22.20with.20inequalities.html#284093224">(May 27 2022 at 05:31)</a>:</h4>
<p>Great!  I will be away from lean until Monday, but after that I should be available!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
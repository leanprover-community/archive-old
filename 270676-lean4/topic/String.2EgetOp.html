---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/String.2EgetOp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html">String.getOp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="287855425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287855425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287855425">(Jun 29 2022 at 13:45)</a>:</h4>
<p>I saw this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">String.getOp</span> <span class="c1">-- String.getOp : String → String.Pos → Char</span>
</code></pre></div>
<p>So I wonder, is this expected?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="s2">""</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="c1">-- 'A'</span>
</code></pre></div>



<a name="287856819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287856819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287856819">(Jun 29 2022 at 13:54)</a>:</h4>
<p>What is the question? Whether <code>getOp</code> should panic in that case?</p>



<a name="287857136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287857136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287857136">(Jun 29 2022 at 13:56)</a>:</h4>
<p>Hm, I would expect <code>getOp</code> to have type <code>String → String.Pos → Option Char</code> instead</p>



<a name="287857278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287857278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287857278">(Jun 29 2022 at 13:57)</a>:</h4>
<p>That would be inconsistent with all other <code>getOp</code> implementations</p>



<a name="287858170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287858170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287858170">(Jun 29 2022 at 14:02)</a>:</h4>
<p>Why doesn't <code>getOp</code> return <code>Option x</code>? I fear the current API risks making programmers not seeing errors in their code in some situations</p>



<a name="287858497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287858497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287858497">(Jun 29 2022 at 14:04)</a>:</h4>
<p>Like, if they assume some list/array/etc is not empty but in fact it is. And they don't see errors because <code>getOp</code> is returning something regardless</p>



<a name="287859389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287859389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287859389">(Jun 29 2022 at 14:11)</a>:</h4>
<p>We have discussed this issue in the past. One of the proposals was:</p>
<ul>
<li><code>a[i]!</code> panics if index out of bounds</li>
<li><code>a[i]?</code> returns <code>Option</code></li>
<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>
</ul>
<p>but, we never implemented this proposal. It is a good time to revisit this issue and decide what to do here before the first official release.</p>



<a name="287859803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287859803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287859803">(Jun 29 2022 at 14:14)</a>:</h4>
<p>(for some reason I imagined a cavalry of Python programmers spamming <code>a[i]!</code> all over their code - I am a Python programmer)</p>



<a name="287860059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287860059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287860059">(Jun 29 2022 at 14:16)</a>:</h4>
<blockquote>
<ul>
<li><code>a[i]!</code> panics if index out of bounds</li>
<li><code>a[i]?</code> returns <code>Option</code></li>
<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>
</ul>
</blockquote>
<p>That makes total sense to me</p>



<a name="287860123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287860123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287860123">(Jun 29 2022 at 14:16)</a>:</h4>
<p>Related issue <a href="https://github.com/leanprover/lean4/issues/406">https://github.com/leanprover/lean4/issues/406</a>. <span class="user-mention" data-user-id="278501">@Andrew Kent</span> suggested that all APIs that may panic should have a <code>!</code> suffix.</p>



<a name="287860579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287860579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287860579">(Jun 29 2022 at 14:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287860059">said</a>:</p>
<blockquote>
<blockquote>
<ul>
<li><code>a[i]!</code> panics if index out of bounds</li>
<li><code>a[i]?</code> returns <code>Option</code></li>
<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>
</ul>
</blockquote>
<p>That makes total sense to me</p>
</blockquote>
<p>Great. It would be great to have more feedback from the community since this is a very disruptive change.</p>
<blockquote>
<p>a[i]! all over their code - I am a Python programmer)</p>
</blockquote>
<p>I suspect you are not the only one that will have <code>a[i]!</code> all over the place.</p>



<a name="287889294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287889294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287889294">(Jun 29 2022 at 17:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287860579">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287860059">said</a>:</p>
<blockquote>
<blockquote>
<ul>
<li><code>a[i]!</code> panics if index out of bounds</li>
<li><code>a[i]?</code> returns <code>Option</code></li>
<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>
</ul>
</blockquote>
<p>That makes total sense to me</p>
</blockquote>
<p>Great. It would be great to have more feedback from the community since this is a very disruptive change.</p>
<blockquote>
<p>a[i]! all over their code - I am a Python programmer)</p>
</blockquote>
<p>I suspect you are not the only one that will have <code>a[i]!</code> all over the place.</p>
</blockquote>
<p>If we end up doing this it could be worth to add a linter that tells you to maybe add  <code>!</code> to your function name if it could panic.</p>
<p>If this lint works recursively (that is if your function calls a function that could panic) it might end up being a little oppressive though since you could of course in theory be sure that you are not violating its invariants and it will never panic but the compiler keeps yelling at you (an option could be used to address this but people might end up being annoyed if there is too many "most likely false positives" they have to option away)</p>
<p>If it does not work recursively (so only check if you directly call to panic!) it could be a little too loose as well though so I'm not 100% sure whether it's worth to go through with it, we'll likely end up with something that either annoys people too much or doesn't annoy them enough :D</p>
<p>Just an idea^^</p>



<a name="287890468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287890468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287890468">(Jun 29 2022 at 17:36)</a>:</h4>
<p>Sort of related to this, in a loop such as <code>for i in [0:37] do ...</code> I wonder if there could be some interface where <code>[0:37]</code> could provide some sort of membership proof if you were to write something like <code>for h : i in [0:37] do ...</code>. I would imagine in this case the proof would be of <code>0 &lt;= i /\ i &lt; 37</code>. This would help with any sort of proposal where <code>a[i]</code> uses <code>i : Fin _</code>.</p>
<p>There are other solutions to this, but this sort of feature might still be useful.</p>



<a name="287898437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287898437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287898437">(Jun 29 2022 at 18:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287890468">said</a>:</p>
<blockquote>
<p>Sort of related to this, in a loop such as <code>for i in [0:37] do ...</code> I wonder if there could be some interface where <code>[0:37]</code> could provide some sort of membership proof if you were to write something like <code>for h : i in [0:37] do ...</code>. I would imagine in this case the proof would be of <code>0 &lt;= i /\ i &lt; 37</code>. This would help with any sort of proposal where <code>a[i]</code> uses <code>i : Fin _</code>.</p>
<p>There are other solutions to this, but this sort of feature might still be useful.</p>
</blockquote>
<p>We already have the <code>for h : i  in [0:37]</code> feature :)<br>
See <a href="https://github.com/leanprover/lean4/blob/master/RELEASES.md">https://github.com/leanprover/lean4/blob/master/RELEASES.md</a> for an example.</p>



<a name="287899839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287899839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287899839">(Jun 29 2022 at 18:45)</a>:</h4>
<blockquote>
<p>If we end up doing this it could be worth to add a linter that tells you to maybe add ! to your function name if it could panic.</p>
</blockquote>
<p>That would be great :)</p>



<a name="287906235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287906235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287906235">(Jun 29 2022 at 19:30)</a>:</h4>
<blockquote>
<p>If we end up doing this it could be worth to add a linter that tells you to maybe add  <code>!</code> to your function name if it could panic.</p>
</blockquote>
<p>To play the devil's advocate, how would you even prove that a function never calls panic?  We have a wonderful proof language, but it cannot say anything about panics.</p>



<a name="287907150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287907150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287907150">(Jun 29 2022 at 19:38)</a>:</h4>
<p>Maybe the panic checker could be like the Lean 3 noncomputability checker, where it makes a best-effort attempt to determine whether or not a function might panic, but it's not a proof per se.  This is more subtle, though, since you'd want to record a predicate on a function's inputs that, when true, guarantee the function will not panic.</p>



<a name="287908073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287908073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287908073">(Jun 29 2022 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287907150">said</a>:</p>
<blockquote>
<p>Maybe the panic checker could be like the Lean 3 noncomputability checker, where it makes a best-effort attempt to determine whether or not a function might panic, but it's not a proof per se.  This is more subtle, though, since you'd want to record a predicate on a function's inputs that, when true, guarantee the function will not panic.</p>
</blockquote>
<p>I was assuming the same kind of best-effort attempt, but it seems Gabriel's point is that we will have to add <code>!</code> to a bunch of functions that depend on <code>panic</code>, but <code>panic</code> is not actually reachable.</p>



<a name="287908421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287908421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287908421">(Jun 29 2022 at 19:48)</a>:</h4>
<p>It might still be useful to have this kind of linter if we add some kind of annotation for marking functions that should be viewed as "panic free"  even if they depend on it.</p>



<a name="287908573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287908573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287908573">(Jun 29 2022 at 19:49)</a>:</h4>
<p>Maybe this panic checker is like the termination checker, where if you can add hypotheses locally to try to automatically prove that the no-panic predicate for a given function application is true?</p>



<a name="287909056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287909056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287909056">(Jun 29 2022 at 19:53)</a>:</h4>
<p>Nontermination is actually a good comparison because it's not syntactically evident and cannot be proven in Lean.</p>



<a name="287909336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287909336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287909336">(Jun 29 2022 at 19:55)</a>:</h4>
<p>It's certainly vexing that you can prove your program correct, but then it panics or runs into an infinite loop when you run it and there's nothing you can do to rule it out.</p>



<a name="287910659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287910659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287910659">(Jun 29 2022 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287907150">said</a>:</p>
<blockquote>
<p>This is more subtle, though, since you'd want to record a predicate on a function's inputs that, when true, guarantee the function will not panic.</p>
</blockquote>
<p>Two more applications of this definedness predicate come to mind:</p>
<ol>
<li>If the predicate is satisfied for the inputs of a <code>partial def</code>, then we should have a theorem that the <code>partial def</code> is equal to its body.</li>
<li>(Very speculatively) The predicate could also record whether all integrals, derivatives, etc., are well-defined.</li>
</ol>



<a name="287911086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287911086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287911086">(Jun 29 2022 at 20:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287908073">said</a>:</p>
<blockquote>
<p>I was assuming the same kind of best-effort attempt, but it seems Gabriel's point is that we will have to add <code>!</code> to a bunch of functions that depend on <code>panic</code>, but <code>panic</code> is not actually reachable.</p>
</blockquote>
<p>More pointedly, I think we would need to add <code>!</code> to most definitions since lots of low-level functions use panic.</p>



<a name="287914939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287914939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287914939">(Jun 29 2022 at 20:30)</a>:</h4>
<p>Yes, most functions calling <code>!</code> functions are <em>supposed</em> to never panic, so an opt-out lint might be a bit bothersome; just think of all the functions indexing into arrays without conclusively proving they're doing the right thing. Instead there could be a <code>@[no_panic]</code> opt-in annotation  for people that really want to make sure.</p>



<a name="287916652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287916652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287916652">(Jun 29 2022 at 20:35)</a>:</h4>
<p>For conditionally panicking functions as well as their <code>?D </code> variants, I still wonder if they should be captured by returning a common <code>Option</code> subtype a la <code>{ x : Option A // i &lt; as.size -&gt; x.isSome }</code>. Then all the variants can be expressed as operations on this type. But it would require unboxed unions to avoid (most of) the <code>Option</code> overhead.</p>



<a name="287921551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287921551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287921551">(Jun 29 2022 at 20:51)</a>:</h4>
<p>Yeah the false positives part is exactly the thing I was worrying about above as well, it might end up just being bothersome to the user.</p>



<a name="287925187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287925187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287925187">(Jun 29 2022 at 21:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287914939">said</a>:</p>
<blockquote>
<p>Yes, most functions calling <code>!</code> functions are <em>supposed</em> to never panic, so an opt-out lint might be a bit bothersome; just think of all the functions indexing into arrays without conclusively proving they're doing the right thing. Instead there could be a <code>@[no_panic]</code> opt-in annotation  for people that really want to make sure.</p>
</blockquote>
<p>Maybe a concrete version of what I was proposing is that you might have an annotation like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[no_panic idx &lt; self.size]</span>
<span class="kd">def</span> <span class="n">Array.getOp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">self.get</span><span class="bp">!</span> <span class="n">idx</span>
</code></pre></div>
<p>and then the panic checker could try to prove that condition automatically wherever the function is used. In simple cases the panic checker could try to synthesize this condition for functions that call conditionally-panicking functions.</p>



<a name="287926859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287926859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287926859">(Jun 29 2022 at 21:16)</a>:</h4>
<p>If you can automatically prove this, then you can also provide the <code>Fin</code> needed for <code>Array.get</code>. I think serious software verification will always require that the code is syntactically <code>panic</code>-free (and <code>implementedBy</code>-free).</p>



<a name="287930524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287930524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287930524">(Jun 29 2022 at 21:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287916652">said</a>:</p>
<blockquote>
<p>But it would require unboxed unions to avoid (most of) the <code>Option</code> overhead.</p>
</blockquote>
<p>I completely forgot that I already had a solution for that... that I never wrote down until now</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Conditional</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">cond</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cond</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kn">namespace</span> <span class="n">Conditional</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">cond</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">get</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Conditional</span> <span class="n">α</span> <span class="n">cond</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cond</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">c</span> <span class="n">h</span>
<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">get</span><span class="bp">!</span> <span class="o">[</span><span class="n">Decidable</span> <span class="n">cond</span><span class="o">]</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Conditional</span> <span class="n">α</span> <span class="n">cond</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">cond</span> <span class="k">then</span> <span class="n">c.get</span> <span class="n">h</span> <span class="k">else</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"in the disco"</span>
<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">get</span><span class="bp">?</span> <span class="o">[</span><span class="n">Decidable</span> <span class="n">cond</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Conditional</span> <span class="n">α</span> <span class="n">cond</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">cond</span> <span class="k">then</span> <span class="n">c.get</span> <span class="n">h</span> <span class="k">else</span> <span class="n">none</span>
<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">getD</span> <span class="o">[</span><span class="n">Decidable</span> <span class="n">cond</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Conditional</span> <span class="n">α</span> <span class="n">cond</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">cond</span> <span class="k">then</span> <span class="n">c.get</span> <span class="n">h</span> <span class="k">else</span> <span class="n">default</span>

<span class="kd">end</span> <span class="n">Conditional</span>

<span class="kd">def</span> <span class="n">Array.get'</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Conditional</span> <span class="n">α</span> <span class="o">(</span><span class="n">i</span> <span class="bp">&lt;</span> <span class="n">as.size</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">as.get</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="c1">-- test code generation</span>
<span class="kd">set_option</span> <span class="n">trace.compiler.ir.result</span> <span class="n">true</span>
<span class="kd">def</span> <span class="n">Array.get</span><span class="bp">!'</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">as.get'</span> <span class="n">i</span> <span class="bp">|&gt;.</span><span class="n">get</span><span class="bp">!</span>
<span class="kd">def</span> <span class="n">Array.getD'</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">as.get'</span> <span class="n">i</span> <span class="bp">|&gt;.</span><span class="n">getD</span>
<span class="kd">def</span> <span class="n">Array.get</span><span class="bp">?'</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">as.get'</span> <span class="n">i</span> <span class="bp">|&gt;.</span><span class="n">get</span><span class="bp">?</span>
</code></pre></div>
<p>As far as I can see, the generated code is optimal thanks to eta expansion</p>



<a name="287957985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287957985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287957985">(Jun 30 2022 at 00:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287906235">said</a>:</p>
<blockquote>
<p>To play the devil's advocate, how would you even prove that a function never calls panic?  We have a wonderful proof language, but it cannot say anything about panics.</p>
</blockquote>
<p>I don't understand what you mean by this? If a definition has branch where it panics and a branch where it doesn't, it can be perfectly possible to prove that it does not panic for certain inputs (i.e., that the result is equal to that of the non-panicking branch). For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">opaque</span> <span class="n">does_not_panic</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">panic_if_true</span><span class="bp">!</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">b</span> <span class="k">then</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"was true"</span> <span class="k">else</span> <span class="n">does_not_panic</span>

<span class="kd">theorem</span> <span class="n">false_does_not_panic</span> <span class="o">:</span> <span class="n">panic_if_true</span><span class="bp">!</span> <span class="n">false</span> <span class="bp">=</span> <span class="n">does_not_panic</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">unfold</span> <span class="n">panic_if_true</span><span class="bp">!;</span> <span class="n">simp</span>
</code></pre></div>



<a name="287958988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287958988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287958988">(Jun 30 2022 at 00:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287859389">said</a>:</p>
<blockquote>
<p>We have discussed this issue in the past. One of the proposals was:</p>
<ul>
<li><code>a[i]!</code> panics if index out of bounds</li>
<li><code>a[i]?</code> returns <code>Option</code></li>
<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>
</ul>
</blockquote>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287930524">said</a>:</p>
<blockquote>
<p>I completely forgot that I already had a solution for that... that I never wrote down until now</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Conditional</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">cond</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cond</span> <span class="bp">→</span> <span class="n">α</span>
<span class="c1">-- [...]</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I personally really like both of these approaches. The <code>Conditional</code> solution is much more general and flexible whereas the bracket macro solution is conveniently terse (but still clear).</p>
<p>It might even be possible to mix the two. For example, to ease the transition, <code>getOp</code> could return a <code>Conditional</code> and <code>Coditional</code> could have a <code>Coe (Conditional a) a := (.get!)</code> instance. This would make most current uses cases still work (due to the coercion). The <code>[]?</code> and <code>[]!</code> macros could be defined on top of this as shorthand for <code>Conditional.get?/getD</code>.  Then, once users have shifted to the new approach, the <code>Conditional</code> coercion could be removed, and the <code>[]</code> could be change to <code>Fin</code> version if desired.</p>



<a name="287963200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287963200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287963200">(Jun 30 2022 at 01:26)</a>:</h4>
<p>I'm also in favour of the notation: <code>a[i]!</code> <code>a[i]?</code>  <code>a[i]</code></p>
<p>Personally, on my own data types I already use the <code>Fin</code> version of <code>a[i]</code>. However instead of <code>a[i]!</code>, I have defined a macro <code>!x</code> that expands to <code>⟨x, sorry⟩</code>, so I can write <code>a[!i]</code> where <code>i</code> is <code>Nat</code>.</p>



<a name="287963620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287963620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287963620">(Jun 30 2022 at 01:33)</a>:</h4>
<p>With this change to the meaning of <code>a[i]</code>, I would also point out that it might be worth to change the type of the index <code>i</code> in <code>for i in [0:n]</code> from <code>Nat</code> to <code>Fin n</code>. Or something along those lines, like notation <code>for i in [n]</code> to produce the <code>Fin n</code> index.</p>



<a name="287998681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/287998681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#287998681">(Jun 30 2022 at 09:25)</a>:</h4>
<blockquote>
<p>If a definition has branch where it panics and a branch where it doesn't, it can be perfectly possible to prove that it does not panic for certain inputs (i.e., that the result is equal to that of the non-panicking branch).</p>
</blockquote>
<p>This is of course not nearly sufficient for panic-freeness:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"every time"</span>
  <span class="n">x</span> <span class="bp">-</span> <span class="n">x</span>

<span class="k">#eval</span> <span class="n">a</span>  <span class="c1">-- beautiful stacktrace</span>

<span class="kd">theorem</span> <span class="n">a_does_not_panic</span><span class="bp">?!?</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
</code></pre></div>



<a name="288012358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288012358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288012358">(Jun 30 2022 at 11:28)</a>:</h4>
<p>Why <code>panic!</code> doesn't require the <code>unsafe</code> attribute on a definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">List.get</span><span class="bp">!'</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">_</span><span class="o">,</span>  <span class="mi">0</span>   <span class="bp">=&gt;</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">as</span><span class="o">,</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">get</span><span class="bp">!'</span> <span class="n">as</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span>     <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"invalid index"</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">sizeOf</span> <span class="n">l</span>
<span class="n">decreasing_by</span> <span class="n">decreasing_tactic</span>
</code></pre></div>
<p>Depending on <code>lean_set_exit_on_panic</code> and <code>lean_set_panic_messages</code> flags this pure function with explicit proof of termination performs I/O and throws a runtime exception. And when these flags aren't enabled (default behavior when building a binary executable) it could silently introduce a logical bug that is ten times worse. </p>
<p>With <code>lean_set_panic_messages(true)</code> Lean is lying about the type of this definition (<code>[Inhabited α] → List α → Nat → IO α</code>).<br>
With <code>lean_set_exit_on_panic(true)</code> Lean is lying about termination of this function. <br>
And without these flags enabled you won't know that something is going wrong.</p>
<p>Doesn't this compromise all static guarantees that Lean could provide?</p>



<a name="288012747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288012747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288012747">(Jun 30 2022 at 11:32)</a>:</h4>
<p><code>unsafe</code> has a very precise definition: it can undermine memory safety. <code>panic!</code> can't.</p>



<a name="288013020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288013020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288013020">(Jun 30 2022 at 11:34)</a>:</h4>
<p>And as discussed above, it is quite hard to make a non-trivial Lean program panic-free, so it definitely should not require a viral annotation</p>



<a name="288013096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288013096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288013096">(Jun 30 2022 at 11:35)</a>:</h4>
<blockquote>
<p><code>unsafe</code> has a very precise definition: it can undermine memory safety.</p>
</blockquote>
<p><code>unsafe</code> also has a second effect: it compromises logical soundness (to clarify: inside <code>unsafe</code>, that is).  <code>panic!</code> is even true constructively.</p>



<a name="288019193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288019193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Evgeniy Kuznetsov <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288019193">(Jun 30 2022 at 12:25)</a>:</h4>
<p>I don't insist on this exact keyword, it can be anything else if you consider <code>unsafe</code> unsuitable.<br>
<span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288013020">said</a>:</p>
<blockquote>
<p>And as discussed above, it is quite hard to make a non-trivial Lean program panic-free, so it definitely should not require a viral annotation</p>
</blockquote>
<p>Even <code>implementedBy</code> trick doesn't  allow to effectively use such a viral annotation when writing a non-trivial program?</p>



<a name="288084866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288084866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288084866">(Jun 30 2022 at 20:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287998681">said</a>:</p>
<blockquote>
<p>This is of course not nearly sufficient for panic-freeness.</p>
</blockquote>
<p>Admittedly, sure, this is true in the context of adversarial examples as you point out. However, it still reasonable to do so in places where <code>panic!</code> is used in a conventional manner (for unproved invariant violations) and the goal is just to prove that the relevant invariant actually does hold  and avoids the panic in a specific case. On the other hand, if the goal is oblivious zero trust panic safety, though, then no, it is not sufficient.</p>



<a name="288294671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288294671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288294671">(Jul 02 2022 at 23:10)</a>:</h4>
<p>Pushed the proposal:</p>
<ul>
<li><code>a[i]!</code> panics if index out of bounds</li>
<li><code>a[i]?</code> returns Option</li>
<li><code>a[i]</code> uses proof and i is a Fin.</li>
</ul>
<p>It is quite disruptive, but it is better now than after the first official release at the end of the summer. <br>
The <code>Array</code> type implements the three notations.<br>
The <code>String</code> type currently only implements the <code>a[i]?</code>, and <code>String.get</code> still returns a default value for invalid positions. <br>
We also have the notation <code>a[i, h]</code> as sugar for <code>a[⟨i, h⟩]</code></p>



<a name="288307808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288307808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288307808">(Jul 03 2022 at 04:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288294671">said</a>:</p>
<blockquote>
<p>We also have the notation <code>a[i, h]</code> as sugar for <code>a[⟨i, h⟩]</code></p>
</blockquote>
<p><strong>Design question:</strong> Would it be possible/reasonable to have <code>a[i, h]</code> expand to yet another <code>getOp</code> version that takes the index and hypothesis as separate parameters (e.g., <code>Array.uget</code>)? This could avoid the potential boxing/unboxing overhead that comes with <code>Fin</code> and remove the need for other types which have an index condition and use the syntax to have a <code>Subtype</code>-like structure (or directly use <code>Subtype</code>)? Just a thought, not sure how reasonable/worthwhile of an idea it is.</p>



<a name="288313519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288313519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288313519">(Jul 03 2022 at 07:28)</a>:</h4>
<p>I'm not sure about the notation <code>a[i, h]</code>. What about multi dimensional arrays, I would like to have a notation <code>a[i, j]</code> for matrices. Wouldn't be there a clash?</p>



<a name="288318150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288318150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288318150">(Jul 03 2022 at 09:35)</a>:</h4>
<p>Also at some point I would like to experiment with notation <code>a[:, j]</code> for slices i.e. j-th column of a matrix . It would be nice if the notation would not clash with that either. (Not saying it does right now but it would be nice to keep this in mind when doing further changes)</p>



<a name="288318345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288318345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288318345">(Jul 03 2022 at 09:40)</a>:</h4>
<p>One thing I do not understand, is why is the notation <code>a[i]</code> done with <code>getOp</code> which has special requirements on argument names etc. Why it is not a simple macro/notation for <code>a.get i</code> ? My guess, is it related to Lean's bootstrapping?</p>



<a name="288319767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288319767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xubai Wang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288319767">(Jul 03 2022 at 10:18)</a>:</h4>
<p>Is it possible to have a <code>GetOp</code> typeclass to reuse this syntax for different index types (like <code>Nat</code>, <code>Range</code>,  <code>Nat × Nat </code>,  <code>Fin</code> and <code>Nat × Prop</code>) at the same time?</p>



<a name="288323037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288323037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xubai Wang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288323037">(Jul 03 2022 at 11:39)</a>:</h4>
<p>For example：</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getOp</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">γ</span>

<span class="kd">class</span> <span class="n">GetOp</span><span class="bp">?</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getOp</span><span class="bp">?</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">For Lists</span>
<span class="cm">-/</span>

<span class="c1">-- as[⟨n, h⟩]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Fin</span> <span class="bp">∘</span> <span class="n">List.length</span><span class="o">)</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">getOp</span> <span class="n">as</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">as.get</span> <span class="n">n</span>

<span class="c1">-- as[n, h]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">×'</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">as.length</span><span class="o">)</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">getOp</span> <span class="n">as</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">as.get</span> <span class="o">⟨</span><span class="n">x.fst</span><span class="o">,</span> <span class="n">x.snd</span><span class="o">⟩</span>

<span class="c1">-- as[n]?</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span><span class="bp">?</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="n">Nat</span> <span class="o">(</span><span class="n">Option</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getOp</span><span class="bp">?</span> <span class="n">as</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">as.get</span><span class="bp">?</span> <span class="n">n</span>

<span class="c1">-- as[[m:n]]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="n">Range</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getOp</span> <span class="n">as</span> <span class="n">r</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">Matrix m[i, j]</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span><span class="bp">?</span> <span class="o">(</span><span class="n">Matrix</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Nat</span> <span class="bp">×</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="288325906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288325906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288325906">(Jul 03 2022 at 12:46)</a>:</h4>
<p>I'm a bit unsure if <code>a[i, j]</code> should be a shorthand for <code>a[i][j]</code> or <code>a[(i, j)]</code>.</p>
<p>Effectively, do you understand matrix as <code>Fin n -&gt; Fin m -&gt; Float</code> or as <code>Prod (Fin n) (Fin m) -&gt; Float</code>.</p>
<p>The second one might be boxing those indices unnecessarily.</p>



<a name="288326519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288326519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xubai Wang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288326519">(Jul 03 2022 at 13:00)</a>:</h4>
<p>The detailed decision is up for who implements it. Also I think boxing (dereferencing) may not be a big overhead in the future, since we will have stack allocated value "soon"?</p>



<a name="288326630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288326630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288326630">(Jul 03 2022 at 13:03)</a>:</h4>
<p>Thanks for the feedback. I will remove the <code>a[i, h]</code> for now. The issue raised by <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> was also exposed by one of our tests, and I used priorities to override the notation.<br>
<a href="https://github.com/leanprover/lean4/commit/a0fdc2d05049ecbaf21f57e9cc4a997e0c6bed91">https://github.com/leanprover/lean4/commit/a0fdc2d05049ecbaf21f57e9cc4a997e0c6bed91</a><br>
I will post other messages discussing how the notation works and other suggestions.</p>



<a name="288326880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288326880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288326880">(Jul 03 2022 at 13:08)</a>:</h4>
<p>We often have to decide whether we should use "dot-notation" (aka namespace-oriented) or "type classes". I am coping here a thread we had in the dev channel last year. It describes the "pros" and "cons" of each approach, and examples.</p>
<h2>type classes pros</h2>
<ul>
<li>Chaining. That is, given an instance <code>ToString A</code>, we can create an instance <code>ToString (List A)</code></li>
<li>We can write polymorphic methods </li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">[</span><span class="n">ToString</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
   <span class="s2">"&gt;&gt; "</span> <span class="bp">++</span> <span class="n">toString</span> <span class="n">a</span>
</code></pre></div>
<h2>type classes cons</h2>
<ul>
<li>Depends heavily on unification. Moreover, it becomes quite unreliable when higher-order unification has to be used. This is often an issue when we want to make a polymorphic method as general as possible. More about this later. </li>
<li>Universe constraints. It is part of the unification problem described in the previous item, but it is often overlooked since the universes are often implicit.</li>
<li>We don't want type class resolution to assign metavariables occurring in input parameters. So, TC often fails in scenarios we don't have sufficient information. The new <code>defaultInstance</code> feature minimizes this problem.</li>
</ul>
<h2>dot-notation pros</h2>
<ul>
<li>Low tech and predictable. Given <code>x : C as</code>, <code>x.foo</code> is notation for <code>C.foo x</code>. The parameters <code>as</code> may contain metavariables. </li>
<li>Allow non-uniform signatures. That is, <code>C.foo</code> and <code>D.foo</code> may have completely different types.</li>
</ul>
<h2>dot-notation cons</h2>
<ul>
<li>No support for chaining </li>
<li>No support for writing polymorphic functions. That is, we can't write</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a.toString</span>
</code></pre></div>
<h1>An Example: the <code>x[i]</code> notation</h1>
<p>In the <code>master</code> branch, <code>x[i]</code> is a notation based on the dot-notation. That is, given <code>x : C as</code>, it is a notation for <code>x.getOp i</code>.<br>
This is flexible since the type of <code>i</code> may or may not depend on <code>x</code>, the result type may or may not depend on <code>x</code> and/or <code>i</code>, and the only information the elaborator needs is the head symbol <code>C</code>, and <code>as</code> may contain a bunch of metavariables. </p>
<p>Now, suppose we have used a type class <code>GetElem</code> for implementing the notation <code>x[i]</code>. The first try would be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="o">:</span> <span class="n">ρ</span> <span class="bp">→</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>
<p>The problem here is that there isn't support for dependencies. For example, we can't implement <code>getElem</code> using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Array.get</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">a.size</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">...</span>
</code></pre></div>
<p>since the index <code>i</code> depends on <code>a</code>.<br>
Then, we may try to define a more general <code>GetElem</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="n">ρ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">))</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">((</span><span class="n">c</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ι</span> <span class="n">c</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="n">c</span> <span class="n">i</span>
</code></pre></div>
<p>Then, we can add instances such as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">a.size</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">a.get</span> <span class="n">i</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">lt</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">RBMapDep</span> <span class="n">α</span> <span class="n">β</span> <span class="n">lt</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">Option</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">a.find</span><span class="bp">?</span> <span class="n">i</span>
</code></pre></div>
<p>Everything looks great until we try to use <code>getElem</code>. The problem is that it generates nontrivial higher-order unification problems.<br>
Note that the type of <code>i</code> at <code>t[i]</code> is of the form <code>?m t</code>. Suppose we have <code>t : Array Nat</code>, after we resolve the TC problem, we have to solve the unification problem <code>?m t =?= Fin t.size</code>. Even a simple version where <code>t</code> is just a variable and we don't take into account reduction, we have two solutions</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">?</span><span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">x.size</span>
<span class="bp">?</span><span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">t.size</span>
</code></pre></div>
<p>In this particular case, the first solution is the right one, but, in general, there is no way to decide. In Lean 2, we have tried to transform elaboration into a constraint solving problem, but the performance was bad, and error messages that are very hard to understand. <br>
So, I don't see how to have classes that rely on higher-order unification and are reliable in practice.</p>



<a name="288327076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288327076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288327076">(Jul 03 2022 at 13:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288307808">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288294671">said</a>:</p>
<blockquote>
<p>We also have the notation <code>a[i, h]</code> as sugar for <code>a[⟨i, h⟩]</code></p>
</blockquote>
<p><strong>Design question:</strong> Would it be possible/reasonable to have <code>a[i, h]</code> expand to yet another <code>getOp</code> version that takes the index and hypothesis as separate parameters (e.g., <code>Array.uget</code>)? This could avoid the potential boxing/unboxing overhead that comes with <code>Fin</code> and remove the need for other types which have an index condition and use the syntax to have a <code>Subtype</code>-like structure (or directly use <code>Subtype</code>)? Just a thought, not sure how reasonable/worthwhile of an idea it is.</p>
</blockquote>
<p>This is an interesting suggestion, but the "function selection process" would have to depend on the type of the index too. The current dispatch is based only on the type of <code>a</code>. Note that, given <code>a : Array Int</code> when we type <code>a[_]</code>, the hole has type <code>Fin a.size</code>. <br>
If we move to type-classes, then we have the problems described in the previous comment.</p>



<a name="288327154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288327154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288327154">(Jul 03 2022 at 13:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288318345">said</a>:</p>
<blockquote>
<p>One thing I do not understand, is why is the notation <code>a[i]</code> done with <code>getOp</code> which has special requirements on argument names etc. Why it is not a simple macro/notation for <code>a.get i</code> ? My guess, is it related to Lean's bootstrapping?</p>
</blockquote>
<p>The notation uses the "dot notation" (aka namespace-based) approach described above.</p>



<a name="288355366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288355366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288355366">(Jul 04 2022 at 00:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288327076">said</a>:</p>
<blockquote>
<p>[T]he "function selection process" would have to depend on the type of the index too. [..] If we move to type-classes, then we have the problems described in the previous comment.</p>
</blockquote>
<p>What if we combined the two? That is, what if we used type class synthesis for the "function selection process" and once found, expanded it via a macro. For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Meta</span> <span class="n">Term</span>

<span class="kd">class</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">op</span> <span class="o">:</span> <span class="n">Name</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">``</span><span class="n">Array.getOp</span><span class="o">⟩</span>

<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">unsafeEvalExpr</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">ToExpr</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">TermElabM</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">Meta.evalExpr</span> <span class="n">α</span> <span class="o">(</span><span class="n">toTypeExpr</span> <span class="n">α</span><span class="o">)</span> <span class="n">e</span>

<span class="kd">@[implementedBy unsafeEvalExpr]</span>
<span class="n">opaque</span> <span class="n">evalExpr</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">ToExpr</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">TermElabM</span> <span class="n">α</span>

<span class="n">elab</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]'"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">a</span> <span class="n">none</span>
  <span class="n">synthesizeSyntheticMVarsNoPostponing</span>
  <span class="k">let</span> <span class="n">α</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">e</span>
  <span class="k">let</span> <span class="n">u</span> <span class="bp">←</span> <span class="n">getDecLevel</span> <span class="n">α</span>
  <span class="k">let</span> <span class="n">inst</span> <span class="o">:=</span> <span class="n">mkApp</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">GetOp</span> <span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="n">α</span>
  <span class="k">let</span> <span class="n">instVal</span> <span class="bp">←</span> <span class="n">synthInstance</span> <span class="n">inst</span>
  <span class="k">let</span> <span class="n">ope</span> <span class="bp">←</span> <span class="n">instantiateMVars</span> <span class="o">(</span><span class="n">mkAppN</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">GetOp.op</span> <span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="bp">#</span><span class="o">[</span><span class="n">α</span><span class="o">,</span> <span class="n">instVal</span><span class="o">])</span>
  <span class="k">let</span> <span class="n">op</span> <span class="bp">←</span> <span class="n">evalExpr</span> <span class="n">Name</span> <span class="n">ope</span>
  <span class="k">let</span> <span class="n">stx</span> <span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="o">(</span><span class="n">mkCIdent</span> <span class="n">op</span><span class="o">)</span> <span class="bp">$</span><span class="n">a</span> <span class="bp">$</span><span class="n">i</span><span class="o">)</span>
  <span class="n">withMacroExpansion</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getRef</span><span class="o">)</span> <span class="n">stx</span> <span class="bp">&lt;|</span> <span class="n">elabTerm</span> <span class="n">stx</span> <span class="n">none</span>

<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="bp">'</span> <span class="c1">-- 1</span>
</code></pre></div>
<p>This would enable the chain benefits of type classes, while avoiding the unification problem.</p>



<a name="288398232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288398232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288398232">(Jul 04 2022 at 11:38)</a>:</h4>
<p>My two cents: I was expecting the proof in <code>a[i]</code> to go after the brackets, as in <code>a[i] h</code>, as if it were replacing the <code>!</code> or <code>?</code></p>



<a name="288402134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288402134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288402134">(Jul 04 2022 at 12:16)</a>:</h4>
<p>Coincidentally that's exactly what you'd have to/could do if <code>a[i]</code> returned <code>Conditional</code></p>



<a name="288418557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288418557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288418557">(Jul 04 2022 at 14:56)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> </p>
<blockquote>
<p>What if we combined the two? That is, what if we used type class synthesis for the "function selection process" and once found, expanded it via a macro. For example:</p>
</blockquote>
<p>One nice feature of your approach is that we can use scoped instances and instance priorities to select which function is used to implement <code>a[i]</code>. For example, we could have </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Array.unsafeReads</span>
<span class="n">scoped</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">``</span><span class="n">Array.get</span><span class="bp">!</span><span class="o">⟩</span>
<span class="kd">end</span> <span class="n">Array.unsafeReads</span>

<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">][⟨</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decide</span><span class="o">⟩]</span><span class="bp">'</span>  <span class="c1">-- index is a Fin</span>
<span class="kn">open</span> <span class="n">Array.unsafeReads</span>
<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="bp">'</span>  <span class="c1">-- index is a Nat</span>
</code></pre></div>
<p>This is good. On the other hand, it feels like an abuse of the type class resolution feature. We would be using it to implement a mapping from type to function name. Let's see what others have to say about this.</p>



<a name="288419501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288419501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288419501">(Jul 04 2022 at 15:05)</a>:</h4>
<p>A typeclass solution that is not parameterized over the index type (like in Rust, for prior work) to me just feels... disappointing. It's neither here nor there.</p>



<a name="288420023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288420023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288420023">(Jul 04 2022 at 15:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288419501">said</a>:</p>
<blockquote>
<p>A typeclass solution that is not parameterized over the index type (like in Rust, for prior work) to me just feels... disappointing</p>
</blockquote>
<p>Yes, it is disappointing, but Rust does not have dependent types. So, they can avoid the higher-order unification problems introduced by a type class such as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="n">ρ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">((</span><span class="n">c</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ι</span> <span class="n">c</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="n">c</span> <span class="n">i</span>
</code></pre></div>
<p>Because they can simply use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="o">:</span> <span class="n">ρ</span> <span class="bp">→</span>  <span class="n">ι</span>  <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>



<a name="288421620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288421620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288421620">(Jul 04 2022 at 15:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288402134">said</a>:</p>
<blockquote>
<p>Coincidentally that's exactly what you'd have to/could do if <code>a[i]</code> returned <code>Conditional</code></p>
</blockquote>
<p>The <code>Conditional</code> proposal streamlines the definition of <code>get?</code>, <code>get!</code>, etc. This is good, but I have two concerns.</p>
<ul>
<li>If <code>i : Fin a.size</code>, we would have to write <code>a[i.val] i.isLt</code> </li>
<li>It may impact the compilation times. The code generator is creating/eliminating joint-points as it inlines these definitions to eliminate the overhead.</li>
</ul>



<a name="288421848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288421848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288421848">(Jul 04 2022 at 15:29)</a>:</h4>
<p>Would this be a defensible use case for <code>[macroInline]</code>? I haven't checked the resulting IR yet, or whether it avoids the join points.</p>



<a name="288422559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288422559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288422559">(Jul 04 2022 at 15:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288421620">said</a>:</p>
<blockquote>
<ul>
<li>If <code>i : Fin a.size</code>, we would have to write <code>a[i.val] i.isLt</code> </li>
</ul>
</blockquote>
<p>Yes. We can keep it as taking <code>Fin</code> and use <code>Conditional.get</code> in its implementation.</p>



<a name="288422637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288422637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288422637">(Jul 04 2022 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288421848">said</a>:</p>
<blockquote>
<p>Would this be a defensible use case for <code>[macroInline]</code>? I haven't checked the resulting IR yet, or whether it avoids the join points.</p>
</blockquote>
<p>Not sure it would work. The code generator would still find the nested if-then-else.</p>



<a name="288422838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288422838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288422838">(Jul 04 2022 at 15:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288422559">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288421620">said</a>:</p>
<blockquote>
<ul>
<li>If <code>i : Fin a.size</code>, we would have to write <code>a[i.val] i.isLt</code> </li>
</ul>
</blockquote>
<p>Yes. We can keep it as taking <code>Fin</code> and use <code>Conditional.get</code> in its implementation.</p>
</blockquote>
<p>Not sure whether it is worth the trouble.</p>



<a name="288423574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288423574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288423574">(Jul 04 2022 at 15:47)</a>:</h4>
<p>I can see a substantial improvement if we can solve the higher-order unification problems generated by a type-class like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="n">ρ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">((</span><span class="n">c</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ι</span> <span class="n">c</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="n">c</span> <span class="n">i</span>
</code></pre></div>
<p>We could try to write a custom elaboration function for <code>getElem</code> applications. We have implemented similar custom elaborators before (e.g., <code>▸</code> for <code>Eq.subst</code>). It is hard to tell how well it would work. <br>
If we succeed, we would be able to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">a.get</span><span class="bp">!</span> <span class="n">i</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">a.size</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">a.get</span> <span class="n">i</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">USize</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">i.toNat</span> <span class="bp">&lt;</span> <span class="n">a.size</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">a</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">a.uget</span> <span class="n">i</span>
</code></pre></div>
<p>We would still need <code>a[i]?</code> for the <code>Option</code> case, or use a scoped instance for it.</p>



<a name="288424264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288424264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288424264">(Jul 04 2022 at 15:53)</a>:</h4>
<p>I was thinking along similar lines, that I would love to tell the elaborator not to bother creating the HO problem regarding <code>i : ?m c</code>, but that <code>i : ?m'</code> is enough for now until TC resolution is done. It seems like typeclasses like this will be a reoccurring issue.</p>



<a name="288426262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288426262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288426262">(Jul 04 2022 at 16:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288424264">said</a>:</p>
<blockquote>
<p>I was thinking along similar lines, that I would love to tell the elaborator not to bother creating the HO problem regarding <code>i : ?m c</code>, but that <code>i : ?m'</code> is enough for now until TC resolution is done. It seems like typeclasses like this will be a reoccurring issue.</p>
</blockquote>
<p>It is not clear to me how your proposal would work. When using the <code>GetElem</code> type class above, we have to infer <code>ρ</code> and <code>ι</code> before we invoke the TC resolution procedure. To infer <code>ι</code>, we need higher-order unification.</p>



<a name="288426518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288426518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288426518">(Jul 04 2022 at 16:13)</a>:</h4>
<blockquote>
<p>It seems like typeclasses like this will be a reoccurring issue.</p>
</blockquote>
<p>I agree. If we solve it for <code>GetElem</code>, we can try to generalize the solution.</p>



<a name="288426711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288426711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288426711">(Jul 04 2022 at 16:15)</a>:</h4>
<p>Oh, I falsely assumed <code>ι</code> was an outParam. I don't know if it <em>should</em> be one, but that would be the closer modelling compared to the current design I think.</p>



<a name="288427390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288427390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288427390">(Jul 04 2022 at 16:22)</a>:</h4>
<p>If <code>ι</code> is an <code>outParam</code>, I don't see a big motivation for moving to type classes. We would be able to use scoped instances to select different implementations like in <span class="user-mention" data-user-id="315577">@Mac</span>'s proposal. Note that <span class="user-mention" data-user-id="315577">@Mac</span>'s proposal completely avoids all ho-unification issues.</p>



<a name="288427863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288427863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288427863">(Jul 04 2022 at 16:27)</a>:</h4>
<p><code>ι</code> not being an <code>outParam</code> would be the strongest point in favor for type classes to me, to enable overloading of the index type. But I don't see how to reconcile that with the HO issues, yeah.</p>



<a name="288429093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288429093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288429093">(Jul 04 2022 at 16:40)</a>:</h4>
<p>I have a slightly more general question regarding this, my knowledge of ho-unification is that:</p>
<ul>
<li>it is not decidable</li>
<li>is related to dependent types</li>
<li>and apparently a pretty big issue</li>
</ul>
<p>But i never really understood <em>what</em> it is, could someone explain to me what the issue arising with this type class would be?</p>



<a name="288430236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288430236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288430236">(Jul 04 2022 at 16:55)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> In the higher-order case, the metavariables can be functions. Even the simply-typed case is already a mess. Consider the following unification problem.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">?</span><span class="n">m</span> <span class="n">a</span> <span class="bp">=?=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">a</span>
</code></pre></div>
<p>Here are some possible solutions</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">?</span><span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">a</span>
<span class="bp">?</span><span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="n">a</span>
<span class="bp">?</span><span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">x</span>
<span class="bp">?</span><span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div>



<a name="288430343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288430343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288430343">(Jul 04 2022 at 16:56)</a>:</h4>
<p>ah and thus solving the alpha parameter doesn't work out nicely, yes?</p>



<a name="288430917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288430917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288430917">(Jul 04 2022 at 17:03)</a>:</h4>
<p>Given <code>a : Array Int</code>, <code>i : Nat</code>, If <code>a[i]</code> is a notation for <code>GetElem.getElem a i</code>, then before invoking TC, we would have to solve the constraints</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">?</span><span class="n">ρ</span> <span class="bp">=?=</span> <span class="n">Array</span> <span class="n">Int</span> <span class="c1">-- Easy case</span>
<span class="bp">?</span><span class="n">ι</span> <span class="n">a</span> <span class="bp">=?=</span> <span class="n">Nat</span> <span class="c1">-- nasty case</span>
</code></pre></div>
<p>The "right" solution for the example above is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">?</span><span class="n">ρ</span> <span class="o">:=</span> <span class="n">Array</span> <span class="n">Int</span>
<span class="bp">?</span><span class="n">ι</span>  <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span>
</code></pre></div>
<p>We have to solve unification problems such as <code>?ι ?ρ =?= Nat</code> in other parts of the system (e.g., computing the motive for <code>induction</code>).<br>
However, in each one of these cases we do not use the general <code>isDefEq</code>, but a custom heuristic that is usually based on "waiting" for information, and using the <code>kabstract</code> function.</p>



<a name="288431230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288431230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288431230">(Jul 04 2022 at 17:06)</a>:</h4>
<p>And in this case, waiting would only make sense if <code>ι</code> is an <code>outParam</code>. Correct?</p>



<a name="288431522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288431522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288431522">(Jul 04 2022 at 17:10)</a>:</h4>
<p>Waiting in the same sense as postponing execution in term elaboration I guess?</p>



<a name="288431621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288431621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288431621">(Jul 04 2022 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288431230">said</a>:</p>
<blockquote>
<p>And in this case, waiting would only make sense if <code>ι</code> is an <code>outParam</code>. Correct?</p>
</blockquote>
<p>Sorry, I was vague. I was referring to the case that  it is not an <code>outParam</code>. The idea is to wait for <code>a</code> and the type of <code>i</code> to be fully "available" (i.e., they do not contain nested metavariables). Then, we compute <code>ι</code> by using <code>kabstract &lt;type-of-i&gt; &lt;a&gt;</code>.</p>



<a name="288432414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288432414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288432414">(Jul 04 2022 at 17:19)</a>:</h4>
<p>I see! Ideally <code>i : Fin ?m</code> would be sufficient to trigger TC resolution, but your idea would already be quite good.</p>



<a name="288436126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288436126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288436126">(Jul 04 2022 at 18:02)</a>:</h4>
<p>We could also put the domain as an extra argument to the type class, avoiding dependencies:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Cont</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Elem</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="o">(</span><span class="n">Dom</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="n">Cont</span> <span class="bp">→</span> <span class="n">Idx</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Cont</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Idx</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Dom</span> <span class="n">xs</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">Elem</span>

<span class="kn">export</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">getElem</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">getElem</span><span class="bp">!</span> <span class="o">[</span><span class="n">GetElem</span> <span class="n">Cont</span> <span class="n">Idx</span> <span class="n">Elem</span> <span class="n">Dom</span><span class="o">]</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">Elem</span><span class="o">]</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Cont</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Idx</span><span class="o">)</span> <span class="o">[</span><span class="n">Decidable</span> <span class="o">(</span><span class="n">Dom</span> <span class="n">xs</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="n">Elem</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">_</span> <span class="k">then</span> <span class="n">getElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">h</span> <span class="k">else</span> <span class="n">unreachable</span><span class="bp">!</span>

<span class="kd">def</span> <span class="n">getElem</span><span class="bp">?</span> <span class="o">[</span><span class="n">GetElem</span> <span class="n">Cont</span> <span class="n">Idx</span> <span class="n">Elem</span> <span class="n">Dom</span><span class="o">]</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Cont</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Idx</span><span class="o">)</span> <span class="o">[</span><span class="n">Decidable</span> <span class="o">(</span><span class="n">Dom</span> <span class="n">xs</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Elem</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">_</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">getElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="n">none</span>

<span class="n">macro</span> <span class="s2">"linarith"</span> <span class="o">:</span> <span class="n">tactic</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">first</span><span class="bp">|</span> <span class="n">trivial</span> <span class="bp">|</span> <span class="n">decide</span> <span class="bp">|</span> <span class="n">assumption</span><span class="o">)</span> <span class="c1">-- TODO</span>
<span class="n">macro</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="n">x</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">getElem</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">i</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">))</span>
<span class="n">macro</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="n">x</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]?"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">getElem</span><span class="bp">?</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">i</span><span class="o">)</span>
<span class="n">macro</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="n">x</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]!"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">getElem</span><span class="bp">!</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">i</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">Nat</span> <span class="n">α</span> <span class="k">fun</span> <span class="n">xs</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">xs.size</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">xs.get</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">Std.Range</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">True</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">xs.extract</span> <span class="n">i.start</span> <span class="n">i.stop</span>

<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span>
<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">][[</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="o">]]</span>
</code></pre></div>



<a name="288441833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288441833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288441833">(Jul 04 2022 at 19:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I think this proposal is cleaner than the <code>Conditional</code> one. Perhaps, we should just accept the fact that the <code>Idx</code> cannot depend on the collection. That is, we can't write <code>instance : GetElem (Array α) (Fin ??) ...</code>. Perhaps this is acceptable. We can still write <code>instance : GetElem (Vector α n) (Fin n) ...</code></p>



<a name="288442394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288442394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288442394">(Jul 04 2022 at 19:20)</a>:</h4>
<p>Here is a version of my proposal that allows the operation to be dependent on the index:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Meta</span> <span class="n">Term</span>

<span class="kd">class</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">op</span> <span class="o">:</span> <span class="n">Name</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">as</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">``</span><span class="n">Array.getOp</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">as</span> <span class="n">USize</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">``</span><span class="n">Array.uget</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetOp</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">as</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">as.size</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">``</span><span class="n">Array.get</span><span class="o">⟩</span>

<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">unsafeEvalExpr</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">ToExpr</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">TermElabM</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">Meta.evalExpr</span> <span class="n">α</span> <span class="o">(</span><span class="n">toTypeExpr</span> <span class="n">α</span><span class="o">)</span> <span class="n">e</span>

<span class="kd">@[implementedBy unsafeEvalExpr]</span>
<span class="n">opaque</span> <span class="n">evalExpr</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">ToExpr</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">TermElabM</span> <span class="n">α</span>

<span class="n">elab</span><span class="o">:</span><span class="n">max</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]'"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">ax</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">a</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">ix</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">i</span> <span class="n">none</span>
  <span class="n">synthesizeSyntheticMVarsNoPostponing</span>
  <span class="k">let</span> <span class="n">ρ</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">ax</span>
  <span class="k">let</span> <span class="n">ι</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">ix</span>
  <span class="k">let</span> <span class="n">u</span> <span class="bp">←</span> <span class="n">getDecLevel</span> <span class="n">ρ</span>
  <span class="k">let</span> <span class="n">v</span> <span class="bp">←</span> <span class="n">getDecLevel</span> <span class="n">ι</span>
  <span class="k">let</span> <span class="n">inst</span> <span class="o">:=</span> <span class="n">mkAppN</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">GetOp</span> <span class="o">[</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">])</span> <span class="bp">#</span><span class="o">[</span><span class="n">ρ</span><span class="o">,</span> <span class="n">ax</span><span class="o">,</span> <span class="n">ι</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">instVal</span> <span class="bp">←</span> <span class="n">synthInstance</span> <span class="n">inst</span>
  <span class="k">let</span> <span class="n">opApp</span> <span class="o">:=</span> <span class="n">mkAppN</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">GetOp.op</span> <span class="o">[</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">])</span> <span class="bp">#</span><span class="o">[</span><span class="n">ρ</span><span class="o">,</span> <span class="n">ax</span><span class="o">,</span> <span class="n">ι</span><span class="o">,</span> <span class="n">instVal</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">opVal</span> <span class="bp">←</span> <span class="n">instantiateMVars</span> <span class="n">opApp</span>
  <span class="k">let</span> <span class="n">op</span> <span class="bp">←</span> <span class="n">evalExpr</span> <span class="n">Name</span> <span class="n">opVal</span>
  <span class="k">let</span> <span class="n">stx</span> <span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="o">(</span><span class="n">mkCIdent</span> <span class="n">op</span><span class="o">)</span> <span class="bp">$</span><span class="n">a</span> <span class="bp">$</span><span class="n">i</span><span class="o">)</span>
  <span class="n">withMacroExpansion</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getRef</span><span class="o">)</span> <span class="n">stx</span> <span class="bp">&lt;|</span> <span class="n">elabTerm</span> <span class="n">stx</span> <span class="n">none</span>

<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="bp">'</span> <span class="c1">-- 1</span>
<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">][(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)]</span><span class="bp">'</span> <span class="o">(</span><span class="kd">by</span> <span class="n">native_decide</span><span class="o">)</span> <span class="c1">-- 1</span>
<span class="k">#eval</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">][</span><span class="n">Fin.mk</span> <span class="mi">1</span> <span class="o">(</span><span class="k">show</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="bp">.</span><span class="n">size</span> <span class="k">from</span> <span class="kd">by</span> <span class="n">decide</span><span class="o">)]</span><span class="bp">'</span> <span class="c1">-- 1</span>
</code></pre></div>



<a name="288443169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288443169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288443169">(Jul 04 2022 at 19:29)</a>:</h4>
<p>What do you think <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span>  / <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>  / <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> ?</p>



<a name="288443747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288443747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288443747">(Jul 04 2022 at 19:35)</a>:</h4>
<p>For me personally, finding out a class <code>GetOp</code> that asks for <code>Name</code> instead of the expected function would be a huge wtf moment. Might not be an issue if this becomes a common pattern or the user side interface is a bit more sane.</p>



<a name="288443925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288443925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288443925">(Jul 04 2022 at 19:37)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> I agree with Tomas, the hack is getting too complicated, and the code above does not have support for postponing elaboration yet.  Another problem is that mechanisms such as <code>[defaultInstances]</code> will not work with your approach.</p>



<a name="288444439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288444439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288444439">(Jul 04 2022 at 19:44)</a>:</h4>
<p>A nice benefit of having <code>_[_]</code> default to a tactic search is that we can give a very clear error message if it fails, even explaining Lean's indexing approach to newcomers that invariably try to apply the standard indexing notation.</p>



<a name="288444781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288444781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288444781">(Jul 04 2022 at 19:48)</a>:</h4>
<p>We can also make the search tactic do the right thing for Fins out of the box.  Then nobody will notice that <code>_[_]</code> doesn't support Fin:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">GetElem</span> <span class="n">Cont</span> <span class="n">Nat</span> <span class="n">Elem</span> <span class="n">Dom</span><span class="o">]</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="n">Cont</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">Elem</span> <span class="k">fun</span> <span class="n">xs</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">Dom</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">getElem</span> <span class="n">xs</span> <span class="n">i.1</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">foo</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fin.mk</span> <span class="n">a</span> <span class="n">h</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">h</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="n">linarith</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span> <span class="bp">·</span> <span class="n">apply</span> <span class="n">foo</span><span class="o">)</span>

<span class="k">#check</span> <span class="k">fun</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">xs.size</span><span class="o">)</span> <span class="bp">=&gt;</span>  <span class="n">xs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</code></pre></div>



<a name="288444925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288444925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288444925">(Jul 04 2022 at 19:50)</a>:</h4>
<p>Can't the Mac's approach be done with an attribute? I.e. tagging functions that follow certain pattern instead of using an odd type class.</p>



<a name="288496752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288496752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288496752">(Jul 05 2022 at 08:49)</a>:</h4>
<p>A bit tangentially related, would it be possible to get <code>a[i]</code> displayed in the goal view as <code>a[i]</code> and not as <code>Array.getOp a i</code>?</p>
<p>mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">a.size</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decide</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">trace_state</span>
  <span class="n">simp</span>
  <span class="n">done</span>
</code></pre></div>
<p>Displays <code>Array.getOp a i = 0</code> instead of <code>a[i] = 0</code>. It makes lots of stuff I work with quite unreadable.</p>



<a name="288497558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288497558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288497558">(Jul 05 2022 at 08:55)</a>:</h4>
<p>Specifically for Array.getOp it's possible with an appUnexpander:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">PrettyPrinter</span>

<span class="kd">@[appUnexpander Array.getOp]</span>
<span class="kd">def</span> <span class="n">unexpandGet</span> <span class="o">:</span> <span class="n">Unexpander</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">Array.getOp</span> <span class="bp">$</span><span class="n">array</span> <span class="bp">$</span><span class="n">index</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">array</span><span class="o">[</span><span class="bp">$</span><span class="n">index</span><span class="o">])</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">throw</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">a.size</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decide</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">trace_state</span>
  <span class="n">simp</span>
  <span class="n">done</span>
</code></pre></div>
<p>Traces</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>
<p>But generalizing this to all getOps (as they are currently implemented) might  require some manual work or magic in the compiler to treat getOp applications to any type specially.</p>
<p>Depending on the implementation suggestions from above it would also be doable with varying degrees of complexity, if we end up with a pure type class it should be trivial because there is only one unexpander required, if we do it with the attribute the thing that handles the attribute would have to generate an unexpander specifically etc.</p>



<a name="288498330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/288498330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#288498330">(Jul 05 2022 at 09:02)</a>:</h4>
<p>Ohh I see, this solution is good enough for me for now. I just add this bit of code to every place where I provide <code>getOp</code>.</p>



<a name="289070431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289070431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289070431">(Jul 10 2022 at 00:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>'s proposal above is now on master. Please update your projects, and thanks for your patience with these changes before the first official release. The proposal seems to be working well after a few improvements to our elaborator.</p>



<a name="289070463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289070463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289070463">(Jul 10 2022 at 00:11)</a>:</h4>
<p>Please see release notes for additional details: <a href="https://github.com/leanprover/lean4/blob/49951b87b953c7cf74f415c1dc1488ae26921cf2/RELEASES.md">https://github.com/leanprover/lean4/blob/49951b87b953c7cf74f415c1dc1488ae26921cf2/RELEASES.md</a></p>



<a name="289081643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289081643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289081643">(Jul 10 2022 at 04:36)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span>  Very cool!  <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span>  One suggestion, though: instead of <code>a[i]'h</code> for index-with-proof-syntax, how about just <code>a[i](h)</code>? Most of the examples that use <code>a[i]'h</code> already end up doing <code>a[i]'(h)</code> so this would be shorter and, in my view, cleaner and clearer.</p>



<a name="289085947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289085947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289085947">(Jul 10 2022 at 06:38)</a>:</h4>
<p>I'm also not sure about the <code>a[i]'h</code> notation. What about <code>a[i|h]</code> or <code>a[i;h]</code>?</p>



<a name="289092521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289092521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289092521">(Jul 10 2022 at 09:29)</a>:</h4>
<p>Cool works nicely! A quick test to find out if notation like <code>∑ i, b[i]</code> works correctly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sum</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="n">macro</span> <span class="s2">"∑"</span> <span class="n">xs</span><span class="o">:</span><span class="n">Lean.explicitBinders</span> <span class="s2">", "</span> <span class="n">b</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">Lean.expandExplicitBinders</span> <span class="bp">`</span><span class="n">sum</span> <span class="n">xs</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">NArray</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">a.size</span><span class="o">}</span>

<span class="kd">@[defaultInstance]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="o">(</span><span class="n">NArray</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">True</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">getElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">xs.1.get</span> <span class="o">(</span><span class="n">xs.2</span> <span class="bp">▸</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">NArray</span> <span class="n">Nat</span> <span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">10</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="k">#check</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>   <span class="c1">--- works as expected!</span>
</code></pre></div>



<a name="289093710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289093710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289093710">(Jul 10 2022 at 10:00)</a>:</h4>
<p>However I'm unable to get the unexpander working. This does not work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[appUnexpander GetElem.getElem]</span>
<span class="kd">def</span> <span class="n">unexpandGet</span> <span class="o">:</span> <span class="n">Unexpander</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">GetElem.getElem</span> <span class="bp">$</span><span class="n">array</span> <span class="bp">$</span><span class="n">index</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">array</span><span class="o">[</span><span class="bp">$</span><span class="n">index</span><span class="o">])</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">throw</span> <span class="o">()</span>
</code></pre></div>
<p>However, there is a bit ambiguity how to unexpand it, do you want <code>a[i]</code> or<code>a[i]'h</code>. I would like to apply the above unexpander only if <code>Dom = (λ _ _ =&gt; True)</code>.</p>



<a name="289093852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289093852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289093852">(Jul 10 2022 at 10:04)</a>:</h4>
<p>For the unexpander there are two mistakes on your side, both related to how syntax works:</p>
<ol>
<li><code>GetElem.getElem</code> is syntactically not equivalent to <code>getElem</code> which is what the macro uses so every occurence of the macro won't match this here already</li>
<li><code>_</code> is interpreted as a literal syntactic <code>_</code> here, you want an antiquotation <code>$_</code></li>
</ol>
<p>And then we get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">PrettyPrinter</span>

<span class="kd">@[appUnexpander GetElem.getElem]</span>
<span class="kd">def</span> <span class="n">unexpandGet</span> <span class="o">:</span> <span class="n">Unexpander</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">getElem</span> <span class="bp">$</span><span class="n">array</span> <span class="bp">$</span><span class="n">index</span> <span class="bp">$</span><span class="n">_</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">array</span><span class="o">[</span><span class="bp">$</span><span class="n">index</span><span class="o">])</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">throw</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">a.size</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">decide</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">trace_state</span>
  <span class="n">simp</span>
  <span class="n">done</span>
</code></pre></div>
<p>which traces</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>



<a name="289093912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289093912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289093912">(Jul 10 2022 at 10:04)</a>:</h4>
<p>Ahh thanks! I was slowly uncovering 1 but had no clue about 2.</p>



<a name="289094008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289094008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289094008">(Jul 10 2022 at 10:06)</a>:</h4>
<p>Should it be <code>@[appUnexpander GetElem.getElem]</code> or <code>@[appUnexpander getElem]</code>? ... both work.</p>



<a name="289094394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289094394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289094394">(Jul 10 2022 at 10:15)</a>:</h4>
<p>I guess I'd use the 2nd since it is what the unexpander in question actually cares about? But I don't know whether it makes a difference.</p>
<p>I'm also not quite sure how to adapt the unexpander to correctly make a difference between the cases where a 'h and none was used, for example</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Int</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a.size</span><span class="o">)</span> <span class="o">:</span> <span class="n">Int</span> <span class="o">:=</span>
  <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="c1">-- Ok</span>
</code></pre></div>
<p>with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[appUnexpander GetElem.getElem]</span>
<span class="kd">def</span> <span class="n">unexpandGet</span> <span class="o">:</span> <span class="n">Unexpander</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">getElem</span> <span class="bp">$</span><span class="n">array</span> <span class="bp">$</span><span class="n">index</span> <span class="bp">$</span><span class="n">h</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">array</span><span class="o">[</span><span class="bp">$</span><span class="n">index</span><span class="o">]</span><span class="bp">'$</span><span class="n">h</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">throw</span> <span class="o">()</span>
</code></pre></div>
<p>turns into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="n">a</span> <span class="n">i</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">'</span><span class="n">h</span>
</code></pre></div>
<p>so there is virtually no difference between <code>a[i]'h</code> and <code>a[i]</code> with the <code>h</code> inferred via tactic on a syntactic level at this point.</p>



<a name="289094633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289094633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289094633">(Jul 10 2022 at 10:20)</a>:</h4>
<p>Yeah, I'm not sure what to do about that. That is why I wanted to do the unexpander only for <code>Dom = (λ _ _ =&gt; True)</code> i.e. when the domain proof is trivial. Maybe, in all other cases unexpand to <code>a[i]'h</code> ?</p>



<a name="289103375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289103375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289103375">(Jul 10 2022 at 13:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289085947">said</a>:</p>
<blockquote>
<p>I'm also not sure about the <code>a[i]'h</code> notation. What about <code>a[i|h]</code> or <code>a[i;h]</code>?</p>
</blockquote>
<p>The <code>a[i]' h</code> notation is based on the following suggestion from <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> </p>
<blockquote>
<p>My two cents: I was expecting the proof in a[i] to go after the brackets, as in a[i] h, as if it were replacing the ! or ?</p>
</blockquote>
<p>The only difference is the <code>'</code>.  <br>
It would be great to have a consensus here. I  don't have a strong preference here, but I found this variant useful when fixing the Lean 4 repo.</p>



<a name="289103471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289103471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289103471">(Jul 10 2022 at 13:35)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Thanks for the feedback. I will add an abbreviation for <code>a[i] ' h</code>. Thus, we can use it in the unexpander.</p>



<a name="289104238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289104238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289104238">(Jul 10 2022 at 13:49)</a>:</h4>
<p>Pushed <a href="https://github.com/leanprover/lean4/commit/35018dbea24dd92d5f75b02a9faa8bbf57a5496d">https://github.com/leanprover/lean4/commit/35018dbea24dd92d5f75b02a9faa8bbf57a5496d</a></p>



<a name="289104330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289104330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289104330">(Jul 10 2022 at 13:50)</a>:</h4>
<p>Since there doesn't seem  to be an immediately natural syntax for <code>a[i]'h</code>, I think it's worth discussing whether we need one at all. Especially if we assume that most short proofs will eventually be automated by e.g. <code>linarith</code> anyway, and for everything longer than one line any such notation seems problematic. Still, sometimes you might not want to type out the proposition for a separate <code>have</code> (though auto-generating that skeleton from a Code Action would be cool). Since we already have other such "implicitly proof-consuming" syntax with well-founded recursion, I'm wondering whether we should have a general syntax for discharging remaining proof obligations from terms on the command level, like with Coq's <code>Program</code>/<code>Obligation</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Int</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a.size</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">Int</span> <span class="o">:=</span>
  <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
<span class="n">where</span>
  <span class="n">case</span> <span class="bp">«</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="bp">»</span> <span class="bp">=&gt;</span>  <span class="c1">-- should also accept a default like `case _`</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">decide</span>
</code></pre></div>



<a name="289104518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289104518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289104518">(Jul 10 2022 at 13:54)</a>:</h4>
<p>For further motivation, imagine repeating the same syntax discussion for a proof-consuming division operator :) ...</p>



<a name="289104775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289104775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289104775">(Jul 10 2022 at 13:59)</a>:</h4>
<p>I think having a user extensible framework for proof consuming operators is a great idea <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span></p>



<a name="289105559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289105559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289105559">(Jul 10 2022 at 14:14)</a>:</h4>
<p>my only concern would be that the connection between the written code and the underlying terms might get a bit further separated -- like, to me, the termination_by is a magic wand that I do not understand, but it's okay because I never have to really interact with the underlying <code>rec</code> definition, just with the equational lemmas...</p>



<a name="289105590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289105590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289105590">(Jul 10 2022 at 14:15)</a>:</h4>
<p>whereas I fully expect users to have to interact with <code>getElem</code> and its corresponding proof terms</p>



<a name="289105656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289105656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289105656">(Jul 10 2022 at 14:16)</a>:</h4>
<p>When would you interact with its proof terms?</p>



<a name="289106019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289106019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289106019">(Jul 10 2022 at 14:24)</a>:</h4>
<p>If you're doing any proof with a term that uses <code>getElem</code> you'd see the version with the proof term in it, if that makes sense. Lean wouldn't hide the underlying proof terms from you as it does with well-founded recursion</p>



<a name="289106073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289106073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289106073">(Jul 10 2022 at 14:25)</a>:</h4>
<p>I guess in the case of well-founded recursion you _can_ still end up seeing the underlying representation, but my impression is that something is wrong if you're seeing it</p>



<a name="289106214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289106214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289106214">(Jul 10 2022 at 14:28)</a>:</h4>
<p>We do in fact hide the proof in the <code>getElem</code> unexpander. And even if you disable <code>pp.notation</code>, you'll still only see <code>_</code> for the proof because of <code>pp.proofs</code>. But at that level the output will be the same regardless of which syntactic approach we choose anyway.</p>



<a name="289109650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109650">(Jul 10 2022 at 15:39)</a>:</h4>
<p>Would it be possible / too magic to have <code>a[i]</code> look for an assumption in the context possibly supplied by <code>have</code> and otherwise fall back on the normal <code>getOp</code>? That would make for some really slick code for stuff like <code>if h : x &lt; a.size then a[i] else 37</code></p>



<a name="289109728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109728">(Jul 10 2022 at 15:40)</a>:</h4>
<p>The choice of <code>'</code> as separator is not particularly consonant with other syntax in lean, but I don't have any better suggestions</p>



<a name="289109729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109729">(Jul 10 2022 at 15:40)</a>:</h4>
<p>Not sure if you've been following this thread, but that's exactly what it does now (except for the falling back part).</p>



<a name="289109742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109742">(Jul 10 2022 at 15:41)</a>:</h4>
<p>It uses this custom extensible tactic which among others calls to <code>assumption</code> so it can do this</p>



<a name="289109744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109744">(Jul 10 2022 at 15:41)</a>:</h4>
<p>oops, I guess the new one is <code>a[i]!</code> now</p>



<a name="289109805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109805">(Jul 10 2022 at 15:42)</a>:</h4>
<p>what's the current state of the fin version?</p>



<a name="289109904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109904">(Jul 10 2022 at 15:45)</a>:</h4>
<p>It is done through a typeclass, so you can write <code>a[i]</code> for <code>i : Nat</code> and fetch proof from context but you can also write <code>a[i]</code> for <code>i : Fin a.size</code>.</p>



<a name="289109994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289109994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289109994">(Jul 10 2022 at 15:47)</a>:</h4>
<p>Ah, just read the release notes which clarify the situation somewhat. The <code>get_elem_tactic</code> tactic doesn't seem to have any access to information about what array or index is being proved?</p>



<a name="289110145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289110145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289110145">(Jul 10 2022 at 15:50)</a>:</h4>
<p>Oh <code>a[i]</code> for <code>i : Fin a.size</code> works because of coercion of <code>Fin a.size</code> to <code>Nat</code> instead of specialized instance of <code>GetElem</code>.</p>



<a name="289110241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289110241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289110241">(Jul 10 2022 at 15:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289109994">said</a>:</p>
<blockquote>
<p>Ah, just read the release notes which clarify the situation somewhat. The <code>get_elem_tactic</code> tactic doesn't seem to have any access to information about what array or index is being proved?</p>
</blockquote>
<p>I guess you could extend it with a type aware tactic that fails per default if there isn't the types it expects around though right?</p>



<a name="289110724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289110724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289110724">(Jul 10 2022 at 16:03)</a>:</h4>
<p>I mean, you can implement it as <code>assumption</code> which is presumably the intent, but I don't see what kind of extra smarts you could give it</p>



<a name="289110792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289110792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289110792">(Jul 10 2022 at 16:04)</a>:</h4>
<p>Do we also want to unify notation <code>a[i] := x</code> and <code>a[i] += x</code>? </p>
<p>Following identical pattern I have defined two classes <code>SetElem</code> and <code>ModifyElem</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">class</span> <span class="n">SetElem</span> <span class="o">(</span><span class="n">Cont</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Elem</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="o">(</span><span class="n">Dom</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="n">Cont</span> <span class="bp">→</span> <span class="n">Idx</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">setElem</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Cont</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Idx</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Elem</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Dom</span> <span class="n">xs</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">Cont</span>

<span class="kn">export</span> <span class="n">SetElem</span> <span class="o">(</span><span class="n">setElem</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ModifyElem</span> <span class="o">(</span><span class="n">Cont</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Elem</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="o">(</span><span class="n">Dom</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="n">Cont</span> <span class="bp">→</span> <span class="n">Idx</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">modifyElem</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Cont</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Idx</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Elem</span> <span class="bp">→</span> <span class="n">Elem</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Dom</span> <span class="n">xs</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">Cont</span>

<span class="kn">export</span> <span class="n">ModifyElem</span> <span class="o">(</span><span class="n">modifyElem</span><span class="o">)</span>

<span class="n">syntax</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="n">atomic</span><span class="o">(</span><span class="n">Lean.Parser.Term.ident</span><span class="o">)</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">term</span> <span class="s2">"]"</span> <span class="s2">" := "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">doElem</span>
<span class="n">syntax</span> <span class="n">atomic</span><span class="o">(</span><span class="n">Lean.Parser.Term.ident</span><span class="o">)</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">term</span> <span class="s2">"]"</span> <span class="s2">" += "</span> <span class="n">term</span> <span class="o">:</span> <span class="n">doElem</span>

<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">doElem</span><span class="bp">|</span> <span class="bp">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span><span class="o">[</span> <span class="bp">$</span><span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="o">]</span> <span class="o">:=</span> <span class="bp">$</span><span class="n">xi</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">doElem</span><span class="bp">|</span> <span class="bp">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span> <span class="o">:=</span> <span class="n">setElem</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">i</span> <span class="bp">$</span><span class="n">xi</span> <span class="o">(</span><span class="kd">by</span> <span class="n">get_elem_tactic</span><span class="o">))</span>
<span class="n">macro_rules</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">doElem</span><span class="bp">|</span> <span class="bp">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span><span class="o">[</span> <span class="bp">$</span><span class="n">i</span><span class="o">:</span><span class="n">term</span> <span class="o">]</span> <span class="bp">+=</span> <span class="bp">$</span><span class="n">xi</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">doElem</span><span class="bp">|</span> <span class="bp">$</span><span class="n">x</span><span class="o">:</span><span class="n">ident</span> <span class="o">:=</span> <span class="n">modifyElem</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">i</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">val</span> <span class="bp">=&gt;</span> <span class="n">val</span> <span class="bp">+</span> <span class="bp">$</span><span class="n">xi</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">get_elem_tactic</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">SetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">Nat</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xs</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">xs.size</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">setElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">x</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">xs.set</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span><span class="n">h</span><span class="o">⟩</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ModifyElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">Nat</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">xs</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">xs.size</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">modifyElem</span> <span class="n">xs</span> <span class="n">i</span> <span class="n">f</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">xs.modify</span> <span class="n">i</span> <span class="n">f</span>

<span class="k">#eval</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">List.toArray</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span>
  <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:=</span> <span class="mi">42</span>
  <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="bp">+=</span> <span class="mi">6</span>
  <span class="n">a</span> <span class="c1">-- returns #[42, 16]</span>
</code></pre></div>



<a name="289110821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289110821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289110821">(Jul 10 2022 at 16:05)</a>:</h4>
<p>Didn't <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> have some implementation of general lvalues? How hard is it to incorporate arrays in that?</p>



<a name="289111350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289111350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289111350">(Jul 10 2022 at 16:17)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/905#issuecomment-1165768170">https://github.com/leanprover/lean4/issues/905#issuecomment-1165768170</a>  And it supports array updates (at least with the syntax from yesterday).</p>



<a name="289111654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289111654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289111654">(Jul 10 2022 at 16:25)</a>:</h4>
<p>That looks really nice!</p>



<a name="289112644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289112644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289112644">(Jul 10 2022 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289109729">said</a>:</p>
<blockquote>
<p>Not sure if you've been following this thread, but that's exactly what it does now (except for the falling back part).</p>
</blockquote>
<p>I expanded the release notes <a href="https://github.com/leanprover/lean4/commit/351fc6ea04ea5aa5763d2981826acafa2ec2a617">https://github.com/leanprover/lean4/commit/351fc6ea04ea5aa5763d2981826acafa2ec2a617</a></p>



<a name="289112759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289112759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289112759">(Jul 10 2022 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289109805">said</a>:</p>
<blockquote>
<p>what's the current state of the fin version?</p>
</blockquote>
<p>I covered the <code>Fin</code> case in the commit above.</p>



<a name="289113935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289113935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289113935">(Jul 10 2022 at 17:12)</a>:</h4>
<p>typo: <code>get_tactic_tactic</code> in the release notes</p>



<a name="289253316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/String.getOp/near/289253316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/String.2EgetOp.html#289253316">(Jul 11 2022 at 21:38)</a>:</h4>
<p>I really like <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>'s proposal of having a syntax to define well-formed checks after the rest of the definition.   ACL2 and PVS both allow one to defer side condition checks like this and that might be partly born out of necessity, but I think it avoids having proofs of these sort of safety side-conditions clutter up the program.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
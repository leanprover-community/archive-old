---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html">Making Lean 4 compiler more functional and monolith</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="269515684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269515684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Silva <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269515684">(Jan 27 2022 at 01:53)</a>:</h4>
<p>Lean 4 in its core is already functional and made in Lean 4.<br>
The problem is in the front-end and backend.</p>
<p>In the front-end, because Lean 4 is made to work using LSP, some of the code is written in TypeScript or JavaScript.<br>
Programming languages such as Hazel are made using a reactive programming language framework (ReasonML in OCaml).</p>
<p>In the backend,  I think that the CakeML approach is one of the best. They implemented a silver CPU in HOL.</p>
<p>I don't know how hard is to implement both of them in Lean, but I would like to know if there is something being made in this direction.</p>



<a name="269518152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269518152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269518152">(Jan 27 2022 at 02:31)</a>:</h4>
<p>FWIW, the front-end is really mostly not implemented in the front-end. The typescript part is a thin wrapper around messages that are created in the lean 4 core.</p>



<a name="269520212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269520212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Silva <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269520212">(Jan 27 2022 at 03:07)</a>:</h4>
<p>I think that in Lean 3, they developed a small framework to use Lean code in VS Code.</p>
<p>Maybe, with one framework like that, this typescript wrapper will no longer be necessary.</p>



<a name="269529756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269529756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269529756">(Jan 27 2022 at 06:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="143232">Guilherme Silva</span> <a href="#narrow/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith/near/269515684">said</a>:</p>
<blockquote>
<p>The problem is in the front-end and backend.</p>
</blockquote>
<p>What is the "problem in the front end and backend"? VScode requires users to write their extensions (or at least the part that touches VScode) in typescript.</p>
<p><span class="user-mention silent" data-user-id="143232">Guilherme Silva</span> <a href="#narrow/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith/near/269515684">said</a>:</p>
<blockquote>
<p>In the backend,  I think that the CakeML approach is one of the best. They implemented a silver CPU in HOL.</p>
</blockquote>
<p>The best at what? I'm sure it's very cool, but a custom ISA for a specific model of FPGA doesn't sound super practical.</p>



<a name="269629575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269629575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Guilherme Silva <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269629575">(Jan 27 2022 at 20:01)</a>:</h4>
<p>A formal model of the processor can help to have fewer bugs, to debug and test the binary code generated.<br>
Another advantage is to make verified optimizations.</p>



<a name="269632980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269632980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269632980">(Jan 27 2022 at 20:28)</a>:</h4>
<p>I don't think there's anything stopping someone from writing a verified compiler for Lean (other than it being a moving target for now), but the developers have said they're not interested in doing it themselves, or at least Leo de Moura has. Mario Carneiro's metamath zero is going after this level of depth, you might find it appealing: <a href="https://github.com/digama0/mm0">https://github.com/digama0/mm0</a>.</p>



<a name="269648780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269648780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269648780">(Jan 27 2022 at 22:19)</a>:</h4>
<p>the target is far less moving if you look at kernel terms. There are multiple type checkers for it. And all the fancy stuff happens in lean syntax, elaboration, etc. The kernel is not changing when the language changes.</p>



<a name="269754675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269754675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269754675">(Jan 28 2022 at 15:37)</a>:</h4>
<p>FWIW, while watching <a href="https://www.youtube.com/watch?v=3ixaLQQNCFk">https://www.youtube.com/watch?v=3ixaLQQNCFk</a> I couldnt stop thinking whether WebAssembly, having a formally defined semantic and being language independent (among many other interesting properties), could be a great compilation target for Lean.</p>
<div class="youtube-video message_inline_image"><a data-id="3ixaLQQNCFk" href="https://www.youtube.com/watch?v=3ixaLQQNCFk"><img src="https://uploads.zulipusercontent.net/c62924d79bd96fdf2ae8128f4f1811ee07a4e40e/68747470733a2f2f692e7974696d672e636f6d2f76692f336978614c51514e43466b2f64656661756c742e6a7067"></a></div>



<a name="269864048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269864048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269864048">(Jan 29 2022 at 13:23)</a>:</h4>
<p>By the way, with the mention of <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>'s MM0 project, if I understand it correctly, it would be able to serve as a verified (external) type checker for any kernel-level proof in any theorem prover's logic, including Lean's.  The idea being as follows:</p>
<ul>
<li>One writes a specification file, which is short, human-readable, and machine-readable, which details the rules of the logical system.</li>
<li>One converts the kernel proof into an MM0 format which has two parts: (a) A human and machine readable part which includes the (elaborated) definitions and theorem statements.  (b) A machine readable part containing the kernel proofs.</li>
<li>MM0 checks a kernel proof against that specification.</li>
<li>MM0 also has (or will have) a proof that the byte code of its checker will follow the specification given to it.</li>
<li>Therefore if the specification is correct (checked by a human), the definitions and theorems are translated correctly to the MM0 format (checked by a human), and Mario finishes verifying the verifier, then the byte code (barring hardware errors) will correctly check the proof.</li>
</ul>
<p>(Someone can correct me if I'm wrong on the details here.)</p>



<a name="269864056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269864056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269864056">(Jan 29 2022 at 13:23)</a>:</h4>
<p>Also, whenever someone mentions verifying a theorem prover, I feel compelled to mention that there are actually two ways to verify a theorem prover:</p>
<ol>
<li>Verify that the checker follows the rules of the logic.</li>
<li>Verify that the rules of the logic are consistent (including any axioms used).</li>
</ol>
<p>MM0's goal as I understand is the first, but it could in theory also be used for the second.</p>



<a name="269864229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Making%20Lean%204%20compiler%20more%20functional%20and%20monolith/near/269864229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Making.20Lean.204.20compiler.20more.20functional.20and.20monolith.html#269864229">(Jan 29 2022 at 13:27)</a>:</h4>
<p>Yes, you could use MM0 for metatheory reasoning, but that's not a current goal. Full proof translations often make metatheory reasoning more accessible, however, since it is only a minor tweak to the exporter to produce theorems in a deep embedding, and then you can prove general theorems about things in the deep embedding like soundness.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
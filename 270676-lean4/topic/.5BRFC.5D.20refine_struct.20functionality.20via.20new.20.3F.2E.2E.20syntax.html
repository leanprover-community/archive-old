---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html">[RFC] refine_struct functionality via new ?.. syntax</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="307871928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/307871928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#307871928">(Nov 04 2022 at 02:08)</a>:</h4>
<p>It seems like I don't have permission to move the topic out of the mathlib4 stream (the <strong>Move topic</strong> option doesn't show up upon clicking the ellipsis next to the topic in the sidebar); anyone who does have permission to move this topic to #lean4 is welcome to do so :) (I changed the name, at least!)</p>



<a name="307892478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/307892478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#307892478">(Nov 04 2022 at 06:41)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="287929" href="/#narrow/stream/287929-mathlib4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax">#mathlib4 &gt; [RFC] refine_struct functionality via new ?.. syntax</a> by <span class="user-mention silent" data-user-id="110087">Scott Morrison</span>.</p>



<a name="309258874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/309258874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#309258874">(Nov 11 2022 at 20:48)</a>:</h4>
<p>Okay, I've implemented this functionality! :) I've done it by modifying a copy of <code>StructInst.lean</code> in such a way that it can easily be slotted in wherever is deemed best: as a modification of/replacement for <code>StructInst.lean</code> in Lean 4, or as an auxiliary file in std4 or mathlib4. The syntax it's implemented with can also be easily modified. (If it turns out that it doesn't belong anywhere, it was at least a great learning experience!)</p>
<p>With the current implementation, you can use e.g. <code>{ x := 0, ?.. }</code> to fill in all non-default fields with holes named by the missing field. There's also functionality to fill in <em>all</em> unspecified fields with goals (instead of using default values); to prefix each goal with a specified name; and to avoid conflicting goal names introduced by multiple occurrences of <code>{ ?.. }</code>.</p>
<p>There are still some design choices to be made (syntax, default behavior, implementation details—the current implementation chooses certain options arbitrarily just to get it working), and while I have some opinions about some of them (see above!), I'll happily defer to whatever people choose!</p>
<p>But first things first:</p>
<ol>
<li>
<p>Where should this functionality go? Should it be part of Lean 4, std4, or mathlib4?</p>
</li>
<li>
<p>What's the procedure for making these choices? Consensus on a github issue, the call of a core dev, etc...? And are there next steps that I should take here re: opening an issue somewhere, continuing to post in this thread, etc.? (This depends on 1, of course! If Lean 4, I can follow the contribution guidelines.)</p>
</li>
</ol>



<a name="309423088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/309423088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#309423088">(Nov 13 2022 at 07:03)</a>:</h4>
<p>I think the general answer to these questions is: put it in mathlib4 first. We'll take anything (* some conditions apply), and then when the maintainers of std4 and/or lean4 want to "promote" something up the chain they can pull it out of mathlib4.</p>
<p>The bandwidth for reviewing material for std4 and lean4 is much narrower, so aiming for mathlib4 first optimises the time of those reviewers, and also gives a chance for some battle-testing. :-)</p>



<a name="310520391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310520391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310520391">(Nov 16 2022 at 23:27)</a>:</h4>
<p>Ok, sounds good! I'll make a new branch and get it running there. :) (Also, I <em>thought</em> it would work easily in core, but I couldn't quite get it to build—bested by something parser-related in the built-in macros. So putting it in mathlib4 is good! <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span>)</p>



<a name="310715134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715134">(Nov 17 2022 at 22:55)</a>:</h4>
<p>So, there are some design and implementation choices to be made before I think this should be accepted and considered "done" in mathlib! I'll post those choices here, but the current "working" version is available on the branch <code>thorimur/refine_struct-via-StructInst</code> <a href="https://github.com/leanprover-community/mathlib4/blob/thorimur/refine_struct-via-StructInst/Mathlib/Lean/Elab/StructInstWithHoles.lean">here</a>. (It's only the linting that fails currently.)</p>
<p>I'm not entirely sure how these decisions get made—if we try reach consensus among people who are interested, and/or what person or group has the final call. (Is it you, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  ? 👀) Either way, if you have an opinion, please react with thumbs up/down (or a number emoji like <span aria-label="two" class="emoji emoji-0032-20e3" role="img" title="two">:two:</span>, if relevant)! Or, use a <span aria-label="check" class="emoji emoji-2705" role="img" title="check">:check:</span> to indicate the current implementation is OK. (Or reply for further discussion!)</p>
<p>I bold the actual questions at the top of each choice to be made. The rest is just me giving any context or thoughts I have.</p>



<a name="310715196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715196">(Nov 17 2022 at 22:56)</a>:</h4>
<p>(Apologies—barrage of messages incoming.)</p>



<a name="310715244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715244">(Nov 17 2022 at 22:56)</a>:</h4>
<h1>Design choices</h1>
<h2><em>Current implementation</em></h2>
<p>The current implementation uses four pieces of syntax to toggle the named quality of the goals independently from the default synthesis behavior. All of these are tentative, pending the following choices. Those are</p>
<table>
<thead>
<tr>
<th style="text-align: right;"></th>
<th style="text-align: center;">use defaults</th>
<th style="text-align: center;">no defaults</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">named, synthetic</td>
<td style="text-align: center;"><code>?..</code></td>
<td style="text-align: center;"><code>?..!</code></td>
</tr>
<tr>
<td style="text-align: right;">unnamed, natural</td>
<td style="text-align: center;"><code>...</code></td>
<td style="text-align: center;"><code>..!</code></td>
</tr>
</tbody>
</table>
<p>Currently <code>...</code> is just to demonstrate functionality/provide a possible stand=in for <code>..</code> if migrated to core. <code>!</code> is also likely to change to something more descriptive.</p>
<p>In the named case, hole names can be prefixed with a custom name via <code>?..x</code> and <code>?..!x</code>. This is also a design choice to make.</p>



<a name="310715316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715316">(Nov 17 2022 at 22:57)</a>:</h4>
<h2>Choice 1: default value synthesis</h2>



<a name="310715334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715334">(Nov 17 2022 at 22:57)</a>:</h4>
<h3>(a) Standard behavior</h3>
<p><strong>Should <code>?..</code> synthesize defaults or not?</strong></p>
<p>Currently, <code>..</code> syntax in structures produces natural holes for all fields. As far as I can tell this is used quite frequently in pattern matching on structures, so I'm not sure we would want to change this behavior.</p>
<p>Mario raised the point that adding a new field to a structure along with a default value for that field shouldn't be a breaking change in the standard case.</p>
<p>I'm new to Lean, so I'm not sure how one typically uses default values in mathematical structures, and whether it would be useful to by default have <code>refine { ?.. }</code> fill in all the data it can, or whether we want to be able to create goals for all fields. Mario also mentioned that typically we'd want to write data explicitly and use tactics only for proofs, e.g. <code>refine { x := 0, ?.. }</code>, which is another point to consider in favor of <code>?..</code> synthesizing defaults.</p>



<a name="310715350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715350">(Nov 17 2022 at 22:57)</a>:</h4>
<h3>(b) Accessible default-synthesis behaviors</h3>
<p><strong>Should it be possible to create natural, unnamed holes while also synthesizing defaults?</strong> I personally can't see a use for this behavior; can someone think of one? If not, a possible syntax design is</p>
<table>
<thead>
<tr>
<th style="text-align: right;"></th>
<th style="text-align: center;">use defaults</th>
<th style="text-align: center;">no defaults</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">named, synthetic</td>
<td style="text-align: center;"><code>?..</code></td>
<td style="text-align: center;"><code>?..!</code></td>
</tr>
<tr>
<td style="text-align: right;">unnamed, natural</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;"><code>..</code></td>
</tr>
</tbody>
</table>
<p>where we rely on the built-in syntax for "no defaults". (Replace <code>?..!</code> with the outcome for <strong>Choice 1.c</strong> below.)</p>
<p><strong>Con:</strong> As is, this breaks the metaphor a little bit. <code>?..</code> is meant to be "the version of <code>..</code> that we expect to interact with". But maybe it's alright—after all, if we have to interact with something, it might make sense that Lean takes care of it as much as it can for us beforehand, in this case by filling the goals it can with default values.</p>
<p>Also, these might switch depending on the outcome of <strong>Choice 1.a</strong>. In that case, the metaphor wouldn't be broken at all.</p>



<a name="310715456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715456">(Nov 17 2022 at 22:58)</a>:</h4>
<h3>(c) Default-synthesis syntax</h3>
<p><strong>What should the syntax for avoiding default synthesis be? <code>!</code>, <code>noDefaults</code>, something else, or nothing?</strong> (Or, if standard behavior is swapped according to <strong>Choice 1.a</strong>, what should the syntax for <em>synthesizing</em> defaults be?)</p>
<p>This implementation uses <code>?..!</code>, and while that is <em>sort of</em> concordant with the use of <code>!</code> in Lean in general—we're telling the hole <code>?..</code> to "work harder" and fill more fields!—it's a bit of a weak metaphor. We could instead do something like <code>?.. noDefaults</code>, or any other token. Suggestions welcome!</p>
<p>Another option is to disallow this functionality entirely, and force the user to write in each <code>x := ?x</code> by hand for fields <code>x</code> with a default value. I don't like this; the option to make it easier is right there! Plus, these goals wouldn't have the nice metadata created by <code>?..!</code>, which means they wouldn't automatically avoid name conflicts and wouldn't be able to pass info (like the field in question) on to other tactics.</p>



<a name="310715486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715486">(Nov 17 2022 at 22:58)</a>:</h4>
<h2>Choice 2: Goal names</h2>



<a name="310715496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715496">(Nov 17 2022 at 22:58)</a>:</h4>
<h3>(a) Prefix syntax</h3>
<p><strong>What syntax should be used to specify a prefix name?</strong> Currently it's possibly to prefix the field name with some <code>a</code> via e.g. <code>?..a</code>. So, if <code>?..</code> produced a goal named <code>foo</code>, <code>?..x</code> would produce a goal named <code>x.foo</code>. The three options I can see are</p>
<ol>
<li><code>?x..</code></li>
<li><code>?..x</code> (current)</li>
<li><code>x@?..</code></li>
</ol>
<p>I personally like <code>?x..</code>—it parallels <code>?x</code>, and puts <code>x</code> in a position that feels more prefix-y (as opposed to at the end). (It's only not what I implemented because I ran into some parsing issues, so it remains to be seen if these can be overcome.)</p>
<p><code>x@?..</code> parallels the naming of patterns, but is a bit cluttered, and is really being used for a different thing. Still, it might be nice.</p>



<a name="310715511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715511">(Nov 17 2022 at 22:58)</a>:</h4>
<h3>(b) Default goal names</h3>
<p><strong>Should names by default be prefixed with the name of the structure?</strong> Currently I don't do this—my feeling is that it can be cluttering to have something like <code>semigroup.mul</code> instead of just <code>mul</code>, so I just use <code>mul</code>. But I thought I'd put this choice out there, since it's easy to change in the code.</p>



<a name="310715527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715527">(Nov 17 2022 at 22:58)</a>:</h4>
<h1>Implementation questions</h1>



<a name="310715534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715534">(Nov 17 2022 at 22:59)</a>:</h4>
<h2>Choice 3: metadata</h2>
<p><strong>How should metadata be stored for each goal?</strong> Currently, the metadata necessary to avoid naming conflicts and to allow access to the structure  information is stored as metadata on the goal's type. Metadata can only be stored on an <code>Expr</code>, and as a <code>KVMap</code> (as far as I know), so this is both fragile (since the type can change as tactics are applied, and the metadata lost) and limited (since <code>KVMap</code>s can only store limited kinds of values). I'm open to more robust implementations. As far as I know the options might be</p>
<ol>
<li>store metadata on the type (current)</li>
<li>use an environment extension (?)</li>
<li>give the metavariables local instances (???)</li>
</ol>
<p>I don't know how either 2 or 3 would work; I'm not very familiar with environment extensions, and I'm not sure how 3 would be done "manually" for each metavariable or how it would be used.</p>



<a name="310715568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/310715568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#310715568">(Nov 17 2022 at 22:59)</a>:</h4>
<h2>Choice 4: Which defaults to avoid synthesizing when avoiding default synthesis?</h2>
<p>Currently, if the binder of a type is <code>.instImplicit</code>, we try to synthesize an instance. <strong>Should this be done even when we don't want to synthesize default values per se?</strong></p>



<a name="312976435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312976435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312976435">(Nov 30 2022 at 02:44)</a>:</h4>
<p>Sorry for the ignorant question <span class="user-mention" data-user-id="548935">@Thomas Murrills</span>, but what happened to this? We've started porting files where <code>refine_struct</code> is being used, and it would be nice to have in mathlib asap.</p>



<a name="312977915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312977915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312977915">(Nov 30 2022 at 03:04)</a>:</h4>
<p>It's <em>basically</em> ready and working on the branch <code>thorimur/refine_struct-via-StructInst</code> in mathlib4, up to the design choices above! (We started discussing it inadvertently <a href="#narrow/stream/287929-mathlib4/topic/Linting.20standards.20for.20mathlib/near/311109890">here</a>, and I suppose I really should have included an update on this thread as well...)</p>



<a name="312978041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978041">(Nov 30 2022 at 03:06)</a>:</h4>
<p>what is mathport supposed to do with the new tactic, since my understanding is that it's not a direct translation?</p>



<a name="312978126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978126">(Nov 30 2022 at 03:07)</a>:</h4>
<p>So (I think—not totally sure of the internals of mathport) we'd align <code>refine_struct</code> with <code>refine</code>, and translate <code>..</code> (when it occurs in a structure instance following <code>refine_struct</code>) into <code>?..</code>. Or, into <code>?..!</code> (or whatever syntax we preferred for "fill with synthetic goals, and don't synthesize defaults")—this would preserve the behavior exactly</p>



<a name="312978192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978192">(Nov 30 2022 at 03:08)</a>:</h4>
<p>Did we establish that <code>..</code> / <code>refine'</code> isn't going to work?</p>



<a name="312978490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978490">(Nov 30 2022 at 03:12)</a>:</h4>
<p>that is to say, the choices about <code>?..</code> vs <code>..</code> aren't really related to the main reason people use <code>refine_struct</code> instead of <code>refine</code> on a struct, which is that it labels the subgoals</p>



<a name="312978504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978504">(Nov 30 2022 at 03:12)</a>:</h4>
<p><code>..</code> / <code>refine'</code> would work for any instances that don't get followed by tactics which refer to the name of the goal explicitly or via <code>pi_instance_derive_field</code>, which also refers to named goals.</p>



<a name="312978532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978532">(Nov 30 2022 at 03:13)</a>:</h4>
<p>can <code>..</code> name the goals?</p>



<a name="312978539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978539">(Nov 30 2022 at 03:13)</a>:</h4>
<p>What do you mean? I've implemented it such that <code>?..</code> labels the subgoals</p>



<a name="312978908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312978908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312978908">(Nov 30 2022 at 03:19)</a>:</h4>
<p><code>..</code> <em>could</em> technically name the subgoals, but as I understand it <code>..</code> is also used quite a bit in pattern-matching by basically expanding something like <code>{ x := 0, .. }</code> to a structure instance with <code>_</code>'s in every spot. (is this correct?) That means we'd want those to be natural and solved by unification, while the named ones should be synthetic opaque, I think. (Though this also rests on my assumption that you can't pattern match with synthetic opaque goals, and I'm not 100% sure if that's true.)</p>
<p>Also, one thing about <code>?..</code> is that (under the current syntax choices) it also synthesizes defaults. If pattern-matching on things like <code>{ x := 0,  .. }</code> works how I think it does, then synthesizing defaults with <code>..</code> would prevent some patterns from matching.</p>
<p>Naming subgoals also currently involves putting metadata on the resulting goals so that future tactics like <code>have_field</code> and <code>pi_instance_derive_field</code> can refer to it, which I don't think we'd want <code>..</code> to be doing all the time in patterns. (<em>However</em>, <code>have_field</code> isn't used and <code>pi_instance</code> could be rewritten to obviate the need for metadata, so.)</p>



<a name="312979036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979036">(Nov 30 2022 at 03:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/312978908">said</a>:</p>
<blockquote>
<p><code>..</code> <em>could</em> technically name the subgoals, but as I understand it <code>..</code> is also used quite a bit in pattern-matching on subgoals by basically expanding to a structure instance with <code>_</code>. (is this correct?) That means we'd want those to be natural, while the named ones should be synthetic opaque, I think.</p>
</blockquote>
<p>Natural mvars can be named too</p>



<a name="312979188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979188">(Nov 30 2022 at 03:23)</a>:</h4>
<p>Right, but metavariables meant to be used as goals shouldn't be natural, right?</p>



<a name="312979257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979257">(Nov 30 2022 at 03:24)</a>:</h4>
<p>I don't think that the full proposal is going to land as is. The dev team just doesn't have the bandwidth for it, and it doesn't seem to have much popular support or even discussion of the proposal beyond me and you</p>



<a name="312979280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979280">(Nov 30 2022 at 03:24)</a>:</h4>
<p>So I think a better target is a MVP that does what we need for mathlib and doesn't make too many other changes</p>



<a name="312979282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979282">(Nov 30 2022 at 03:24)</a>:</h4>
<p>Right, that's why currently it's going to mathlib!</p>



<a name="312979328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979328">(Nov 30 2022 at 03:25)</a>:</h4>
<p>I anticipate issues with two competing structure syntaxes, this is bad for the parser</p>



<a name="312979400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979400">(Nov 30 2022 at 03:26)</a>:</h4>
<p>How so? This one only occurs in cases that explicitly include <code>?..</code> or <code>?..!</code> (no optionality)</p>



<a name="312979466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979466">(Nov 30 2022 at 03:27)</a>:</h4>
<p>Would it work if it wasn't in the <code>term</code> category and was just a special bit of syntax accepted by <code>refine_struct</code>?</p>



<a name="312979534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979534">(Nov 30 2022 at 03:28)</a>:</h4>
<p>It's a backtracking issue even if it is distinct from the existing syntax</p>



<a name="312979557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979557">(Nov 30 2022 at 03:29)</a>:</h4>
<p>I mean, I guess if you want an MVP I could insist that the parser just demands <code>refine_struct</code> in front of the current structure-with-<code>?..</code> syntax, and then at the end it feeds the instance it got back as syntax to <code>refine</code></p>



<a name="312979574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979574">(Nov 30 2022 at 03:29)</a>:</h4>
<p>oh, is backtracking on syntax very expensive? <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span></p>



<a name="312979695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979695">(Nov 30 2022 at 03:30)</a>:</h4>
<p>We define a lot of structures. :-)</p>



<a name="312979723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979723">(Nov 30 2022 at 03:31)</a>:</h4>
<p>Ah...would the mathlib syntax get checked first? oof, yeah...</p>



<a name="312979731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979731">(Nov 30 2022 at 03:31)</a>:</h4>
<p>At least until recently parsing <code>def x := [[[[[[[[[[[[[[[[[[[[</code> was exponential in the number of <code>[</code> because of parser backtracking among the various syntaxes that start with <code>[</code></p>



<a name="312979831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979831">(Nov 30 2022 at 03:33)</a>:</h4>
<p>I see...so it would only really be efficient enough if subsumed into core, and if there isn't bandwidth/support for it there...</p>



<a name="312979900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979900">(Nov 30 2022 at 03:34)</a>:</h4>
<p>right, the correct way to handle this efficiently is with a <code>".." &lt;|&gt; "?.."</code> at the end of the structure parser instead of having two carbon copy parsers that differ only in the last bit</p>



<a name="312979951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312979951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312979951">(Nov 30 2022 at 03:35)</a>:</h4>
<p>I think a lighter change that would do what we need and might not even break the world is to make <code>..</code> introduce named synthetic mvars</p>



<a name="312980051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980051">(Nov 30 2022 at 03:36)</a>:</h4>
<p>yeah, that's what I was trying for when trying to see if I could get it into core! I ran into problems only really with the built-in macro in <code>StructInst</code>...it has a bit that goes <code>$[..%$ell]?</code>, and it didn't seem to want to use something like <code>$[$ell:variadicHole]?</code> with <code>variadicHole</code> a parser in <code>Term</code>, I'm guessing due to when various things become available for what.</p>



<a name="312980095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980095">(Nov 30 2022 at 03:37)</a>:</h4>
<blockquote>
<p>I think a lighter change that would do what we need and might not even break the world is to make .. introduce named synthetic mvars</p>
</blockquote>
<p>Ok, I can try this. I worry about the synthetic vs. synthetic opaque distinction though. It seemed to run into problems when they were just synthetic</p>



<a name="312980102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980102">(Nov 30 2022 at 03:37)</a>:</h4>
<p>Does it work in pattern position?</p>



<a name="312980162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980162">(Nov 30 2022 at 03:38)</a>:</h4>
<p>i.e. does <code>match x with | { a := ?a } =&gt; ...</code> work</p>



<a name="312980176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980176">(Nov 30 2022 at 03:38)</a>:</h4>
<p>Is <code>?a</code> always synthetic opaque?</p>



<a name="312980189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980189">(Nov 30 2022 at 03:38)</a>:</h4>
<p>yes, but expressions are handled specially in pattern position</p>



<a name="312980227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980227">(Nov 30 2022 at 03:39)</a>:</h4>
<p>Hmm okay! Let me check if <code>?..</code> works in pattern position on my branch</p>



<a name="312980364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980364">(Nov 30 2022 at 03:40)</a>:</h4>
<p>Oh weird, <code>?a</code> in pattern position acts the same as <code>a</code></p>



<a name="312980414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980414">(Nov 30 2022 at 03:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="n">where</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="k">#check</span> <span class="k">let</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">?</span><span class="n">a</span> <span class="o">}</span> <span class="o">:=</span> <span class="n">Foo.mk</span> <span class="mi">0</span><span class="bp">;</span> <span class="n">a</span>
</code></pre></div>



<a name="312980492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980492">(Nov 30 2022 at 03:42)</a>:</h4>
<p>hmmm! on my branch</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo'</span> <span class="n">where</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="k">match</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">5</span> <span class="o">:</span> <span class="n">Foo'</span> <span class="o">}</span> <span class="k">with</span> <span class="bp">|</span> <span class="o">{</span> <span class="bp">?..</span> <span class="o">}</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
</code></pre></div>
<p>yields "invalid pattern" (but <code>..</code> works)</p>



<a name="312980590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980590">(Nov 30 2022 at 03:44)</a>:</h4>
<p>is <code>{ ?.. }</code> an <code>elab</code> or <code>macro</code>?</p>



<a name="312980594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980594">(Nov 30 2022 at 03:44)</a>:</h4>
<p><code>elab</code></p>



<a name="312980609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980609">(Nov 30 2022 at 03:44)</a>:</h4>
<p>Since it's based off of the term elab <code>StructInst</code>, but just applied in different syntactic circumstances</p>



<a name="312980809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312980809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312980809">(Nov 30 2022 at 03:47)</a>:</h4>
<p>Looks like <a href="https://github.com/leanprover/lean4/blob/3e45060dd52c13ee4904da1ccf6279df154f1a8a/src/Lean/Elab/PatternVar.lean#L181-L184">the set of patterns is non-extensible</a></p>



<a name="312981050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312981050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312981050">(Nov 30 2022 at 03:50)</a>:</h4>
<p>Oh, ok! So we might only be able to tell if creating named synthetic opaque goals works in patterns in this case by actually modifying <code>..</code>'s behavior in core. I could try that tomorrow</p>



<a name="312981087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312981087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312981087">(Nov 30 2022 at 03:50)</a>:</h4>
<p>(Well, or by reading the right code, I guess!)</p>



<a name="312981692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312981692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312981692">(Nov 30 2022 at 03:57)</a>:</h4>
<p>The code I posted above shows what happens when you use synthetic opaques in a pattern</p>



<a name="312981755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312981755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312981755">(Nov 30 2022 at 03:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/312980364">said</a>:</p>
<blockquote>
<p>Oh weird, <code>?a</code> in pattern position acts the same as <code>a</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="n">where</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="k">#check</span> <span class="k">let</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">?</span><span class="n">a</span> <span class="o">}</span> <span class="o">:=</span> <span class="n">Foo.mk</span> <span class="mi">0</span><span class="bp">;</span> <span class="n">a</span>
</code></pre></div>
</blockquote>



<a name="312981841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312981841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312981841">(Nov 30 2022 at 03:59)</a>:</h4>
<p>Oh, sorry, I misread—I thought you had said <code>?a</code> syntax was handled differently in patterns, but you had said that the expressions were handled differently, my bad</p>



<a name="312982014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982014">(Nov 30 2022 at 04:00)</a>:</h4>
<p>So is this...desirable? Is it okay to have those names floating around</p>



<a name="312982140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982140">(Nov 30 2022 at 04:02)</a>:</h4>
<p>I think the main possibility for breakage is this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span> <span class="s2">"foo"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(⟨</span><span class="bp">$</span><span class="o">(</span><span class="n">Lean.mkIdent</span> <span class="bp">`</span><span class="n">a</span><span class="o">)⟩)</span>
<span class="k">#check</span> <span class="k">let</span> <span class="o">(</span><span class="n">foo</span><span class="o">,</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Foo.mk</span> <span class="mi">0</span><span class="o">,</span> <span class="n">Foo.mk</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span> <span class="n">a</span>
              <span class="c1">-- ^^^ invalid pattern, variable 'a' occurred more than once</span>
</code></pre></div>



<a name="312982252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982252">(Nov 30 2022 at 04:03)</a>:</h4>
<p>oh oops, I did it wrong</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span> <span class="s2">"foo"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(⟨</span><span class="bp">?$</span><span class="o">(</span><span class="n">Lean.mkIdent</span> <span class="bp">`</span><span class="n">a</span><span class="o">)⟩)</span>
<span class="k">#check</span> <span class="k">let</span> <span class="o">(</span><span class="n">foo</span><span class="o">,</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Foo.mk</span> <span class="mi">0</span><span class="o">,</span> <span class="n">Foo.mk</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span> <span class="n">a</span> <span class="c1">-- ok, `a` refers to the second occurrence</span>
</code></pre></div>



<a name="312982350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982350">(Nov 30 2022 at 04:04)</a>:</h4>
<p>that is, <code>?a</code> acts kind of like <code>a</code>, but if there are multiple occurrences they will shadow instead of causing the multiple declaration error</p>



<a name="312982418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982418">(Nov 30 2022 at 04:05)</a>:</h4>
<p>My implementation does aggressively avoid naming conflict when creating the metavariable names by checking the metavariable context, but relies on metadata on the metavariables to do so—overhead I imagine we'd want to avoid when we don't plan on using it? Or is that cheap? (Do metavar contexts work the same way in patterns?)</p>



<a name="312982512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982512">(Nov 30 2022 at 04:06)</a>:</h4>
<p>performing extra checks here is probably not a performance concern, but adding more state to the mvar context is almost certainly a non-starter</p>



<a name="312982761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982761">(Nov 30 2022 at 04:09)</a>:</h4>
<p>adding more state—does that happen by checking it? just want to make sure it's clear that the metadata is on the field metavariables as mdata on the type, not, like, as extra metavariables in the context or something</p>



<a name="312982952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312982952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312982952">(Nov 30 2022 at 04:11)</a>:</h4>
<p>(though, this is something I wanted to check in review or something: <em>should</em> it be there as mdata on the type? would local instances (which I don't understand, at least insofar as how metavariables acquire/use them in their local instance field) be feasible and/or more robust? (All I know about local instances is that metavariables have a field for them.))</p>



<a name="312983111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312983111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312983111">(Nov 30 2022 at 04:13)</a>:</h4>
<p>Actually, looking at the code I linked earlier, it directly traverses the syntax of that closed class of expressions in order to find the set of bound variables. Therefore <code>{ .. }</code> does <em>not</em> act the same as <code>{x := _}</code> or <code>{x := ?a}</code> because the latter actually has an <code>?a</code> in the syntax. So my projection is that if you made <code>{ .. }</code> make synthetic mvars it would not change anything about the set of accessible variables and the <code>let ?a := 1; a</code> example wouldn't work if <code>?a</code> was generated by a <code>{ .. }</code> pattern match</p>



<a name="312983162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312983162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312983162">(Nov 30 2022 at 04:13)</a>:</h4>
<p>Nice!</p>



<a name="312983235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312983235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312983235">(Nov 30 2022 at 04:14)</a>:</h4>
<p>(I think—assuming the goal is for its pattern behavior to not change.)</p>



<a name="312983253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312983253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312983253">(Nov 30 2022 at 04:14)</a>:</h4>
<p>yes, I think we want that</p>



<a name="312983331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312983331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312983331">(Nov 30 2022 at 04:15)</a>:</h4>
<p>99% of uses of <code>..</code> in lean core are in patterns, so if the behavior there is unchanged then you have a good chance of not breaking it</p>



<a name="312983615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312983615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312983615">(Nov 30 2022 at 04:18)</a>:</h4>
<p>fwiw I do still think that having <code>..</code> name metavariables is super unintuitive from a usage perspective for exactly that reason...because you expect <code>..</code> to be discarded or taken care of like <code>_</code>, whereas <code>?</code>-ish things are things you're going to care about later. but I've said my piece, so ultimately I'll do whatever is decided</p>



<a name="312984172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312984172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312984172">(Nov 30 2022 at 04:24)</a>:</h4>
<p>By the way, <code>apply</code> also names its subgoals using named natural metavariables</p>



<a name="312984685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312984685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312984685">(Nov 30 2022 at 04:30)</a>:</h4>
<p>hmm, true. but that does seem inconsistent with the behavior of <code>refine</code>, which is the context I'm basing this line of thought off of...</p>



<a name="312984717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312984717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312984717">(Nov 30 2022 at 04:31)</a>:</h4>
<p>also does apply attempt to fill in those <code>_</code>s?</p>



<a name="312985099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312985099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312985099">(Nov 30 2022 at 04:36)</a>:</h4>
<p>but, in any case! I've written enough about my reasoning for <code>?</code> at the top of this topic, lol. so, if we <em>do</em> have <code>..</code> make named metavariables, should there still be metadata on the metavariables? If not, three things would happen:</p>
<ul>
<li>I would rewrite how name conflicts are resolved</li>
<li><code>have_field</code> would not be ported (never actually used in mathlib besides in <code>pi_instance</code>, but might be used by people outside of mathlib, idk)</li>
<li>either <code>pi_instance_derive_field</code> would need to explicitly take in the name of the field as an argument, <em>or</em> it would have to be subsumed into <code>piInstance</code> in the way talked about over at the thread I started about porting <code>pi_instance</code> (which would be the cleaner (and easier) approach imo)</li>
</ul>
<p>does all that sound good? or should we keep the metadata?</p>



<a name="312986040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312986040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312986040">(Nov 30 2022 at 04:48)</a>:</h4>
<p>also, in this case, what about synthesizing all defaults that are possible to synthesize? that functionality is implemented—would we just not use it, or would we want special syntax for it?</p>



<a name="312986657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312986657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312986657">(Nov 30 2022 at 04:56)</a>:</h4>
<p>I think we need to do that for compatibility with the old lean 4 behavior</p>



<a name="312986991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312986991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312986991">(Nov 30 2022 at 05:00)</a>:</h4>
<p>which one? (keep/abandon metadata or abandon a way to access default synthesis?)</p>



<a name="312990592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312990592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312990592">(Nov 30 2022 at 05:44)</a>:</h4>
<p>keep default synthesis</p>



<a name="312991071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/312991071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#312991071">(Nov 30 2022 at 05:51)</a>:</h4>
<p>oh, ok, neat. what syntax should be used? I'm guessing it needs to be different than <code>..</code> otherwise patterns using it will only match those that have the default values for the fields, right? (or no?) (currently <code>..</code> does not synthesize any defaults)</p>



<a name="313385470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313385470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313385470">(Dec 01 2022 at 21:55)</a>:</h4>
<p>/poll Generally, what syntax should create named goals for fields in structure syntax (esp. in the context of <code>refine</code>)?<br>
<code>?..</code> for named goals,  <code>..</code> for patterns (unnamed goals)<br>
<code>..</code> for everything (both named goals and patterns)</p>



<a name="313469200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313469200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313469200">(Dec 02 2022 at 10:33)</a>:</h4>
<p>I think you're not getting many responses because many people (including me) are fine with either option and don't have a strong opinion.</p>



<a name="313469486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313469486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313469486">(Dec 02 2022 at 10:35)</a>:</h4>
<p>I guess that should be an option then?</p>



<a name="313471335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313471335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313471335">(Dec 02 2022 at 10:45)</a>:</h4>
<p>I gave this issue some thought last night and I think we haven't been considering one of the more important aspects of synthetic opaque vs natural metavars which is that opaque mvars can't be solved by unification. So the question becomes: should the holes in a structure be fillable by unification? To demonstrate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">y</span> <span class="o">:</span> <span class="n">α</span>
  <span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="o">}</span> <span class="c1">-- ok</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">?</span><span class="n">a</span><span class="o">,</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="o">}</span> <span class="c1">-- fail</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">..</span> <span class="o">}</span> <span class="c1">-- ok</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">?..</span> <span class="o">}</span> <span class="c1">-- fail?</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refine_struct</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">..</span> <span class="o">}</span> <span class="c1">-- fail?</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refine_struct</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">?..</span> <span class="o">}</span> <span class="c1">-- fail?</span>
</code></pre></div>
<p>From this perspective, I think it is clear that we <em>do</em> want the variables in the <code>..</code>/<code>?..</code> to be fillable by unification and not become subgoals, which means that really we should be using <code>..</code> and (named) natural mvars. That means using <code>refine'</code>, but I think this is justifiable because in <code>refine</code> with <code>?a</code> holes the whole point is that you are explicitly labeling the subgoals and can syntactically see how many there are. In the case of <code>?..</code> you can't do that, you know that there is some number of them but that's kind of useless information.</p>
<p>To summarize, I think we should just make structure instances name the holes corresponding to the natural mvars being generated, similar to what <code>apply</code> does (which BTW uses natural mvars for the same reason - we don't know in advance how many goals there will be and we don't want unification to be blocked from closing off subgoals).</p>



<a name="313471490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313471490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313471490">(Dec 02 2022 at 10:46)</a>:</h4>
<p><span class="user-mention" data-user-id="548935">@Thomas Murrills</span></p>



<a name="313522298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313522298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313522298">(Dec 02 2022 at 15:21)</a>:</h4>
<p>Mario, is this orthogonal to the poll, or are they related?</p>



<a name="313524840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313524840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313524840">(Dec 02 2022 at 15:31)</a>:</h4>
<p>It indirectly suggests the "<code>..</code> for everything" option. The poll talks about "named goals", but goal naming is unrelated to the use of <code>?_</code> vs <code>_</code> style goals, which is the main argument for using <code>?..</code> "by analogy". The argument above is that we want <code>refine_struct</code> instances to produce <code>_</code> goals, not <code>?_</code> goals, in which case it would make more sense to use <code>..</code> to denote them.</p>



<a name="313570380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313570380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313570380">(Dec 02 2022 at 19:09)</a>:</h4>
<p>hmm, I disagree, but…for basically the same reasons you’ve given! I think in the case that you <em>do</em> want things solved by unification, you <em>should</em> indeed use blanks, and therefore should use <code>..</code>. but goals that get pushed out by <code>refine</code> to be solved by the user are specifically <em>not</em> the ones given by blanks! so if you want goals that the <em>user</em> should get out of <code>refine</code>, they should be synthetic opaque. If you want something synthesized by unification in the course of a proof, you can always use <code>y := _</code>, and it’s then clear that Lean is taking care of it, not the user.</p>
<p>I’m not sure whether it makes sense to require <code>refine'</code> every time the user wants to refine a structure. It is true that you can’t see explicitly how many goals you get from <code>?..</code>, only <em>that</em> there are labeled goals, but the goals <em>are</em> being labeled, just like with <code>?a</code> (and unlike <code>_</code>), <em>in the context of using <code>refine</code></em>. making the behavior <code>apply</code>-like would separate the process of refining structures off from the general activity of <code>refine</code>-ing, which, maybe we want, maybe we don’t. I tend to think that given how many structures the ordinary user is often interacting with, it would be good to give them a way of refining them in the ordinary course of a proof without resorting to different techniques.</p>
<p>so I suppose it’s really a matter of deciding what we consider the important feature of <code>?</code> is in this context, weighed against the relegation the feature of refining structures to <code>refine'</code> and being unable to do it in the course of an ordinary use of <code>refine</code>.</p>



<a name="313571772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313571772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313571772">(Dec 02 2022 at 19:17)</a>:</h4>
<p>(Aside: perhaps unexpectedly...in the current implementation... <code>example : Foo x := { eq := rfl, ?.. }</code> succeeds <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span> I'm not sure when the unification actually occurs here, since I do think this is unexpected behavior, and your expectation that it should leave a goal <code>?y</code> is correct. Let me look at the code.)</p>



<a name="313572331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313572331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313572331">(Dec 02 2022 at 19:20)</a>:</h4>
<blockquote>
<p>only that there are labeled goals, but the goals are being labeled, just like with ?a (and unlike _), in the context of using refine.</p>
</blockquote>
<p>Again, labeling goals is completely independent of the synthetic opaque thing</p>



<a name="313572463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313572463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313572463">(Dec 02 2022 at 19:21)</a>:</h4>
<p><code>refine'</code> is for when you aren't being precise about the subgoals being generated by a term, just "anything that hasn't been solved yet", and that's also what this <code>..</code> is doing</p>



<a name="313572683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313572683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313572683">(Dec 02 2022 at 19:22)</a>:</h4>
<p>if you use synthetic opaques when you shouldn't you will get very confusing error messages like "can't unify <code>37 : Nat</code> with <code>?m.1234 : Nat</code>" which make no sense</p>



<a name="313573147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313573147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313573147">(Dec 02 2022 at 19:25)</a>:</h4>
<blockquote>
<p>and being unable to do it in the course of an ordinary use of refine.</p>
</blockquote>
<p>You can use <code>refine</code> to refine a structure, you just have to say all the fields you are going to refine and give them names (or not, and let them pick up the default names).</p>



<a name="313574402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313574402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313574402">(Dec 02 2022 at 19:33)</a>:</h4>
<blockquote>
<p>Again, labeling goals is completely independent of the synthetic opaque thing</p>
</blockquote>
<p>Internally, yes, but I'd argue that "whether goals are labeled" is an important feature of how a user <em>thinks</em> about the difference between using <code>refine</code> and <code>refine'</code> (if they even are familiar with <code>refine'</code>), since (afaik) named natural metavariables cannot be created by the user via syntax. Here, <code>?..</code> is something that the user is intentionally creating, not simply a way to hope lean figures it out and then deal with what's left, so to speak. (up to defaults, of course, but imo that's more a question of how high-priority we perceive <code>?..</code> to be when it fills in fields with goals.) That's the perspective I'm viewing this from.</p>
<blockquote>
<p>You can use refine to refine a structure, you just have to say all the fields you are going to refine and give them names (or not, and let them pick up the default names).</p>
</blockquote>
<p>Yes, but you could do that anyway :) Ultimately, the whole point of this is making proofs easier to write, isn't it?</p>



<a name="313574863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313574863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313574863">(Dec 02 2022 at 19:36)</a>:</h4>
<p>If using <code>?..</code> causes partial definitions to fail, that's not very nice since that's the whole point of the tactic. We certainly wouldn't be able to roll it out as a replacement for <code>refine_struct</code></p>



<a name="313575379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313575379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313575379">(Dec 02 2022 at 19:39)</a>:</h4>
<p>FYI, <code>refine'</code> is not a deprecated tactic, although the name leaves something to be desired. Besides backward compatibility, it is useful for automation-heavy proofs that just want to discharge all the subgoals by similar methods. The majority of <code>refine_struct</code> uses are in proofs of this form - note that it is extremely common to have <code>refine_struct</code> followed by <code>&lt;;&gt;</code> instead of an enumeration of cases</p>



<a name="313579195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579195">(Dec 02 2022 at 20:03)</a>:</h4>
<p>Just to make sure I'm on the same page, which partial definitions failing are you talking about? Ones where a field could be synthesized by unification, but isn't?</p>



<a name="313579367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579367">(Dec 02 2022 at 20:04)</a>:</h4>
<p>stuff like this one from above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refine_struct</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">?..</span> <span class="o">}</span>
</code></pre></div>



<a name="313579501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579501">(Dec 02 2022 at 20:05)</a>:</h4>
<p>If I provided no fields at all, I would have gotten two goals. If I provide the <code>eq</code> field then I don't get one goal, I get a type error</p>



<a name="313579508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579508">(Dec 02 2022 at 20:05)</a>:</h4>
<p>not nice</p>



<a name="313579807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579807">(Dec 02 2022 at 20:06)</a>:</h4>
<p>It's even more weird when <code>eq</code> has an auto param which fills in the <code>rfl</code></p>



<a name="313579853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579853">(Dec 02 2022 at 20:06)</a>:</h4>
<p>Ah, yes. It should never give a type error in that case.</p>



<a name="313579935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313579935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313579935">(Dec 02 2022 at 20:07)</a>:</h4>
<p>but you need to use natural mvars to get that behavior</p>



<a name="313580332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313580332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313580332">(Dec 02 2022 at 20:09)</a>:</h4>
<p>Well...currently it doesn't give an error, but does fill it in as <code>x</code> unexpectedly <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> This might be because internally, it starts with natural metavariables, then assigns them later—investigating rn. In any case it's a great test case! :)</p>



<a name="313581460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313581460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313581460">(Dec 02 2022 at 20:17)</a>:</h4>
<p>btw in Lean 3 this error happens in this case. (did I transcribe this correctly? note that I added an extra field in an attempt to have there be a goal, since I'm not sure why this error happens.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refine_struct</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">..</span> <span class="o">}</span>
<span class="c1">-- match failed state: no goals</span>
</code></pre></div>



<a name="313581487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313581487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313581487">(Dec 02 2022 at 20:17)</a>:</h4>
<p>assign them later you say? then I'm sure you will also enjoy this test case:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="n">opaque</span> <span class="n">foo</span> <span class="o">(</span><span class="n">_</span> <span class="n">_</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">True</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refine</span> <span class="n">foo</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">?..</span> <span class="o">}</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">?..</span> <span class="o">}</span>
</code></pre></div>



<a name="313582272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313582272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313582272">(Dec 02 2022 at 20:23)</a>:</h4>
<p>Ooo, interesting! Yes, that behaves incorrectly, I believe—it gives a single case <code>y</code>. What does <code>opaque</code> do?</p>



<a name="313582317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313582317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313582317">(Dec 02 2022 at 20:23)</a>:</h4>
<p>it's supposed to give a single case</p>



<a name="313582344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313582344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313582344">(Dec 02 2022 at 20:23)</a>:</h4>
<p>ah! great then! lol</p>



<a name="313582386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313582386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313582386">(Dec 02 2022 at 20:24)</a>:</h4>
<p>but that's also what happens if you use <code>..</code></p>



<a name="313582455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313582455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313582455">(Dec 02 2022 at 20:24)</a>:</h4>
<p><code>opaque</code> is just a definition that you can't unfold</p>



<a name="313582595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313582595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313582595">(Dec 02 2022 at 20:25)</a>:</h4>
<p>if it was defined to be <code>trivial</code> then lean would just unfold it instead of forcing the structs to match</p>



<a name="313583322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313583322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313583322">(Dec 02 2022 at 20:29)</a>:</h4>
<p>Aaanyway, this is not going in a productive direction. We're trying to replace <code>refine_struct</code> here, and AFAICT that means fixing structure instances to name the goals and nothing more. I don't want to get in extensive discussions about alternative tactics that are implemented prior to having any demand or examples of real world use. Mixing these two things is blocking us from being able to check this one off the list.</p>



<a name="313585498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313585498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313585498">(Dec 02 2022 at 20:43)</a>:</h4>
<p>Hmm, I see what I'm doing as just a translation of <code>refine_struct</code> from Lean 3 notation to Lean 4 notation, instead of being an implementation of alternative tactics and the like. Not sure what you mean about it not going in a productive direction—haven't we showed that my current implementation at least doesn't fail in the ways you're expecting it to?</p>



<a name="313585505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313585505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313585505">(Dec 02 2022 at 20:43)</a>:</h4>
<p>Btw, I sort of figured out the reason <code>?..</code> doesn't create a goal in the <code>eq := rfl</code> case. It's because of how something like <code>rfl</code> affects <em>any</em> omitted field, and occurs before the default synthesis loop even starts, and therefore before fields are even checked for whether or not they're missing (which happens at the end of the loop). Check this out, which works fine in lean 4 even though <code>y</code> is omitted and doesn't have a default value:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foorfl</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">Foorfl</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="o">}</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="313587379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313587379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313587379">(Dec 02 2022 at 20:54)</a>:</h4>
<p>So, although it's a bit of a gotcha, <code>?..</code> not producing a goal in this case is consistent with it having "low precedence" among the ways the structure instance <em>itself</em> would synthesize values, because <code>?..</code> makes goals out of any fields the structure instance considers to be <em>missing</em> when it's all finished (and since no "fields missing" error happens in the above, we wouldn't expect any goals to arise when inserting <code>?..</code>).</p>



<a name="313587708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313587708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313587708">(Dec 02 2022 at 20:57)</a>:</h4>
<p>Here's something else worth noting about lean's existing behavior: for the same reasons, it prefers unification pre-default synthesis to default values. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foorfld</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">Foorfld</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="o">}</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="313607603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313607603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313607603">(Dec 02 2022 at 23:29)</a>:</h4>
<p>Ok, I finally checked, and there's a more serious problem to just using <code>..</code>: as I was worried about, having it synthesize defaults breaks patterns. I think the code that we were looking at <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  in <code>PatternVar.lean</code> was only for collecting variable names—but the syntax on the lhs of a pattern case is then still elaborated as usual before being matched. I think this happens e.g. <a href="https://github.com/leanprover/lean4/blob/e16880607800ed68a6e2c2a2aebf60d1b75227c9/src/Lean/Elab/Match.lean#L339">here</a>.</p>
<p>I minimally changed a fresh copy of <code>StructInst.lean</code> so that <code>..</code> synthesized defaults instead of inserting a syntactic hole. This means marking the field as default, then returning from the default loop instead of reporting fields missing and throwing an error—each field value starts out as a natural metavariable, so this just leaves any that didn't get assigned to a default value as such. You can see it/try it out as <a href="https://github.com/leanprover/lean4/compare/master...thorimur:lean4:master">the only commit on the master branch of my lean4 fork that's ahead of master</a>.</p>
<p>Anyway, this builds, but upon linking the new toolchains etc., the following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="n">where</span>
  <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="k">match</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">{</span> <span class="bp">..</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">}</span> <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">Nat.succ</span> <span class="n">_</span> <span class="o">}</span> <span class="bp">=&gt;</span> <span class="n">false</span>

<span class="k">#eval</span> <span class="n">test</span> <span class="c1">-- false</span>
</code></pre></div>
<p>(You can see by how it doesn't count this as redundant that something is up, but <code>test</code> confirms that it's behaving how we think it does.)</p>
<p>So...do we stick with <code>..</code> and just don't synthesize defaults, or use new syntax (whether <code>?..</code> or something else)?</p>



<a name="313607774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313607774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313607774">(Dec 02 2022 at 23:30)</a>:</h4>
<p>You can just check <code>inPattern</code> and not synthesize defaults in patterns</p>



<a name="313607860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313607860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313607860">(Dec 02 2022 at 23:31)</a>:</h4>
<p>From within <code>StructInst.lean</code>? Oh, ok...</p>



<a name="313609901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313609901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313609901">(Dec 02 2022 at 23:51)</a>:</h4>
<p>Ok, let's get this bike shedded! :) Last call for <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/313385470">the poll on <code>?..</code>/<code>..</code> syntax</a>. (Deadline of, say...tomorrowish?) Voting for the "either's fine" option is also useful so that we can see that people have seen it!</p>
<p>Brief list of things to consider:</p>
<p>In favor of <code>?..</code>:</p>
<ul>
<li>legibility for the average user: currently <code>?</code> is present after <code>refine</code> in lean 4 iff a goal is created, e.g. <code>?x</code>, and <code>?..</code> preserves this fact, hopefully making the fact that it creates goals more legible. (otherwise <code>..</code> is the only "unmarked" source of goals in <code>refine</code>) (whether it accomplishes this is up for debate though!) (<a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/307835631">this message</a> is a...<em>slightly</em> longer version of my case for it!)<ul>
<li>flipside of this: keeps the usage of <code>..</code> consistent (it's not being used for multiple things)</li>
</ul>
</li>
<li>the implementation for this is already figured out in mathlib, doesn't require me to rewrite (BIG caveat: not in core yet, because I don't know anything about wrangling stage0. I'm assured it could be figured out but ofc would take bandwidth)</li>
<li>allows goals to be synthetic opaque in <code>refine</code> as goals usually are in that context—not sure if we want this, see above (after poll) for discussion</li>
</ul>
<p>(note: if you were at the meeting, voting for <code>?..</code> doesn't necessarily entail <em>also</em> including extra things like <code>?..!</code> etc., which were just placeholders to show possible functionality! <code>?..</code> could be the only new syntax introduced.)</p>
<p>In favor of just <code>..</code>:</p>
<ul>
<li>doesn't require change to existing syntax (easier for me alone to incorporate into core, doesn't take up bandwidth)</li>
<li>doesn't add more symbols/sigils (staves off ASCII soup in all forms)</li>
<li>if goals are natural, then the syntax is consistent (caveat: this would mean people would have to use <code>refine'</code> instead of <code>refine</code> to access the functionality of <code>refine_struct</code>)</li>
</ul>



<a name="313610534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313610534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313610534">(Dec 02 2022 at 23:58)</a>:</h4>
<p>I voted for <code>..</code>, mostly just on the basis of avoiding ASCII art. :-) I do like the <code>?</code>-iff-new-goals point, and the saving-you-work point, in favour of <code>?..</code>!</p>



<a name="313625064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313625064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313625064">(Dec 03 2022 at 02:53)</a>:</h4>
<p>Just to see how difficult it would be, I'm extending that toy example above to get the "just <code>..</code>" version working in core so we have both options. (spoiler: maybe not that difficult! Looks like I can use the same process and just guard things with a <code>(← read).inPattern</code> check, because my original changes were pretty minimally invasive to begin with.)</p>



<a name="313625425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313625425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313625425">(Dec 03 2022 at 02:59)</a>:</h4>
<p>Independently, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , where did we land re: synthetic opaque v. natural? is there still any reason to be concerned about synthetic opaque goals preventing unification? Every potentially problematic case that's been mentioned so far hasn't actually wound up being  problematic, right? (I haven't seen the type error we're looking to avoid ever happen so far, but maybe we just haven't found the right test case?) (also, looks like <code>refine'</code> plays nice with synthetic opaque goals too, so it doesn't break any existing use of <code>refine'</code> in lean 4).</p>
<p>If possible I'd love to be able to offer people the ability to use <code>refine</code> instead of <code>refine'</code> to easily refine structures (might also be worth adding to the <code>refine</code> docstring?), so I'm a little reluctant to force the goals to be natural...!</p>



<a name="313626147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313626147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313626147">(Dec 03 2022 at 03:10)</a>:</h4>
<p>As I said a while ago, I don't have the energy to continue this conversation. Please set this aside for now or find someone else to discuss this with.</p>



<a name="313627198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313627198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313627198">(Dec 03 2022 at 03:28)</a>:</h4>
<p>No problem, understandable! :)</p>
<p>For anyone else reading, this isn’t the syntax discussion—this is the orthogonal question of whether the goals created (in either case) should be synthetic opaque or natural.</p>
<p>It was suggested earlier in this thread (<a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/313471335">here</a> and then the discussion really starts <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/313574863">here</a>) that there would be actual problems (e.g. unsavory type errors) if the metavariables produced were synthetic opaque, but so far the examples given didn’t wind up producing the errors they were expected to.</p>
<p>However, I’m wondering if there are other cases which <em>do</em> produce the problems mentioned, since it seemed plausible. So this is an open request for test cases which might break because of synthetic opaqueness (or an explanation if I’m mistaken and the given examples already behave incorrectly).</p>



<a name="313628732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313628732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313628732">(Dec 03 2022 at 03:55)</a>:</h4>
<p>My suggestion: implement whatever thing keeps feature parity with Lean 3 to the best of your knowledge. I think there's at least one open PR which needs this on which you can test. If we have to fix things later, so be it. We can also add extra features later if need be.</p>



<a name="313629800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/313629800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#313629800">(Dec 03 2022 at 04:10)</a>:</h4>
<p>Sounds good :) I’ll try to find that PR!</p>



<a name="314166393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314166393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314166393">(Dec 06 2022 at 04:03)</a>:</h4>
<p>Alright, I couldn't find that PR to test on (if anyone knows it, feel free to link me to it!)—but it's so easy to change from <code>.syntheticOpaque</code> to <code>.natural</code> that I think this thing finally might be juuuuust about ready for review, and it can be figured out there. (The tests used so far all work fine with <code>.syntheticOpaque</code>.) <em>But:</em></p>



<a name="314166488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314166488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314166488">(Dec 06 2022 at 04:05)</a>:</h4>
<p>There is one thing I wasn't sure how to translate into lean 4 from lean 3—this test:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">pi.has_one</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine_struct</span> <span class="o">{</span> <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="mi">1</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#print</span> <span class="n">pi.has_one</span>
</code></pre></div>
<p>I'm not totally sure what's going on here, even though it's discussed <a href="#narrow/stream/113488-general/topic/Need.20help.20with.20class.20instance.20resolution">here</a>. (The actual test in lean 3 is written with <code>run_cmd</code> instead of <code>#print</code>, and I'm even less sure of how to translate that.)</p>
<p>Since there's no <code>HasOne</code> in lean 4 core which makes things work for that <code>1</code>, I'm not sure what I should use, or what might demonstrate the (lack of) unseemly <code>eq.mpr</code>s (or whatever the lean 4 equivalent is).</p>
<p>My best-attempt translation seemed to be free of them, but it involved writing out <code>have inst : ((x : α) → _root_.HasOne (β x)) := by infer_instance; exact fun x =&gt; (inst x).one</code> in the proof, and I'm not confident that a lack of weird things there implies a lack of weird things in the case where we use something equivalent to <code>fun _ =&gt; 1</code>. What would an equivalent version of this test be?</p>



<a name="314167407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314167407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314167407">(Dec 06 2022 at 04:16)</a>:</h4>
<p><code>has_one</code> is <code>One</code> in lean 4. (Pro-tip: to find out how something is translated if it's not a trivial naming convention change, try grepping for <code>#align has_one</code> in mathlib4.)</p>



<a name="314167456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314167456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314167456">(Dec 06 2022 at 04:18)</a>:</h4>
<p>Oh, you mean in core. For tests, you can just provide a suitably stubbed out version of the mathlib typeclass. The file that declares <code>Zero</code> and <code>One</code> is very short</p>



<a name="314167818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314167818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314167818">(Dec 06 2022 at 04:22)</a>:</h4>
<p>The purpose of this test is to ensure that <code>refine_struct</code> doesn't introduce anything other than a <a href="http://Foo.mk">Foo.mk</a> application</p>



<a name="314167852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314167852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314167852">(Dec 06 2022 at 04:23)</a>:</h4>
<p>it doesn't really matter if the <code>fun _ =&gt; 1</code> is replaced by something else, this is just the simplest example of a struct literal you can write in lean 3</p>



<a name="314167861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314167861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314167861">(Dec 06 2022 at 04:23)</a>:</h4>
<p>you can use <code>Inhabited</code> or something else in lean 4</p>



<a name="314168479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314168479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314168479">(Dec 06 2022 at 04:33)</a>:</h4>
<p>Ok, thanks! I think I mostly follow, but I'm still not <em>totally</em> sure of what the right way to do this is. Here's my best guess? (Or is <code>Inhabited</code> special, and it really should be a stubbed-out thing?)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">pi.Inhabited</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine</span> <span class="o">{</span> <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="n">exact</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">default</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#print</span> <span class="n">pi.Inhabited</span>
</code></pre></div>



<a name="314169087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314169087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314169087">(Dec 06 2022 at 04:44)</a>:</h4>
<p>Well, if that is a good translation, it looks like there is indeed only <code>@Inhabited.mk</code> in the function body. :)</p>



<a name="314169121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314169121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314169121">(Dec 06 2022 at 04:45)</a>:</h4>
<p>I assume there is also <code>default</code>? What does it look like specifically</p>



<a name="314169248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314169248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314169248">(Dec 06 2022 at 04:47)</a>:</h4>
<p>yes, sorry, I meant as the head of the expression! here's the full output of the <code>#print</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pi.Inhabited</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="bp">→</span>
  <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="bp">→</span> <span class="o">[</span><span class="n">inst</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Inhabited.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)]</span> <span class="bp">→</span> <span class="n">Inhabited.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">inst</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Inhabited.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)]</span> <span class="bp">=&gt;</span>
  <span class="bp">@</span><span class="n">Inhabited.mk.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="k">fun</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">@</span><span class="n">Inhabited.default.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">inst</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="314169452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314169452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314169452">(Dec 06 2022 at 04:51)</a>:</h4>
<p>yeah, that looks like a success. Just put that in the expected.out file</p>



<a name="314174049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314174049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314174049">(Dec 06 2022 at 05:46)</a>:</h4>
<p>The PR mentioned above that wants to use <code>refine_struct</code> has been merged. If you search for <code>refine_struct</code> in mathlib4 you'll find two porting notes, in <code>Mathlib.Order.Basic</code> and in <code>Mathlib.Order.BooleanAlgebra</code>, which show how the proof used to look in mathlib3.</p>



<a name="314178451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314178451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314178451">(Dec 06 2022 at 06:43)</a>:</h4>
<p>Ah, thank you!</p>



<a name="314178478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314178478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314178478">(Dec 06 2022 at 06:43)</a>:</h4>
<p>I looked at the <code>BooleanAlgebra</code> one, and found something strange:</p>



<a name="314178594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314178594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314178594">(Dec 06 2022 at 06:44)</a>:</h4>
<p>On the nightly (none of my modifications), this happens: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">PUnit.booleanAlgebra</span> <span class="o">:</span> <span class="n">BooleanAlgebra</span> <span class="n">PUnit</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine</span> <span class="o">{</span> <span class="n">PUnit.biheytingAlgebra</span> <span class="k">with</span>
    <span class="n">le_sup_inf</span> <span class="o">:=</span> <span class="bp">?</span><span class="n">x</span>  <span class="c1">-- [error when printing message: unknown goal _uniq.80720]</span>
    <span class="n">inf_compl_le_bot</span> <span class="o">:=</span> <span class="bp">?</span><span class="n">y</span>
    <span class="n">top_le_sup_compl</span> <span class="o">:=</span> <span class="bp">?</span><span class="n">z</span> <span class="o">}</span>
</code></pre></div>



<a name="314179045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314179045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314179045">(Dec 06 2022 at 06:50)</a>:</h4>
<p>(Note that using <code>refine'</code> and <code>_</code> doesn't change this.) It seems to be percolating up from <code>withGoalCtx</code>, but how the metavariable appears, I'm not sure. It's not visible directly in the tactic state.</p>



<a name="314179129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314179129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314179129">(Dec 06 2022 at 06:51)</a>:</h4>
<p>(Should this be moved to a different thread, since it's technically not something to do with my port of <code>refine_struct</code>? Although I suppose it would help to know these kinds of things wouldn't be encountered!)</p>



<a name="314185702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314185702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314185702">(Dec 06 2022 at 07:56)</a>:</h4>
<p>Anyway! It looks like I have things finished for the <code>..</code> version. :)</p>



<a name="314185712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314185712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314185712">(Dec 06 2022 at 07:56)</a>:</h4>
<p>The poll did wind up with <code>?..</code> having a slight edge 4-2(-1), but I imagine the following are relevant:</p>
<ul>
<li>my vote for <code>?..</code> probably shouldn't count for much, given my newness</li>
<li>Jireh (who's one of the 4 votes for <code>?..</code>) also voted for either's fine</li>
<li><code>..</code> is basically ready for review, whereas <code>?..</code> is only ready up to stage 0 wrangling, which I would need someone to help me with.</li>
</ul>
<p>So, given the relative ambivalence, and in the interest of not blocking other things...I guess <code>..</code> syntax it is, at least for now, I suppose? Sound good? :)</p>



<a name="314185717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314185717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314185717">(Dec 06 2022 at 07:56)</a>:</h4>
<p>If so, how does this work? The contribution guidelines say I ought to make a detailed issue on github. (Then that I should wait for one of the core developers to give me a go-ahead, after which they'll work with me to make sure the PR gets merged. I'm guessing there's also...review, at some stage, too? Again, totally new to contributing to a project like this! <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>)</p>
<p>Should I open that detailed issue on the lean4 repo, or are there any more things to address here on zulip? (Or should something else happen instead?)</p>



<a name="314235586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314235586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314235586">(Dec 06 2022 at 13:21)</a>:</h4>
<p>How would you describe the candidate change to core? Assume that none of the devs have been following along, so you need to give a simple example which does not talk about <code>refine_struct</code>, and demonstrate how the behavior is changed (and why it's a good thing, if the example itself doesn't make that obvious).</p>



<a name="314327636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314327636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314327636">(Dec 06 2022 at 21:12)</a>:</h4>
<p>How's this?</p>



<a name="314327665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314327665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314327665">(Dec 06 2022 at 21:13)</a>:</h4>
<p>This is a modification to the structure instance elaborator which causes <code>..</code> in structure instances to create named goals for all omitted fields that cannot be synthesized via default values. This aids in interactive proofs that use <code>refine</code>. For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Foo</span> <span class="n">where</span>
  <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">z</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">refine</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">..</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">}</span><span class="bp">;</span> <span class="n">case</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="mi">0</span>
</code></pre></div>
<p>The goal <code>?y</code> for the field <code>y</code> is created in the course of elaborating the structure instance, enabling one to write <code>case y =&gt; ...</code>.</p>
<p>Default field values that are autoparams are tried, and, if they fail, are replaced with a named goal.</p>
<p>The resulting goals are equipped with metadata that enables later tactics to recover information about the field and structure from which they originated (such as the field projections). This enables certain automations.</p>
<p>Name conflicts among multiple simultaneously-occurring structure instances with overlapping field names are resolved by appending indices to the goals that are unique to each structure instance (e.g. <code>?y</code>, <code>?y_1</code>).</p>
<p>This modification only applies to structure instance syntax that is encountered outside of a pattern. Inside a pattern, the pre-existing behavior for <code>..</code> is maintained, which simply fills all omitted fields with natural holes at the syntax level.</p>
<p>Note that existing uses of <code>refine'</code> that use <code>{ .. }</code> are not broken.</p>



<a name="314328104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314328104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314328104">(Dec 06 2022 at 21:16)</a>:</h4>
<p>(I figure I can give more technical details and context, like a link to the zulip discussion, afterwards in the conversation on the issue, right? Or should that be in the main body?)</p>



<a name="314333430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314333430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314333430">(Dec 06 2022 at 21:53)</a>:</h4>
<p>That sounds like 4 features in one. Can they be done separately?</p>



<a name="314333661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314333661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314333661">(Dec 06 2022 at 21:55)</a>:</h4>
<p>How much of lean core and/or tests are broken by this? How big is the diff?</p>



<a name="314334205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314334205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314334205">(Dec 06 2022 at 21:59)</a>:</h4>
<p>more specifically, I see the following separate features:</p>
<ul>
<li><code>..</code> names the generated holes</li>
<li>autoparams (and opt params?) are tried</li>
<li>name conflict resolution (is this a requirement for the tactic not to fail?)</li>
<li>Goals are equipped with metadata (what metadata, how is this encoded?)</li>
</ul>



<a name="314337238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314337238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314337238">(Dec 06 2022 at 22:19)</a>:</h4>
<p>No tests are (newly) broken in core (besides the interactive hover test, because I updated the structure instance docstring :) ).</p>
<p>Are multiple PRs for small things better? If so there might be some things I'd split—e.g. I update <code>exprToSyntax</code> to take an optional type argument instead of needing to infer the type every time.</p>
<p>Let me see how large the diff is and if the features can be separated...</p>



<a name="314337391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314337391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314337391">(Dec 06 2022 at 22:20)</a>:</h4>
<p>(Btw, it's just on <a href="https://github.com/leanprover/lean4/compare/master...thorimur:lean4:master">the master branch of my fork</a> if you'd like to look at it)</p>



<a name="314337595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314337595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314337595">(Dec 06 2022 at 22:21)</a>:</h4>
<p>Ok, the diff is large because I added docstrings for all of the functions in <code>StructInst.lean</code> as well as a module doc with an overview of the code and some small things I think should be addressed in review (before review?)</p>



<a name="314338315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314338315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314338315">(Dec 06 2022 at 22:26)</a>:</h4>
<p><strong>name conflicts</strong>: So, I'd personally think of resolving the name conflicts as part of just the task of naming the holes, but I guess I could just name the holes "badly" (without conflict resolution) first. It wouldn't be a huge change but it would be a change and take time. Plus this depends on the metadata as written, so it would come after that feature.</p>



<a name="314338461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314338461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314338461">(Dec 06 2022 at 22:27)</a>:</h4>
<p><strong>autoparams</strong>: autoparams being tried can be easily split off, since <code>StructInst.lean</code> takes care of autoparams separately anyway, so it's kind of in its own neck of the woods.</p>



<a name="314338706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314338706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314338706">(Dec 06 2022 at 22:29)</a>:</h4>
<p>However, optparams are handled in the default loop, and I don't even touch that process (I intervene afterwards. Even in the mathlib implementation that let you turn off default synthesis, I just guarded the default loop by an appropriate check). Defaults will get synthesized by themselves anyway.</p>



<a name="314339018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314339018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314339018">(Dec 06 2022 at 22:30)</a>:</h4>
<p><strong>name conflicts again</strong>: Oh, wait, re: name conflict: I don't think it's a requirement not to fail. I use a <code>userName</code> argument to a <code>mkFreshExprMVar</code> call, not syntax—does that ensure different mvar ids are created?</p>



<a name="314339500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314339500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314339500">(Dec 06 2022 at 22:33)</a>:</h4>
<p><strong>Metadata</strong>: The metadata implementation is the thing I'm least confident in proposing, tbh. it puts <code>KVMap</code> <code>mdata</code> on the type expression of each metavariable. I worry that that's not robust, and I don't know how local instances work, but I notice that each metavariable has a field for them, and I wonder if they would be more robust...</p>



<a name="314339932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314339932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314339932">(Dec 06 2022 at 22:36)</a>:</h4>
<p>In any case, they currently store a boolean check that this hole did come from <code>..</code> syntax, the original syntax ref of the structure instance, the structure name, the field name, and the index (for name conflict resolution). (The mathlib implementation also stored the user-specified name used to prefix the goals if one was provided.)</p>



<a name="314340199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314340199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314340199">(Dec 06 2022 at 22:38)</a>:</h4>
<p>Not sure if metadata is attached at a premium and less metadata = better. If so I could remove the boolean check (and check another way) and the syntax ref.</p>



<a name="314340772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314340772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314340772">(Dec 06 2022 at 22:42)</a>:</h4>
<p><strong>dsimp</strong>: If all details should be in the issue body (and not in subsequent messages that I'd send), there's technically another feature here: it <code>dsimp</code>s the types of the named goals. This is to maintain parity with <code>refine_struct</code>. Otherwise, goals like <code>{ a := 1 }.a = { a := 1 }.a</code> might be produced (instead of <code>1 = 1</code>). <code>dsimp</code> is how <code>refine_struct</code> solves this problem, so I figured that's what I ought to do—however, it does require importing <code>Lean.Meta.Tactic.Simp.Main</code>, and I'm not sure if this is frowned upon. There might be more surgical ways to approach this.</p>
<p>(Note: it only actually <em>uses</em> <code>dsimp</code> when creating the types of the metavariables created by <code>..</code> in this case. It doesn't <code>dsimp</code> anything else.)</p>



<a name="314341400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314341400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314341400">(Dec 06 2022 at 22:47)</a>:</h4>
<p>Ok, that's it! (Also, wait, were you asking these questions now in this thread, or were you implying that I ought to answer them in the issue body (or both)? I assumed the former)</p>



<a name="314341586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314341586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314341586">(Dec 06 2022 at 22:48)</a>:</h4>
<p>(In any case, <em>all</em> of these features are required to maintain parity with the unstated motivation of absorbing the functionality of <code>refine_struct</code>.)</p>



<a name="314348317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314348317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314348317">(Dec 06 2022 at 23:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314337595">said</a>:</p>
<blockquote>
<p>Ok, the diff is large because I added docstrings for all of the functions in <code>StructInst.lean</code></p>
</blockquote>
<p>That is a separate PR</p>
<blockquote>
<p>as well as a module doc with an overview of the code and some small things I think should be addressed in review (before review?)</p>
</blockquote>
<p>Is this a module doc for StructInst.lean itself or for your PR version? It doesn't make any sense to be the latter, you shouldn't put review comments in the code itself</p>



<a name="314348719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314348719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314348719">(Dec 06 2022 at 23:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314339018">said</a>:</p>
<blockquote>
<p><strong>name conflicts again</strong>: Oh, wait, re: name conflict: I don't think it's a requirement not to fail. I use a <code>userName</code> argument to a <code>mkFreshExprMVar</code> call, not syntax—does that ensure different mvar ids are created? EDIT: just checked, it still produces multiple cases even if they're all named <code>foo</code>. However, addressing these cases individually with <code>case</code> is, of course, a bit difficult, which is part of the point of naming goals...so I'm not sure whether to split it off.</p>
</blockquote>
<p>The point here is to make all the pieces as small and easy to review as possible. One giant PR has a large chance of just being rejected and not really looked at.</p>



<a name="314348943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314348943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314348943">(Dec 06 2022 at 23:45)</a>:</h4>
<p>I see! Ok, I can definitely try to make that the case. :)</p>



<a name="314348947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314348947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314348947">(Dec 06 2022 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314339932">said</a>:</p>
<blockquote>
<p>In any case, they currently store a boolean check that this hole did come from <code>..</code> syntax, the original syntax ref of the structure instance, the structure name, the field name, and the index (for name conflict resolution). (The mathlib implementation also stored the user-specified name used to prefix the goals if one was provided.)</p>
</blockquote>
<p>That does indeed sound quite excessive. Everything in the expr can potentially get serialized into oleans, so unless there is a strong guarantee that it will not persist past elaboration I would try to keep annotations light</p>



<a name="314349164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314349164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314349164">(Dec 06 2022 at 23:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314340772">said</a>:</p>
<blockquote>
<p><strong>dsimp</strong>: If all details should be in the issue body (and not in subsequent messages that I'd send), there's technically another feature here: it <code>dsimp</code>s the types of the named goals. This is to maintain parity with <code>refine_struct</code>. Otherwise, goals like <code>{ a := 1 }.a = { a := 1 }.a</code> might be produced (instead of <code>1 = 1</code>). <code>dsimp</code> is how <code>refine_struct</code> solves this problem, so I figured that's what I ought to do—however, it does require importing <code>Lean.Meta.Tactic.Simp.Main</code>, and I'm not sure if this is frowned upon. There might be more surgical ways to approach this.</p>
</blockquote>
<p>This requires a redesign. You should probably just bring it up as an issue, perhaps suggesting the dsimp approach, and let the devs come up with their own solution.</p>



<a name="314349644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314349644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314349644">(Dec 06 2022 at 23:51)</a>:</h4>
<blockquote>
<p>Is this a module doc for StructInst.lean itself or for your PR version? It doesn't make any sense to be the latter, you shouldn't put review comments in the code itself</p>
</blockquote>
<p>It's a module doc that essentially explains how the code in the file works (it doesn't privilege explaining my additions or refer to them as additions). Not sure if that's something people want to be there. Then there's a separate little section I use for review question, which I expect to be removed before it was merged/PR'd—I was just using that section as a place to put them.</p>



<a name="314349699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314349699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314349699">(Dec 06 2022 at 23:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="548935">Thomas Murrills</span> <a href="#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314337238">said</a>:</p>
<blockquote>
<p>Are multiple PRs for small things better? If so there might be some things I'd split—e.g. I update <code>exprToSyntax</code> to take an optional type argument instead of needing to infer the type every time.</p>
</blockquote>
<p>For your first PR, definitely you should start small. You should build your credibility before going for any major changes.</p>



<a name="314349810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314349810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314349810">(Dec 06 2022 at 23:52)</a>:</h4>
<p>Ok, sounds great. Thanks so much for explaining all this to me. :)</p>



<a name="314349901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314349901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314349901">(Dec 06 2022 at 23:53)</a>:</h4>
<p>The docs PR sounds like a good place to start, the devs are always very welcoming to those</p>



<a name="314350160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314350160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314350160">(Dec 06 2022 at 23:55)</a>:</h4>
<p>Ok, great! So for the specifics of how to do this, do I, say:</p>
<ul>
<li>open an issue</li>
<li>wait for a core dev to approve of it in the abstract</li>
<li>then make the PR (etc.)?<br>
or do I make the PR along with the issue? Just a little unsure of the relationship between issues and PR's in this context.</li>
</ul>



<a name="314350264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314350264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314350264">(Dec 06 2022 at 23:56)</a>:</h4>
<p>Oh, and: do these each need separate [RFC] threads here on zulip? I'd hope this one suffices, but I'm happy to make more if it's desired.</p>



<a name="314350422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314350422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314350422">(Dec 06 2022 at 23:57)</a>:</h4>
<p>I think this thread has suffered from a signal to noise issue, there is too much stuff for a busy person to read through. Summarize!</p>



<a name="314350818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314350818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314350818">(Dec 07 2022 at 00:00)</a>:</h4>
<p>By the way (looking at your master branch), I don't think it's necessary to even mention that the goals are named in the doc comment on structure instances. The first bullet point about <code>..</code> seems sufficient, although it should indicate that it's not a pattern-exclusive syntax (by contrast to rust, for example, from which we got the syntax) but works in <code>refine</code> too.</p>



<a name="314351174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314351174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314351174">(Dec 07 2022 at 00:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">eType</span> <span class="o">:=</span> <span class="n">type.getD</span> <span class="o">(</span><span class="bp">←</span> <span class="n">inferType</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>
<p>this will not do what you want</p>



<a name="314351230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314351230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314351230">(Dec 07 2022 at 00:03)</a>:</h4>
<p>ah, ok. why not?</p>



<a name="314352776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314352776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314352776">(Dec 07 2022 at 00:16)</a>:</h4>
<p>it macro expands to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">a</span> <span class="bp">&lt;-</span> <span class="n">inferType</span> <span class="n">e</span>
<span class="k">let</span> <span class="n">eType</span> <span class="o">:=</span> <span class="n">type.getD</span> <span class="n">a</span>
</code></pre></div>



<a name="314353456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314353456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314353456">(Dec 07 2022 at 00:20)</a>:</h4>
<p>I thought <code>getD</code> being <code>@[macro_inline]</code> meant it only evaluated <code>(← inferType e)</code> if <code>type</code> is <code>none</code>? Does that guarantee not apply in monadic code?</p>



<a name="314353957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314353957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314353957">(Dec 07 2022 at 00:23)</a>:</h4>
<p>ah, my nemesis...the inability to lift <code>&lt;-</code> across a binder</p>



<a name="314354227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354227">(Dec 07 2022 at 00:25)</a>:</h4>
<p>better?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">eType</span> <span class="bp">←</span> <span class="k">match</span> <span class="n">type</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">t</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="n">t</span>
    <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="n">inferType</span> <span class="n">e</span>
</code></pre></div>



<a name="314354770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354770">(Dec 07 2022 at 00:28)</a>:</h4>
<p><code>@[macro_inline]</code> isn't literally a macro, it operates at an early phase of the compiler, not during elaboration / macro expansion</p>



<a name="314354815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354815">(Dec 07 2022 at 00:28)</a>:</h4>
<p><code>do</code> notation is a macro however, so it runs first and does the aforementioned transformation</p>



<a name="314354822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354822">(Dec 07 2022 at 00:28)</a>:</h4>
<p>ah, makes sense that <code>do</code> would expand first then!</p>



<a name="314354866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354866">(Dec 07 2022 at 00:29)</a>:</h4>
<p>not to mention that you couldn't do <code>getD</code> first anyway, it wouldn't be type correct</p>



<a name="314354894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354894">(Dec 07 2022 at 00:29)</a>:</h4>
<p>note that  you had to insert a <code>pure</code> that isn't present in the definition of <code>getD</code> to write the replacement code</p>



<a name="314354900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314354900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314354900">(Dec 07 2022 at 00:29)</a>:</h4>
<p>(or, golfed: <code>let eType ← (type.map pure).getD (inferType e)</code>. but the former is more readable...)</p>



<a name="314355063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314355063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314355063">(Dec 07 2022 at 00:30)</a>:</h4>
<p>Right, makes sense! This is my first outing with monads—still getting used to some aspects of them. :)</p>



<a name="314355161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314355161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314355161">(Dec 07 2022 at 00:31)</a>:</h4>
<p>we could have a <code>getDM</code> however which builds this laziness into the type signature</p>



<a name="314355216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314355216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314355216">(Dec 07 2022 at 00:31)</a>:</h4>
<p>Let me see if I can write that as an exercise!</p>



<a name="314356031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314356031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314356031">(Dec 07 2022 at 00:39)</a>:</h4>
<p>Ok, I think this works.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[macro_inline]</span> <span class="kd">def</span> <span class="n">Option.getDM</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Monad</span> <span class="n">m</span><span class="o">]</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="n">x</span>
  <span class="bp">|</span> <span class="n">none</span><span class="o">,</span>   <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">e</span>
</code></pre></div>



<a name="314357505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314357505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314357505">(Dec 07 2022 at 00:55)</a>:</h4>
<p>Anyway! Got a bit sidetracked there. So. Are these next steps for me correct?</p>
<ol>
<li>make a zulip thread for each individual PR I plan to offer, starting with docstrings for structInst, then maybe a couple smaller PR's, then the rest</li>
<li>at the same time, make an RFC github issue on the lean4 repo for the first feature (and link to the appropriate zulip thread)</li>
<li>after a core dev says to, make a PR</li>
<li>repeat steps 2 and 3 with the remaining features</li>
</ol>



<a name="314363626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314363626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314363626">(Dec 07 2022 at 02:02)</a>:</h4>
<p>I think (1) is already done. For the smaller things you don't need (2) either and can skip to step (3). For the main feature I think an RFC issue on lean 4 repo is appropriate. You aren't likely to get more attention from core devs by posting here unless you ping them directly (and you shouldn't do that unless you have trimmed down the required reading to a manageable level).</p>



<a name="314367103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314367103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314367103">(Dec 07 2022 at 02:46)</a>:</h4>
<p>Ok, I'll just directly make a PR to lean4 adding the docstrings in <code>StructInst.lean</code> then! :)</p>



<a name="314749335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314749335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314749335">(Dec 08 2022 at 19:02)</a>:</h4>
<p>Hmm. I made the docs pull request, but it didn't pass all tests. Strangely, the only one it didn't pass was something completely unrelated to structures (<code>calcInType</code>), and in only the Linux release:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="mi">826</span><span class="bp">/</span><span class="mi">1645</span> <span class="n">Test</span>  <span class="bp">#</span><span class="mi">827</span><span class="o">:</span> <span class="n">leanruntest_calcInType.lean</span> <span class="bp">...............................***</span><span class="n">Failed</span>    <span class="mi">0</span><span class="bp">.</span><span class="mi">36</span> <span class="n">sec</span>
<span class="bp">../../</span><span class="n">common.sh</span><span class="o">:</span> <span class="n">line</span> <span class="mi">28</span><span class="o">:</span> <span class="mi">37016</span> <span class="n">Segmentation</span> <span class="n">fault</span>      <span class="o">(</span><span class="n">core</span> <span class="n">dumped</span><span class="o">)</span> <span class="n">LEAN_BACKTRACE</span><span class="bp">=</span><span class="mi">0</span> <span class="s2">"$@"</span> <span class="mi">2</span><span class="bp">&gt;&amp;</span><span class="mi">1</span>
     <span class="mi">37017</span> <span class="n">Done</span>                    <span class="bp">|</span> <span class="n">perl</span> <span class="bp">-</span><span class="n">pe</span> <span class="bp">'</span><span class="n">s</span><span class="bp">/</span><span class="o">(</span><span class="bp">\?</span><span class="o">(</span><span class="bp">\</span><span class="n">w</span><span class="bp">|</span><span class="n">_</span><span class="bp">\</span><span class="n">w</span><span class="bp">+</span><span class="o">))</span><span class="bp">\.</span><span class="o">[</span><span class="mi">0</span><span class="bp">-</span><span class="mi">9</span><span class="o">]</span><span class="bp">+/\</span><span class="mi">1</span><span class="bp">/</span><span class="n">g'</span> <span class="bp">&gt;</span> <span class="s2">"$f.produced.out"</span>
<span class="n">Unexpected</span> <span class="n">return</span> <span class="n">code</span> <span class="mi">139</span> <span class="n">executing</span> <span class="bp">'</span><span class="n">lean</span> <span class="bp">-</span><span class="n">j</span> <span class="mi">0</span> <span class="bp">-</span><span class="n">Dlinter.all</span><span class="bp">=</span><span class="n">false</span> <span class="n">calcInType.lean'</span><span class="bp">;</span> <span class="n">expected</span> <span class="mi">0</span><span class="bp">.</span> <span class="n">Output</span><span class="o">:</span>
</code></pre></div>
<p>Is this something I should be worried about? It produces an X next to the pull request, saying that it's unable to be merged. (My fork is up to date with master, and other PR's are passing all checks.)</p>



<a name="314772104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314772104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314772104">(Dec 08 2022 at 21:08)</a>:</h4>
<p>This is a recent issue caused by an update to the github runners that is currently causing random segfaults on linux. It is not related to your PR and hopefully it will be fixed soon if it isn't already</p>



<a name="314774098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%5BRFC%5D%20refine_struct%20functionality%20via%20new%20%3F..%20syntax/near/314774098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Murrills <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax.html#314774098">(Dec 08 2022 at 21:21)</a>:</h4>
<p>Great! As expected, then, I added a commit, and it happened to pass the checks :)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Automation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html">Automation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="284627901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284627901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284627901">(Jun 01 2022 at 15:29)</a>:</h4>
<p>Does Lean4 have any automation features?<br>
I've previously used Agda so I'm thinking of things like:</p>
<ol>
<li>the auto option which attempts to fill in the proof for you</li>
<li>The refine option which takes part of a proof and creates the right combination of holes for you</li>
<li>The auto-split features which does a case split on a variable or variables and creates all the cases with holes in the right places</li>
</ol>
<p>I found these really useful in Agda, both to reduce the need for tons of typing, and as a kind of built-in tutorial that could teach me things I didn't know. </p>
<p>I'd love to hear about any other features that lean has which result in any additional code/proof being written by Lean, or any projects thinking about these things</p>



<a name="284630171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284630171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284630171">(Jun 01 2022 at 15:46)</a>:</h4>
<p>We use tactics for this (e.g. <code>simp</code>, <code>refine</code>/<code>apply</code>, <code>cases</code>)</p>



<a name="284634832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284634832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284634832">(Jun 01 2022 at 16:21)</a>:</h4>
<p>As a side node, I am a little surprised that of all things an agda user would be asking for automation, I was under the impression that agda was especially well known for not making use of too much automation but rather sticking to the basics and typing the proof terms out etc? At least most agda people I've come across so far usually disliked tactics * a lot*.</p>



<a name="284637265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284637265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284637265">(Jun 01 2022 at 16:38)</a>:</h4>
<p>I think the Agda automation in question is the editor mode feature set (<code>C-c C-r</code> for refine, etc). The main difference is that in Agda the source <code>.agda</code> file contains the results of this automation, and not the automation steps themselves.</p>



<a name="284637308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284637308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284637308">(Jun 01 2022 at 16:38)</a>:</h4>
<p>In my (limited) Agda experience, you wouldn't really want to write all the proof terms without assistance and Agda doesn't make it easy to do so.</p>



<a name="284845263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284845263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284845263">(Jun 03 2022 at 07:31)</a>:</h4>
<p>Yes, the three things they askes for are exactly the useful commands bound by agda-mode.</p>



<a name="284847857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284847857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284847857">(Jun 03 2022 at 08:05)</a>:</h4>
<p>I should possibly clarify, that I'm a long way from an experienced Agda user.<br>
As <span class="user-mention" data-user-id="110032">@Reid Barton</span> said, I was mostly wondering about the editor features which put code into the source file for you with holes to fill yourself.<br>
I found this increadibly useful when learning, as it created all the syntax for me and hugely reduced both the amount of typing and the amount of errors I had</p>



<a name="284848222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284848222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284848222">(Jun 03 2022 at 08:09)</a>:</h4>
<p>We may eventually get there, but the existence of the tactic framework lowers the priority of these features quite a bit compared to Agda</p>



<a name="284860895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284860895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284860895">(Jun 03 2022 at 10:39)</a>:</h4>
<p>Is there anything in the pipeline that would facilitate it as part of Lean, or would that kind of thing be better as a standalone tool, or part of <code>lean4-mode</code> in emacs?</p>



<a name="284860919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284860919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284860919">(Jun 03 2022 at 10:39)</a>:</h4>
<p>I'll probably have a play around at implementing something myself, but I might as well do it in the most sensible way so any advice is much appreciated!</p>



<a name="284861698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284861698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284861698">(Jun 03 2022 at 10:49)</a>:</h4>
<p>It would have to be a Lean plugin at the very least to reliably get type information and potentially for structurally modifying the syntax tree. I think any reasonable implementation could definitely be merged into Lean.</p>



<a name="284861833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284861833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284861833">(Jun 03 2022 at 10:51)</a>:</h4>
<p>My student assistant <span class="user-mention" data-user-id="405106">@Lars König</span> is planning to look into improving the pretty printer towards a practical code formatter next, which any tools that want to generate syntax should benefit from as they don't have to care about formatting anymore</p>



<a name="284888918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/284888918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#284888918">(Jun 03 2022 at 14:50)</a>:</h4>
<p>Does Lean 4 have something like Lean 3's hole commands?</p>



<a name="285467445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467445">(Jun 08 2022 at 23:43)</a>:</h4>
<p>Me again with more stupid questions.<br>
Is there a way to get lean to dump the AST of an expression?<br>
I want to play around with some stuff in python, so ideally need the AST in some machine readable form.<br>
All implicit brackets put back in and prefix notation would work, but a more proper AST would be amazing.</p>



<a name="285467543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467543">(Jun 08 2022 at 23:44)</a>:</h4>
<p>I want to create a mini proof planner which can take some theorems, some axioms and a goal and attempt to generate a proof in first order logic which lean would check.</p>



<a name="285467557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467557">(Jun 08 2022 at 23:44)</a>:</h4>
<p>Do you want the syntax level AST or the logical expression?</p>



<a name="285467562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467562">(Jun 08 2022 at 23:45)</a>:</h4>
<p>okay expression</p>



<a name="285467702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467702">(Jun 08 2022 at 23:47)</a>:</h4>
<p>You can use something like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Term</span>


<span class="k">#eval</span> <span class="k">show</span> <span class="n">TermElabM</span> <span class="n">_</span> <span class="k">from</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">expr</span> <span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="n">Nat.add</span> <span class="mi">1</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">elabTerm</span> <span class="n">expr</span> <span class="n">none</span>
</code></pre></div>
<p>it will return the <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc">docs4#Lean.Expr</a> that corresponds to the syntax you put in the `() notation. If you want to integrate this into Lean as a tactic you probably want to start looking into how Lean meta programming works first, we're currently putting a (very WIP) resource together for this here. <a href="https://github.com/arthurpaulino/lean4-metaprogramming-book">https://github.com/arthurpaulino/lean4-metaprogramming-book</a></p>



<a name="285467806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467806">(Jun 08 2022 at 23:48)</a>:</h4>
<p>And as a general remark, there is no need to do all of this in python and outside of Lean, Lean 4 is perfectly adequate and well equipped to do just what you want on its own with its meta programming facilities.</p>



<a name="285467838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285467838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285467838">(Jun 08 2022 at 23:49)</a>:</h4>
<p><span class="user-mention" data-user-id="504244">@Rosie Baish</span> there are work items on the VSCode extension for doing some things like <a href="https://github.com/leanprover/vscode-lean4/issues/45">code actions to "fill holes" with suggestions form Lean Language Server</a>.  So definitely open to suggestions and even PR help on any great ideas you might have there.  The poor mans version right now is that the lean program can print stuff in the InfoView which you can then "copy to editor" with a button in the info view :-)   The other poor man's trick for filling holes is to type underscore in your Lean program and then look at the intellisense when you hover over the underscore.  That at least tells you what kind of think you need to put there to complete the program.</p>



<a name="285468674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285468674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285468674">(Jun 09 2022 at 00:00)</a>:</h4>
<p>I was aware that Lean4 could do everything I needed, but I'm a very long way from proficient in it<br>
I just wanted to hack a quick prototype together, and python is my most familiar language for that<br>
If it turns out to be a good idea I'll look at porting it to lean etc.</p>



<a name="285468795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285468795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285468795">(Jun 09 2022 at 00:00)</a>:</h4>
<p>Also, I'm not sure I understand the distinction you made between syntax level AST and logical expression <span class="user-mention" data-user-id="395550">@Henrik Böving</span> ?</p>



<a name="285468962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285468962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285468962">(Jun 09 2022 at 00:02)</a>:</h4>
<p>Lean has a <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Syntax#doc">docs4#Lean.Syntax</a> type for representing the user level syntax, for example things like <code>1 + 1</code> are not desugared to basically <code>Nat.add 1 1</code> in this but are represented as <code>1 + 1</code> but in a syntax tree form so it wouldn't be too interesting for you. There is then a component in the compiler called the term elaborator (which is what I'm calling to here, hence <code>TermElabM</code> that turns a <code>Syntax</code> into an <code>Expr</code> which can actually be used for type checking and all that proof stuff you are interested in.</p>



<a name="285469089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285469089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285469089">(Jun 09 2022 at 00:05)</a>:</h4>
<p>I wanted the version that turns <code>(a \and b)</code> into <code>(prop.and a b)</code>, or something similar<br>
I ran the code snippet you posted above and it generated a huge expression that didn't fit on my screen</p>



<a name="285469116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285469116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285469116">(Jun 09 2022 at 00:05)</a>:</h4>
<p>I basically just want lean to output stuff in a way that means I don't have to figure out all the infix notation and associativity myself</p>



<a name="285469341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285469341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285469341">(Jun 09 2022 at 00:09)</a>:</h4>
<p>The syntax definition you linked looks perfect to me, so I think I just need to figure out how to turn the current assumptions and goal into that format, and how to turn an arbitrary theorem into that format</p>



<a name="285469845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285469845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285469845">(Jun 09 2022 at 00:16)</a>:</h4>
<p>No operating on the <code>Syntax</code> directly for proof generation is really not a good idea, if you want this to work on any user defined notation and properly together with the Lean compiler you want to operate on <code>Expr</code> because <code>Expr</code> is what all tactics and proof automation operates on really. The syntax tree for the above expression will look more tame but once you start getting into logic stuff blows up again big time, consider for example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="k">show</span> <span class="n">MetaM</span> <span class="n">_</span> <span class="k">from</span> <span class="k">do</span>
  <span class="bp">`</span><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="285470560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285470560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285470560">(Jun 09 2022 at 00:25)</a>:</h4>
<p>Point taken, thanks!<br>
I think I got spooked by the amount of stuff that the Nat example gave, the second one you sent is much more readable!</p>



<a name="285623519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285623519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> John Burnham <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285623519">(Jun 10 2022 at 02:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="504244">Rosie Baish</span> <a href="#narrow/stream/270676-lean4/topic/Automation/near/285467445">said</a>:</p>
<blockquote>
<p>Is there a way to get lean to dump the AST of an expression?<br>
I want to play around with some stuff in python, so ideally need the AST in some machine readable form.<br>
All implicit brackets put back in and prefix notation would work, but a more proper AST would be amazing.</p>
</blockquote>
<p>We're doing this in the Yatima project, you can take a look at our <a href="https://github.com/yatima-inc/yatima-lang/blob/main/Main.lean">https://github.com/yatima-inc/yatima-lang/blob/main/Main.lean</a> for an example of how to parse a <code>.lean</code> file to get the <code>Lean.Environment</code> that contains all the constants, expressions, etc. And <a href="https://github.com/yatima-inc/yatima-lang/blob/main/Yatima/DebugUtils.lean">https://github.com/yatima-inc/yatima-lang/blob/main/Yatima/DebugUtils.lean</a> for an example of how to print things.</p>
<p>Most of the components you need, like the Lean parser and <code>Lean.Expr</code> printer, are importable from the Lean namespace, so our stuff is mostly just gluing existing things together, but might be of interest</p>



<a name="285689229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285689229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285689229">(Jun 10 2022 at 15:09)</a>:</h4>
<p><span class="user-mention" data-user-id="432681">@John Burnham</span> Thanks</p>



<a name="285689579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285689579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285689579">(Jun 10 2022 at 15:11)</a>:</h4>
<p>I've managed to get a basic prototype working that inserts bits of proof into the file for me.<br>
However whenever it inserts it the syntax highlighting in Emacs utterly breaks.<br>
I'm assuming that the LSP server isn't being updated or something, is there a part of lean4-mode I can use to workaround this?<br>
Or do I need to get my code to paste into the buffer at point rather than do a direct insertion?</p>



<a name="285691191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285691191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285691191">(Jun 10 2022 at 15:22)</a>:</h4>
<p>You'd have to look into lsp-mode's implementation as to when it triggers an update and whether you can do that manually</p>



<a name="285691336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285691336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285691336">(Jun 10 2022 at 15:23)</a>:</h4>
<p>Note that synthesizing &amp; inserting text on the client side definitely is not a robust approach, we're aiming for syntax tree transformation on the server side. Multiple people are working on a general framework for this.</p>



<a name="285691821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285691821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285691821">(Jun 10 2022 at 15:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> Yeah, I know that what I'm doing falls into the "horrible and hacky" category :-)<br>
It's mostly just there to save me a load of typing, because I tend to go through the same few steps on every proof/case and they're highly amenable to automation!</p>



<a name="285695620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285695620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285695620">(Jun 10 2022 at 15:54)</a>:</h4>
<p>Have you considered using tactics?</p>



<a name="285767861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285767861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285767861">(Jun 11 2022 at 08:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  Yes<br>
I don't want to use tactics because of what I consider to be a major floor in the concept - they're not cacheable. (n.b. there may be a more technical term that I don't know here)<br>
Phrased another way, the complexity of generating a proof is in a different class to the complexity of checking a proof.<br>
The reason I'm using Lean is to automate proofs about a programming language semantics<br>
I therefore have a bunch of theorems which I want to prove hold for an inductive definition.<br>
However, the inductive definition is generated from my semantics, and so will change over time.<br>
Because of this, as part of my continuous integration I want to re-run all of my proofs.</p>
<p>Lets assume I have some arbitrarily complex tactic which can prove any of the theorems I want, but has a runtime measured in hours.<br>
If it's a tactic, then every time I rerun my proof (either because theres a new version of Lean, or a new version of my semantics, or any of 100 other reasons to want to re-verify) I have to take that multi-hour runtime hit for every single one of my theorems</p>
<p>On the other hand, if I have a proof generator, it will spit out a proof of how it constructed the proof, which can then be checked much faster.</p>
<p>I can then have my CI simply use lean to check the proof that it generates, which is much more efficient.<br>
If it fails, then I can go and repair the proof, either manually or automatically using the proof-generator.</p>



<a name="285768006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285768006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285768006">(Jun 11 2022 at 08:40)</a>:</h4>
<p>If a tactic had a way to "show it's working" as it were, I'd be entirely happy with them</p>



<a name="285768622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285768622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285768622">(Jun 11 2022 at 08:57)</a>:</h4>
<p>There was a similar question here: <a href="#narrow/stream/113488-general/topic/Leans.20version.20of.20.22Show.20Proof.22.3F">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Leans.20version.20of.20.22Show.20Proof.22.3F</a><br>
Maybe <code>show_term</code> would help you with what you are trying to do? I don't know it there is a Lean 4 equivalent yet, but it shouldn't be too hard to implement.</p>



<a name="285769594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285769594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285769594">(Jun 11 2022 at 09:23)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span> <br>
Do you mean do a show_term and then paste the result in as the proof?<br>
Or does lean use the output of show_term on subsequant runs?<br>
Because the latter is what I need, and modifying the source file seems like the most sensible way to acheive it</p>



<a name="285769950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285769950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285769950">(Jun 11 2022 at 09:32)</a>:</h4>
<p>No, Lean will always rerun the tactics inside <code>show_term</code> because where is Lean supposed to cache this? On the other hand, with Lean 4, I guess you could make a variant of <code>show_term</code> that caches the results in an external file.</p>



<a name="285770079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285770079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285770079">(Jun 11 2022 at 09:36)</a>:</h4>
<p>You can also use the <code>#print</code> command to print the tactic generated proof and then copy&amp;paste it back to your source code. </p>
<p>A simple example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">id</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">id</span><span class="o">]</span>

<span class="k">#print</span> <span class="n">foo</span>  <span class="c1">--- fun x =&gt; of_eq_true (eq_self x)</span>

<span class="kd">theorem</span> <span class="n">foo'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">id</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">of_eq_true</span> <span class="o">(</span><span class="n">eq_self</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="285770135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285770135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285770135">(Jun 11 2022 at 09:37)</a>:</h4>
<p>I was thinking you could use <code>show_term</code> as is, but I don't know if this is too much manual labor for your application. You could paste the output of <code>show_term</code>, but keep the <code>show_term</code> command in a comment. Whenever the proof breaks, you can uncomment to regenerate a proof term.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="bp">...</span> <span class="o">:=</span>
<span class="c">/-</span><span class="cm"> by show_term { expensive_tactic } -/</span>
<span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">=&gt;</span> <span class="bp">@</span><span class="n">explicit</span> <span class="n">proof</span> <span class="n">term</span>
</code></pre></div>



<a name="285771114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285771114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285771114">(Jun 11 2022 at 10:02)</a>:</h4>
<p>Ah, that's cool.<br>
And a lot closer to what I had in mind!</p>



<a name="285775445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285775445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285775445">(Jun 11 2022 at 11:47)</a>:</h4>
<p>Yes, caching of tactic results is an issue in general, though in this context, it sounds like mostly a theoretical (or perhaps philosophical) one.</p>



<a name="285775701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285775701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285775701">(Jun 11 2022 at 11:53)</a>:</h4>
<p>If you're just applying <code>refine</code>, <code>induction</code>, <code>constructor</code>, etc. in an easily-automated way, there's no reason to suspect that proof generation time would be large compared to proof checking time.</p>



<a name="285786829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285786829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285786829">(Jun 11 2022 at 16:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/270676-lean4/topic/Automation/near/285775701">said</a>:</p>
<blockquote>
<p>If you're just applying <code>refine</code>, <code>induction</code>, <code>constructor</code>, etc. in an easily-automated way, there's no reason to suspect that proof generation time would be large compared to proof checking time.</p>
</blockquote>
<p>That's the start, but I'm currently implementing some backtracking stuff where it keeps attempting different strategies, with a timeout option for stuff it can't do!</p>



<a name="285787389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285787389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285787389">(Jun 11 2022 at 16:37)</a>:</h4>
<p>My thought would be to have a tactic parameterized by another tactic/term (e.g., <code>cache proof</code>) that  globally loads a <code>Name</code> to proof term map for the file (e.g., from a JSON file) and then checks if the current definition is in the map. If not, elaborate <code>proof</code>. If it is in the map, try to use that term. If it fails to type check, elaborate <code>proof</code>. If <code>proof</code> is  successfully re-elaborated, save the new term for <code>prrof</code> into the map and save the whole map to back to the cache file at the end of the program.</p>



<a name="285788195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285788195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285788195">(Jun 11 2022 at 16:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Automation/near/285787389">said</a>:</p>
<blockquote>
<p>My thought would be to have a tactic parameterized by another tactic/term (e.g., <code>cache proof</code>) that  globally loads a <code>Name</code> to proof term map for the file (e.g., from a JSON file) and then checks if the current definition is in the map. If not, elaborate <code>proof</code>. If it is in the map, try to use that term. If it fails to type check, elaborate <code>proof</code>. If <code>proof</code> is  successfully re-elaborated, save the new term for <code>prrof</code> into the map and save the whole map to back to the cache file at the end of the program.</p>
</blockquote>
<p>That would be really cool<br>
How easy would that be to implement?<br>
I'd have no idea where to start!</p>



<a name="285789665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285789665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285789665">(Jun 11 2022 at 17:31)</a>:</h4>
<p>I am working on a proof of concept.  I just need to figure out how to serialize (and deserialize) expressions.</p>



<a name="285789797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285789797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285789797">(Jun 11 2022 at 17:34)</a>:</h4>
<p>The olean loader/saver should be able to do that right? Maybe look there.</p>



<a name="285789831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285789831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285789831">(Jun 11 2022 at 17:35)</a>:</h4>
<p>In general what you are describing sounds like olean but split per declaration instead of per module.</p>



<a name="285791735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285791735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285791735">(Jun 11 2022 at 18:26)</a>:</h4>
<p>A fair comparison -- oleans do store a lot more than just terms, though.</p>



<a name="285807580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285807580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285807580">(Jun 11 2022 at 23:33)</a>:</h4>
<p>Here is the main body of my PoC:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Elab.ElabRules</span>
<span class="kn">open</span> <span class="n">System</span> <span class="n">Lean</span> <span class="n">Meta</span> <span class="n">Elab</span> <span class="n">Term</span> <span class="n">Command</span>

<span class="n">initialize</span> <span class="n">termCacheExt</span> <span class="o">:</span> <span class="n">EnvExtension</span> <span class="o">(</span><span class="n">Option</span> <span class="o">(</span><span class="n">NameMap</span> <span class="n">Expr</span><span class="o">))</span> <span class="bp">←</span>
  <span class="n">registerEnvExtension</span> <span class="o">(</span><span class="n">pure</span> <span class="n">none</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">setTermCache</span> <span class="o">(</span><span class="n">cache</span> <span class="o">:</span> <span class="n">NameMap</span> <span class="n">Expr</span><span class="o">)</span>  <span class="o">:</span> <span class="n">CoreM</span> <span class="n">PUnit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">modifyEnv</span> <span class="o">(</span><span class="n">termCacheExt.setState</span> <span class="bp">·</span> <span class="n">cache</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">getTermCacheFile</span> <span class="o">:</span> <span class="n">CoreM</span> <span class="n">FilePath</span> <span class="o">:=</span>
  <span class="n">return</span> <span class="n">FilePath.mk</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getFileName</span><span class="o">)</span> <span class="bp">|&gt;.</span><span class="n">withExtension</span> <span class="s2">"json"</span>

<span class="kd">def</span> <span class="n">getTermCache</span> <span class="o">:</span> <span class="n">CoreM</span> <span class="o">(</span><span class="n">NameMap</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">if</span> <span class="k">let</span> <span class="n">some</span> <span class="n">cache</span> <span class="o">:=</span> <span class="n">termCacheExt.getState</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="k">then</span>
    <span class="n">return</span> <span class="n">cache</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">cacheFile</span> <span class="bp">←</span> <span class="n">getTermCacheFile</span>
    <span class="k">let</span> <span class="n">cache</span> <span class="bp">←</span> <span class="n">liftM</span> <span class="o">(</span><span class="n">m</span> <span class="o">:=</span> <span class="n">IO</span><span class="o">)</span> <span class="k">do</span>
      <span class="n">try</span>
        <span class="k">let</span> <span class="n">contents</span> <span class="bp">←</span> <span class="n">IO.FS.readFile</span> <span class="n">cacheFile</span>
        <span class="k">let</span> <span class="n">json</span> <span class="bp">←</span> <span class="n">IO.ofExcept</span> <span class="bp">&lt;|</span> <span class="n">Json.parse</span> <span class="n">contents</span>
        <span class="n">IO.ofExcept</span> <span class="bp">&lt;|</span> <span class="n">fromJson</span><span class="bp">?</span> <span class="n">json</span>
      <span class="n">catch</span>
      <span class="bp">|</span> <span class="n">IO.Error.noFileOrDirectory</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="o">{}</span>
      <span class="bp">|</span> <span class="n">err</span> <span class="bp">=&gt;</span> <span class="n">throw</span> <span class="n">err</span>
    <span class="n">setTermCache</span> <span class="n">cache</span>
    <span class="n">return</span> <span class="n">cache</span>

<span class="kd">def</span> <span class="n">modifyTermCache</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">NameMap</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="n">NameMap</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">CoreM</span> <span class="n">PUnit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">setTermCache</span> <span class="bp">&lt;|</span> <span class="n">f</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getTermCache</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">saveTermCache</span> <span class="o">:</span> <span class="n">CoreM</span> <span class="n">PUnit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">if</span> <span class="k">let</span> <span class="n">some</span> <span class="n">cache</span> <span class="o">:=</span> <span class="n">termCacheExt.getState</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getEnv</span><span class="o">)</span> <span class="k">then</span>
    <span class="n">IO.FS.writeFile</span> <span class="o">(</span><span class="bp">←</span> <span class="n">getTermCacheFile</span><span class="o">)</span> <span class="o">(</span><span class="n">Json.pretty</span> <span class="bp">&lt;|</span> <span class="n">toJson</span> <span class="n">cache</span><span class="o">)</span>

<span class="n">elab</span> <span class="s2">"cached_term "</span> <span class="n">key</span><span class="o">:</span><span class="n">ident</span> <span class="n">tm</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">&lt;=</span> <span class="n">expectedType</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">key.getId</span>
  <span class="k">let</span> <span class="n">cache</span> <span class="bp">←</span> <span class="n">getTermCache</span>
  <span class="k">if</span> <span class="k">let</span> <span class="n">some</span> <span class="n">exp</span> <span class="o">:=</span> <span class="n">cache.find</span><span class="bp">?</span> <span class="n">id</span> <span class="k">then</span>
    <span class="k">let</span> <span class="n">ty</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">exp</span>
    <span class="k">if</span> <span class="o">(</span><span class="bp">←</span> <span class="n">isDefEq</span> <span class="n">ty</span> <span class="n">expectedType</span><span class="o">)</span> <span class="k">then</span>
      <span class="n">return</span> <span class="n">exp</span>
  <span class="k">let</span> <span class="n">exp</span> <span class="bp">←</span> <span class="n">elabTermAndSynthesize</span> <span class="n">tm</span> <span class="n">expectedType</span>
  <span class="n">modifyTermCache</span> <span class="o">(</span><span class="bp">·.</span><span class="n">insert</span> <span class="n">id</span> <span class="n">exp</span><span class="o">)</span>
  <span class="n">return</span> <span class="n">exp</span>

<span class="n">elab</span> <span class="s2">"save_term_cache"</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">=&gt;</span>
  <span class="n">liftCoreM</span> <span class="n">saveTermCache</span>
</code></pre></div>
<p>The JSON serialization of <code>Expr</code> is not efficient and it does not work for auto-generated names, but it was quick and dirty solution in the my absence of knowing the proper way to serialize expressions. I am also not sure how to register <code>save_term_cache</code> to run at the end of elaboration so right now it has to be done manually. However, I think the code serves as a decent demonstrate of how this could be done.</p>



<a name="285808303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285808303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rosie Baish <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285808303">(Jun 11 2022 at 23:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Automation/near/285807580">said</a>:</p>
<blockquote>
<p>Here is the main body of my PoC:</p>
</blockquote>
<p>Here is my somewhat hacky python stuff, very much in a pre-alpha state for now:<br>
<a href="https://github.com/RosieBaish/lean_auto_mode">https://github.com/RosieBaish/lean_auto_mode</a><br>
You pass it the output of the "Lean Goals" buffer in emacs either in a file or stdin an it prints out it's best effort at a proof.</p>



<a name="285841972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285841972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285841972">(Jun 12 2022 at 13:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Automation/near/285787389">said</a>:</p>
<blockquote>
<p>My thought would be to have a tactic parameterized by another tactic/term (e.g., <code>cache proof</code>) that  globally loads a <code>Name</code> to proof term map for the file (e.g., from a JSON file) and then checks if the current definition is in the map. If not, elaborate <code>proof</code>. If it is in the map, try to use that term. If it fails to type check, elaborate <code>proof</code>. If <code>proof</code> is  successfully re-elaborated, save the new term for <code>prrof</code> into the map and save the whole map to back to the cache file at the end of the program.</p>
</blockquote>
<p>One issue with this approach is that you won't notice the proof is broken until the cached proof breaks as well. Which means you lose reproducibility unless you check in the cache as well, with all the usual downsides of generated files in git such as fun merge conflicts. But it might not be the end of the world.</p>



<a name="285846475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Automation/near/285846475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Automation.html#285846475">(Jun 12 2022 at 14:51)</a>:</h4>
<p>(deleted)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/termination.20by.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html">termination by</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272062195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272062195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272062195">(Feb 16 2022 at 01:16)</a>:</h4>
<p>i need a termination by but i dont really know how they work. i need it for this function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">xs</span><span class="o">,</span> <span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xss</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">allPairsAux</span> <span class="n">xss</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">yss</span> <span class="bp">=&gt;</span> <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">yss</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span>
</code></pre></div>



<a name="272063025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063025">(Feb 16 2022 at 01:28)</a>:</h4>
<p>I think this is actually kind of an advanced example because it's not on one argument:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xss</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xss</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">yss</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">yss.length</span> <span class="bp">&lt;</span> <span class="n">yss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">yss</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span>
  <span class="n">termination_by</span> <span class="n">_</span> <span class="n">_</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span>
</code></pre></div>



<a name="272063326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063326">(Feb 16 2022 at 01:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="228466">Chris B</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272063025">said</a>:</p>
<blockquote>
<p>I think this is actually kind of an advanced example because it's not on one argument:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xss</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xss</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">yss</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">yss.length</span> <span class="bp">&lt;</span> <span class="n">yss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">yss</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span>
  <span class="n">termination_by</span> <span class="n">_</span> <span class="n">_</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span>
</code></pre></div><br>
</p>
</blockquote>
<p>how is the termination by working there? and why are the <code>have</code>s nessacery?</p>



<a name="272063531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063531">(Feb 16 2022 at 01:36)</a>:</h4>
<p>They're not strictly necessary, the syntax for termination hints allows for a <code>decreasing_by &lt;tactic proof&gt;</code>clause to discharge the proof obligations, but I think <code>decreasing_by</code> has issues when more than one branch produces a unique obligation. But in any case you have to show that something being passed as an argument is strictly decreasing with each recursive call, where decreasing is defined in terms of some instance of <code>WellFoundedRelation</code>.</p>



<a name="272063560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063560">(Feb 16 2022 at 01:37)</a>:</h4>
<p>For each branch I think it looks in the local assumptions for a proof first, which is why the <code>have</code> thing works.</p>



<a name="272063745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063745">(Feb 16 2022 at 01:40)</a>:</h4>
<p>ah yes</p>



<a name="272063753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063753">(Feb 16 2022 at 01:41)</a>:</h4>
<p>how does the <code>by simp</code> thing work?</p>



<a name="272063830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272063830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272063830">(Feb 16 2022 at 01:42)</a>:</h4>
<p>also, what is <code>hx:xs</code> and <code>hy:ys</code>?</p>



<a name="272064127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272064127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272064127">(Feb 16 2022 at 01:47)</a>:</h4>
<p><code>hx</code> and <code>hy</code> are hypotheses. The <code>by simp</code> parts are tactic proofs, <code>simp</code> is a tactic that applies lemmas; it's applying the stuff in the brackets.</p>



<a name="272064521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272064521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272064521">(Feb 16 2022 at 01:54)</a>:</h4>
<p>Well I guess more accurately it's like syntax for a match that preserves the hypotheses in the match arms. So like in the first case you need a witness that <code>hy = []</code>.</p>



<a name="272064706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272064706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272064706">(Feb 16 2022 at 01:57)</a>:</h4>
<p>how can i debug print values in the middle of a function?</p>



<a name="272064961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272064961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272064961">(Feb 16 2022 at 02:01)</a>:</h4>
<p>Nevermind, i found it</p>



<a name="272065486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272065486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272065486">(Feb 16 2022 at 02:09)</a>:</h4>
<p>i do have a question about my function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum.reverse</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">ys.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span>
</code></pre></div>
<p>lets say i input <code>['a', 'b'] [1, 2, 3] []</code>. Here is how the iterations should go:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[]</span>
<span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span>
<span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span>
<span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span>
<span class="o">[</span><span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span> <span class="c1">-- this is what it should turn into, because it matches at the second case, but for some reason this is not happening</span>
<span class="c1">-- same process</span>
</code></pre></div>
<p>this is the output: <code>[("a", 1), ("a", 2), ("a", 3)]</code></p>
<p>i wish there was a way i could debug and print the values</p>



<a name="272065570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272065570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272065570">(Feb 16 2022 at 02:10)</a>:</h4>
<p>do you have an idea why this could be happening <span class="user-mention" data-user-id="228466">@Chris B</span> ?</p>



<a name="272065989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272065989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272065989">(Feb 16 2022 at 02:18)</a>:</h4>
<p>Because the version you just posted is now explicitly reversing the list in the nil/nil case.</p>



<a name="272066330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272066330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272066330">(Feb 16 2022 at 02:24)</a>:</h4>
<p>What do you expect <code>allPairsAux ['a', 'b'] [] [('a', 3), ('a', 2), ('a', 1)]</code> to be?</p>



<a name="272067049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272067049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272067049">(Feb 16 2022 at 02:37)</a>:</h4>
<p>well it shouldn't return accum.reverse since it doesnt match the [] [] case</p>



<a name="272067301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272067301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272067301">(Feb 16 2022 at 02:42)</a>:</h4>
<p>why is it matching on that then <span class="user-mention" data-user-id="228466">@Chris B</span></p>



<a name="272067944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272067944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272067944">(Feb 16 2022 at 02:54)</a>:</h4>
<p>It isn't matching the [] [] case.</p>



<a name="272068337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272068337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272068337">(Feb 16 2022 at 03:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xss</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xss</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">yss</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">yss.length</span> <span class="bp">&lt;</span> <span class="n">yss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">yss</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span>
  <span class="n">termination_by</span> <span class="n">_</span> <span class="n">_</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span>

<span class="c1">-- [('a', 3), ('a', 2), ('a', 1)]</span>
<span class="k">#eval</span> <span class="n">allPairsAux</span> <span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[]</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum.reverse</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xss</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xss</span> <span class="n">ys</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">yss</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">yss.length</span> <span class="bp">&lt;</span> <span class="n">yss.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">yss</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span>
  <span class="n">termination_by</span> <span class="n">_</span> <span class="n">_</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span>

<span class="c1">-- [('a', 1), ('a', 2), ('a', 3)]</span>
<span class="k">#eval</span> <span class="n">allPairsAux</span> <span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[]</span>
</code></pre></div>



<a name="272068413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272068413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272068413">(Feb 16 2022 at 03:02)</a>:</h4>
<p>The only thing I changed is the <code>accum.reverse</code> in the nil/nil case.</p>



<a name="272069034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272069034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272069034">(Feb 16 2022 at 03:15)</a>:</h4>
<p>Yes, but that is not the output i am looking for</p>



<a name="272069095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272069095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272069095">(Feb 16 2022 at 03:16)</a>:</h4>
<p>What i meant here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[]</span>
<span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span>
<span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span>
<span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span> <span class="o">[]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span>
<span class="o">[</span><span class="sc">'b'</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">[(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">1</span><span class="o">)]</span> <span class="c1">-- this is what it should turn into, because it matches at the second case, but for some reason this is not happening</span>
<span class="c1">-- same process</span>
</code></pre></div>
<p>Is not the output, but it what allPairsAux should be taking as its arguments on its next iteration</p>



<a name="272069137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272069137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272069137">(Feb 16 2022 at 03:17)</a>:</h4>
<p>The output should actually be </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[(</span><span class="bp">“</span><span class="n">a</span><span class="bp">”</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="bp">“</span><span class="n">a</span><span class="bp">”</span><span class="o">,</span>  <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="bp">“</span><span class="n">a</span><span class="bp">”</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span>  <span class="o">(</span><span class="bp">“</span><span class="n">b</span><span class="bp">”</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="bp">“</span><span class="n">b</span><span class="bp">”</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="bp">“</span><span class="n">b</span><span class="bp">”</span><span class="o">,</span> <span class="mi">3</span><span class="o">)]</span>
</code></pre></div>
<p>Sorry for not making myself clear</p>



<a name="272070015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272070015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272070015">(Feb 16 2022 at 03:34)</a>:</h4>
<p>That's just not the function you wrote, I don't know what to tell you.  In the case that <code>ys</code> is empty and <code>xs</code> is not, you're calling the function recursively with the tail of <code>xs</code> and the empty list.</p>



<a name="272070026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272070026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272070026">(Feb 16 2022 at 03:34)</a>:</h4>
<p>But you seem to expect <code>ys</code> to become <code>[1, 2, 3]</code> again.</p>



<a name="272070280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272070280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272070280">(Feb 16 2022 at 03:40)</a>:</h4>
<p>I think it's easier if you write an auxiliary function that receives <code>a : α</code> and <code>l : List β</code> and then returns something of type <code>List (α × β)</code>. Such that the return of <code>2</code> and <code>["a", "b", "c"]</code> is <code>[(2, "a"), (2, "b"), (2, "c")]</code>.</p>
<p>Then you can do a <code>foldl</code> on a <code>List α</code> using your function</p>



<a name="272070628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272070628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272070628">(Feb 16 2022 at 03:49)</a>:</h4>
<p>Unless, of course, you want to go through the exercise of building a standalone function. Then you can ignore my idea</p>



<a name="272109465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272109465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272109465">(Feb 16 2022 at 12:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272070280">said</a>:</p>
<blockquote>
<p>I think it's easier if you write an auxiliary function that receives <code>a : α</code> and <code>l : List β</code> and then returns something of type <code>List (α × β)</code>. Such that the return of <code>2</code> and <code>["a", "b", "c"]</code> is <code>[(2, "a"), (2, "b"), (2, "c")]</code>.</p>
<p>Then you can do a <code>foldl</code> on a <code>List α</code> using your function</p>
</blockquote>
<p>An auxiliary function for my auxiliary function?</p>



<a name="272109562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272109562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272109562">(Feb 16 2022 at 12:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="228466">Chris B</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272070015">said</a>:</p>
<blockquote>
<p>That's just not the function you wrote, I don't know what to tell you.  In the case that <code>ys</code> is empty and <code>xs</code> is not, you're calling the function recursively with the tail of <code>xs</code> and the empty list.</p>
</blockquote>
<p>I wanted it to reset to the original ys</p>



<a name="272109612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272109612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272109612">(Feb 16 2022 at 12:34)</a>:</h4>
<p>that would solve the whole problem</p>



<a name="272109684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272109684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272109684">(Feb 16 2022 at 12:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272070280">said</a>:</p>
<blockquote>
<p>I think it's easier if you write an auxiliary function that receives <code>a : α</code> and <code>l : List β</code> and then returns something of type <code>List (α × β)</code>. Such that the return of <code>2</code> and <code>["a", "b", "c"]</code> is <code>[(2, "a"), (2, "b"), (2, "c")]</code>.</p>
<p>Then you can do a <code>foldl</code> on a <code>List α</code> using your function</p>
</blockquote>
<p>Why would I want to use fold? Doesn’t fold turn a sequence into a value</p>



<a name="272109808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272109808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272109808">(Feb 16 2022 at 12:36)</a>:</h4>
<p>if I could hold the original values somewhere</p>



<a name="272111497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272111497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272111497">(Feb 16 2022 at 12:53)</a>:</h4>
<p>That "value" can be another sequence.</p>



<a name="272112017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272112017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272112017">(Feb 16 2022 at 12:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272111497">said</a>:</p>
<blockquote>
<p>That "value" can be another sequence.</p>
</blockquote>
<p>And that sequence holds the original two lists?</p>



<a name="272112800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272112800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272112800">(Feb 16 2022 at 13:07)</a>:</h4>
<p>You can build up a tuple as an aux function, and use prod.snd to get your final value. Check out accumulators in Haskell too.</p>



<a name="272112811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272112811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272112811">(Feb 16 2022 at 13:07)</a>:</h4>
<p>i tried using a Product, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">origs</span><span class="o">:</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">List</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">origs.2</span><span class="o">)</span> <span class="n">accum</span> <span class="n">origs</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">ys.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">origs.1</span><span class="o">)</span> <span class="n">ys</span> <span class="n">accum</span> <span class="n">origs</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span> <span class="n">origs</span>
</code></pre></div>
<p>but i get the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="bp">'</span><span class="n">assumption'</span> <span class="n">failed</span><span class="o">,</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span>
<span class="n">xs</span><span class="bp">✝</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span>
<span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span>
<span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
<span class="n">origs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">List</span> <span class="n">β</span>
<span class="n">x</span><span class="bp">✝</span> <span class="o">:</span> <span class="n">α</span>
<span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span>
<span class="n">hx</span> <span class="o">:</span> <span class="n">xs</span><span class="bp">✝</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">✝</span> <span class="o">::</span> <span class="n">xs</span>
<span class="n">hy</span> <span class="o">:</span> <span class="n">ys</span> <span class="bp">=</span> <span class="o">[]</span>
<span class="n">h0</span> <span class="o">:</span> <span class="n">List.length</span> <span class="n">xs</span> <span class="bp">+</span> <span class="n">List.length</span> <span class="n">ys</span> <span class="bp">&lt;</span> <span class="n">List.length</span> <span class="n">xs</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">⊢</span> <span class="n">List.length</span> <span class="n">origs.snd</span> <span class="bp">+</span> <span class="n">List.length</span> <span class="n">accum</span> <span class="bp">&lt;</span> <span class="n">List.length</span> <span class="n">accum</span>
</code></pre></div>
<p>its pretty weird in my opinion</p>



<a name="272113338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272113338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272113338">(Feb 16 2022 at 13:12)</a>:</h4>
<p>What could have cuased the assumption to fail?</p>



<a name="272116269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272116269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272116269">(Feb 16 2022 at 13:38)</a>:</h4>
<p>well, it's definitely <em>not</em> true that <code>List.length origs.snd + List.length accum &lt; List.length accum</code>, right?</p>



<a name="272116419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272116419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272116419">(Feb 16 2022 at 13:40)</a>:</h4>
<p>I suggest you start out with a <code>partial def</code> so you can make sure the definition is correct first without worrying about termination</p>



<a name="272116428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272116428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272116428">(Feb 16 2022 at 13:40)</a>:</h4>
<p>I have to prove that too?</p>



<a name="272116437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272116437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272116437">(Feb 16 2022 at 13:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272116419">said</a>:</p>
<blockquote>
<p>I suggest you start out with a <code>partial def</code> so you can make sure the definition is correct first without worrying about termination</p>
</blockquote>
<p>ok</p>



<a name="272116498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272116498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272116498">(Feb 16 2022 at 13:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272116269">said</a>:</p>
<blockquote>
<p>well, it's definitely <em>not</em> true that <code>List.length origs.snd + List.length accum &lt; List.length accum</code>, right?</p>
</blockquote>
<p>where can i use that?</p>



<a name="272119884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272119884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272119884">(Feb 16 2022 at 14:07)</a>:</h4>
<p>Any ideas???</p>



<a name="272123002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272123002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272123002">(Feb 16 2022 at 14:31)</a>:</h4>
<p>The last version you posted does not terminate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">origs</span><span class="o">:</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">List</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">origs.2</span><span class="o">)</span> <span class="n">accum</span> <span class="n">origs</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">ys.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">origs.1</span><span class="o">)</span> <span class="n">ys</span> <span class="n">accum</span> <span class="n">origs</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span> <span class="n">origs</span>

<span class="k">#eval</span> <span class="n">allPairsAux</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">([</span><span class="mi">1</span><span class="o">],[</span><span class="mi">1</span><span class="o">])</span>  <span class="c1">-- Does not terminate.</span>
</code></pre></div>
<p>Reid is right. Try to add <code>partial</code> like I did here and test the function using <code>#eval</code> until it does what you want it to do. Then you can attempt to prove termination.</p>



<a name="272126669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272126669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272126669">(Feb 16 2022 at 14:59)</a>:</h4>
<p>i tried this but its the same thign</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">origs</span><span class="o">:</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">List</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">hx</span><span class="o">:</span><span class="n">xs</span><span class="o">,</span> <span class="n">hy</span><span class="o">:</span><span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">accum</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="n">xs</span> <span class="o">(</span><span class="n">origs.snd</span><span class="o">)</span> <span class="n">accum</span> <span class="n">origs</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">_</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">xs.length</span> <span class="bp">+</span> <span class="n">ys.length</span> <span class="bp">&lt;</span> <span class="n">ys.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">Nat.lt_succ_self</span><span class="o">]</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">origs.fst</span><span class="o">)</span> <span class="n">ys</span> <span class="n">accum</span> <span class="n">origs</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span> <span class="bp">=&gt;</span>
    <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="n">ys</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)::</span><span class="n">accum</span><span class="o">)</span> <span class="n">origs</span>

<span class="n">termination_by</span> <span class="n">_</span> <span class="n">_</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">accum</span> <span class="n">origs</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">origs.snd</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">+</span> <span class="n">accum.length</span> <span class="bp">&lt;</span> <span class="n">accum.length</span>
</code></pre></div>



<a name="272126748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272126748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272126748">(Feb 16 2022 at 14:59)</a>:</h4>
<p>EDIT: fixed</p>



<a name="272127076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272127076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272127076">(Feb 16 2022 at 15:01)</a>:</h4>
<p>Isn't your server dead? CTRL+SHIFT+X sometimes brings it back to life</p>



<a name="272127154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272127154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272127154">(Feb 16 2022 at 15:02)</a>:</h4>
<p>It was because I was evalutating a function that didnt terminate</p>



<a name="272127252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272127252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272127252">(Feb 16 2022 at 15:02)</a>:</h4>
<p>something keeps crashing vscode though</p>



<a name="272127326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272127326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272127326">(Feb 16 2022 at 15:03)</a>:</h4>
<p>and I really dont know how to fix the termination. Im going to admit it</p>



<a name="272127471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272127471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272127471">(Feb 16 2022 at 15:04)</a>:</h4>
<p>Here's my attempt at it (at least of what I think you are trying to define):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairs</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">xs.bind</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">ys.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>
</code></pre></div>



<a name="272129332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272129332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272129332">(Feb 16 2022 at 15:19)</a>:</h4>
<p>Ah you used map. My goal was ultimately to use functions like map and fold as little as possible. But you know, its much esier. Also, what does xs.bind do?</p>



<a name="272129641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272129641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272129641">(Feb 16 2022 at 15:21)</a>:</h4>
<p>I have no idea how the code you wrote works</p>



<a name="272130951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272130951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272130951">(Feb 16 2022 at 15:31)</a>:</h4>
<p><code>l.bind f</code> is <code>(l.map f).join</code>, where <code>join</code> flattens a list of lists</p>



<a name="272131089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272131089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272131089">(Feb 16 2022 at 15:32)</a>:</h4>
<p>that is, you apply the function to each element of the list, and then concatenate all the resulting lists (the function returns a list for each element)</p>



<a name="272132030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272132030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272132030">(Feb 16 2022 at 15:38)</a>:</h4>
<p>Maybe it's easier to understand if I write it using two auxiliary definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">attach</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ys.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">attach</span> <span class="mi">2</span> <span class="o">[</span><span class="s2">"a"</span><span class="o">,</span><span class="s2">"b"</span><span class="o">,</span><span class="s2">"c"</span><span class="o">]</span>
<span class="c1">-- [(2, "a"), (2, "b"), (2, "c")]</span>

<span class="kd">def</span> <span class="n">allPairsAux</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">:=</span> <span class="n">xs.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">attach</span> <span class="n">x</span> <span class="n">ys</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">allPairsAux</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="s2">"a"</span><span class="o">,</span><span class="s2">"b"</span><span class="o">,</span><span class="s2">"c"</span><span class="o">]</span>
<span class="c1">-- [[(1, "a"), (1, "b"), (1, "c")], [(2, "a"), (2, "b"), (2, "c")], [(3, "a"), (3, "b"), (3, "c")]]</span>

<span class="kd">def</span> <span class="n">allPairs</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">allPairsAux</span> <span class="n">xs</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">join</span>

<span class="k">#eval</span> <span class="n">allPairs</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="s2">"a"</span><span class="o">,</span><span class="s2">"b"</span><span class="o">,</span><span class="s2">"c"</span><span class="o">]</span>
<span class="c1">-- [(1, "a"), (1, "b"), (1, "c"), (2, "a"), (2, "b"), (2, "c"), (3, "a"), (3, "b"), (3, "c")]</span>
</code></pre></div>



<a name="272132098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272132098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272132098">(Feb 16 2022 at 15:39)</a>:</h4>
<p>Here's a version using only primitive operations on list:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairs</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">rec</span> <span class="n">aux</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">ys</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">rec</span> <span class="n">aux₂</span>
    <span class="bp">|</span> <span class="o">[],</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r</span>
    <span class="bp">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">::</span> <span class="n">r</span>
    <span class="n">aux₂</span> <span class="n">ys</span> <span class="o">(</span><span class="n">aux</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">r</span><span class="o">)</span>
  <span class="n">aux</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">[]</span>
</code></pre></div>



<a name="272132285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272132285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272132285">(Feb 16 2022 at 15:40)</a>:</h4>
<p>Here's another version that should work but causes a kernel type check error (cc: <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairs</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">rec</span> <span class="n">aux</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">rec</span> <span class="n">aux₂</span>
    <span class="bp">|</span> <span class="o">[],</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r</span>
    <span class="bp">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">::</span> <span class="n">r</span>
    <span class="n">aux₂</span> <span class="n">ys</span> <span class="o">(</span><span class="n">aux</span> <span class="n">xs</span> <span class="n">r</span><span class="o">)</span>
  <span class="n">aux</span> <span class="n">xs</span> <span class="o">[]</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">(</span><span class="n">kernel</span><span class="o">)</span> <span class="n">declaration</span> <span class="n">has</span> <span class="n">free</span> <span class="kd">variables</span> <span class="bp">'</span><span class="n">allPairs.aux'</span>
</code></pre></div>



<a name="272132605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272132605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272132605">(Feb 16 2022 at 15:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272132285">said</a>:</p>
<blockquote>
<p>Here's another version that should work but causes a kernel type check error (cc: <span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">allPairs</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">rec</span> <span class="n">aux</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">rec</span> <span class="n">aux₂</span>
    <span class="bp">|</span> <span class="o">[],</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r</span>
    <span class="bp">|</span> <span class="n">y</span><span class="o">::</span><span class="n">ys</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">::</span> <span class="n">r</span>
    <span class="n">aux₂</span> <span class="n">ys</span> <span class="o">(</span><span class="n">aux</span> <span class="n">xs</span> <span class="n">r</span><span class="o">)</span>
  <span class="n">aux</span> <span class="n">xs</span> <span class="o">[]</span>
</code></pre></div>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">(</span><span class="n">kernel</span><span class="o">)</span> <span class="n">declaration</span> <span class="n">has</span> <span class="n">free</span> <span class="kd">variables</span> <span class="bp">'</span><span class="n">allPairs.aux'</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Thanks for reporting the issue. I will take a look.</p>



<a name="272132801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272132801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272132801">(Feb 16 2022 at 15:44)</a>:</h4>
<p>I love it when bugs are found by casually playing with a system</p>



<a name="272132924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272132924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272132924">(Feb 16 2022 at 15:45)</a>:</h4>
<p>I think they call it "<a href="https://en.wikipedia.org/wiki/Monkey_testing">monkey testing</a>"</p>



<a name="272133257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272133257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272133257">(Feb 16 2022 at 15:47)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/issues/1020">https://github.com/leanprover/lean4/issues/1020</a></p>



<a name="272133727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272133727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272133727">(Feb 16 2022 at 15:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/termination.20by/near/272132924">said</a>:</p>
<blockquote>
<p>I think they call it "<a href="https://en.wikipedia.org/wiki/Monkey_testing">monkey testing</a>"</p>
</blockquote>
<p>I knew that terminology for random tests equipped with brutally fast inputs (easily applicable for testing apps with GUIs). Which makes me wonder if it's possible to apply this technique to attack the Lean kernel in various ways in search for bugs like this</p>



<a name="272133977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272133977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272133977">(Feb 16 2022 at 15:52)</a>:</h4>
<p>that sounds more like fuzz testing (which would probably work fairly well against the lean kernel)</p>



<a name="272142681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/termination%20by/near/272142681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/termination.20by.html#272142681">(Feb 16 2022 at 16:50)</a>:</h4>
<p>Thanks everyone</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
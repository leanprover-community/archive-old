---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html">Simplifications in proofs/type-checking not happening; wh...</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="255048495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255048495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255048495">(Sep 27 2021 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="266304">@Siddhartha Gadgil</span> We would be very grateful if you could create a self-contained example that exposes the issue you are experiencing. <br>
<a href="https://leanprover-community.github.io/mwe.html">https://leanprover-community.github.io/mwe.html</a></p>



<a name="255048973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255048973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255048973">(Sep 27 2021 at 13:37)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> Thanks. I will work on it.</p>



<a name="255056699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255056699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255056699">(Sep 27 2021 at 14:25)</a>:</h4>
<p>Am I correct that <code>whnf</code> for an (indexed) inductive type should give one of the constructors applied to arguments?</p>



<a name="255170040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255170040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255170040">(Sep 28 2021 at 06:53)</a>:</h4>
<p>I am struggling to minimize the example though I have made many simplifications. It seems to be a depth of recursion with matching issue. Concretely, I have the following situation.</p>
<ul>
<li>A function <code>solveSAT</code>returns something with an example input which gives problems (in a sense that I elaborate later). </li>
<li><code>solveSAT</code> is recursive, in fact calls itself twice.</li>
<li>If I define a function <code>solveSATOuter</code> by copying the code of <code>solveSAT</code>, so this calls <code>solveSAT</code> instead of  itself with the same example input, what is returned is fine.</li>
<li>If even one of the calls to <code>solveSAT</code> in <code>solveSatOuter</code> is replaced by a recursive call to <code>solveSatOuter</code>, the problems resurface.</li>
</ul>
<p>Here by <em>problems</em> I mean two things.</p>
<ul>
<li>the type of a term is not simplified (which it was upto the nightly build on September 19, 2021).</li>
<li>when computing <code>whnf</code> (as I sketched above) stuff crashes.</li>
</ul>
<p>As far as I can see, there is no reason <code>solveSAT</code> and <code>solveSATOuter</code> should behave differently as far as the first issue goes at least.</p>
<p>I welcome any suggestions on how to further minimize (the source for the stuff mentioned above is <a href="http://on%20github">https://github.com/siddhartha-gadgil/Saturn/blob/whnf-crash/Saturn/WhnfMwe2.lean</a>). </p>
<p>I will also keep trying to minimize.</p>
<p>Thanks.</p>



<a name="255188744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255188744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255188744">(Sep 28 2021 at 09:44)</a>:</h4>
<p>The apparent bug shows up in the following code (about 200 lines, no dependancies). As I comment, making a tiny change (replacing <code>cls</code> by <code>clauses</code>, in a context with the statement <code>let cls := clauses</code>) causes the error to disappear.</p>
<p>I am posting this below for feedback before posting an issue. This is with nigthtly version 2021-09-20 (and presumably all later ones)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Meta</span>
<span class="kn">open</span> <span class="n">Nat</span>

<span class="kd">structure</span> <span class="n">ProvedSkip</span><span class="o">(</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">result</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">lt</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">result</span> <span class="bp">=</span> <span class="n">m</span>
  <span class="n">ge</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">result</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">provedSkip</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ProvedSkip</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">c</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span>
    <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="o">,</span> <span class="k">fun</span> <span class="n">hyp</span> <span class="bp">=&gt;</span> <span class="n">False.elim</span> <span class="o">(</span><span class="n">Nat.lt_irrefl</span> <span class="n">m</span> <span class="o">(</span><span class="n">Nat.lt_of_lt_of_le</span> <span class="n">c</span> <span class="n">hyp</span><span class="o">))⟩</span>
  <span class="k">else</span>
    <span class="o">⟨</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">fun</span> <span class="n">hyp</span> <span class="bp">=&gt;</span> <span class="n">absurd</span> <span class="n">hyp</span> <span class="n">c</span><span class="o">,</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">skip</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">provedSkip</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">result</span>

<span class="kd">theorem</span> <span class="n">skip_below_eq</span><span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">skip</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">hyp</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">provedSkip</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">hyp</span>

<span class="kd">theorem</span> <span class="n">skip_above_eq</span><span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">skip</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">hyp</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">provedSkip</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">ge</span> <span class="n">hyp</span>

<span class="kd">theorem</span> <span class="n">skip_not_below_eq</span><span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Not</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">skip</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">hyp</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">lem</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="o">:=</span>
      <span class="k">match</span> <span class="n">Nat.lt_or_ge</span> <span class="n">m</span> <span class="n">n</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">Or.inl</span> <span class="n">lt</span> <span class="bp">=&gt;</span> <span class="n">absurd</span> <span class="n">lt</span> <span class="n">hyp</span>
      <span class="bp">|</span> <span class="n">Or.inr</span> <span class="n">ge</span> <span class="bp">=&gt;</span> <span class="n">ge</span>
    <span class="n">skip_above_eq</span> <span class="n">n</span> <span class="n">m</span> <span class="n">lem</span>

<span class="kd">theorem</span> <span class="n">skip_lt</span><span class="o">:</span> <span class="o">(</span><span class="n">k</span> <span class="n">j</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">skip</span> <span class="n">k</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">+</span> <span class="mi">2</span> <span class="o">:=</span>
    <span class="k">fun</span> <span class="n">k</span> <span class="n">j</span> <span class="bp">=&gt;</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="k">then</span>
        <span class="k">let</span> <span class="n">eqn</span> <span class="o">:=</span> <span class="n">skip_below_eq</span> <span class="n">k</span> <span class="n">j</span> <span class="n">c</span>
        <span class="kd">by</span>
          <span class="n">rw</span> <span class="o">[</span><span class="n">eqn</span><span class="o">]</span>
          <span class="n">apply</span> <span class="n">Nat.le_step</span>
          <span class="n">apply</span> <span class="n">Nat.le_refl</span>
          <span class="n">done</span>
      <span class="k">else</span>
        <span class="k">let</span> <span class="n">eqn</span> <span class="o">:=</span> <span class="n">skip_not_below_eq</span> <span class="n">k</span> <span class="n">j</span> <span class="n">c</span>
        <span class="kd">by</span>
          <span class="n">rw</span> <span class="o">[</span><span class="n">eqn</span><span class="o">]</span>
          <span class="n">apply</span> <span class="n">Nat.le_refl</span>
          <span class="n">done</span>

<span class="kd">theorem</span> <span class="n">skip_le_succ</span> <span class="o">{</span><span class="n">n</span> <span class="n">k</span> <span class="n">j</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">skip</span> <span class="n">k</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
   <span class="kd">by</span>
    <span class="n">intro</span> <span class="n">hyp</span>
    <span class="n">apply</span> <span class="n">Nat.le_trans</span> <span class="o">(</span><span class="n">skip_lt</span> <span class="n">k</span> <span class="n">j</span><span class="o">)</span>
    <span class="n">apply</span> <span class="n">Nat.succ_lt_succ</span>
    <span class="n">exact</span> <span class="n">hyp</span>

<span class="kd">def</span> <span class="n">FinSeq</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">theorem</span> <span class="n">witness_independent</span><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">seq</span><span class="o">:</span> <span class="n">FinSeq</span> <span class="n">n</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span><span class="bp">→</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">iw</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">jw</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span>
        <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">seq</span> <span class="n">i</span> <span class="n">iw</span> <span class="bp">=</span> <span class="n">seq</span> <span class="n">j</span> <span class="n">jw</span> <span class="o">:=</span>
        <span class="k">fun</span> <span class="n">i</span> <span class="n">j</span> <span class="n">iw</span> <span class="n">jw</span> <span class="n">eqn</span> <span class="bp">=&gt;</span>
          <span class="k">match</span> <span class="n">j</span><span class="o">,</span> <span class="n">eqn</span><span class="o">,</span> <span class="n">jw</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">ijw</span> <span class="bp">=&gt;</span>
               <span class="n">rfl</span>

<span class="kn">namespace</span> <span class="n">FinSeq</span>
<span class="kd">def</span> <span class="n">init</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">seq</span> <span class="o">:</span> <span class="n">FinSeq</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">α</span><span class="o">):</span> <span class="n">FinSeq</span> <span class="n">n</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">k</span> <span class="n">w</span> <span class="bp">=&gt;</span>
      <span class="n">seq</span> <span class="n">k</span> <span class="o">(</span><span class="n">Nat.le_step</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">last</span><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">seq</span> <span class="o">:</span> <span class="n">FinSeq</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">α</span><span class="o">):</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">seq</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.le_refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">delete</span><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">k</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">kw</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">seq</span> <span class="o">:</span> <span class="n">FinSeq</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">α</span><span class="o">):</span> <span class="n">FinSeq</span> <span class="n">n</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">j</span> <span class="n">w</span> <span class="bp">=&gt;</span>
    <span class="n">seq</span> <span class="o">(</span><span class="n">skip</span> <span class="n">k</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">skip_le_succ</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">FinSeq</span>

<span class="kd">inductive</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">cons</span><span class="o">{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">head</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tail</span><span class="o">:</span> <span class="n">Vector</span>  <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span>  <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">infixr</span><span class="o">:</span><span class="mi">66</span> <span class="s2">"+:"</span> <span class="bp">=&gt;</span> <span class="n">Vector.cons</span>

<span class="kn">open</span> <span class="n">Vector</span>

<span class="kd">def</span> <span class="n">Vector.coords</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">v</span><span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">FinSeq</span> <span class="n">n</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">j</span> <span class="n">jw</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">n</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">jw</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="n">zero</span><span class="o">),</span> <span class="n">nil</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">lt</span> <span class="bp">=&gt;</span> <span class="n">nomatch</span> <span class="n">lt</span>
  <span class="bp">|</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cons</span> <span class="n">head</span> <span class="n">tail</span><span class="o">,</span> <span class="n">zero</span><span class="o">,</span> <span class="n">lt</span> <span class="bp">=&gt;</span> <span class="n">head</span>
  <span class="bp">|</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">cons</span> <span class="n">head</span> <span class="n">tail</span><span class="o">,</span> <span class="n">j</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">w</span> <span class="bp">=&gt;</span>  <span class="n">tail.coords</span> <span class="n">j</span> <span class="o">(</span><span class="n">Nat.le_of_succ_le_succ</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">seqVecAux</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span> <span class="n">m</span> <span class="n">l</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}:</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span> <span class="bp">→</span>
    <span class="o">(</span><span class="n">seq1</span> <span class="o">:</span> <span class="n">FinSeq</span> <span class="n">n</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">accum</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span>
       <span class="n">Vector</span> <span class="n">α</span> <span class="n">l</span><span class="o">:=</span>
    <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">seq2</span> <span class="bp">=&gt;</span>
      <span class="kd">by</span>
        <span class="k">have</span> <span class="n">ss</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
          <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">s</span><span class="o">]</span>
          <span class="n">apply</span> <span class="n">Nat.zero_add</span>
          <span class="n">done</span>
        <span class="k">have</span> <span class="n">sf</span> <span class="o">:</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">Vector</span> <span class="n">α</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
          <span class="n">rw</span> <span class="o">[</span><span class="n">ss</span><span class="o">]</span>
        <span class="n">exact</span> <span class="n">Eq.mpr</span> <span class="n">sf</span> <span class="n">seq2</span>
        <span class="n">done</span>
    <span class="bp">|</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">s</span> <span class="n">seq1</span> <span class="n">seq2</span> <span class="bp">=&gt;</span>
      <span class="k">let</span> <span class="n">ss</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">+</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>  <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span>
        <span class="kd">by</span>
          <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">s</span><span class="o">]</span>
          <span class="n">rw</span> <span class="o">[(</span><span class="n">Nat.add_comm</span> <span class="n">m</span> <span class="mi">1</span><span class="o">)]</span>
          <span class="n">rw</span> <span class="o">[(</span><span class="n">Nat.add_assoc</span> <span class="n">k</span> <span class="mi">1</span> <span class="n">m</span><span class="o">)]</span>
          <span class="n">done</span>
      <span class="n">seqVecAux</span> <span class="n">ss</span> <span class="o">(</span><span class="n">seq1.init</span><span class="o">)</span> <span class="o">((</span><span class="n">seq1.last</span><span class="o">)</span> <span class="bp">+</span><span class="o">:</span> <span class="n">seq2</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">FinSeq.vec</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}{</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">FinSeq</span> <span class="n">n</span> <span class="n">α</span>  <span class="bp">→</span>  <span class="n">Vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span>
    <span class="k">fun</span> <span class="n">seq</span> <span class="bp">=&gt;</span> <span class="n">seqVecAux</span> <span class="o">(</span><span class="n">Nat.add_zero</span> <span class="n">n</span><span class="o">)</span> <span class="n">seq</span> <span class="n">Vector.nil</span>

<span class="kd">def</span> <span class="n">Clause</span><span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">Option</span> <span class="n">Bool</span><span class="o">)</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">Valuation</span><span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Vector</span> <span class="n">Bool</span> <span class="n">n</span>

<span class="kd">inductive</span> <span class="n">SatAnswer</span><span class="o">{</span><span class="n">dom</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">clauses</span> <span class="o">:</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">Clause</span> <span class="n">n</span><span class="o">)</span> <span class="n">dom</span><span class="o">)</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">unsat</span> <span class="o">:</span> <span class="n">SatAnswer</span> <span class="n">clauses</span>
  <span class="bp">|</span> <span class="n">sat</span> <span class="o">:</span>  <span class="n">SatAnswer</span> <span class="n">clauses</span>

<span class="kd">structure</span> <span class="n">SimpleRestrictionClauses</span><span class="o">{</span><span class="n">dom</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}</span>
    <span class="o">(</span><span class="n">clauses</span><span class="o">:</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">Clause</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">dom</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">codom</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">restClauses</span> <span class="o">:</span> <span class="n">Vector</span>  <span class="o">(</span><span class="n">Clause</span> <span class="n">n</span><span class="o">)</span> <span class="n">codom</span>

<span class="kd">def</span> <span class="n">prependRes</span><span class="o">{</span><span class="n">dom</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">branch</span><span class="o">:</span> <span class="n">Bool</span><span class="o">)(</span><span class="n">focus</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)(</span><span class="n">focusLt</span> <span class="o">:</span> <span class="n">focus</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">(</span><span class="n">clauses</span><span class="o">:</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">Clause</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">dom</span><span class="o">):</span>
        <span class="o">(</span><span class="n">rd</span> <span class="o">:</span> <span class="n">SimpleRestrictionClauses</span> <span class="n">clauses</span><span class="o">)</span> <span class="bp">→</span>
           <span class="o">(</span><span class="n">head</span> <span class="o">:</span> <span class="n">Clause</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span>
        <span class="n">SimpleRestrictionClauses</span> <span class="o">(</span><span class="n">head</span> <span class="bp">+</span><span class="o">:</span> <span class="n">clauses</span><span class="o">)</span> <span class="o">:=</span>
        <span class="k">fun</span> <span class="n">rd</span>  <span class="n">head</span> <span class="bp">=&gt;</span>
          <span class="k">if</span> <span class="n">c</span> <span class="o">:</span> <span class="n">head.coords</span> <span class="n">focus</span> <span class="n">focusLt</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">branch</span> <span class="k">then</span>
            <span class="o">⟨</span><span class="n">rd.codom</span><span class="o">,</span> <span class="n">rd.restClauses</span><span class="o">⟩</span>
          <span class="k">else</span>
            <span class="o">⟨</span><span class="n">rd.codom</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">FinSeq.vec</span> <span class="o">(</span><span class="n">FinSeq.delete</span> <span class="n">focus</span> <span class="n">focusLt</span> <span class="n">head.coords</span><span class="o">))</span> <span class="bp">+</span><span class="o">:</span> <span class="n">rd.restClauses</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">restClauses</span><span class="o">{</span><span class="n">dom</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">}(</span><span class="n">branch</span><span class="o">:</span> <span class="n">Bool</span><span class="o">)(</span><span class="n">focus</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)(</span><span class="n">focusLt</span> <span class="o">:</span> <span class="n">focus</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">(</span><span class="n">clauses</span><span class="o">:</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">Clause</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">dom</span><span class="o">)</span> <span class="o">:</span>
         <span class="n">SimpleRestrictionClauses</span> <span class="n">clauses</span> <span class="o">:=</span>
            <span class="k">match</span> <span class="n">dom</span><span class="o">,</span> <span class="n">clauses</span> <span class="k">with</span>
            <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span>  <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">Vector.nil</span><span class="o">⟩</span>
            <span class="bp">|</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">Vector.cons</span> <span class="n">head</span> <span class="n">clauses</span> <span class="bp">=&gt;</span>
                <span class="n">prependRes</span> <span class="n">branch</span> <span class="n">focus</span> <span class="n">focusLt</span> <span class="n">clauses</span>
                            <span class="o">(</span><span class="n">restClauses</span> <span class="n">branch</span> <span class="n">focus</span> <span class="n">focusLt</span> <span class="n">clauses</span><span class="o">)</span> <span class="n">head</span>

<span class="kd">def</span> <span class="n">answerSAT</span><span class="o">{</span><span class="n">n</span> <span class="n">dom</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}:</span> <span class="o">(</span><span class="n">clauses</span> <span class="o">:</span> <span class="n">Vector</span> <span class="o">(</span><span class="n">Clause</span> <span class="n">n</span><span class="o">)</span> <span class="n">dom</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">SatAnswer</span> <span class="n">clauses</span> <span class="o">:=</span>
      <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
           <span class="k">match</span> <span class="n">dom</span> <span class="k">with</span>
            <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">cls</span> <span class="bp">=&gt;</span> <span class="n">SatAnswer.sat</span>
            <span class="bp">|</span> <span class="n">l</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span>  <span class="n">SatAnswer.unsat</span>
      <span class="bp">|</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span>
        <span class="k">fun</span> <span class="n">clauses</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="n">cls</span> <span class="o">:=</span> <span class="n">clauses</span>
        <span class="k">let</span> <span class="n">bd</span> <span class="o">:=</span> <span class="n">zero_lt_succ</span> <span class="n">m</span>
        <span class="k">let</span> <span class="n">rd</span>  <span class="o">:=</span>
            <span class="n">restClauses</span> <span class="n">false</span> <span class="n">zero</span> <span class="n">bd</span> <span class="n">clauses</span>
        <span class="k">let</span> <span class="n">subCls</span> <span class="o">:=</span> <span class="n">rd.restClauses</span>
        <span class="k">let</span> <span class="n">subSol</span><span class="o">:</span> <span class="n">SatAnswer</span> <span class="n">subCls</span> <span class="o">:=</span> <span class="n">answerSAT</span> <span class="n">subCls</span>
        <span class="k">match</span> <span class="n">subSol</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="n">SatAnswer.sat</span>   <span class="bp">=&gt;</span>
          <span class="n">SatAnswer.sat</span>
        <span class="bp">|</span> <span class="n">SatAnswer.unsat</span>  <span class="bp">=&gt;</span>
            <span class="k">let</span> <span class="n">rd</span> <span class="o">:=</span> <span class="n">restClauses</span> <span class="n">true</span> <span class="n">zero</span> <span class="n">bd</span> <span class="n">cls</span> <span class="c1">-- replacing cls by clauses fixes this</span>
            <span class="k">let</span> <span class="n">subCls</span> <span class="o">:=</span> <span class="n">rd.restClauses</span>
            <span class="k">let</span> <span class="n">subSol</span> <span class="o">:</span> <span class="n">SatAnswer</span> <span class="n">subCls</span> <span class="o">:=</span> <span class="n">answerSAT</span> <span class="n">subCls</span>
            <span class="k">match</span> <span class="n">subSol</span> <span class="k">with</span>
            <span class="bp">|</span> <span class="n">SatAnswer.sat</span>   <span class="bp">=&gt;</span>
                <span class="n">SatAnswer.sat</span>
            <span class="bp">|</span> <span class="n">SatAnswer.unsat</span>   <span class="bp">=&gt;</span>
                <span class="n">SatAnswer.unsat</span>

<span class="kn">open</span> <span class="n">Lean.Meta</span>
<span class="kn">open</span> <span class="n">Lean.Elab.Term</span>

<span class="n">syntax</span> <span class="o">(</span><span class="n">name</span><span class="o">:=</span> <span class="n">nrmlform</span><span class="o">)</span><span class="s2">"whnf!"</span> <span class="n">term</span> <span class="o">:</span> <span class="n">term</span>
<span class="kd">@[termElab nrmlform]</span> <span class="kd">def</span> <span class="n">normalformImpl</span> <span class="o">:</span> <span class="n">TermElab</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">stx</span> <span class="n">expectedType</span><span class="bp">?</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">stx</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">whnf</span><span class="bp">!</span> <span class="bp">$</span><span class="n">s</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">do</span>
        <span class="k">let</span> <span class="n">t</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">s</span> <span class="n">none</span>
        <span class="k">let</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">whnf</span> <span class="n">t</span>
        <span class="n">return</span> <span class="n">e</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Lean.Elab.throwIllFormedSyntax</span>


<span class="kd">def</span> <span class="n">cls1</span> <span class="o">:</span> <span class="n">Clause</span> <span class="mi">2</span> <span class="o">:=</span> <span class="c1">-- ¬P</span>
  <span class="o">(</span><span class="n">some</span> <span class="n">false</span><span class="o">)</span> <span class="bp">+</span><span class="o">:</span> <span class="o">(</span><span class="n">none</span><span class="o">)</span> <span class="bp">+</span><span class="o">:</span> <span class="n">Vector.nil</span>

<span class="kd">def</span> <span class="n">cls2</span> <span class="o">:</span> <span class="n">Clause</span> <span class="mi">2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">some</span> <span class="n">true</span><span class="o">)</span> <span class="bp">+</span><span class="o">:</span> <span class="n">none</span> <span class="bp">+</span><span class="o">:</span> <span class="n">Vector.nil</span>  <span class="c1">-- P</span>

<span class="kd">def</span> <span class="n">egStatement</span> <span class="o">:=</span> <span class="n">cls1</span> <span class="bp">+</span><span class="o">:</span> <span class="n">cls2</span> <span class="bp">+</span><span class="o">:</span> <span class="n">Vector.nil</span>

<span class="kd">def</span> <span class="n">egAnswer</span> <span class="o">:</span> <span class="n">SatAnswer</span> <span class="n">egStatement</span> <span class="o">:=</span> <span class="n">answerSAT</span> <span class="n">egStatement</span>

<span class="kd">def</span> <span class="n">egAnswerNorm</span> <span class="o">:</span> <span class="n">SatAnswer</span> <span class="n">egStatement</span> <span class="o">:=</span> <span class="n">whnf</span><span class="bp">!</span> <span class="n">egAnswer</span>                    <span class="c1">-- gives the error</span>
</code></pre></div>
<p>Thanks</p>



<a name="255266449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255266449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255266449">(Sep 28 2021 at 17:48)</a>:</h4>
<p><span class="user-mention" data-user-id="266304">@Siddhartha Gadgil</span> Thanks for creating a self-contained repro. I just pushed a fix for this issue.</p>



<a name="255323999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Simplifications%20in%20proofs/type-checking%20not%20happening%3B%20wh.../near/255323999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Simplifications.20in.20proofs.2Ftype-checking.20not.20happening.3B.20wh.2E.2E.2E.html#255323999">(Sep 29 2021 at 00:44)</a>:</h4>
<p>Wow, thanks a lot</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/mathport.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html">mathport</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224462996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224462996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224462996">(Jan 29 2021 at 12:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I cannot reproduce your error, but I will create a Dockerfile that runs the entire pipeline to preempt this kind of issue.</p>



<a name="224467503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224467503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224467503">(Jan 29 2021 at 13:08)</a>:</h4>
<p>Already started working on a Nix build and filling a binary cache at <a href="https://app.cachix.org/cache/port34">https://app.cachix.org/cache/port34</a></p>



<a name="224827952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224827952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224827952">(Feb 02 2021 at 04:32)</a>:</h4>
<p>I am curious how far we can push heuristic delaboration. Suppose we are able to delaborate into:</p>
<ul>
<li>terms (when reasonably small)</li>
<li>have/let</li>
<li>calc</li>
<li>induction</li>
<li>cases</li>
<li>rewrite</li>
<li>apply</li>
<li>simp</li>
<li>decision procedures (e.g. ring)</li>
<li>...?</li>
</ul>
<p>Might these proofs be inspectable/maintainable enough to obviate the need for manual proof-porting? How many other tactics provide significant compression of the proof terms? Note: even this level of delaboration may be hard for various reasons, and may require a lot of search.</p>



<a name="224828381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224828381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224828381">(Feb 02 2021 at 04:41)</a>:</h4>
<p>There could be advantages to automatically producing structured proofs. I personally find it difficult to maintain/port proofs that use e.g. <code>refine</code> or <code>apply</code> without braces around the subgoals.</p>



<a name="224828981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224828981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224828981">(Feb 02 2021 at 04:54)</a>:</h4>
<p>we have a style guide about that, so it shouldn't come up often</p>



<a name="224829179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224829179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224829179">(Feb 02 2021 at 04:58)</a>:</h4>
<p>One way to get tactic proofs to delaborate is to have the tactic put a tag in the theorem saying the tactic's name and arguments. This is a little tricky in lean 3 though because the natural language for that is to put <code>name</code> and <code>expr</code> in the term, in identity-function annotations, but <code>expr</code> at least is <code>meta</code> and so can't appear in most proof terms</p>



<a name="224851016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224851016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224851016">(Feb 02 2021 at 10:13)</a>:</h4>
<p>Yeah, I think focusing on subgoals is probably the least of the worries here. Not that all of mathlib does it perfectly, but it's one of the stricter style rules we have because of the obvious maintenance benefits</p>



<a name="224851170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224851170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224851170">(Feb 02 2021 at 10:14)</a>:</h4>
<p>The tagging tactics idea is interesting, but it sounds like it would end up a weird hybrid of porting proof terms and porting surface syntax. Would it be easier to hack the Lean 3 parser to output Lean 4-ish proof scripts?</p>



<a name="224851359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224851359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224851359">(Feb 02 2021 at 10:16)</a>:</h4>
<p>I guess delaboration would work best at the type level, ignoring proofs. What are the prospects of generating file skeletons automatically with this? For a manual porting effort it would still be really useful to have an outline of what you need to update.</p>



<a name="224853958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224853958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224853958">(Feb 02 2021 at 10:41)</a>:</h4>
<p>Automatic delaboration of proofs (= converting proof terms into readable tactic scripts) is definitely an interesting topic that deserves research, and it would also be useful independently of the mathlib porting process.<br>
That said, I believe you can divide mathlib proofs into roughly two camps: 1) one-line term mode proofs, 2) long tactic proofs.  Even the Lean 3 delaborator is good enough for (1) typically.  But (2) uses a large number of fragile tactics: I would expect the Lean 4 versions of <code>ring</code>, etc. to have slightly different behavior.  Their behavior has changed often enough already.  There will always be a boundary on which proofs can be automatically ported, and I don't think we can shift this boundary very far.<br>
I'm not sure how desirable it is to delaborate Lean 3 code for a whole module (what Rob suggested I believe), given how much of mathlib is automatically generated: there's automatically generated lemmas (equation lemmas, simps), automatic copy&amp;paste (to_additive), and more (alias, ...).  Not to speak of comments, etc.</p>



<a name="224905069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224905069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224905069">(Feb 02 2021 at 17:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/224853958">said</a>:</p>
<blockquote>
<p>I'm not sure how desirable it is to delaborate Lean 3 code for a whole module (what Rob suggested I believe), given how much of mathlib is automatically generated: there's automatically generated lemmas (equation lemmas, simps), automatic copy&amp;paste (to_additive), and more (alias, ...).  Not to speak of comments, etc.</p>
</blockquote>
<p>I'm thinking of this as a first pass before manual effort. Suppose you use mathport to make a Lean 4 <code>target.olean</code> from a Lean 3 <code>source.olean</code>. The goal is now to write a Lean 4 <code>target.lean</code> with the same interface as the olean. Delaborating the definitions and theorem statements gives you this, so you know exactly what you need to fill in. You're right that a lot of stuff is created automatically and we'd have to detect this and look for overlaps, but that doesn't sound unreasonable. Things like <code>simps</code> and <code>to_additive</code> leave behind trails that we can automatically detect (or we can add tags if necessary).</p>



<a name="224905281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224905281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224905281">(Feb 02 2021 at 17:24)</a>:</h4>
<p>Semantic comments (doc strings) should be part of the delaboration, but yeah, other comments can't be. It would also be hard to capture sections, namespaces, variables, etc.</p>



<a name="224905337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224905337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224905337">(Feb 02 2021 at 17:24)</a>:</h4>
<p>So this doesn't let you ignore <code>source.lean</code> completely.</p>



<a name="224905577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224905577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224905577">(Feb 02 2021 at 17:26)</a>:</h4>
<p>Actually, namespaces could get in the way here. If things get delaborated in the root namespace I guess all names will be fully specified, which would be ugly.</p>



<a name="224905993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224905993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224905993">(Feb 02 2021 at 17:28)</a>:</h4>
<p>Now that we can access imported Lean 3 notations in Lean 4, I believe that parsing mathlib as-is in Lean 4 is definitely feasible. Even if it's just 95% of mathlib that can be parsed, that should give you a much better base to build on (i.e. getting the file to actually <em>elaborate</em>) than a delaborated skeleton I think.</p>



<a name="224906549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224906549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224906549">(Feb 02 2021 at 17:32)</a>:</h4>
<p>Of course this should then be translated to "actual" Lean 4 syntax so mathlib doesn't end up with some weird Lean 4 accent. This part is not quite as clear to me yet because we haven't built enough tooling in the direction of refactorings so far, but it sounds at least as feasible as any delaboration approach to me.</p>



<a name="224906620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224906620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224906620">(Feb 02 2021 at 17:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> What do think is the best way to do that?  Can we just add macros for the Lean 3 syntax?  Is there anything that would be hard to do this way?</p>



<a name="224906822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224906822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224906822">(Feb 02 2021 at 17:34)</a>:</h4>
<p>As far as refactoring goes, I hope that the Lean 4 server gets "quickfix" support at some point.  Getting rid of the compat layer should just be a question of hitting ctrl-. maniacally then.</p>



<a name="224907571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224907571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224907571">(Feb 02 2021 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/224906620">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> What do think is the best way to do that?  Can we just add macros for the Lean 3 syntax?  Is there anything that would be hard to do this way?</p>
</blockquote>
<p>For notations the exporter can't handle, user-defined parsers, and tactics (at least their syntax), it really should be as easy as that, yeah. That leaves built-in syntax that is different from Lean 4 as the hardest part. It might be necessary/easier to use the internal <code>Lean.Parser</code> there in favor of the simpler <code>syntax</code> command.</p>



<a name="224908096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224908096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224908096">(Feb 02 2021 at 17:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/224906822">said</a>:</p>
<blockquote>
<p>As far as refactoring goes, I hope that the Lean 4 server gets "quickfix" support at some point.  Getting rid of the compat layer should just be a question of hitting ctrl-. maniacally then.</p>
</blockquote>
<p>I do hope we get there one day :) . But apart from editor integration, the part I wasn't sure about yet is that you either need good tooling for translating syntax while preserving/adapting formatting, or you need a great code formatter you can just run on the unformatted result. We have some initial work on both parts, but there's still lots of work to be done.</p>



<a name="224908694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224908694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224908694">(Feb 02 2021 at 17:48)</a>:</h4>
<p>I don't think you need to worry about formatting for an MVP.  Just having the editor integration set up is enough to be very useful.  People are ecstatic about "Try this:" in Lean 3, and that's way less sophisticated.</p>



<a name="224913289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224913289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224913289">(Feb 02 2021 at 18:20)</a>:</h4>
<p>Yeah. I definitely want to avoid a "parse Lean 3 syntax now, translate to Lean 4 syntax later" scenario where the "later" never happens. But if we translate &amp; pretty-print immediately, then fix up the formatting while doing the actual porting, the current pretty printer might not be too far from being usable for that.</p>



<a name="224914166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224914166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224914166">(Feb 02 2021 at 18:26)</a>:</h4>
<p>To give an idea of what the output currently looks like, this is a pretty-printed part of <code>Prelude.lean</code>: <a href="https://github.com/leanprover/lean4/blob/master/tests/lean/Reformat.lean.expected.out">https://github.com/leanprover/lean4/blob/master/tests/lean/Reformat.lean.expected.out</a><br>
Only comments are preserved, all indentation &amp; line breaks are from the pretty printer</p>



<a name="224953268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224953268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224953268">(Feb 02 2021 at 23:38)</a>:</h4>
<p>FYI I have been collecting issues at <a href="https://github.com/dselsam/mathport/issues">https://github.com/dselsam/mathport/issues</a>. Currently there are three open requests for backports:</p>
<ul>
<li><a href="https://github.com/dselsam/mathport/issues/3">https://github.com/dselsam/mathport/issues/3</a> don't rely on inductive result types getting unfolded<ul>
<li>after this, we will be able to build the porting tool using <code>lean4:master</code></li>
</ul>
</li>
<li><a href="https://github.com/dselsam/mathport/issues/7">https://github.com/dselsam/mathport/issues/7</a> don't toggle reducibility after-the-fact<ul>
<li>this is the source of many TC failures and also many perf problems (e.g. unfolding <code>real.pi</code> for no reason)</li>
</ul>
</li>
<li><a href="https://github.com/dselsam/mathport/issues/4">https://github.com/dselsam/mathport/issues/4</a> make sure all classes are structures (or abbreviations of structures), not definitions<ul>
<li>this causes many TC failures</li>
</ul>
</li>
</ul>
<p>Are these backports acceptable? Progress on the porting is mostly bottlenecked on the backports, and also on general rising-tide-lifts-all-ships Lean4 features/tactics/ergonomics.</p>



<a name="224953538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224953538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224953538">(Feb 02 2021 at 23:41)</a>:</h4>
<p>I'm on the fence about <a href="https://github.com/leanprover-community/mathlib/issues/3">#3</a>. I think there are at least a few examples where we want the constants to have the stated types, and it sounds like Leo's suggestion will make the terms have the wrong type, which will cause issues with typeclass search down the line</p>



<a name="224953674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224953674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224953674">(Feb 02 2021 at 23:42)</a>:</h4>
<p>Are there any <code>@[class] def</code> in the lean 3 core library?</p>



<a name="224953846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224953846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224953846">(Feb 02 2021 at 23:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/224953674">said</a>:</p>
<blockquote>
<p>Are there any <code>@[class] def</code> in the lean 3 core library?</p>
</blockquote>
<p>Not according to grep.</p>



<a name="224955777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224955777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224955777">(Feb 03 2021 at 00:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/224953538">said</a>:</p>
<blockquote>
<p>I'm on the fence about <a href="https://github.com/leanprover-community/mathlib/issues/3">#3</a>. I think there are at least a few examples where we want the constants to have the stated types, and it sounds like Leo's suggestion will make the terms have the wrong type, which will cause issues with typeclass search down the line</p>
</blockquote>
<p>The example that Daniel posted on the github thread can be "fixed" by hand. <br>
Note that we only need to unfold definitions  in an inductive declaration <code>C</code> in the following two cases :<br>
1- The header is not producing a <code>Type/Prop</code><br>
2- The constructor type contains an application of the form <code>f ... (C ...) ...</code> and <code>f</code> is a definition.  </p>
<p>How often this happens in mathlib? Case 1 seems quite rare. I can see Case 2 occurring in mathlib inductive predicates, but how many do you have?</p>
<p>This feature requires kernel modifications, including support for nested inductives, and paching code that makes assumptions that will not be true anymore after we change the kernel. Daniel already mentioned that many modules broke after he tried to patch the kernel.</p>
<p>We have to prioritize, I have zillions of things to do, and I will not merge kernel hacks to support this.</p>



<a name="224960394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224960394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224960394">(Feb 03 2021 at 01:01)</a>:</h4>
<p>In case 1, shouldn't it be a typechecking error? If it's literally not a Type/Prop even after unfolding then it shouldn't be accepted by the kernel. Case 2 does happen, although I'm not sure about the frequency - perhaps Daniel has statistics on this, because my grep skills aren't up to the task atm. Of course we use lots of inductive types (I get 700 hits in mathlib) but most of these are not problematic because they are manifestly pi types targeting Prop/Type. I had an example of this in mind from the QPF project but I don't think it survived the PR process.</p>
<p>A related situation that might come up in less contrived situations is constructors that don't manifestly target the right type, because they have a <code>let</code> in them, for example. I have definitely written code like that in software verification settings, where you have large and complex inductive types, although when it comes time to actually prove properties about the inductive type I usually find it better to have explicit equality assumptions in the constructors.</p>
<p>One way to support this without kernel hacks would be to make the kernel inductive behind the scenes with these things unfolded, and then redeclare the type and constructors with the given types and prove them by defeq. That said, I guess part of the point of adding nested / mutual inductives to the kernel was to avoid this kind of facade pattern, and I agree that this isn't a big priority. I'll do a once-over of mathlib to see if the existing uses can be fixed, and report back if something really critical depends on it.</p>



<a name="224960779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224960779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224960779">(Feb 03 2021 at 01:06)</a>:</h4>
<blockquote>
<p>In case 1, shouldn't it be a typechecking error? If it's literally not a Type/Prop even after unfolding then it shouldn't be accepted by the kernel.</p>
</blockquote>
<p>In case 1, I meant the type after elaboration is not of the form <code>... -&gt; Sort u</code> for some <code>u</code>.<br>
In Daniel's example, the type was <code>set (set a)</code> after elaboration. After unfolding the first <code>set</code>, we have <code>set a -&gt; Prop</code>.</p>



<a name="224960950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224960950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224960950">(Feb 03 2021 at 01:08)</a>:</h4>
<blockquote>
<p>I have definitely written code like that in software verification settings</p>
</blockquote>
<p>We have to prioritize. Let's focus on mathlib only.</p>



<a name="224961017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224961017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224961017">(Feb 03 2021 at 01:09)</a>:</h4>
<blockquote>
<p>One way to support this without kernel hacks would be to make the kernel inductive </p>
</blockquote>
<p>I know what has to be done. However knowing and doing are two completely different things ;)</p>



<a name="224961441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224961441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224961441">(Feb 03 2021 at 01:14)</a>:</h4>
<p>Regarding Daniel's <code>set (set A)</code> example specifically, this is exploiting definitional equality of <code>set A</code>, which is bad style in mathlib anyway (because it messes up the use of <code>\in</code> and <code>{x | p}</code>). So I don't think there will be any problem removing that use.</p>



<a name="224961602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224961602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224961602">(Feb 03 2021 at 01:16)</a>:</h4>
<p>What about this one?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">presieve</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">⦃</span><span class="n">Y</span><span class="o">⦄,</span> <span class="n">set</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">⟶</span> <span class="n">X</span><span class="o">)</span>
<span class="c1">-- ...</span>
<span class="kd">inductive</span> <span class="n">singleton</span> <span class="o">:</span> <span class="n">presieve</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">singleton</span> <span class="n">f</span>
</code></pre></div>



<a name="224961931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224961931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224961931">(Feb 03 2021 at 01:20)</a>:</h4>
<p>cc: <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> , how important is the definitional equality of <code>presieve X</code> here?</p>



<a name="224961966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224961966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224961966">(Feb 03 2021 at 01:20)</a>:</h4>
<p>I don't work with the category theory library much</p>



<a name="224962277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224962277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224962277">(Feb 03 2021 at 01:24)</a>:</h4>
<p>I think I'll just try the facade pattern manually for that one</p>



<a name="224962329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224962329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224962329">(Feb 03 2021 at 01:25)</a>:</h4>
<p>I haven't been following this discussion so I don't really understand the suggested change, but I think as long as there's a coe or other nice notation for presieves and the definition of singleton is via some form of inductive, it should all be fine</p>



<a name="224975088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224975088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224975088">(Feb 03 2021 at 05:30)</a>:</h4>
<p>I'll defer to Bhavik <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="224984671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224984671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224984671">(Feb 03 2021 at 08:07)</a>:</h4>
<p>About <a href="https://github.com/dselsam/mathport/issues/7">https://github.com/dselsam/mathport/issues/7</a>, can this be simulated by introducing a new constant and an axiom that it is provably equal to the object we have constructed? Setting the <code>irreducible</code> attribute after the construction is something we use in mathlib for several complicated objects (like the reals, the integral, and so on) whose construction is involved but for which the construction can be forgotten once a basic API has been established. This is something that we will still need to do in Lean4.</p>



<a name="224985421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224985421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224985421">(Feb 03 2021 at 08:18)</a>:</h4>
<p>I think the proposal is to have something like that: <code>real</code> which is irreducible, and <code>real_implementation</code> where we set up the api.</p>



<a name="224985431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224985431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224985431">(Feb 03 2021 at 08:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> We can add a macro for the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">constant</span> <span class="n">pi_core</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">classical.some</span> <span class="n">exists_cos_eq_zero</span> <span class="o">}</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span> <span class="n">pi_core.1</span>
<span class="kd">theorem</span> <span class="n">pi_def</span> <span class="o">:</span> <span class="n">pi</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">classical.some</span> <span class="n">exists_cos_eq_zero</span> <span class="o">:=</span> <span class="n">pi_core.2</span>
</code></pre></div>



<a name="224986444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224986444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224986444">(Feb 03 2021 at 08:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span> <span class="s2">"irreducible_def"</span> <span class="n">name</span><span class="o">:</span><span class="n">ident</span> <span class="s2">" : "</span> <span class="n">type</span><span class="o">:</span><span class="n">term</span> <span class="s2">" := "</span> <span class="n">decl</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">=&gt;</span>
<span class="bp">`</span><span class="o">(</span><span class="kd">noncomputable</span> <span class="kd">constant</span> <span class="n">wrapped</span> <span class="o">:</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">$</span><span class="n">type</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">$</span><span class="n">decl</span> <span class="o">}</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="bp">$</span><span class="n">name</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span> <span class="n">wrapped.1</span>
<span class="kn">protected</span> <span class="kd">theorem</span> <span class="bp">$</span><span class="o">(</span><span class="n">mkIdentFrom</span> <span class="n">name</span> <span class="o">(</span><span class="n">name.getId</span> <span class="bp">++</span> <span class="bp">`</span><span class="n">eqn</span><span class="o">))</span> <span class="o">:</span> <span class="bp">$</span><span class="n">name</span> <span class="bp">=</span> <span class="bp">$</span><span class="n">decl</span> <span class="o">:=</span> <span class="n">wrapped.2</span><span class="o">)</span>

<span class="n">irreducible_def</span> <span class="n">pi</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">classical.some</span> <span class="n">exists_cos_eq_zero</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pi</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">classical.some</span> <span class="n">exists_cos_eq_zero</span> <span class="o">:=</span> <span class="n">pi.eqn</span>
</code></pre></div>



<a name="224998632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224998632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224998632">(Feb 03 2021 at 10:43)</a>:</h4>
<p>I still need to see how this would work to define, say, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>. Would this lead to DTT hell when constructing the basic API?</p>



<a name="224999026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224999026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224999026">(Feb 03 2021 at 10:47)</a>:</h4>
<p>For ℝ it is easy, we can define <code>constant reals : (α : Type) × conditionally_complete_linear_ordered_field α</code> and then say <code>def ℝ := reals.1</code>.  There isn't even any need to expose the implementation here.</p>



<a name="224999203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224999203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224999203">(Feb 03 2021 at 10:49)</a>:</h4>
<p>I'm more worried about wrappers such as <code>with_one</code> (or <code>opposite</code>).</p>



<a name="224999251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224999251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224999251">(Feb 03 2021 at 10:49)</a>:</h4>
<blockquote>
<p>Both <code>unop (op X) = X</code> and <code>op (unop X) = X</code> are definitional equalities. Notably, every object of the opposite category is definitionally of the form <code>op X</code>, which greatly simplifies the definition of the structure of the opposite category, for example.</p>
</blockquote>



<a name="224999384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224999384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224999384">(Feb 03 2021 at 10:51)</a>:</h4>
<p>Maybe the category theory people can chime in on this.  Would a semireducible opposite be enough?  <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> <span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span></p>



<a name="224999742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/224999742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#224999742">(Feb 03 2021 at 10:54)</a>:</h4>
<p>We can experiment with this today in mathlib.  This is essentially the API we'll have in Lean 4 (maybe we need to write <code>irreducible_def</code> instead, but that's just syntax):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- immediately mark as irreducible</span>
<span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">3</span>
<span class="c1">-- never use `local attribute [reducible]`, instead use `rw`/`simp`/`unfold`</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">*</span><span class="n">foo</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">foo</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>



<a name="225010008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010008">(Feb 03 2021 at 12:50)</a>:</h4>
<p>Is this different from making <code>opposite</code> a structure?</p>



<a name="225010074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010074">(Feb 03 2021 at 12:51)</a>:</h4>
<p>Making it irreducible (and never overriding it locally) is about the same as making it a structure.  From what I understand, that would be horrible.</p>



<a name="225010092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010092">(Feb 03 2021 at 12:51)</a>:</h4>
<p>The question is if it would be possible to make it semireducible instead of irreducible (i.e. just a plain <code>def</code>).</p>



<a name="225010263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010263">(Feb 03 2021 at 12:53)</a>:</h4>
<p>Semireducible was what we had originally and it led to lots of confusion because, if you don't have a clear distinction between <code>A B : C</code> and <code>A B : opposite C</code>, then you don't know whether <code>A \hom B</code> is a map from <code>A</code> to <code>B</code> or a map from <code>B</code> to <code>A</code>.</p>



<a name="225010477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010477">(Feb 03 2021 at 12:55)</a>:</h4>
<p>I'm not entirely sure how bad it would be to use a structure; from what I remember, I found the current setup with <code>irreducible</code> provided the most definitional equalities and so we built <code>opposite</code> on top of it. There was never a time that we seriously tried using a structure instead, since there was no need to.</p>



<a name="225010551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010551">(Feb 03 2021 at 12:56)</a>:</h4>
<p>Now we have a lot of code  using <code>opposite</code>, so we can find out experimentally whether that comment is really correct.</p>



<a name="225010825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010825">(Feb 03 2021 at 12:59)</a>:</h4>
<p>For stuff like <code>with_one</code> I think we just use this irreducibility to get a few things about <code>option</code> for free, like the functor/monad instances. I don't think it's a big deal, we can just reimplement them in a few lines (for each of the relevant <code>with_*</code>) manually.</p>



<a name="225010990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225010990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225010990">(Feb 03 2021 at 13:01)</a>:</h4>
<p>I've tried making <code>is_O</code> and friends irreducible in <a href="https://github.com/leanprover-community/mathlib/issues/6021">#6021</a>.  It's not pretty but not awful either.  This was probably the easiest irreducible to remove.  <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> where would you expect the most DTT hell from making definitions irreducible immediately?</p>



<a name="225011414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225011414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225011414">(Feb 03 2021 at 13:05)</a>:</h4>
<p><code>additive</code> and <code>multiplicative</code> are another minefield.  Maybe it's time to revive <a href="https://github.com/leanprover-community/mathlib/issues/2292">#2292</a> now.</p>



<a name="225013369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225013369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225013369">(Feb 03 2021 at 13:20)</a>:</h4>
<p>I'd be pretty scared of <code>data/real/basic.lean</code>, but maybe I'm too pessimistic.</p>



<a name="225014091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225014091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225014091">(Feb 03 2021 at 13:25)</a>:</h4>
<p>Related to <a href="https://leanprover-community.github.io/mathlib_docs/find/additive">docs#additive</a>, I remember a pr about <a href="https://leanprover-community.github.io/mathlib_docs/find/order_dual">docs#order_dual</a> where I tried to come up with an alternative proof for something to avoid relying on definitional equality, but found all the lemmas I needed were missing</p>



<a name="225015646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225015646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225015646">(Feb 03 2021 at 13:38)</a>:</h4>
<p>BTW, my general preference in these matters is to use <code>structure</code> rather than <code>irreducible</code>, since everyone knows about <code>structure</code> but I'm not sure I even really understand what <code>irreducible</code> does and doesn't do.</p>



<a name="225019967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225019967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225019967">(Feb 03 2021 at 14:10)</a>:</h4>
<p>Yes, I also feel like I don't understand <code>irreducible</code>. I made <code>with_zero</code> and <code>with_one</code> irreducible in <a href="https://github.com/leanprover-community/mathlib/issues/3883">#3883</a> because I was finding them frustrating to work with. People were abusing type equality in code and the resulting "not strictly speaking type correct in some sense" code would cause leaks, where I was trying to prove things about <code>0</code> or <code>1</code> but was staring at goals which talked about <code>none</code>. I would have been equally happy simply ripping out the definition <code>with_zero X := option X</code> and replacing it with a new inductive type with constructors <code>zero</code> and <code>some x</code>, but at the time people discouraged me from doing this because it would have led to a bunch of code duplication. Right now we steal a bunch of proofs from <code>option</code> when making the <code>with_zero</code> API and then mark it irreducible at the end. I should apologise in advance if this is not relevant, I do not really understand the issues of what is being talked about here.</p>



<a name="225023449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225023449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225023449">(Feb 03 2021 at 14:36)</a>:</h4>
<blockquote>
<p>but I'm not sure I even really understand what irreducible does and doesn't do.</p>
</blockquote>
<p>also, there is no <code>irreducible</code> in Lean4, only <code>constant</code> which is truly opaque (even to the kernel)</p>



<a name="225023984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225023984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225023984">(Feb 03 2021 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/225013369">said</a>:</p>
<blockquote>
<p>I'd be pretty scared of <code>data/real/basic.lean</code>, but maybe I'm too pessimistic.</p>
</blockquote>
<p>Ok this was easy: <a href="https://github.com/leanprover-community/mathlib/issues/6024">#6024</a>.</p>



<a name="225025895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225025895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225025895">(Feb 03 2021 at 14:54)</a>:</h4>
<p>The real test will be to completely remove the Cauchy reals and replace them with Bourbaki reals that we also have.</p>



<a name="225026505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225026505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225026505">(Feb 03 2021 at 14:58)</a>:</h4>
<p>Bourbaki = the reals are the unique complete Archimedean ordered field?</p>



<a name="225026640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225026640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225026640">(Feb 03 2021 at 14:59)</a>:</h4>
<p>The updated definition by Gabriel is the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">real</span> <span class="o">:=</span> <span class="n">of_cauchy</span> <span class="o">::</span>
<span class="o">(</span><span class="n">cauchy</span> <span class="o">:</span> <span class="bp">@</span><span class="n">cau_seq.completion.Cauchy</span> <span class="n">ℚ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">abs</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>Can someone explain what this is? What are these <code>::</code>?</p>



<a name="225026738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225026738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225026738">(Feb 03 2021 at 15:00)</a>:</h4>
<p>The default constructor for a structure is called <code>mk</code>.  But <code>real.mk</code> already means something different.  The <code>::</code> allows you to rename the constructor.</p>



<a name="225026850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225026850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225026850">(Feb 03 2021 at 15:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/225023984">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/225013369">said</a>:</p>
<blockquote>
<p>I'd be pretty scared of <code>data/real/basic.lean</code>, but maybe I'm too pessimistic.</p>
</blockquote>
<p>Ok this was easy: <a href="https://github.com/leanprover-community/mathlib/issues/6024">#6024</a>.</p>
</blockquote>
<p>Great! I still see <code>irreducible</code> though -- is it possible to wrap <code>lt</code> in a constant?</p>



<a name="225026924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225026924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225026924">(Feb 03 2021 at 15:01)</a>:</h4>
<p>Not in Lean 3.  I don't want to add hundreds of noncomputable annotations.</p>



<a name="225027044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225027044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225027044">(Feb 03 2021 at 15:02)</a>:</h4>
<p><code>lt</code> is a <code>Prop</code> though, why would it matter?</p>



<a name="225027053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225027053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225027053">(Feb 03 2021 at 15:02)</a>:</h4>
<p>The idea here is to only use irreducible in such a way that we can simulate in Lean 4.  For example using the <code>irreducible_def</code> macro I posted above.</p>



<a name="225027181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225027181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225027181">(Feb 03 2021 at 15:03)</a>:</h4>
<p>Ah then it <em>might</em> be possible.  But I don't see why it matters.  We don't want to add hacks now just to remove them again in a few months.</p>



<a name="225027297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225027297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225027297">(Feb 03 2021 at 15:03)</a>:</h4>
<p>In which sense is this irreducible, though? If Lean sees an equality <code>x + y = z</code> and wants to check it definitionally, it will never unfold by itself the definition of addition on the fields of the structure to check if they match after this unfolding, right?</p>



<a name="225027593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225027593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225027593">(Feb 03 2021 at 15:05)</a>:</h4>
<p>Also, <a href="https://github.com/leanprover-community/mathlib/issues/6024">#6024</a> doesn't build ;-)</p>



<a name="225027608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225027608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225027608">(Feb 03 2021 at 15:05)</a>:</h4>
<p>Oops, so <code>+</code> is irreducible now, and I accidentally made it semireducible.</p>



<a name="225028390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225028390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225028390">(Feb 03 2021 at 15:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/225027053">said</a>:</p>
<blockquote>
<p>The idea here is to only use irreducible in such a way that we can simulate in Lean 4.  For example using the <code>irreducible_def</code> macro I posted above.</p>
</blockquote>
<p>If I am reading <a href="https://github.com/leanprover-community/mathlib/blob/f8dadb5c855646f5a96e3551737801dbafb4fbd3/src/data/real/basic.lean#L87-L98">https://github.com/leanprover-community/mathlib/blob/f8dadb5c855646f5a96e3551737801dbafb4fbd3/src/data/real/basic.lean#L87-L98</a> correctly, it looks like you are manually unfolding <code>lt</code> after-the-fact. So if the auto-porter used your macro to define <code>lt</code>, the downstream proof would break.</p>



<a name="225028709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225028709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225028709">(Feb 03 2021 at 15:12)</a>:</h4>
<p>I'm going to experiment with <code>opposite</code>-as-structure later today.</p>



<a name="225028716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225028716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225028716">(Feb 03 2021 at 15:12)</a>:</h4>
<p><code>simp [real.lt]</code> uses the equation lemma.  The macro also produces an equation lemma <code>real.lt.eqn</code>.</p>



<a name="225028752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225028752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225028752">(Feb 03 2021 at 15:12)</a>:</h4>
<p>There should be no <em>definitional</em> unfolding happening.</p>



<a name="225031878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225031878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225031878">(Feb 03 2021 at 15:33)</a>:</h4>
<p>I may be missing something obvious, but your macro doesn't seem to guarantee that the equation lemma of the <code>constant</code> and the equation lemma(s) of the original definition line up. How about this:</p>
<ul>
<li>when mathport reaches a definition, it looks ahead to see if it is immediately declared irreducible</li>
<li>if so, it collects all equation lemmas, and creates a constant <code>{ x  // all equation lemmas hold }</code></li>
<li>it then creates a def for (new constant).val and one for each of the eqn lemmas (new constant).property[...]</li>
<li>it then aligns the old decl and equation lemmas with the new ones</li>
</ul>



<a name="225032045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225032045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225032045">(Feb 03 2021 at 15:34)</a>:</h4>
<p>FYI I will be offline today but back tomorrow.</p>



<a name="225033272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225033272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225033272">(Feb 03 2021 at 15:43)</a>:</h4>
<p>There's typically only a single equation for irreducible definitions, but yes, that sounds good.  The macro was intended as an illustration for "this is how it will be after we've ported mathlib", not a suggestion for the porting tool.</p>



<a name="225047867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225047867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225047867">(Feb 03 2021 at 17:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/225026505">said</a>:</p>
<blockquote>
<p>Bourbaki = the reals are the unique complete Archimedean ordered field?</p>
</blockquote>
<p>No, that wouldn't be a construction but a characterization. Bourbaki constructs real number as the completion of the topological ring of rational number, using a <em>lot</em> of the topology library.</p>



<a name="225049300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225049300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225049300">(Feb 03 2021 at 17:25)</a>:</h4>
<p>Is this what Johannes originally did in mathlib?  I believe Mario removed that construction in favor of the current elementary one to reduce dependencies.</p>



<a name="225051098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225051098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225051098">(Feb 03 2021 at 17:36)</a>:</h4>
<p>Johannes originally did a somewhat hybrid version, not going full Bourbaki. Mario added an elementary construction because there were huge performance issues. This was before we started to mark stuff irreducible.</p>



<a name="225052566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/225052566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#225052566">(Feb 03 2021 at 17:47)</a>:</h4>
<p>I agree that it is a bit ridiculous that the definition of real numbers in Lean is understandable by freshmen students... clearly we should take inspiration from integration theory do things properly. <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span> <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span>  [/trolling]</p>



<a name="226086158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226086158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226086158">(Feb 12 2021 at 02:22)</a>:</h4>
<p>Updates and issues:</p>
<ul>
<li>
<p>I back-ported a minor adjustment to <code>dite</code> and <code>ite</code> but haven't PRed yet (not sure what the protocol is for multi-repo changes):</p>
<ul>
<li><a href="https://github.com/dselsam/lean3/tree/dite">https://github.com/dselsam/lean3/tree/dite</a></li>
<li><a href="https://github.com/dselsam/mathlib/tree/dite">https://github.com/dselsam/mathlib/tree/dite</a></li>
</ul>
</li>
<li>
<p>Lean4's <code>&lt;</code> doesn't match lean3's <code>&lt;</code> on nats. In lean3, <code>nat.lt</code> and <code>nat.le</code> are inductive whereas <code>Nat.lt</code> and <code>Nat.le</code> are defined as the boolean versions returning true. I think this instance clash will cause big problems and needs to be fixed.</p>
</li>
<li>
<p>The number-mismatch is more problematic than I realized at first. Lean3 uses <code>zero</code>, <code>one</code>, <code>bit0</code> and <code>bit1</code>, whereas Lean4 uses <code>OfNat α n</code>. It is not trivial to auto-convert during the porting. I tried making <code>OfNat</code> instances from <code>has_zero</code>, <code>has_one</code>, and <code>has_add</code>, but it relies on a recursive function with idealized type <code>Π [has_one α] [has_add α], ℕ → α</code>. For easy auto-porting, this function must permit reasonably efficient  reduction in the kernel. Thus, it cannot be well-founded or partial. But if it relies on fuel, it becomes impossibly expensive to confirm <code>2 + 2 = 4</code> in the kernel.</p>
</li>
<li>
<p>To align <code>applicative</code> and <code>monad</code>, all that needs to happen is that <code>seq_left</code> and <code>seq_right</code> must require the discarded action to return <code>unit</code>. It is easy to change, but there is some theory based on <code>lawful_applicative</code> and <code>lawful_monad</code> that broke, so ideally somebody who works on that part of the library can finish propagating the change.</p>
</li>
<li>
<p>The current lack of <code>string</code>-&gt;<code>String</code> alignment is not catastrophic but it is unpleasant, since e.g. <code>auto_param</code>s will show as lists of nats. A few issues are blocking this alignment.</p>
<ol>
<li><code>fin</code> is a def in lean3 whereas <code>Fin</code> is a structure in lean4. Note that it is important for it to be a structure in lean4 because there is special support in the system for it in various places, and so <code>Fin</code> needs to be the whnf.</li>
<li><code>unsigned</code> is a def in lean3 whereas <code>UInt32</code> is a structure in lean4 for the same reason as <code>Fin</code></li>
<li>The <code>nat.lt</code> issue also complicates this.</li>
<li>The general number mismatch also complicates this.</li>
</ol>
</li>
</ul>



<a name="226086365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226086365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226086365">(Feb 12 2021 at 02:26)</a>:</h4>
<p>Are there any updates on the two open backports?</p>
<p>- <a href="https://github.com/dselsam/mathport/issues/7">https://github.com/dselsam/mathport/issues/7</a><br>
  - <a href="https://github.com/dselsam/mathport/issues/4">https://github.com/dselsam/mathport/issues/4</a></p>
<p>Note that I switched <a href="https://github.com/dselsam/mathport/issues/3">https://github.com/dselsam/mathport/issues/3</a> from <code>backport</code> to <code>blocked</code>, pending a final decision about what to support on the lean4 side.</p>



<a name="226086627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226086627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226086627">(Feb 12 2021 at 02:30)</a>:</h4>
<p>Regarding <a href="https://github.com/dselsam/mathport/issues/4">dselsam/mathport#4</a>, there were two PRs handling this; <a href="https://github.com/leanprover-community/mathlib/issues/6028">#6028</a> was merged and covered most of the occurrences I could find with a quick grep, and <a href="https://github.com/leanprover-community/mathlib/issues/6061">#6061</a> added a linter and removed all remaining occurrences. However <a href="https://github.com/leanprover-community/mathlib/issues/6061">#6061</a> has not been merged as there is some mysterious typeclass breakage in an unrelated area</p>



<a name="226086846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226086846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226086846">(Feb 12 2021 at 02:34)</a>:</h4>
<p>As for things like <code>Nat.lt</code> vs <code>nat.lt</code>, as I mentioned to you before we have to find a way to handle non-defeq replacements, defeq is setting way too high a bar. For propositions it's feasible that we can prove an equality and simp it away in lemmas</p>



<a name="226086883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226086883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226086883">(Feb 12 2021 at 02:35)</a>:</h4>
<p>I think backporting <code>Nat.lt</code> is out of the question, that would be way too disruptive</p>



<a name="226087052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226087052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226087052">(Feb 12 2021 at 02:38)</a>:</h4>
<p>Also, <code>a &lt; b := a + 1 &lt;= b</code> is super convenient and used all the time. Could we maybe have a conversation about why these were changed and whether we need to be doing something different with decidable predicates in general?</p>



<a name="226087091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226087091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226087091">(Feb 12 2021 at 02:40)</a>:</h4>
<p>For "multi-repo changes", we have been first merging changes to Lean 3, then releasing a new version of Lean 3, and then finally making the necessary changes to mathlib in a PR that bumps the Lean version.</p>



<a name="226088299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226088299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226088299">(Feb 12 2021 at 03:00)</a>:</h4>
<p>Regarding <code>fin</code>, we changed it from a structure to a def because of some inconveniences expressed in <a href="https://github.com/leanprover-community/lean/issues/359">lean#359</a>. <span class="user-mention" data-user-id="112680">@Johan Commelin</span> can probably say more.</p>



<a name="226088400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226088400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226088400">(Feb 12 2021 at 03:02)</a>:</h4>
<p><code>nat.lt</code> would need to be aligned for a def-eq alignment of <code>string</code> to <code>String</code>, but otherwise wouldn't need to be. The issue is the clashing instances. Would you just want to ignore the Lean4 instance and have <code>m &lt; n</code> mean the Mathlib <code>nat.lt</code>? This may be problematic, since Lean4 may internally synthesize decidable instances of things at various times and now may end up with ones that don't use the <code>Nat</code> primitives that are builtin to the kernel, e.g. <code>Nat.blt</code>.</p>



<a name="226088521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226088521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226088521">(Feb 12 2021 at 03:04)</a>:</h4>
<p>My first choice would be to get <code>Nat.lt</code> to have the same definition as in mathlib, with a decidable instance following the lean 4 style</p>



<a name="226088541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226088541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226088541">(Feb 12 2021 at 03:04)</a>:</h4>
<p>I suspect the current definition of <code>Nat.lt</code> was chosen because it's the easiest definition that adheres with <code>Nat.blt</code></p>



<a name="226088564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226088564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226088564">(Feb 12 2021 at 03:05)</a>:</h4>
<p>but we should be able to prove the equivalence of the two definitions and use this equivalence in the implementation of the decidable instance for <code>Nat.lt</code></p>



<a name="226088645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226088645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226088645">(Feb 12 2021 at 03:07)</a>:</h4>
<p>I don't think it matters as much whether <code>Nat.le</code> retains the lean 3 definition vs lean 4, because the underlying inductive type <code>nat.less_than_or_equal</code> is an internal implementation detail that is used extremely rarely in mathlib</p>



<a name="226089694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226089694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226089694">(Feb 12 2021 at 03:12)</a>:</h4>
<p>Re: applicative and monad, could you put your work on a branch and/or PR what you have?</p>



<a name="226093805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226093805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226093805">(Feb 12 2021 at 03:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226089694">said</a>:</p>
<blockquote>
<p>Re: applicative and monad, could you put your work on a branch and/or PR what you have?</p>
</blockquote>
<p>Here is the basic change that needs to be propagated: <a href="https://github.com/dselsam/lean3/commit/7e8ead2c0d371ddacef7db30e7dd68d52f4b768f">https://github.com/dselsam/lean3/commit/7e8ead2c0d371ddacef7db30e7dd68d52f4b768f</a> Note that this change breaks within the lean3 repo.</p>



<a name="226095486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226095486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226095486">(Feb 12 2021 at 03:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226087052">said</a>:</p>
<blockquote>
<p>Also, <code>a &lt; b := a + 1 &lt;= b</code> is super convenient and used all the time. Could we maybe have a conversation about why these were changed </p>
</blockquote>
<p><code>Nat.lt</code> is also defined that way in Lean4: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L536-L537">https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L536-L537</a></p>



<a name="226095569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226095569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226095569">(Feb 12 2021 at 03:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> </p>
<blockquote>
<p>I think backporting <code>Nat.lt</code> is out of the question, that would be way too disruptive</p>
</blockquote>
<blockquote>
<p>I don't think it matters as much whether <code>Nat.le</code> retains the lean 3 definition vs lean 4, because the underlying inductive type <code>nat.less_than_or_equal</code> is an internal implementation detail that is used extremely rarely in mathlib</p>
</blockquote>
<p>Can you please clarify, what would be way too disruptive and what doesn't matter that much?</p>



<a name="226095866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226095866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226095866">(Feb 12 2021 at 03:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226088564">said</a>:</p>
<blockquote>
<p>but we should be able to prove the equivalence of the two definitions and use this equivalence in the implementation of the decidable instance for <code>Nat.lt</code></p>
</blockquote>
<p>Meaning something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">axiom</span> <span class="n">Nat.le2</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">axiom</span> <span class="n">Nat.leOfTrue</span>  <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">Nat.ble</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">true</span>     <span class="bp">→</span> <span class="n">Nat.le2</span> <span class="n">m</span> <span class="n">n</span>
<span class="kd">axiom</span> <span class="n">Nat.leOfFalse</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">Nat.ble</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">true</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">Nat.le2</span> <span class="n">m</span> <span class="n">n</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Decidable</span> <span class="o">(</span><span class="n">Nat.le2</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Nat.ble</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">true</span> <span class="k">then</span> <span class="n">isTrue</span> <span class="o">(</span><span class="n">Nat.leOfTrue</span> <span class="n">h</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">isFalse</span> <span class="o">(</span><span class="n">Nat.leOfFalse</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="226097416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226097416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226097416">(Feb 12 2021 at 04:34)</a>:</h4>
<blockquote>
<p>Can you please clarify, what would be way too disruptive and what doesn't matter that much?</p>
</blockquote>
<p>Changing the definition of <code>nat.lt</code> in lean 3 to make it not validate <code>a &lt; b =?= a + 1 &lt;= b</code> would break lots and lots of things. Changing the definition of <code>nat.le</code> would not break much because <code>nat.less_than_or_equal</code> is not (or should not be) used directly in proofs</p>



<a name="226097482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226097482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226097482">(Feb 12 2021 at 04:36)</a>:</h4>
<blockquote>
<p>Meaning something like this?</p>
</blockquote>
<p>Yes. We should be able to slot in any convenient definition into <code>Nat.le2</code>, as long as those two theorems <code>Nat.leOfTrue</code> and <code>Nat.leOfFalse</code> are provable, and we should see no performance penalty</p>



<a name="226097604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226097604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226097604">(Feb 12 2021 at 04:38)</a>:</h4>
<p>On the assumption that lean 4 isn't doing much with proofs about <code>Nat.le</code>, it would be relatively easier to forward port <code>nat.less_than_or_equal</code> to lean 4 than backport <code>Nat.ble a b = true</code> to lean 3, which will break the foundational theorems plus the handful of mathlib theorems that use this inductive definition</p>



<a name="226097790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226097790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226097790">(Feb 12 2021 at 04:42)</a>:</h4>
<blockquote>
<p>Changing the definition of <a href="http://nat.lt">nat.lt</a> in lean 3 to make it not validate a &lt; b =?= a + 1 &lt;= b would break lots and lots of things</p>
</blockquote>
<p>To reiterate, that is how <code>Nat.lt</code> is defined in Lean4 as well so this would not be an issue.</p>



<a name="226097802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226097802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226097802">(Feb 12 2021 at 04:42)</a>:</h4>
<p>right</p>



<a name="226097990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226097990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226097990">(Feb 12 2021 at 04:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226097604">said</a>:</p>
<blockquote>
<p>On the assumption that lean 4 isn't doing much with proofs about <code>Nat.le</code>, it would be relatively easier to forward port <code>nat.less_than_or_equal</code> to lean 4 than backport <code>Nat.ble a b = true</code> to lean 3, which will break the foundational theorems plus the handful of mathlib theorems that use this inductive definition</p>
</blockquote>
<p>I can't assess how hard it would be to backport, but I don't see an issue with forward-porting <a href="#narrow/stream/270676-lean4/topic/mathport/near/226095866">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226095866</a> Leo may not want the extra complexity though.</p>



<a name="226098010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098010">(Feb 12 2021 at 04:46)</a>:</h4>
<p>Regarding <code>seq_left</code>, can we just not align it? Or have a separate typeclass for the notation? It seems like it's just a pessimization. I recall <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> had a rationale for this change but I forget what it was and whether it applies to the <code>*&gt;</code> notation as separate from <code>do</code> notation</p>



<a name="226098127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098127">(Feb 12 2021 at 04:49)</a>:</h4>
<p>Plus do notation has been extended so radically in lean 4 since the change was first made that perhaps the rationale doesn't apply anymore</p>



<a name="226098204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098204">(Feb 12 2021 at 04:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226098010">said</a>:</p>
<blockquote>
<p>Regarding <code>seq_left</code></p>
</blockquote>
<ul>
<li>It is not necessary to align it. The downside is that there will be two of many different classes, and the category-theoretic monad won't be connected to the lean <code>Monad</code></li>
<li>If you wanted, you could make the constructors align but then (still in lean3) use the notation for a definition of the original type (that adds a discard). You would still need to update the <code>lawful</code> types and patch a few proofs though</li>
</ul>



<a name="226098281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098281">(Feb 12 2021 at 04:52)</a>:</h4>
<p>I don't remember the rationale either :)</p>



<a name="226098310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098310">(Feb 12 2021 at 04:52)</a>:</h4>
<p>I'm hoping we can align <code>Monad</code> and <code>monad</code> with lean 3 <code>seq_left</code> being a separate thing</p>



<a name="226098345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098345">(Feb 12 2021 at 04:53)</a>:</h4>
<p>perhaps <code>a *&gt; b</code> is defined over applicatives as <code>Monad.seq_left (discard a) b</code></p>



<a name="226098394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098394">(Feb 12 2021 at 04:54)</a>:</h4>
<p>with <code>Monad.seq_left</code> having no particular notation</p>



<a name="226098397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098397">(Feb 12 2021 at 04:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226098345">said</a>:</p>
<blockquote>
<p>perhaps <code>a *&gt; b</code> is defined over applicatives as <code>Monad.seq_left (discard a) b</code></p>
</blockquote>
<p>I think that is what I was suggesting above.</p>
<blockquote>
<ul>
<li>If you wanted, you could make the constructors align but then (still in lean3) use the notation for a definition of the original type (that adds a discard). You would still need to update the <code>lawful</code> types and patch a few proofs though</li>
</ul>
</blockquote>



<a name="226098416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098416">(Feb 12 2021 at 04:55)</a>:</h4>
<p>aha ok</p>



<a name="226098476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098476">(Feb 12 2021 at 04:56)</a>:</h4>
<p>even though <code>seq_left</code> is a field of the <code>monad</code> structure I don't think anyone ever gives them a non-default implementation</p>



<a name="226098493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098493">(Feb 12 2021 at 04:57)</a>:</h4>
<p>Even without that trick, I think adding the <code>discard</code>s manually is just a few minutes with egrep and not a big issue. The somewhat harder part is that the lawful type needs to change and a few proofs need to be patched.</p>



<a name="226098511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098511">(Feb 12 2021 at 04:57)</a>:</h4>
<p>I think it's probably not hard but it's going to make mathlib worse. It's not a desirable change</p>



<a name="226098787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098787">(Feb 12 2021 at 05:03)</a>:</h4>
<p>Hold off then until you can discuss with Sebastian.</p>



<a name="226098806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226098806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226098806">(Feb 12 2021 at 05:03)</a>:</h4>
<p>Do you have thoughts about the number-mismatch?</p>



<a name="226099038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226099038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226099038">(Feb 12 2021 at 05:08)</a>:</h4>
<p>I'm not sure I understand the way you set up the problem. What is this function <code>Π [has_one α] [has_add α], ℕ → α</code> that you need? That looks like <code>OfNat</code> and it's already got an efficient implementation in lean 4</p>



<a name="226099062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226099062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226099062">(Feb 12 2021 at 05:09)</a>:</h4>
<p>To interpret lean 3 numeral expressions you just need <code>bit0</code> and <code>bit1</code> and the corresponding functions <code>n + n</code> and <code>n+n+1</code> are passably fast in the lean 4 kernel</p>



<a name="226099711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226099711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226099711">(Feb 12 2021 at 05:25)</a>:</h4>
<p>I meant something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HasZero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">HasOne</span>  <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">HasZero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">HasOne</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">HasOne.one</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">HasOne</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">HasOne.one</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">nat2bitsFuelAux</span> <span class="o">(</span><span class="n">fuel</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">fuel</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span>        <span class="bp">=&gt;</span> <span class="n">arbitrary</span>
  <span class="bp">|</span> <span class="n">fuel</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="bp">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arbitrary</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">HasOne.one</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">nat2bitsFuelAux</span> <span class="n">fuel</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">))</span>
    <span class="k">else</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">nat2bitsFuelAux</span> <span class="n">fuel</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">))</span>

<span class="c1">-- note: partial and wf don't compute in the kernel</span>
<span class="kd">def</span> <span class="n">nat2bitsFuel</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">nat2bitsFuelAux</span> <span class="mi">10</span> <span class="n">n</span>

<span class="c1">-- already takes a while, and 10 fuel is not enough for all of mathlib (real.pi has big numbers)</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">nat2bitsFuel</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">nat2bitsFuel</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat2bitsFuel</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="226099842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226099842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226099842">(Feb 12 2021 at 05:28)</a>:</h4>
<p>I tried replacing <code>bit0</code>/<code>bit1</code> expressions with variations of <code>OfNat.ofNat &lt;type&gt; &lt;nat&gt; &lt;instNat2bitsInAlpha&gt;</code> which are definitionally equal and fine for isolated numbers, but basic arithmetic (e.g. <code>2 + 2 =?= 4</code>) is intractable for the kernel. This comes up in e.g. <code>zero_lt_four</code>.</p>



<a name="226099944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226099944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226099944">(Feb 12 2021 at 05:31)</a>:</h4>
<p>So I'm thinking more like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HasZero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">HasOne</span>  <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">HasZero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">HasOne</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">bit1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">HasOne.one</span>

<span class="kd">instance</span> <span class="n">instZero2Nat</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">noindex</span><span class="bp">!</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">HasZero.zero</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">instOne2Nat</span>  <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">noindex</span><span class="bp">!</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">HasOne.one</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">bit0</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">bit0</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">bit0</span> <span class="o">(</span><span class="n">bit0</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="226099994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226099994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226099994">(Feb 12 2021 at 05:32)</a>:</h4>
<p>But now in Lean4, you have <code>bit0</code> and <code>bit1</code> everywhere instead of numbers.</p>



<a name="226100037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100037">(Feb 12 2021 at 05:33)</a>:</h4>
<p>I would like to make</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>work, but this requires instances of <code>OfNat A 2</code> and <code>OfNat A 4</code> and it's not clear to me how lean 4 expects me to build a countable infinity of typeclasses</p>



<a name="226100090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100090">(Feb 12 2021 at 05:34)</a>:</h4>
<p>I suspect this might be a design flaw re: <code>OfNat</code> instances. It's not necessarily an option to inhabit <code>OfNat A n</code> directly, if all you have to start from is a ring, say</p>



<a name="226100106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100106">(Feb 12 2021 at 05:35)</a>:</h4>
<p>If instances can be constructed by binary recursion then that might work, but what is the structure of lean 4 nat literals that can be pattern matched on?</p>



<a name="226100118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100118">(Feb 12 2021 at 05:35)</a>:</h4>
<p>This works in principle (and has kernel def-eq) but it is just too slow: <a href="https://github.com/dselsam/mathport/blob/strings2/Lib4/PrePort/Number.lean#L36-L50">https://github.com/dselsam/mathport/blob/strings2/Lib4/PrePort/Number.lean#L36-L50</a></p>



<a name="226100165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100165">(Feb 12 2021 at 05:36)</a>:</h4>
<p>No I mean that the instance should depend on the number</p>



<a name="226100234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100234">(Feb 12 2021 at 05:38)</a>:</h4>
<p>I don't follow, but I need to sign off now. To be continued.</p>



<a name="226100236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100236">(Feb 12 2021 at 05:38)</a>:</h4>
<p>Thanks for your help.</p>



<a name="226100404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100404">(Feb 12 2021 at 05:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">HasOne</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">instZero2Nat</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">noindex</span><span class="bp">!</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">HasZero.zero</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">instOne2Nat</span>  <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">noindex</span><span class="bp">!</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">HasOne.one</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">instBit0Nat</span> <span class="o">[</span><span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bit0</span> <span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="n">n</span><span class="o">)⟩</span>
<span class="kd">instance</span> <span class="n">instBit1Nat</span> <span class="o">[</span><span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">HasOne</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bit1</span> <span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="n">n</span><span class="o">)⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inferInstance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">bit1</span> <span class="bp">$</span> <span class="n">bit0</span> <span class="bp">$</span> <span class="n">bit1</span> <span class="bp">$</span> <span class="n">bit0</span> <span class="bp">$</span> <span class="n">bit0</span> <span class="mi">1</span><span class="o">))</span>
</code></pre></div>



<a name="226100412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100412">(Feb 12 2021 at 05:42)</a>:</h4>
<p>I want the <code>inferInstance</code> line to actually be constructed by typeclass inference</p>



<a name="226100425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100425">(Feb 12 2021 at 05:43)</a>:</h4>
<p>There might be a way to get unification hints to do this?</p>



<a name="226100512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226100512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226100512">(Feb 12 2021 at 05:45)</a>:</h4>
<p>Well, maybe it suffices for mathport to do its own fake typeclass inference here, although using <code>OfNat</code> with such an instance is barely better than the original approach of writing <code>bit0/bit1</code>  chains</p>



<a name="226101423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226101423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226101423">(Feb 12 2021 at 06:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226088299">said</a>:</p>
<blockquote>
<p>Regarding <code>fin</code>, we changed it from a structure to a def because of some inconveniences expressed in <a href="https://github.com/leanprover-community/lean/issues/359">lean#359</a>. <span class="user-mention silent" data-user-id="112680">Johan Commelin</span> can probably say more.</p>
</blockquote>
<p>I refactor <code>fin</code> to be a subtype because there is quite a bunch of API for subtypes and I didn't see the point in duplicating all of it for <code>fin</code>.</p>



<a name="226168818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226168818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226168818">(Feb 12 2021 at 17:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226100512">said</a>:</p>
<blockquote>
<p>using <code>OfNat</code> with such an instance is barely better than the original approach of writing <code>bit0/bit1</code>  chains</p>
</blockquote>
<p>I think it is essential that we can write e.g. <code>2</code> instead of <code>bit0 1</code>, at least when there is a natural <code>∀ n, OfNat α n</code> instance, e.g. nats, rationals, reals</p>



<a name="226170331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226170331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226170331">(Feb 12 2021 at 17:39)</a>:</h4>
<p>It wouldn't be so bad for Mathlib4 and Lean4 to have different definitions of <code>Fin</code>. I would like to align strings though to avoid the <code>auto_param</code> garbage prints. I see two other options (besides backporting <code>Fin</code>-as-structure):</p>
<ul>
<li>Since <code>string</code> is almost never used in actual math, perhaps we can just create a Lean4-friendly Fin type <code>fin4</code> and have characters use that instead of the regular <code>fin</code>. </li>
<li>Or we could just not port anything that depends on the def-eq details of characters that would be changed by auto-aligning.</li>
</ul>



<a name="226173193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226173193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226173193">(Feb 12 2021 at 17:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226100425">said</a>:</p>
<blockquote>
<p>There might be a way to get unification hints to do this?</p>
</blockquote>
<p>I don' think this is supported. The following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unif_hint</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span> <span class="o">(</span><span class="n">m</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=?=</span> <span class="n">n</span> <span class="bp">|-</span> <span class="n">m</span> <span class="bp">=?=</span> <span class="n">bit0</span> <span class="n">n</span>
</code></pre></div>
<p>is not accepted because <code>?m =?= bit0 (?m / 2)</code> does not hold definitionally.</p>



<a name="226181379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226181379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226181379">(Feb 12 2021 at 19:04)</a>:</h4>
<p>Alternatively, we could get unification to somehow "directly" support <code>n+k</code> patterns, i.e. <code>n*2+3 =?= 17</code> matches <code>n =?= 7</code>. Without something like this, the whole idea of typeclasses reflecting on syntax interacts badly with the unstructured space of lean 4 nat literals; there's no way to write a finite set of instances that covers all natural numbers by induction</p>



<a name="226181583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226181583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226181583">(Feb 12 2021 at 19:06)</a>:</h4>
<p>If typeclass inference can call arbitrary tactics, that would be another way to support such a thing. I'm not sure where the design landed on that point. <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> Do you know?</p>



<a name="226182143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226182143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226182143">(Feb 12 2021 at 19:10)</a>:</h4>
<p>That unification hint isn't quite right, it needs to be specialized to numerals, i.e.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unif_hint</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span> <span class="mi">3</span> <span class="bp">=?=</span> <span class="n">n</span> <span class="bp">|-</span> <span class="mi">6</span> <span class="bp">=?=</span> <span class="n">bit0</span> <span class="n">n</span>
<span class="n">unif_hint</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span> <span class="mi">4</span> <span class="bp">=?=</span> <span class="n">n</span> <span class="bp">|-</span> <span class="mi">8</span> <span class="bp">=?=</span> <span class="n">bit0</span> <span class="n">n</span>
<span class="n">unif_hint</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span> <span class="mi">5</span> <span class="bp">=?=</span> <span class="n">n</span> <span class="bp">|-</span> <span class="mi">10</span> <span class="bp">=?=</span> <span class="n">bit0</span> <span class="n">n</span>
<span class="bp">...</span>
</code></pre></div>
<p>I think you can see why this needs special elaborator support. Nat literals have special kernel support and so other aspects have to be similarly lifted to compensate</p>



<a name="226307338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226307338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226307338">(Feb 14 2021 at 14:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226181583">said</a>:</p>
<blockquote>
<p>If typeclass inference can call arbitrary tactics, that would be another way to support such a thing. I'm not sure where the design landed on that point. <span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> Do you know?</p>
</blockquote>
<p>There are no plans to do that anymore. Making the two systems mutually dependent would be insanity in the implementation, both on the term and (monad) type level. Having typeclass resolution and unification be interdependent is already complex enough.</p>



<a name="226330232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226330232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226330232">(Feb 14 2021 at 22:51)</a>:</h4>
<p>What do you mean by mutually dependent? What I am (coming around to) suggesting is more like a dynamically created typeclass instance, which is triggered on some syntactic condition that fits into the discrimination tree like <code>prime (ofNat n)</code> and calls a procedure that determines if this "instance" applies or not and returns a proof if so. It interacts minimally with the rest of the system, it's not delayed but is tried in order with other instances. These extensions can also live in the same monad as whatever typeclasses normally see, it doesn't have to be a full blown TacticM.</p>



<a name="226358202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226358202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226358202">(Feb 15 2021 at 08:57)</a>:</h4>
<p>Ok, that's a pretty different proposal</p>



<a name="226398445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226398445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226398445">(Feb 15 2021 at 15:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> are you proposing something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">InstanceGenerator</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">generate</span> <span class="o">:</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="n">MetaM</span> <span class="o">(</span><span class="n">Option</span> <span class="n">Expr</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> maybe just `Option Expr` -/</span>

<span class="kd">@[instanceGenerator]</span>
<span class="kd">def</span> <span class="n">generateOfNat</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">InstanceGenerator</span> <span class="o">(</span><span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">generate</span> <span class="n">goal</span> <span class="bp">=</span> <span class="k">do</span>
    <span class="c1">-- if n is concrete, do the recursion here to produce the instance in terms of bit0/bit1</span>
    <span class="gr">sorry</span>
<span class="o">}</span>
</code></pre></div>
<p>And then this thing is inserted into the DTree for the <code>α</code>, and tried like any other instance, except the custom <code>generate</code> code is called instead of the normal resolution step?</p>



<a name="226408019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226408019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226408019">(Feb 15 2021 at 16:59)</a>:</h4>
<p>Uh, kind of, although as a practical matter I think that mixing the two meta-levels in one statement will cause problems (you can't call the generator code unless you have an actual compiled type alpha with one, add, n). But you can probably hide the details behind a macro. Probably something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">InstanceGenerator</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">trigger</span> <span class="o">:</span> <span class="n">Expr</span>
  <span class="n">generate</span> <span class="o">:</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="n">MetaM</span> <span class="o">(</span><span class="n">Option</span> <span class="n">Expr</span><span class="o">)</span>

<span class="kd">@[instanceGenerator]</span>
<span class="kd">def</span> <span class="n">generateOfNat</span> <span class="o">:</span> <span class="n">InstanceGenerator</span> <span class="n">where</span>
  <span class="n">trigger</span> <span class="bp">=</span> <span class="bp">`</span><span class="o">({</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
  <span class="n">generate</span> <span class="n">goal</span> <span class="bp">=</span> <span class="k">do</span>
    <span class="c1">-- if n is concrete, do the recursion here to produce the instance in terms of bit0/bit1</span>
    <span class="gr">sorry</span>
</code></pre></div>
<p>I think the <code>generate</code> function should be in a monad, working with exprs without the elaborator functions is pretty hard, but it's fine if the determinism is expressed as a constraint to programmers, i.e. "we will cache the result of this instance so you might get incorrect results if your generator tactic depends on the phase of the moon"</p>



<a name="226408656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226408656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226408656">(Feb 15 2021 at 17:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226408019">said</a>:</p>
<blockquote>
<p>I think the <code>generate</code> function should be in a monad, working with exprs without the elaborator functions is pretty hard</p>
</blockquote>
<p>I don't think <code>TermElabM</code> will be on the table -- this proposal only seems plausible in the current design if the monad can easily lift to <code>SynthM</code>, which basically means it must be <code>MetaM</code>. What operations specifically do you think you will need to perform?</p>



<a name="226409382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409382">(Feb 15 2021 at 17:11)</a>:</h4>
<p>I'm not entirely sure, I haven't written enough lean 4 tactic code to say. In lean 3 it was certainly the case that life is a lot easier if you can use <code>to_expr</code> to build terms</p>



<a name="226409456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409456">(Feb 15 2021 at 17:12)</a>:</h4>
<p>or <code>mk_app</code></p>



<a name="226409549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409549">(Feb 15 2021 at 17:13)</a>:</h4>
<p>Maybe MetaM is fine. (Maybe SynthM? What's in there?)</p>



<a name="226409686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409686">(Feb 15 2021 at 17:14)</a>:</h4>
<p>The app-builder is in <code>MetaM</code>. <code>SynthM</code> is just some tabled-resolution metadata on top of <code>MetaM</code> and won't be helpful for this purpose.</p>



<a name="226409757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409757">(Feb 15 2021 at 17:15)</a>:</h4>
<p>I mention that only because it might be useful to see that metadata to prevent looping</p>



<a name="226409820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409820">(Feb 15 2021 at 17:16)</a>:</h4>
<p>Most leaf node instances won't need it</p>



<a name="226409921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226409921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226409921">(Feb 15 2021 at 17:17)</a>:</h4>
<p>Tabled resolution can still do its loop-prevention magic even with these instance generators. Tabling is orthogonal to how the "generator" nodes actually generate the subgoals. (aside: one of my <code>SearchT</code> extensions implements a very generic tabling algorithm)</p>



<a name="226410101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226410101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226410101">(Feb 15 2021 at 17:20)</a>:</h4>
<p>MetaM sounds good to me then</p>



<a name="226410863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226410863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226410863">(Feb 15 2021 at 17:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226408019">said</a>:</p>
<blockquote>
<p>...<br>
  trigger = `({α : Type} [One α] [Add α] (n : Nat) -&gt; OfNat α n)<br>
 ...</p>
</blockquote>
<p>Aside: I think it should just be the trigger itself, e.g. <code>OfNat ?α ?n</code> since that is the only thing a generator has to go on -- as long as you are in <code>MetaM</code>, you can then try synthesizing <code>One ?α</code> and <code>Add ?α</code> yourself.</p>
<p>EDIT: actually that would be insane since it would create separate <code>SynthM</code> invocations. You would need the original <code>SynthM</code> to solve the TC subgoals, and then trigger the generator function and pass it the instances. I don't have time right now to think about it carefully.</p>



<a name="226411237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226411237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226411237">(Feb 15 2021 at 17:30)</a>:</h4>
<p>FYI I linked to this thread from <a href="https://github.com/dselsam/mathport/issues/17">https://github.com/dselsam/mathport/issues/17</a></p>



<a name="226411693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226411693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226411693">(Feb 15 2021 at 17:34)</a>:</h4>
<p>Yeah it can just be whatever data structure the SynthM is working on</p>



<a name="226411960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226411960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226411960">(Feb 15 2021 at 17:36)</a>:</h4>
<p>although the postprocessing to put this into a usable form in the discrimination tree on <code>@[instanceGenerator]</code> has room to manipulate the term before entering it; the notation <code>  `({α : Type} [One α] [Add α] (n : Nat) -&gt; OfNat α n)</code> is mostly to make it easy for users to specify the signature</p>



<a name="226412155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226412155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226412155">(Feb 15 2021 at 17:38)</a>:</h4>
<p>and as I alluded to above, this can all be hidden behind a macro so that you are writing something more like your earlier version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">instanceGenerator</span> <span class="n">generateOfNat</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span> <span class="n">where</span>
  <span class="n">generate</span> <span class="n">goal</span> <span class="bp">=</span> <span class="k">do</span>
    <span class="c1">-- if n is concrete, do the recursion here to produce the instance in terms of bit0/bit1</span>
    <span class="gr">sorry</span>
</code></pre></div>



<a name="226412274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226412274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226412274">(Feb 15 2021 at 17:39)</a>:</h4>
<p>See my EDIT above: <a href="#narrow/stream/270676-lean4/topic/mathport/near/226410863">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226410863</a></p>



<a name="226412458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226412458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226412458">(Feb 15 2021 at 17:40)</a>:</h4>
<p>That's sort of what I meant by preventing loops, if you restart the instance context you can get into trouble</p>



<a name="226412517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226412517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226412517">(Feb 15 2021 at 17:41)</a>:</h4>
<p>I think that means that we need a version of <code>mkAppM</code> in SynthM that does typeclass inference in that monad instead of firing up a new one</p>



<a name="226412812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226412812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226412812">(Feb 15 2021 at 17:44)</a>:</h4>
<p>Currently in TC, at each node the generated instance is constructed before the subgoals are solved, in terms of the metavariables representing the subgoals. You might need to generalize this part, so that your <code>generate</code> function is executed eagerly on these arguments instead of just being applied to them (and so can only inspect non-metavariable goals, e.g. <code>n</code> in the <code>OfNat</code> example)</p>



<a name="226413037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226413037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226413037">(Feb 15 2021 at 17:46)</a>:</h4>
<p>In this example, the fact that the signature is <code>{α : Type} [One α] [Add α] (n : Nat) : OfNat α n</code> means that the ambient TC process is responsible for supplying values of <code>One</code> and <code>Add</code>. The generator only has to create an instance once these are known</p>



<a name="226413149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226413149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226413149">(Feb 15 2021 at 17:47)</a>:</h4>
<p>I suppose it's possible to hand these subgoals to the generator and require it to call some function to continue TC inference on those subgoals, but that seems like eliminable boilerplate unless the generator somehow wants to control the timing of this resolution</p>



<a name="226413351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226413351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226413351">(Feb 15 2021 at 17:49)</a>:</h4>
<p>Also you somehow need to signal what of the goal needs to be concrete, for example <code>n</code> has to not be a metavariable when the generator is called, or at least it needs to be considered for calling again when <code>n</code> is resolved</p>



<a name="226413431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226413431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226413431">(Feb 15 2021 at 17:50)</a>:</h4>
<p>possibly the usual rules about TC outParams and such are sufficient</p>



<a name="226414027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414027">(Feb 15 2021 at 17:55)</a>:</h4>
<p>Maybe all you need is a way to register an <code>Expr -&gt; MetaM Expr</code> postprocessor for a regular instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">instBits2Nat</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">@[postprocessFor instBits2Nat]</span> <span class="kd">def</span> <span class="n">expandBits2Nat</span> <span class="o">(</span><span class="n">instVal</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="o">(</span><span class="n">Option</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">instVal</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">instBits2Nat</span> <span class="n">_</span> <span class="n">one</span> <span class="n">add</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="c">/-</span><span class="cm"> recurse on n, build bit0/bit1 term -/</span>
</code></pre></div>
<p>Then this postprocess function could be called here: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319</a></p>



<a name="226414227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414227">(Feb 15 2021 at 17:57)</a>:</h4>
<p>What would go in the <code>...</code>? <code>sorry</code>?</p>



<a name="226414368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414368">(Feb 15 2021 at 17:58)</a>:</h4>
<p>Because I'm considering in particular the case where the instance is allowed to fail for some values of its arguments, like my earlier example of <code>instance generatePrime : prime n := ...</code></p>



<a name="226414390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414390">(Feb 15 2021 at 17:59)</a>:</h4>
<p>There should be some front-end way of not needing to provide that value at all, e.g. with your <code>InstanceGenerator</code> type that takes a target and a post-process function. The point of the comment was that it shouldn't be <code>generate</code>, it should be <code>postprocess</code> and it should see the metavariables corresponding to the TC subgoals.</p>



<a name="226414518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414518">(Feb 15 2021 at 18:00)</a>:</h4>
<p>It wouldn't be the end of the world to use <code>sorry</code> there, since as you say it's going to be postprocessed away</p>



<a name="226414594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414594">(Feb 15 2021 at 18:00)</a>:</h4>
<p>although if the instance generator fails during postprocessing you might be in deep trouble</p>



<a name="226414740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414740">(Feb 15 2021 at 18:02)</a>:</h4>
<p>Syntactically I would probably prefer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[instanceGenerator]</span>
<span class="kd">def</span> <span class="n">expandBits2Nat</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">InstanceGenerator</span> <span class="o">(</span><span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">postProcess</span> <span class="o">(</span><span class="n">instVal</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="o">(</span><span class="n">Option</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="o">}</span>
</code></pre></div>



<a name="226414807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414807">(Feb 15 2021 at 18:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/mathport/near/226414594">said</a>:</p>
<blockquote>
<p>although if the instance generator fails during postprocessing you might be in deep trouble</p>
</blockquote>
<p>I changed it to <code>MetaM (Option Expr)</code> in the example.</p>



<a name="226414835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414835">(Feb 15 2021 at 18:03)</a>:</h4>
<p>I suppose that can be transformed to what I mentioned, if attribute macros have that much power, but that's quite a lie of a type signature</p>



<a name="226414977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226414977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226414977">(Feb 15 2021 at 18:04)</a>:</h4>
<p>when is the postprocessor called? I meant that if it fails you still want to be able to try the next instance</p>



<a name="226415136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226415136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226415136">(Feb 15 2021 at 18:05)</a>:</h4>
<p>Here: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319</a><br>
You just return <code>none</code> if it fails, and it is as if the types didn't unify in a normal TC generation step.</p>



<a name="226746425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226746425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226746425">(Feb 17 2021 at 23:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Here is a lightweight implementation of the instance-post-processor proposal: <a href="https://github.com/dselsam/lean4/commit/c3c74f8ac273e93dfd6340cf94bf0cfb1f867286">https://github.com/dselsam/lean4/commit/c3c74f8ac273e93dfd6340cf94bf0cfb1f867286</a> Can you please play around with it and see if it supports all the use-cases you had in mind?</p>



<a name="226747933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226747933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226747933">(Feb 18 2021 at 00:11)</a>:</h4>
<p>Well, I don't know how to compile lean 4 yet but I can guess based on the code. Is the <code>nat2Bits</code> function required in this implementation? I think I would rather have <code>instBits2Nat</code> be an axiom or, even better, something that doesn't type check, so that if the postprocessor fails to do its job then an error is triggered</p>



<a name="226750981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226750981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226750981">(Feb 18 2021 at 00:49)</a>:</h4>
<p>It can be a constant as well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[instance]</span> <span class="kd">constant</span> <span class="n">instBits2Nat</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="n">n</span>
</code></pre></div>



<a name="226751125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226751125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226751125">(Feb 18 2021 at 00:50)</a>:</h4>
<p>We can nail down ergonomics later though -- the more salient question is whether the capability is adequate.</p>



<a name="226754561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226754561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226754561">(Feb 18 2021 at 01:40)</a>:</h4>
<p>I think so. What happens to the <code>"foo"</code> error message if it fails? It would be nice for this to show up in the instance trace, but not essential</p>



<a name="226755256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226755256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226755256">(Feb 18 2021 at 01:51)</a>:</h4>
<p>Good question. In the version I pushed, <code>synth</code> does not catch that exception, so you just see e.g. <code>/home/dselsam/omega/lean4/tests/lean/instancePostProcessor.lean:44:8: error: foo</code>. That is a programmer error though -- a post-processor can fail gracefully by returning <code>pure none</code>.</p>



<a name="226758668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226758668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226758668">(Feb 18 2021 at 02:55)</a>:</h4>
<p>There was an example that came up recently about fin numerals which are appropriately bounded. I haven't tested this but hopefully this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Lean.Meta</span>

<span class="kd">structure</span> <span class="n">Fin2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span>  <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">isLt</span> <span class="o">:</span> <span class="n">Nat.ble</span> <span class="n">n</span> <span class="n">val</span> <span class="bp">=</span> <span class="n">false</span>

<span class="kd">def</span> <span class="n">Fin2.OfNat</span> <span class="o">(</span><span class="n">i</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Nat.ble</span> <span class="n">n</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">false</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Fin2</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩⟩</span>

<span class="kd">@[instance]</span> <span class="kd">axiom</span> <span class="n">finOfNatFake</span> <span class="o">(</span><span class="n">i</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Fin2</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span>

<span class="kd">@[instancePostProcessor finOfNatFake]</span>
<span class="kd">def</span> <span class="n">finOfNatPostProcessor</span> <span class="o">:</span> <span class="n">Lean.Meta.InstancePostProcessor</span> <span class="n">where</span>
  <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="bp">#</span><span class="o">[</span><span class="n">ei</span><span class="o">,</span> <span class="n">en</span><span class="o">]</span> <span class="bp">←</span> <span class="n">pure</span> <span class="n">e.getAppArgs</span> <span class="bp">|</span> <span class="n">throwError</span> <span class="s2">"foo"</span>
    <span class="k">let</span> <span class="n">some</span> <span class="n">i</span> <span class="bp">←</span> <span class="n">pure</span> <span class="o">(</span><span class="bp">←</span> <span class="n">instantiateMVars</span> <span class="o">(</span><span class="bp">←</span> <span class="n">whnf</span> <span class="n">ei</span><span class="o">))</span><span class="bp">.</span><span class="n">natLit</span><span class="bp">?</span> <span class="bp">|</span> <span class="n">pure</span> <span class="n">none</span>
    <span class="k">let</span> <span class="n">some</span> <span class="n">n</span> <span class="bp">←</span> <span class="n">pure</span> <span class="o">(</span><span class="bp">←</span> <span class="n">instantiateMVars</span> <span class="o">(</span><span class="bp">←</span> <span class="n">whnf</span> <span class="n">en</span><span class="o">))</span><span class="bp">.</span><span class="n">natLit</span><span class="bp">?</span> <span class="bp">|</span> <span class="n">pure</span> <span class="n">none</span>
    <span class="k">if</span> <span class="n">i</span> <span class="bp">≥</span> <span class="n">n</span> <span class="k">then</span> <span class="n">return</span> <span class="n">none</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="n">some</span> <span class="bp">$</span> <span class="n">mkApp3</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">`</span><span class="n">Fin.OfNat</span><span class="o">)</span> <span class="n">ei</span> <span class="n">en</span> <span class="bp">$</span>
      <span class="n">mkApp2</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">Eq.refl</span> <span class="o">[</span><span class="n">levelOne</span><span class="o">])</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">toExpr</span> <span class="n">false</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- works</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- works</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- works</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- fails</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- fails</span>
</code></pre></div>
<p>(I'm redeclaring <code>Fin</code> so that the existing instance doesn't trigger as fallback.)</p>



<a name="226759912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226759912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226759912">(Feb 18 2021 at 03:17)</a>:</h4>
<p>Your example exposes an issue :) Currently when no post-processor succeeds, the axiom <code>finOfNatFake</code> remains in the proof. Your example has a few small errors so FYI here is a version that runs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Lean.Meta</span>

<span class="kd">structure</span> <span class="n">Fin2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span>  <span class="o">:</span> <span class="n">Nat</span>
  <span class="n">isLt</span> <span class="o">:</span> <span class="n">Nat.ble</span> <span class="n">n</span> <span class="n">val</span> <span class="bp">=</span> <span class="n">false</span>

<span class="kd">def</span> <span class="n">Fin2.OfNat</span> <span class="o">(</span><span class="n">i</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Nat.ble</span> <span class="n">n</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">false</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Fin2</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩⟩</span>

<span class="kd">@[instance]</span> <span class="kd">axiom</span> <span class="n">finOfNatFake</span> <span class="o">(</span><span class="n">i</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Fin2</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span>

<span class="kd">@[instancePostProcessor finOfNatFake]</span>
<span class="kd">def</span> <span class="n">finOfNatPostProcessor</span> <span class="o">:</span> <span class="n">Lean.Meta.InstancePostProcessor</span> <span class="n">where</span>
  <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="bp">#</span><span class="o">[</span><span class="n">ei</span><span class="o">,</span> <span class="n">en</span><span class="o">]</span> <span class="bp">←</span> <span class="o">(</span><span class="n">e.getAppArgs.mapM</span> <span class="bp">λ</span> <span class="n">arg</span> <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">arg</span> <span class="bp">←</span> <span class="n">instantiateMVars</span> <span class="n">arg</span>
      <span class="k">let</span> <span class="n">arg'</span> <span class="bp">←</span> <span class="n">whnfD</span> <span class="n">arg</span>
      <span class="n">pure</span> <span class="n">arg'</span><span class="o">)</span> <span class="bp">|</span> <span class="n">throwError</span> <span class="s2">"foo"</span>
    <span class="k">match</span> <span class="o">(</span><span class="n">ei.natLit</span><span class="bp">?</span><span class="o">,</span> <span class="n">en.natLit</span><span class="bp">?</span><span class="o">)</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">i</span><span class="o">,</span> <span class="n">some</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">if</span> <span class="n">i</span> <span class="bp">≥</span> <span class="n">n</span> <span class="k">then</span> <span class="n">pure</span> <span class="n">none</span> <span class="k">else</span>
       <span class="n">pure</span> <span class="bp">$</span> <span class="n">some</span> <span class="bp">$</span> <span class="n">mkApp3</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">`</span><span class="n">Fin2.OfNat</span><span class="o">)</span> <span class="n">ei</span> <span class="n">en</span> <span class="bp">$</span>
         <span class="n">mkApp2</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">Eq.refl</span> <span class="o">[</span><span class="n">levelOne</span><span class="o">])</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">``</span><span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">toExpr</span> <span class="n">false</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">other</span> <span class="bp">=&gt;</span>
      <span class="n">pure</span> <span class="n">none</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- works</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">Fin2</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- whoops, works with `finOfNatFake`</span>
</code></pre></div>



<a name="226759983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226759983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226759983">(Feb 18 2021 at 03:18)</a>:</h4>
<p>Maybe <em>if</em> there are post-processors for an instance, then it is a failure if none of them work</p>



<a name="226760096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226760096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226760096">(Feb 18 2021 at 03:20)</a>:</h4>
<p>Yeah, I don't think it's a problem if there is only one postprocessor per instance, and it overrides whatever match status you get from the original. That makes more sense with the original model anyway</p>



<a name="226760141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226760141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226760141">(Feb 18 2021 at 03:21)</a>:</h4>
<p>In fact, I think it is dangerous to allow multiple postprocessors on one instance, because if the first one modifies the expression and the second one expects it to be a constant application then you will hit that <code>throwError "foo"</code> line</p>



<a name="226760385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226760385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/mathport.html#226760385">(Feb 18 2021 at 03:26)</a>:</h4>
<p>FYI the commit above just picks the first post-processor that doesn't return <code>none</code>. It doesn't iterate multiple post-processors.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
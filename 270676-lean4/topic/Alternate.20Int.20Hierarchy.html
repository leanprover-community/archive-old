---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html">Alternate Int Hierarchy</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240773164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240773164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240773164">(May 30 2021 at 20:44)</a>:</h4>
<p><strong>I am not sure whether or not this belongs here or in a different channel.</strong> However, I am writing it in Lean 4 so I am sticking it here. If it should go elsewhere, feel free to move it. </p>
<p>I was exploring alternate definitions of <code>Nat</code>/<code>Int</code> and was curious if anyone saw any immediate flaws with this definition of numbers:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">AltInt</span>

<span class="kd">inductive</span> <span class="n">PNat</span>
<span class="bp">|</span> <span class="n">one</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">PNat</span> <span class="bp">-&gt;</span> <span class="n">PNat</span>

<span class="kd">def</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">Option</span> <span class="n">PNat</span>

<span class="kd">inductive</span> <span class="n">Dipole</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">Dipole</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">Dipole</span> <span class="n">A</span>

<span class="kd">def</span> <span class="n">NzInt</span> <span class="o">:=</span> <span class="n">Dipole</span> <span class="n">PNat</span>
<span class="kd">def</span> <span class="n">Int</span> <span class="o">:=</span> <span class="n">Option</span> <span class="n">NzInt</span>
</code></pre></div>
<p>In particular, I am curious as to why Lean 4 proper doesn't go the <code>Int := zero | pos PNat | neg PNat</code> route for integers since that seems a lot simpler tan the <code>Int := ofNat Nat | negSucc Nat</code> that is currently used.</p>
<p>It also allows for the following definition of natural (truncating) division (which I think is correct -- haven't proven it yet though) that seems much simpler than what is currently used in core (for one, it uses structural rather than well-founded recursion):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- using the defs above</span>

<span class="kn">namespace</span> <span class="n">Nat</span>

<span class="kd">@[matchPattern]</span> <span class="kd">def</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">none</span>
<span class="kd">@[matchPattern]</span> <span class="kd">def</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="n">PNat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">some</span>
<span class="kd">@[matchPattern]</span> <span class="kd">def</span> <span class="n">one</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">PNat.one</span>

<span class="kd">@[matchPattern]</span>
<span class="kd">def</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">one</span>
<span class="bp">|</span> <span class="n">nonzero</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">nonzero</span> <span class="o">(</span><span class="n">PNat.succ</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">Nat</span>

<span class="kn">namespace</span> <span class="n">PNat</span>

<span class="kd">def</span> <span class="n">succSubDivTrunc</span> <span class="o">:</span>  <span class="n">PNat</span> <span class="bp">-&gt;</span> <span class="n">PNat</span> <span class="bp">-&gt;</span> <span class="n">PNat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">one</span><span class="o">,</span> <span class="n">one</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat.one</span>
<span class="bp">|</span> <span class="n">one</span><span class="o">,</span> <span class="n">succ</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat.zero</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="n">m</span><span class="o">,</span> <span class="n">one</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">succSubDivTrunc</span> <span class="n">m</span> <span class="n">n</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="n">m</span><span class="o">,</span> <span class="n">succ</span> <span class="n">r</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">succSubDivTrunc</span> <span class="n">m</span> <span class="n">r</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">divTrunc</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">PNat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">succSubDivTrunc</span> <span class="n">m</span> <span class="n">n</span> <span class="n">n</span>

<span class="kd">end</span> <span class="n">PNat</span>
</code></pre></div>
<p><strong>Any comments, insights, etc.?</strong> They would be much appreciated.</p>



<a name="240773505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240773505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240773505">(May 30 2021 at 20:53)</a>:</h4>
<p>I'm surprised that you say a construction with three constructors is "a lot simpler" than a construction with two constructors. How are you going to prove associativity of addition using the three-constructor definition -- you have 27 cases to deal with I guess.</p>



<a name="240773636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240773636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240773636">(May 30 2021 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy/near/240773505">said</a>:</p>
<blockquote>
<p>I'm surprised that you say a construction with three constructors is "a lot simpler" than a construction with two constructors. How are you going to prove associativity of addition using the three-constructor definition -- you have 27 cases to deal with I guess.</p>
</blockquote>
<p>The constructors are nested though. So you prove associativity for the levels separately, greatly reducing the number of cases. You can then use the inner proofs in the proofs of the outer cases.</p>



<a name="240773864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240773864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240773864">(May 30 2021 at 21:02)</a>:</h4>
<p>For example, for <code>Nat</code>, you can show that <code>a + b + nonzero c = nonzero (a + b + c) </code> and then use the associative property for <code>PNat</code> add to prove associativity for <code>Nat</code>.</p>



<a name="240774158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240774158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240774158">(May 30 2021 at 21:09)</a>:</h4>
<p>Then why even define <code>PNat</code> (for the definition of <code>Int</code>), when it is clearly isomorphic to <code>Nat</code>?</p>



<a name="240774426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240774426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240774426">(May 30 2021 at 21:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy/near/240774158">said</a>:</p>
<blockquote>
<p>Then why even define <code>PNat</code> (for the definition of <code>Int</code>), when it is clearly isomorphic to <code>Nat</code>?</p>
</blockquote>
<p>Because it is in many cases semantically different?  For example, the <code>divTrunc</code> definition wouldn't work for <code>Nat</code>. Sure I could pretend that<code>Nat</code>'s <code>zero</code> meant <code>one</code>, but that conceptual disconnect seems undesirable. Mathlib (version 3 at least) also defines a <code>pnat</code> (though that definition is propositional), so a desire for the conceptual distinction seems reasonable.</p>



<a name="240774719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/240774719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#240774719">(May 30 2021 at 21:22)</a>:</h4>
<p>(deleted)</p>



<a name="244318985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244318985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244318985">(Jun 29 2021 at 17:39)</a>:</h4>
<p>I was trying to do something similar ​as well as I found it more elegant</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">Nat</span>

<span class="kd">inductive</span> <span class="n">int</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">int</span>
<span class="bp">|</span> <span class="n">pos_succ</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">int</span>
<span class="bp">|</span> <span class="n">neg_succ</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">int</span>

<span class="kn">open</span> <span class="n">int</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">`pos_succ (Nat.zero)` is the representation of +1</span>
<span class="cm">`neg_succ (Nat.zero)` is the representation for -1</span>
<span class="cm">-/</span>

<span class="kd">def</span> <span class="n">int.incr</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:=</span>
 <span class="bp">​</span><span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
 <span class="bp">​|</span> <span class="n">int.zero</span> <span class="bp">=&gt;</span> <span class="n">pos_succ</span> <span class="o">(</span><span class="n">Nat.zero</span><span class="o">)</span>
 <span class="bp">​|</span> <span class="n">pos_succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">pos_succ</span> <span class="o">(</span><span class="n">a.succ</span><span class="o">)</span>
 <span class="bp">​|</span> <span class="n">neg_succ</span> <span class="n">b</span> <span class="bp">=&gt;</span>
   <span class="bp">​</span><span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
   <span class="bp">​|</span> <span class="n">Nat.zero</span> <span class="bp">=&gt;</span> <span class="n">int.zero</span>
   <span class="bp">​|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">neg_succ</span> <span class="n">b</span>

<span class="k">#reduce</span> <span class="o">(</span><span class="n">neg_succ</span> <span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">incr.incr.incr.incr.incr</span>

<span class="kd">def</span> <span class="n">int.decr</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:=</span>
 <span class="bp">​</span><span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
 <span class="bp">​|</span> <span class="n">int.zero</span> <span class="bp">=&gt;</span> <span class="n">neg_succ</span> <span class="o">(</span><span class="n">Nat.zero</span><span class="o">)</span>
 <span class="bp">​|</span> <span class="n">neg_succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">neg_succ</span> <span class="o">(</span><span class="n">a.succ</span><span class="o">)</span>
 <span class="bp">​|</span> <span class="n">pos_succ</span> <span class="n">b</span> <span class="bp">=&gt;</span>
   <span class="bp">​</span><span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
   <span class="bp">​|</span> <span class="n">Nat.zero</span> <span class="bp">=&gt;</span> <span class="n">int.zero</span>
   <span class="bp">​|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">pos_succ</span> <span class="n">b</span>

<span class="k">#reduce</span> <span class="o">(</span><span class="n">pos_succ</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">decr.decr.decr.decr</span>

<span class="kd">def</span> <span class="n">add_int_Nat</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>  <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
 <span class="bp">​</span><span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
 <span class="bp">​|</span> <span class="n">Nat.zero</span> <span class="bp">=&gt;</span> <span class="n">a</span>
 <span class="bp">​|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">add_int_Nat</span> <span class="n">a.incr</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">sub_int_Nat</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>  <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
     <span class="bp">​</span><span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
     <span class="bp">​|</span> <span class="n">Nat.zero</span> <span class="bp">=&gt;</span> <span class="n">a</span>
     <span class="bp">​|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">sub_int_Nat</span> <span class="n">a.decr</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
 <span class="bp">​</span><span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
 <span class="bp">​|</span> <span class="n">int.zero</span> <span class="bp">=&gt;</span> <span class="n">b</span>
 <span class="bp">​|</span> <span class="n">pos_succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">add_int_Nat</span> <span class="n">b</span> <span class="n">a.succ</span>
 <span class="bp">​|</span> <span class="n">neg_succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">sub_int_Nat</span> <span class="n">b</span> <span class="n">a.succ</span>

<span class="k">#reduce</span> <span class="n">add</span> <span class="o">(</span><span class="n">pos_succ</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">neg_succ</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">-- pos_succ 2</span>
</code></pre></div>
<p>And I am indeed struggling to prove associativity</p>



<a name="244323624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244323624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244323624">(Jun 29 2021 at 18:11)</a>:</h4>
<p>One approach is to, regardless of the specific definition of <code>int</code>, start by defining its eliminator based on an <code>equiv</code>, and prove it satisfies the correct equations. After that, there will be no more case analyses. Now you can define <code>add</code> and <code>mul</code>.</p>



<a name="244323783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244323783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244323783">(Jun 29 2021 at 18:12)</a>:</h4>
<p>You also need to prove <code>int.incr</code> and <code>int.decr</code> form an <code>equiv</code> first.</p>



<a name="244326497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244326497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244326497">(Jun 29 2021 at 18:31)</a>:</h4>
<p>I'm still at a pretty basic level... I get that <code>incr</code> and <code>decr</code> can form an <code>equiv</code>, but can you unpack the part about defining an eliminator based on an equiv a bit more?</p>



<a name="244326663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244326663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244326663">(Jun 29 2021 at 18:32)</a>:</h4>
<p>There is no need for a new type, you can do this type of matching on <code>Int</code> itself!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[matchPattern]</span> <span class="n">abbrev</span> <span class="n">Int.posSucc</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ofNat</span> <span class="n">n.succ</span>

<span class="kd">def</span> <span class="n">Int.incr</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">posSucc</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">posSucc</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">posSucc</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">negSucc</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">negSucc</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">negSucc</span> <span class="n">n</span>
</code></pre></div>
<p>And so on...</p>



<a name="244327755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244327755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244327755">(Jun 29 2021 at 18:40)</a>:</h4>
<p>My <em>guess</em> is that Reid is suggesting that given a type X, a term <code>z : X</code> and an equiv X ~= X you can get a map from <code>int</code> to X -- and furthermore this classifies int up to unique isomorphism as an initial object.</p>



<a name="244328591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244328591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244328591">(Jun 29 2021 at 18:47)</a>:</h4>
<p>Yes that's right. Something like <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate">docs#nat.iterate</a> but with an <code>equiv</code> as the input.<br>
The key point is that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> is an equiv, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><msup><mi>e</mi><mi>n</mi></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(e^n(x)) = e^{n+1}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> holds not just for positive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> (by definition) but also for negative <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>--this uses the equations of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>--and likewise <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msup><mi>e</mi><mi>n</mi></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e^{-1}(e^n(x)) = e^{n-1}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> also for positive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p>



<a name="244328679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244328679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244328679">(Jun 29 2021 at 18:47)</a>:</h4>
<p>Then you can combine this with an induction principle like "if P(0) and P(n) =&gt; P(n+1) and P(n) =&gt; P(n-1) then P(n) holds for all n" and never worry again about whether numbers are positive or negative.</p>



<a name="244328932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244328932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244328932">(Jun 29 2021 at 18:49)</a>:</h4>
<p>The difficulty with giving a direct by-cases definition of <code>add</code> and running with it is that you will know by definition that (say) <code>a + (b + 1) = (a + b) + 1</code> when <code>b</code> is positive, but not when it's negative. So you end up with cases everywhere, and you will have to use the fact that <code>succ</code> and <code>pred</code> cancel manually.</p>



<a name="244329022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244329022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244329022">(Jun 29 2021 at 18:50)</a>:</h4>
<p>I have to go for now but I can try to write up something later if it remains unclear.</p>



<a name="244329082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244329082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244329082">(Jun 29 2021 at 18:50)</a>:</h4>
<p>If it helps, here's a little API for int.iterate which we wrote at Imperial as part of a group theory project: <a href="https://github.com/ImperialCollegeLondon/group-theory-game/blob/152ec4a92ad67b6174a3d240c63fa56a6df6017e/src/int/iterate.lean">https://github.com/ImperialCollegeLondon/group-theory-game/blob/152ec4a92ad67b6174a3d240c63fa56a6df6017e/src/int/iterate.lean</a></p>



<a name="244329814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244329814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244329814">(Jun 29 2021 at 18:56)</a>:</h4>
<p>Right, this sort of thing is what I had in mind but you might need to organize some things a bit differently if you don't have <code>int.add</code> yet.</p>



<a name="244332498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244332498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244332498">(Jun 29 2021 at 19:14)</a>:</h4>
<p>Is this similar to well founded recursion by ordering the integers like 0, -1, 1, -2, 2 etc ?</p>



<a name="244332583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244332583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244332583">(Jun 29 2021 at 19:15)</a>:</h4>
<p>A similar trick to the one I mentioned above works for simulating the inductive definition of <code>Int</code> in terms of positive integers as @Mac originally intended. The additional cost is a weird definition of positive integers as follows.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Pos</span> <span class="o">:=</span> <span class="n">Nat</span>

<span class="kn">namespace</span> <span class="n">Pos</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">one</span> <span class="o">:</span> <span class="n">Pos</span> <span class="o">:=</span> <span class="n">Nat.zero</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">Pos</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Pos.one</span><span class="o">⟩</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Pos</span> <span class="o">:=</span> <span class="n">Nat.succ</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Pos</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">Pos</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Pos.add</span><span class="o">⟩</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Pos</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Nat.add</span> <span class="o">(</span><span class="n">Nat.mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Mul</span> <span class="n">Pos</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Pos.mul</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">Pos</span>
</code></pre></div>
<p>Then this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[matchPattern]</span> <span class="n">abbrev</span> <span class="n">Int.ofPos</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Int</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Int.ofNat</span> <span class="n">n.succ</span>
<span class="kd">@[matchPattern]</span> <span class="n">abbrev</span> <span class="n">Int.negOfPos</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Int</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Int.negSucc</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">Int.decr</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">ofPos</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">ofPos</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">ofPos</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">negOfPos</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">negOfPos</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">negOfPos</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>In other words, we can always pretend <code>Int</code> is defined as @Mac wants</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Int</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">ofPos</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">negOfPos</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Int</span>
</code></pre></div>
<p>or as @Brandon wants</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Int</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">posSucc</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">negSucc</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Int</span>
</code></pre></div>
<p>even though the real definition of <code>Int</code> is actually</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Int</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ofNat</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">negSucc</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Int</span>
</code></pre></div>



<a name="244337093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244337093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244337093">(Jun 29 2021 at 19:49)</a>:</h4>
<p>That's an interesting trick, François</p>



<a name="244352647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Alternate%20Int%20Hierarchy/near/244352647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy.html#244352647">(Jun 29 2021 at 21:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119741">François G. Dorais</span> <a href="#narrow/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy/near/244332583">said</a>:</p>
<blockquote>
<p>In other words, we can always pretend <code>Int</code> is defined as @Mac wants</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Int</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">ofPos</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Int</span>
<span class="bp">|</span> <span class="n">negOfPos</span> <span class="o">:</span> <span class="n">Pos</span> <span class="bp">→</span> <span class="n">Int</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This <em>is</em> a neat trick! :) </p>
<p>However, it largely defeats the purpose of the original definition. The point of the original definition is to all for the conditions of nonzero/positive/negative to be defined structurally at type level rather than via an attendant proof. </p>
<p>That is, with my alternate definition, you would no longer need conditions like <code>h : a /= 0</code> or <code>h : a &gt; 0</code> you could just pass a <code>NzInt</code> or <code>PNat</code> and be guaranteed that by the type. You can, of course, simulate this by creating a new bundle type that bundles a <code>Nat</code>/<code>Int</code> but that has annoying implications when in proofs and pattern matches as the type is now much more structurally complex and a lot of thing snow have to be proved rather than just holding structurally. </p>
<p>The  use of the <code>Option</code> (or an equivalent <code>Zeroid  a := zero | nonzero a</code> type) provides similar structural benefits to proofs/definitions and allows for easy generalization among multiple possibly zero types (i.e., <code>Nat</code>, <code>Int</code>, <code>Rat</code>, etc.). While a zero monoid also does the latter, <code>Zeroid</code> does it structurally, which is useful in many cases.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
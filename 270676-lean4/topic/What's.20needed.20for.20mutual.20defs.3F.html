---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html">What's needed for mutual defs?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="286214112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286214112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286214112">(Jun 15 2022 at 13:49)</a>:</h4>
<p>Hi! Not sure how troublesome this is but we're trying to make <code>mutual</code> blocks with a somewhat minimal baggage. What else do we need to make this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">prelude</span>

<span class="kd">def</span> <span class="n">id</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kd">inductive</span> <span class="n">Unit</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">unit</span>

<span class="kd">inductive</span> <span class="n">Bar</span>
  <span class="bp">|</span> <span class="n">hi</span> <span class="bp">|</span> <span class="n">bye</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">Bar.hi</span>

<span class="kd">inductive</span> <span class="n">MyNat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">MyNat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">MyNat</span> <span class="bp">→</span> <span class="n">MyNat</span>

<span class="kd">structure</span> <span class="n">PProd</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">fst</span> <span class="o">:</span> <span class="n">α</span>
  <span class="n">snd</span> <span class="o">:</span> <span class="n">β</span>

<span class="kd">mutual</span>

  <span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">MyNat</span> <span class="bp">→</span> <span class="n">MyNat</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">zero</span>
  <span class="c1">-- tactic 'cases' failed, nested error:</span>
  <span class="c1">-- tactic 'cases' failed, not applicable to the given hypothesis</span>
  <span class="c1">-- _fun_discr✝ : MyNat</span>
  <span class="c1">-- motive : MyNat → Sort ?u.74</span>
  <span class="c1">-- h_1 : Unit → motive MyNat.zero</span>
  <span class="c1">-- h_2 : (n : MyNat) → motive (MyNat.succ n)</span>
  <span class="c1">-- ⊢ motive _fun_discr✝ after processing</span>
  <span class="c1">--   _</span>
  <span class="c1">-- the dependent pattern matcher can solve the following kinds of equations</span>
  <span class="c1">-- - &lt;var&gt; = &lt;term&gt; and &lt;term&gt; = &lt;var&gt;</span>
  <span class="c1">-- - &lt;term&gt; = &lt;term&gt; where the terms are definitionally equal</span>
  <span class="c1">-- - &lt;constructor&gt; = &lt;constructor&gt;, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil</span>
  <span class="c1">--     | .succ n =&gt; (g n).succ</span>

  <span class="kd">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">MyNat</span> <span class="bp">→</span> <span class="n">MyNat</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">zero</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>

<span class="kd">end</span>
</code></pre></div>



<a name="286214734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286214734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286214734">(Jun 15 2022 at 13:54)</a>:</h4>
<p>You should probably get comfortable with navigating the Lean source code if that's your goal. For example, starting at "tactic 'cases' failed, not applicable to the given hypothesis" you should soon find the next missing type.</p>



<a name="286216294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286216294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286216294">(Jun 15 2022 at 14:05)</a>:</h4>
<p>Sorry, the error message is cryptic to me :/<br>
I can't parse that there is a missing type, so I can't parse what the missing type is</p>



<a name="286216337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286216337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286216337">(Jun 15 2022 at 14:05)</a>:</h4>
<p>BTW, when defining your own prelude, be aware of the issue <a href="https://github.com/leanprover/lean4/issues/188">https://github.com/leanprover/lean4/issues/188</a></p>



<a name="286217162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286217162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286217162">(Jun 15 2022 at 14:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286216294">said</a>:</p>
<blockquote>
<p>Sorry, the error message is cryptic to me :/<br>
I can't parse that there is a missing type, so I can't parse what the missing type is</p>
</blockquote>
<p>That's why I talked about navigating the codebase: if you grep for the message (preferable the second half, as the first half could be templated), you're already very close.</p>



<a name="286218336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286218336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286218336">(Jun 15 2022 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> Regarding <a href="https://github.com/leanprover/lean4/pull/188">lean4#188</a>, I think lean should have something like rust's "lang items": when you declare <code>Nat</code> you would put a <code>@[lang]</code> (or <code>@[lang = "Nat"]</code>) attribute on it and this would use the given key / the declaration name to determine what to check about the definition</p>



<a name="286218451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286218451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286218451">(Jun 15 2022 at 14:20)</a>:</h4>
<p>This is also useful for documenting which types have extra special compiler magic on top of the usual</p>



<a name="286219819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286219819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286219819">(Jun 15 2022 at 14:29)</a>:</h4>
<p>(The <code>@[lang = "Nat"]</code> form would allow decoupling lang items from their names, so that for example you could declare it to have the name <code>nat</code> instead in a custom prelude. But this would require plumbing the name lookups everywhere instead of hardcoding names like <code> `Nat.add</code> around and personally I don't think it's worth it.)</p>



<a name="286220056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286220056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286220056">(Jun 15 2022 at 14:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286217162">said</a>:</p>
<blockquote>
<p>grep for the message</p>
</blockquote>
<p>Ah, now I understood the idea. Thanks!</p>



<a name="286258969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286258969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286258969">(Jun 15 2022 at 19:07)</a>:</h4>
<p>So, apparently <a href="https://github.com/leanprover/lean4/blob/ce78c17f2d0602bcf8201181938a97a048e3bcf7/src/Lean/Meta/Tactic/Cases.lean#L147">this match</a> is falling in the "anything else" case, which means that <code>casesOn</code> is not being found in the environment. However, I couldn't find a <code>casesOn</code> type that I could add to my prelude file <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="286262320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286262320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286262320">(Jun 15 2022 at 19:34)</a>:</h4>
<p>I tried another approach: copy increasingly longer bits of <code>Prelude.lean</code> until it works.<br>
Apparently no more types are missing, but I don't have what's needed to allow Lean to prove terminations by itself. How does that work?</p>



<a name="286262371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286262371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286262371">(Jun 15 2022 at 19:34)</a>:</h4>
<p>This is the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">prelude</span>

<span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">id</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">a</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">Function.comp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">δ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">δ</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">Function.const</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">a</span>

<span class="kd">set_option</span> <span class="n">checkBinderAnnotations</span> <span class="n">false</span> <span class="k">in</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">inferInstance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">i</span>
<span class="kd">set_option</span> <span class="n">checkBinderAnnotations</span> <span class="n">false</span> <span class="k">in</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">inferInstanceAs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">i</span>

<span class="kd">set_option</span> <span class="n">bootstrap.inductiveCheckResultingUniverse</span> <span class="n">false</span> <span class="k">in</span>
<span class="kd">inductive</span> <span class="n">PUnit</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">unit</span> <span class="o">:</span> <span class="n">PUnit</span>

<span class="sd">/-- An abbreviation for `PUnit.{0}`, its most common instantiation.</span>
<span class="sd">    This Type should be preferred over `PUnit` where possible to avoid</span>
<span class="sd">    unnecessary universe parameters. -/</span>
<span class="n">abbrev</span> <span class="n">Unit</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">PUnit</span>

<span class="kd">@[matchPattern]</span> <span class="n">abbrev</span> <span class="n">Unit.unit</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">PUnit.unit</span>

<span class="sd">/-- Auxiliary unsafe constant used by the Compiler when erasing proofs from code. -/</span>
<span class="n">unsafe</span> <span class="kd">axiom</span> <span class="n">lcProof</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span>

<span class="sd">/-- Auxiliary unsafe constant used by the Compiler to mark unreachable code. -/</span>
<span class="n">unsafe</span> <span class="kd">axiom</span> <span class="n">lcUnreachable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span>

<span class="kd">inductive</span> <span class="n">True</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">True</span>

<span class="kd">inductive</span> <span class="n">False</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">inductive</span> <span class="n">Empty</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">set_option</span> <span class="n">bootstrap.inductiveCheckResultingUniverse</span> <span class="n">false</span> <span class="k">in</span>
<span class="kd">inductive</span> <span class="n">PEmpty</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="n">where</span>

<span class="kd">def</span> <span class="n">Not</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">False</span>

<span class="kd">@[macroInline]</span> <span class="kd">def</span> <span class="n">False.elim</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">False</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="o">:=</span>
  <span class="n">False.rec</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="n">h</span>

<span class="kd">@[macroInline]</span> <span class="kd">def</span> <span class="n">absurd</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Not</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="n">False.elim</span> <span class="o">(</span><span class="n">h₂</span> <span class="n">h₁</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Eq</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">a</span>

<span class="kd">@[simp]</span> <span class="n">abbrev</span> <span class="n">Eq.ndrec.</span><span class="o">{</span><span class="n">u1</span><span class="o">,</span> <span class="n">u2</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u2</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u1</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="n">Eq.rec</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">α</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">motive</span> <span class="n">α</span><span class="o">)</span> <span class="n">m</span> <span class="n">h</span>

<span class="kd">@[matchPattern]</span> <span class="kd">def</span> <span class="n">rfl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">Eq.refl</span> <span class="n">a</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">id_eq</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">id</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">Eq.subst</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="n">Eq.ndrec</span> <span class="n">h₂</span> <span class="n">h₁</span>

<span class="kd">theorem</span> <span class="n">Eq.symm</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="n">h</span> <span class="bp">▸</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">Eq.trans</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="n">h₂</span> <span class="bp">▸</span> <span class="n">h₁</span>

<span class="kd">@[macroInline]</span> <span class="kd">def</span> <span class="n">cast</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="n">Eq.rec</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">α</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">α</span><span class="o">)</span> <span class="n">a</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">congrArg</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">f</span> <span class="n">a₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">h</span> <span class="bp">▸</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">congr</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">f₁</span> <span class="n">f₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">f₁</span> <span class="n">f₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">a₁</span><span class="o">)</span> <span class="o">(</span><span class="n">f₂</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">h₁</span> <span class="bp">▸</span> <span class="n">h₂</span> <span class="bp">▸</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">congrFun</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">β</span> <span class="n">x</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">h</span> <span class="bp">▸</span> <span class="n">rfl</span>

<span class="n">init_quot</span>

<span class="kd">inductive</span> <span class="n">HEq</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">refl</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">HEq</span> <span class="n">a</span> <span class="n">a</span>

<span class="kd">@[matchPattern]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">HEq.rfl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">HEq</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="n">HEq.refl</span> <span class="n">a</span>

<span class="kd">theorem</span> <span class="n">eq_of_heq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">HEq</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">HEq</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">cast</span> <span class="n">h</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span>
    <span class="k">fun</span> <span class="n">α</span> <span class="n">β</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h₁</span> <span class="bp">=&gt;</span>
      <span class="n">HEq.rec</span> <span class="o">(</span><span class="n">motive</span> <span class="o">:=</span> <span class="k">fun</span> <span class="o">{</span><span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">HEq</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Eq</span> <span class="o">(</span><span class="n">cast</span> <span class="n">h₂</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span>
        <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Eq</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">rfl</span><span class="o">)</span>
        <span class="n">h₁</span>
  <span class="n">this</span> <span class="n">α</span> <span class="n">α</span> <span class="n">a</span> <span class="n">a'</span> <span class="n">h</span> <span class="n">rfl</span>

<span class="kd">structure</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">fst</span> <span class="o">:</span> <span class="n">α</span>
  <span class="n">snd</span> <span class="o">:</span> <span class="n">β</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">unbox</span><span class="o">]</span> <span class="n">Prod</span>

<span class="sd">/-- Similar to `Prod`, but `α` and `β` can be propositions.</span>
<span class="sd">   We use this Type internally to automatically generate the brecOn recursor. -/</span>
<span class="kd">structure</span> <span class="n">PProd</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">fst</span> <span class="o">:</span> <span class="n">α</span>
  <span class="n">snd</span> <span class="o">:</span> <span class="n">β</span>

<span class="kd">structure</span> <span class="n">And</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">intro</span> <span class="o">::</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">PSum</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">PSum</span> <span class="n">α</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="n">inr</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">PSum</span> <span class="n">α</span> <span class="n">β</span>

<span class="kd">inductive</span> <span class="n">Bar</span>
  <span class="bp">|</span> <span class="n">hi</span> <span class="bp">|</span> <span class="n">bye</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="n">Bar.hi</span>

<span class="kd">inductive</span> <span class="n">MyNat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">MyNat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">MyNat</span> <span class="bp">→</span> <span class="n">MyNat</span>

<span class="kd">mutual</span>

  <span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">MyNat</span> <span class="bp">→</span> <span class="n">MyNat</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">zero</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>

  <span class="kd">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">MyNat</span> <span class="bp">→</span> <span class="n">MyNat</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">zero</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>

<span class="kd">end</span>
</code></pre></div>



<a name="286262752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286262752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286262752">(Jun 15 2022 at 19:38)</a>:</h4>
<p>When I check your example with ordinary nats:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>

  <span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">zero</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>

  <span class="kd">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">zero</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>

<span class="kd">end</span>
</code></pre></div>
<p>And print what they elaborate to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">f._mutual</span> <span class="o">(</span><span class="n">PSum.inl</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>There is this magical _mutual declaration which if you print it is quite huge and among other things requires WellFounded recursion and the corresponding instances for well founded relation etc.</p>
<p>So I would imagine you need at least parts of <code>Init.WF</code> and maybe also <code>Init.WFTactics</code></p>



<a name="286262981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286262981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286262981">(Jun 15 2022 at 19:40)</a>:</h4>
<p>(Which as you can see in doc-gen adds up to a whole lot of files because these already make use of quite a few imports)</p>



<a name="286263167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286263167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286263167">(Jun 15 2022 at 19:42)</a>:</h4>
<p>Alright, thanks!!<br>
I will try another route then <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="286263491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286263491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286263491">(Jun 15 2022 at 19:45)</a>:</h4>
<p>I don't really think you can avoid well founded recursion here though, mutual just always seems to involve using well founded recursion to show termination so you won't be able to get around it. How much of it you need for your trivial examples is a completely different question though</p>



<a name="286264000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286264000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286264000">(Jun 15 2022 at 19:49)</a>:</h4>
<p>Yeah turns out my plan to end up with a very small environment was slipping through my fingers</p>



<a name="286264096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286264096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286264096">(Jun 15 2022 at 19:50)</a>:</h4>
<p>Why exactly are you doing this btw?</p>



<a name="286264354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286264354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286264354">(Jun 15 2022 at 19:52)</a>:</h4>
<p>Long story short, we're trying to achieve some kind of "translation" of the Lean environment through metaprogramming. And I'm trying to test our method to translate mutual definitions</p>



<a name="286264519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286264519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286264519">(Jun 15 2022 at 19:54)</a>:</h4>
<p>But if you were to just translate every declaration that is in a regular <code>Environment</code> right now things would just work out by themselves no? After all in a regular one all of this stuff is in place.</p>



<a name="286264640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286264640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286264640">(Jun 15 2022 at 19:55)</a>:</h4>
<p>Yeah but the environment is HUGE, so I was looking for a small and controlled environment</p>



<a name="286265067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286265067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286265067">(Jun 15 2022 at 19:58)</a>:</h4>
<p>It definitley is yes, but e.g. before I started to try and obtain all of the equational lemmata for doc-gen (which requires running additional meta code with tactics for every <code>def</code> because they are calculated dynamically) doc-gen did actually run through an environment with a fully loaded mathlib quite quickly, pretty printing and analyzing every declaration and even now it is in the minute span at most so processing large environments in short time definitley is possible.</p>



<a name="286265081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286265081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286265081">(Jun 15 2022 at 19:59)</a>:</h4>
<p>ah it is not a timing concern i see.</p>



<a name="286265597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286265597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286265597">(Jun 15 2022 at 20:02)</a>:</h4>
<p>In that case maybe you could use the regular environment and write some code that recursively figures out what declarations a certain other declaration depends on so you can make a list of things for your <code>mutual</code> example and only translate all the declarations that are required for it?</p>



<a name="286266174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286266174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286266174">(Jun 15 2022 at 20:06)</a>:</h4>
<p>Yeah that's precisely what I'm trying right now</p>



<a name="286278230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286278230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> John Burnham <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286278230">(Jun 15 2022 at 21:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286264354">said</a>:</p>
<blockquote>
<p>Long story short, we're trying to achieve some kind of "translation" of the Lean environment through metaprogramming. And I'm trying to test our method to translate mutual definitions</p>
</blockquote>
<p>A slightly longer version of the story is that we're trying to transform a <code>Lean.Environment</code> which is a map keyed on names, to a map keyed on cryptographic hashes of a name-irrelevant representation of the constants (vaguely similar to the hashing of <a href="https://www.unison-lang.org/">https://www.unison-lang.org/</a>). This lets us content-address any constant in a way that bypasses the hierarchical namespace. So</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">id1</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">id2</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">y</span>
</code></pre></div>
<p>which are identical except for names, would hash to the same anonymous constant.</p>
<p>Anyway, to do this for <code>mutual</code> blocks is complicated (since you can't hash a cyclic reference graph in the same way you would an acyclic one), so we're trying to create some simple test cases to try our solution against</p>



<a name="286283317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286283317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286283317">(Jun 15 2022 at 22:29)</a>:</h4>
<p>A this is a thing I've been wondering for a while: Why exactly is this desirable? :D</p>



<a name="286283380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286283380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286283380">(Jun 15 2022 at 22:30)</a>:</h4>
<p>I get that it has a certain "technical beauty" appeal but i never understood why people actually want this.</p>



<a name="286286464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286286464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> John Burnham <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286286464">(Jun 15 2022 at 23:03)</a>:</h4>
<p>Well, there are a lot of <em>potential</em> benefits to content addressing (like for build systems etc). But the concrete use-case our Yatima project (<a href="https://github.com/yatima-inc/yatima-lang/wiki">https://github.com/yatima-inc/yatima-lang/wiki</a>) needs this for is that we're compiling Lean to the Lurk language for recursive zkSNARKs (<a href="https://github.com/lurk-lang">https://github.com/lurk-lang</a>), so that we can have lightweight cryptographic certificates that <code>myProof : myTheorem</code> validly checks (which can be verified in constant time without re-running a kernel)</p>
<p>Having nameless content-addressing allows us to compose any such certificate of <code>proof1 : Theorem1</code> with any other certificate of<code>proof2 : Theorem2</code> irrespective of their use of the hierarchical namespace (like if they rely on two different constants both with the same name). This greatly improves certificate generation performance</p>



<a name="286286819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286286819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> John Burnham <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286286819">(Jun 15 2022 at 23:08)</a>:</h4>
<p>I know there have been threads around Unison-style content-addressing for Lean (or <code>lake</code>) here in the past, and totally open to generalizing Yatima's content-addressing schema if that's of interest. But we're implementing this for a very domain-specific reason, which may have different  constraints.</p>
<p>One thing though is that our content-addressing uses <a href="https://ipld.io/">https://ipld.io/</a>, which will let you composably share Lean constants and environments over  IPFS (<a href="https://ipfs.io/">https://ipfs.io/</a>), which is kinda neat</p>



<a name="286316652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/What%27s%20needed%20for%20mutual%20defs%3F/near/286316652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F.html#286316652">(Jun 16 2022 at 07:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286283317">said</a>:</p>
<blockquote>
<p>A this is a thing I've been wondering for a while: Why exactly is this desirable? :D</p>
</blockquote>
<p>Outside of a concrete use cases like John mentioned there are two other notable general advantages:  it eliminates code bloat caused by cross-package code duplication and it allows for easy, transparent aliasing of definitions (ie.g., <code>nat</code>, <code>Nat</code>, <code>natural</code>, <code>Natural</code> can all resolve to the same thing). The later feature is general to any language that decouples names from unit identifiers .</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
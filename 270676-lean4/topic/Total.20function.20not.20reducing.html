---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Total.20function.20not.20reducing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html">Total function not reducing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="290123675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290123675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290123675">(Jul 19 2022 at 16:16)</a>:</h4>
<p>Hello, everyone. I am making an algebraic effect library.</p>
<p>Eff.lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Eff</span>

<span class="kd">class</span> <span class="kd">inductive</span> <span class="n">Has</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">x</span> <span class="n">xs</span> <span class="bp">-&gt;</span> <span class="n">Has</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span>

<span class="c1">-- any way to automate this?</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Has.zero</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">prev</span><span class="o">:</span> <span class="n">Has</span> <span class="n">a</span> <span class="n">xs</span><span class="o">]</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">a</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Has.succ</span> <span class="n">prev</span>


<span class="kd">inductive</span> <span class="n">Union</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="o">[</span><span class="n">_prf</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">ε</span> <span class="n">εs</span><span class="o">]</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ε</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Union</span> <span class="n">εs</span> <span class="n">α</span>


<span class="kd">example</span> <span class="o">:</span> <span class="n">Union</span> <span class="o">[</span><span class="n">IO</span><span class="o">]</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">Union.mk</span> <span class="o">(</span><span class="n">IO.println</span> <span class="s2">"Hello"</span><span class="o">)</span>
<span class="kd">axiom</span> <span class="n">Example_Monad</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Union</span> <span class="o">[</span><span class="n">Example_Monad</span><span class="o">,</span> <span class="n">IO</span><span class="o">]</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">Union.mk</span> <span class="o">(</span><span class="n">IO.println</span> <span class="s2">"Hello"</span><span class="o">)</span>


<span class="kd">inductive</span> <span class="n">Free</span> <span class="o">:</span> <span class="o">(</span><span class="n">_monad</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">_res</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">pure</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">bind</span> <span class="o">:</span> <span class="n">ε</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Pure</span> <span class="o">(</span><span class="n">Free</span> <span class="n">ε</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">pure</span> <span class="o">:=</span> <span class="n">Free.pure</span>

<span class="kd">def</span> <span class="n">Free.recurbind</span> <span class="o">(</span><span class="n">val</span><span class="o">:</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cont</span><span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">val</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">Free.pure</span> <span class="n">v</span> <span class="bp">=&gt;</span> <span class="n">cont</span> <span class="n">v</span>
  <span class="bp">|</span> <span class="n">Free.bind</span> <span class="n">mval</span> <span class="n">mcont</span> <span class="bp">=&gt;</span>
    <span class="n">Free.bind</span> <span class="n">mval</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="bp">=&gt;</span> <span class="n">Free.recurbind</span> <span class="o">(</span><span class="n">mcont</span> <span class="n">a'</span><span class="o">)</span> <span class="n">cont</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Bind</span> <span class="o">(</span><span class="n">Free</span> <span class="n">ε</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">bind</span> <span class="o">:=</span> <span class="n">Free.recurbind</span>


<span class="kd">def</span> <span class="n">Eff</span> <span class="o">(</span><span class="n">es</span><span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">_res</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">Free</span> <span class="o">(</span><span class="n">Union</span> <span class="n">es</span><span class="o">)</span>


<span class="kd">example</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">Eff</span> <span class="o">[</span><span class="n">IO</span><span class="o">]</span> <span class="n">Nat</span>


<span class="kd">def</span> <span class="n">lift</span> <span class="o">[</span><span class="n">has</span><span class="o">:</span> <span class="n">Has</span> <span class="n">ε</span> <span class="n">εs</span><span class="o">]</span> <span class="o">(</span><span class="n">simple</span><span class="o">:</span> <span class="n">ε</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Eff</span> <span class="n">εs</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">un</span> <span class="o">:</span> <span class="n">Union</span> <span class="n">εs</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Union.mk</span> <span class="n">simple</span>
  <span class="n">Free.bind</span> <span class="n">un</span> <span class="n">Free.pure</span>
</code></pre></div>
<p>However, the function <code>Eff</code> above is not reducing.</p>
<p>Main.lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Eff</span>
<span class="kn">open</span> <span class="n">Eff</span>

<span class="kd">def</span> <span class="n">main_eff</span> <span class="o">:</span> <span class="n">Eff</span> <span class="o">[</span><span class="n">IO</span><span class="o">]</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">lift</span> <span class="bp">$</span> <span class="n">IO.println</span> <span class="s2">"hello"</span>
  <span class="n">lift</span> <span class="bp">$</span> <span class="n">IO.println</span> <span class="s2">"hello"</span>
</code></pre></div>
<p>error: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Main.lean</span><span class="o">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">2</span>

<span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
  <span class="n">Bind</span> <span class="o">(</span><span class="n">Eff</span> <span class="o">[</span><span class="n">IO</span><span class="o">])</span>
</code></pre></div>



<a name="290124167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124167">(Jul 19 2022 at 16:19)</a>:</h4>
<p>How do I make <code>Eff [IO]</code> reduce to <code>Free (Union [IO])</code>?</p>



<a name="290124318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124318">(Jul 19 2022 at 16:20)</a>:</h4>
<p>By declaring your definition of <code>Eff</code> as an <code>abbrev</code> or tagging it with <code>@[reducible]</code> (equivalent):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">Eff</span> <span class="o">(</span><span class="n">es</span><span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">_res</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">Free</span> <span class="o">(</span><span class="n">Union</span> <span class="n">es</span><span class="o">)</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">Eff</span> <span class="o">(</span><span class="n">es</span><span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">_res</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">Free</span> <span class="o">(</span><span class="n">Union</span> <span class="n">es</span><span class="o">)</span>
</code></pre></div>



<a name="290124357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124357">(Jul 19 2022 at 16:21)</a>:</h4>
<p>Where can I find all the @[xxxx] "pragma"?</p>



<a name="290124391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124391">(Jul 19 2022 at 16:21)</a>:</h4>
<p>Also abbrev/lemma/def stuff</p>



<a name="290124406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124406">(Jul 19 2022 at 16:21)</a>:</h4>
<p>I can't find in tutorial</p>



<a name="290124623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124623">(Jul 19 2022 at 16:23)</a>:</h4>
<p>In an ideal world we would have a tutorial for all of this already but since we are at a very early stage the answer right now is: by reading other people's code, specifically parts of the Lean compiler and Stdlib as well as Mathlib are sources of good code.</p>
<p>And the alternative is to just ask here.</p>
<p>One could argue that mentioning <code>abbrev</code> in <a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html</a> would definitely make sense though since its a very basic thing we do all the time.</p>



<a name="290124846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124846">(Jul 19 2022 at 16:25)</a>:</h4>
<p>Regarding types of declarations you have already found most though in main Lean we have</p>
<ul>
<li><code>def</code>, <code>abbrev</code></li>
<li><code>axiom</code></li>
<li><code>structure</code>, <code>class</code></li>
<li><code>inductive</code>, <code>class inductive</code></li>
<li><code>axiom</code></li>
<li><code>opaque</code></li>
<li><code>instance</code></li>
<li><code>theorem</code></li>
<li><code>example</code></li>
</ul>
<p>and that's all, <code>lemma</code> is a syntactic abbreviation for <code>theorem</code> that is added by mathlib</p>



<a name="290124892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290124892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sébastien Michelland <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290124892">(Jul 19 2022 at 16:25)</a>:</h4>
<p>To clarify, <code>@[reducible]</code> marks the definition as reducible for typeclass inference specifically. By default typeclass inference avoids reducing because it would make the search very expensive.</p>



<a name="290125082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290125082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290125082">(Jul 19 2022 at 16:26)</a>:</h4>
<p>what's the different between <code>axiom</code> and <code>opaque</code></p>



<a name="290125347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290125347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290125347">(Jul 19 2022 at 16:28)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> thanks! it works.</p>



<a name="290125380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290125380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290125380">(Jul 19 2022 at 16:28)</a>:</h4>
<p><code>opaque</code> requires you to provide a proof that the type is <code>Inhabited</code> which avoids inconsistencies. <code>axiom</code> can in theory allow you to introduce whatever you want.</p>



<a name="290129789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290129789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290129789">(Jul 19 2022 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290125380">said</a>:</p>
<blockquote>
<p><code>opaque</code> requires you to provide a proof that the type is <code>Inhabited</code></p>
</blockquote>
<p>Technically, it now just requires <code>Nonempty</code>, not <code>Inhabited</code> (with caveats):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">opaque</span> <span class="n">Foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">@[instance]</span> <span class="kd">axiom</span> <span class="n">Foo.nonempty</span> <span class="o">:</span> <span class="n">Nonempty</span> <span class="n">Foo</span>
<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">unsafeFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="n">unsafeCast</span> <span class="mi">0</span>

<span class="n">opaque</span> <span class="n">unimplFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- errors, noncomputable</span>
<span class="kd">noncomputable</span> <span class="n">opaque</span> <span class="n">noncomputableFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- works</span>
<span class="kd">@[implementedBy unsafeFoo]</span> <span class="n">opaque</span> <span class="n">implFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- works</span>
<span class="kd">@[extern c inline "0"]</span> <span class="n">opaque</span> <span class="n">externFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="290141466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290141466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290141466">(Jul 19 2022 at 18:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290129789">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290125380">said</a>:</p>
<blockquote>
<p><code>opaque</code> requires you to provide a proof that the type is <code>Inhabited</code></p>
</blockquote>
<p>Technically, it now just requires <code>Nonempty</code>, not <code>Inhabited</code> (with caveats):</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">opaque</span> <span class="n">Foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">@[instance]</span> <span class="kd">axiom</span> <span class="n">Foo.nonempty</span> <span class="o">:</span> <span class="n">Nonempty</span> <span class="n">Foo</span>
<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">unsafeFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="n">unsafeCast</span> <span class="mi">0</span>

<span class="n">opaque</span> <span class="n">unimplFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- errors, noncomputable</span>
<span class="kd">noncomputable</span> <span class="n">opaque</span> <span class="n">noncomputableFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- works</span>
<span class="kd">@[implementedBy unsafeFoo]</span> <span class="n">opaque</span> <span class="n">implFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- works</span>
<span class="kd">@[extern c inline "0"]</span> <span class="n">opaque</span> <span class="n">externFoo</span> <span class="o">:</span> <span class="n">Foo</span> <span class="c1">-- works</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I'm new to Lean. I have to remember all these keywords? <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>



<a name="290142619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290142619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290142619">(Jul 19 2022 at 18:40)</a>:</h4>
<p>It gets easier over time :p and most of what he showed isn't relevant to everyday Lean don't worry</p>



<a name="290142659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290142659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290142659">(Jul 19 2022 at 18:40)</a>:</h4>
<p>what the different between <code>def</code> and <code>theorem</code>?</p>



<a name="290142806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290142806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290142806">(Jul 19 2022 at 18:41)</a>:</h4>
<p>Also, is there something like <code>go</code> or <code>let ([a 1] [b 2]) body</code> in lisp for inline recursion?</p>



<a name="290143084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143084">(Jul 19 2022 at 18:43)</a>:</h4>
<p>a <code>theorem</code> is always of type <code>P</code> where <code>P : Prop</code>, a <code>def</code> can be whatever.</p>
<p>inline recursion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">iotaTR</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">rec</span> <span class="n">go</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span>
    <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">r.reverse</span>
    <span class="bp">|</span> <span class="n">m</span><span class="bp">@</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">go</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span><span class="o">::</span><span class="n">r</span><span class="o">)</span>
  <span class="n">go</span> <span class="n">n</span> <span class="o">[]</span>
</code></pre></div>
<p>like this?</p>



<a name="290143245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143245">(Jul 19 2022 at 18:45)</a>:</h4>
<p>yes</p>



<a name="290143301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143301">(Jul 19 2022 at 18:45)</a>:</h4>
<p>How do I turn anything into a string</p>



<a name="290143443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143443">(Jul 19 2022 at 18:46)</a>:</h4>
<p><code>Sort</code> and <code>Type</code> has any difference?</p>



<a name="290143639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143639">(Jul 19 2022 at 18:48)</a>:</h4>
<p>we have the <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ToString#doc">docs4#ToString</a> typeclass to turn stuff into strings, we have <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Repr#doc">docs4#Repr</a> for "debug representation" of data structure basically and we have format strings like: <code>s!"Lalalala {variable} lalalalala"</code></p>
<p>There is an infinite hierarchy of types, we have</p>
<ol>
<li><code>Prop</code> at the bottom where <code>Prop</code> is equivalent to <code>Sort 0</code></li>
<li><code>Type</code> which is equivalent to <code>Sort 1</code></li>
<li><code>Type 1</code> which is equivalent to <code>Sort 2</code><br>
and so on until infinity. The hierarchy exists in order to avoid self reference paradoxa</li>
</ol>



<a name="290143771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143771">(Jul 19 2022 at 18:49)</a>:</h4>
<p>Prop is Sort 0?</p>



<a name="290143786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143786">(Jul 19 2022 at 18:49)</a>:</h4>
<p>I don't quite understand</p>



<a name="290143844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290143844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290143844">(Jul 19 2022 at 18:49)</a>:</h4>
<p>Yes, they are aliases for each other</p>



<a name="290144012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144012">(Jul 19 2022 at 18:51)</a>:</h4>
<p>you can even ask Lean about this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="mi">0</span> <span class="bp">=</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="mi">1</span> <span class="bp">=</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">=</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rfl</span>
</code></pre></div>



<a name="290144133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144133">(Jul 19 2022 at 18:52)</a>:</h4>
<p>What exactly is <code>Prop</code>?</p>



<a name="290144224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144224">(Jul 19 2022 at 18:52)</a>:</h4>
<p>There is also the difference between computable subset of <code>Type 0</code> and "incomputable" <code>Type 0</code></p>



<a name="290144284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144284">(Jul 19 2022 at 18:53)</a>:</h4>
<p>What exactly is <code>Prop</code>?</p>



<a name="290144325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144325">(Jul 19 2022 at 18:53)</a>:</h4>
<p>If <code>x : p</code>, <code>y : p</code>, and <code>p : Prop</code>, then <code>x = y</code> is true by <code>rfl</code> ("proof irrelevance") and there are also some special rules for universe levels when <code>Prop</code> is involved ("impredicativity" I believe?). It's meant to represent the universe of mathematical Propositions.</p>



<a name="290144337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144337">(Jul 19 2022 at 18:53)</a>:</h4>
<p>It is the type of mathematical <code>Prop</code>erties. So everything that we want to express as a logical statement in Lean has type <code>Prop</code>, equalities, inequalities, statements about correctness of certain functions etc.</p>



<a name="290144560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144560">(Jul 19 2022 at 18:55)</a>:</h4>
<p>In general if you have some statement <code>p</code> where <code>p : Prop</code> and you provide a value <code>h : p</code> what you have done is create a proof that <code>p</code> does indeed hold, this is the principle of how proofs work in Lean. What Kyle is describing above is a certain special property of <code>Prop</code> in Lean which says that if we have two proofs of the same statement we can always consider those proofs equivalent (it helps with code generation efficiency)</p>



<a name="290144887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290144887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290144887">(Jul 19 2022 at 18:57)</a>:</h4>
<p>I suppose <code>Prop</code>'s special properties were originally motivated by codegen, but it seems to be important for doing classical mathematics (like it's possible to define <code>Subtype</code> with the correct cardinality).</p>



<a name="290145024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290145024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290145024">(Jul 19 2022 at 18:58)</a>:</h4>
<p>There's another thing about <code>Prop</code> that's special, which is its elimination rules -- in contrast to <code>Type</code>, they prevent you from getting data out of a proposition.</p>



<a name="290145077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290145077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290145077">(Jul 19 2022 at 18:58)</a>:</h4>
<p>(It seems people have found <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723">this diagram</a> to be useful, so here's a link.)</p>



<a name="290145537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290145537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290145537">(Jul 19 2022 at 19:01)</a>:</h4>
<p><a href="https://lean-forward.github.io/logical-verification/2018/41_notes.html">This page about foundations</a> mentions everything I've mentioned about <code>Prop</code>.</p>



<a name="290146447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290146447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290146447">(Jul 19 2022 at 19:08)</a>:</h4>
<p>What's the constructor for Prop?<br>
Only <code>_=_</code>?</p>



<a name="290146543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290146543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290146543">(Jul 19 2022 at 19:09)</a>:</h4>
<p>No there are lots of ways to construct propositions, just like there are lots of ways to construct types.</p>



<a name="290146551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290146551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290146551">(Jul 19 2022 at 19:09)</a>:</h4>
<p>No you are mis understanding, just like you can declare your own things in <code>Type</code> (<code>Nat</code>, <code>String</code> etc.) you can also declare your own things in <code>Prop</code> via inductive and structure, <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc">docs4#Eq</a>, <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le#doc">docs4#Nat.le</a> etc.</p>



<a name="290146758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290146758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290146758">(Jul 19 2022 at 19:11)</a>:</h4>
<p>So it's a black box?</p>



<a name="290146818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290146818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290146818">(Jul 19 2022 at 19:11)</a>:</h4>
<p>I use Idris more and there is no such thing as <code>Prop</code> in Idris. The equality type <code>Equal a</code> is like <code>inductive</code> in Lean</p>



<a name="290146889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290146889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290146889">(Jul 19 2022 at 19:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Main</span><span class="bp">&gt;</span> <span class="o">:</span><span class="n">doc</span> <span class="n">Equal</span>
<span class="n">Prelude.Equal</span> <span class="o">:</span> <span class="n">Prec</span>
<span class="n">data</span> <span class="n">Builtin.Equal</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
  <span class="n">Totality</span><span class="o">:</span> <span class="n">total</span>
  <span class="n">Visibility</span><span class="o">:</span> <span class="n">public</span> <span class="kn">export</span>
  <span class="n">Constructor</span><span class="o">:</span> <span class="n">Refl</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>
  <span class="n">Hints</span><span class="o">:</span>
    <span class="n">Equivalence</span> <span class="n">ty</span> <span class="n">Equal</span>
    <span class="n">Euclidean</span> <span class="n">ty</span> <span class="n">Equal</span>
    <span class="n">PartialEquivalence</span> <span class="n">ty</span> <span class="n">Equal</span>
    <span class="n">Reflexive</span> <span class="n">ty</span> <span class="n">Equal</span>
    <span class="n">Symmetric</span> <span class="n">ty</span> <span class="n">Equal</span>
    <span class="n">Tolerance</span> <span class="n">ty</span> <span class="n">Equal</span>
    <span class="n">Transitive</span> <span class="n">ty</span> <span class="n">Equal</span>
</code></pre></div>



<a name="290147010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290147010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290147010">(Jul 19 2022 at 19:13)</a>:</h4>
<p>Our equality type is also an inductive in Lean as I linked above: <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc">docs4#Eq</a> it is just that we gave our mathematical propositions a special place to live in for the reasons outlined above</p>



<a name="290147355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290147355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290147355">(Jul 19 2022 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290145024">said</a>:</p>
<blockquote>
<p>There's another thing about <code>Prop</code> that's special, which is its elimination rules -- in contrast to <code>Type</code>, they prevent you from getting data out of a proposition.</p>
</blockquote>
<p>So <code>Prop</code> don't increase the universe level by one?</p>



<a name="290147824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290147824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Locria Cyber <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290147824">(Jul 19 2022 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="515610">Locria Cyber</span> <a href="#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290123675">said</a>:</p>
<blockquote>
<p>Eff.lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Eff</span>

<span class="kd">class</span> <span class="kd">inductive</span> <span class="n">Has</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">x</span> <span class="n">xs</span> <span class="bp">-&gt;</span> <span class="n">Has</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span>

<span class="c1">-- any way to automate this?</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Has.zero</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">prev</span><span class="o">:</span> <span class="n">Has</span> <span class="n">a</span> <span class="n">xs</span><span class="o">]</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">a</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Has.succ</span> <span class="n">prev</span>


<span class="kd">inductive</span> <span class="n">Union</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="o">[</span><span class="n">_prf</span> <span class="o">:</span> <span class="n">Has</span> <span class="n">ε</span> <span class="n">εs</span><span class="o">]</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ε</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Union</span> <span class="n">εs</span> <span class="n">α</span>


<span class="kd">example</span> <span class="o">:</span> <span class="n">Union</span> <span class="o">[</span><span class="n">IO</span><span class="o">]</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">Union.mk</span> <span class="o">(</span><span class="n">IO.println</span> <span class="s2">"Hello"</span><span class="o">)</span>
<span class="kd">axiom</span> <span class="n">Example_Monad</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Union</span> <span class="o">[</span><span class="n">Example_Monad</span><span class="o">,</span> <span class="n">IO</span><span class="o">]</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">Union.mk</span> <span class="o">(</span><span class="n">IO.println</span> <span class="s2">"Hello"</span><span class="o">)</span>


<span class="kd">inductive</span> <span class="n">Free</span> <span class="o">:</span> <span class="o">(</span><span class="n">_monad</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">_res</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">_</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">pure</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">bind</span> <span class="o">:</span> <span class="n">ε</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Pure</span> <span class="o">(</span><span class="n">Free</span> <span class="n">ε</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">pure</span> <span class="o">:=</span> <span class="n">Free.pure</span>

<span class="kd">def</span> <span class="n">Free.recurbind</span> <span class="o">(</span><span class="n">val</span><span class="o">:</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cont</span><span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Free</span> <span class="n">ε</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">val</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">Free.pure</span> <span class="n">v</span> <span class="bp">=&gt;</span> <span class="n">cont</span> <span class="n">v</span>
  <span class="bp">|</span> <span class="n">Free.bind</span> <span class="n">mval</span> <span class="n">mcont</span> <span class="bp">=&gt;</span>
    <span class="n">Free.bind</span> <span class="n">mval</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="bp">=&gt;</span> <span class="n">Free.recurbind</span> <span class="o">(</span><span class="n">mcont</span> <span class="n">a'</span><span class="o">)</span> <span class="n">cont</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Bind</span> <span class="o">(</span><span class="n">Free</span> <span class="n">ε</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">bind</span> <span class="o">:=</span> <span class="n">Free.recurbind</span>
</code></pre></div>
</blockquote>
<p>In this case, I do need to take data out of <code>Has e es</code> though.</p>
<p>I need to take stacked monad apart to handle algebraic effects, and <code>_prf</code> in <code>Union.mk</code> is the position that I need to use.</p>
<p>In a sense, I need to pattern match <code>Has e es</code>, but it's never shown to the user.</p>



<a name="290191076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290191076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290191076">(Jul 20 2022 at 03:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290143084">said</a>:</p>
<blockquote>
<p>a <code>theorem</code> is always of type <code>P</code> where <code>P : Prop</code>, a <code>def</code> can be whatever.</p>
</blockquote>
<p>Technically,  a <code>theorem</code> can be of any type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">5</span> <span class="c1">-- ok</span>
</code></pre></div>
<p>I believe a <code>theorem</code> is essentially a <code>noncomputable def</code> (just with some syntactic sugar on top) :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">5</span>
<span class="kd">def</span> <span class="n">addFoo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">error:</span>
<span class="cm">failed to compile definition, consider marking it as 'noncomputable'</span>
<span class="cm">because it depends on 'foo', and it does not have executable code</span>
<span class="cm">-/</span>
<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">foo</span> <span class="c1">-- ok</span>
</code></pre></div>
<p>However, Henrik is right in spirit. We generally use a <code>theorem</code> for proposition we want to prove and a <code>def</code> for encoding concepts and generating code. I just enjoy demonstrating edge cases. <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="290191480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Total%20function%20not%20reducing/near/290191480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Total.20function.20not.20reducing.html#290191480">(Jul 20 2022 at 04:04)</a>:</h4>
<p>Actually I think it's a <code>noncomputable opaque</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
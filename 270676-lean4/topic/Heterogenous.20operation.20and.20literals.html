---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html">Heterogenous operation and literals</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281441307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281441307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281441307">(May 06 2022 at 13:52)</a>:</h4>
<p>I'm having hard time using heterogenous operations together with number literals. For example writing <code>2*x</code> always gives me an error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
  <span class="n">HMul</span> <span class="n">X</span> <span class="n">X</span> <span class="bp">?</span><span class="n">m.1180</span>
 <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
  <span class="n">OfNat</span> <span class="n">X</span> <span class="mi">2</span>
</code></pre></div>
<p>i.e. Lean tries to use homogenous operation and cast <code>2</code> to <code>X</code>. What I have to do it to manually specify the type of two,<code>(2:ℝ)*x</code>.</p>
<p>Here is variant of this problem with addition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Idx</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">i.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i.toUSize</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">USize</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="c1">-- this works</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">5</span>  <span class="c1">-- this does not work</span>
</code></pre></div>



<a name="281443021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281443021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281443021">(May 06 2022 at 14:05)</a>:</h4>
<p>I don't know how to tell Lean to automatically look for an instance of an heterogeneous operation when using <code>+</code>.<br>
But this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Idx</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">i.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i.toUSize</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">USize</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="c1">-- this works</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">5</span>  <span class="c1">-- this does not work</span>

<span class="kd">def</span> <span class="n">mySum</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Idx</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">n</span> <span class="bp">+</span> <span class="n">s</span>

<span class="kd">notation</span> <span class="n">n</span> <span class="s2">" ⊹ "</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">mySum</span> <span class="n">n</span> <span class="n">s</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">⊹</span> <span class="mi">5</span> <span class="c1">-- this works</span>
</code></pre></div>



<a name="281443250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281443250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281443250">(May 06 2022 at 14:07)</a>:</h4>
<p>Haha cute <span aria-label="laughter tears" class="emoji emoji-1f602" role="img" title="laughter tears">:laughter_tears:</span>  but no, I really want to use normal <code>+</code> sign.</p>



<a name="281443976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281443976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281443976">(May 06 2022 at 14:12)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>: isn't it a bit weird though? I mean, using <code>+</code> to simbolize a sum of things with different types</p>



<a name="281444892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281444892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281444892">(May 06 2022 at 14:19)</a>:</h4>
<p>Yeah in this instance you are probably right. But with scalar multiplication I really want to write <code>2*x</code> for <code>x : X</code> where <code>X</code> is a vector space.</p>



<a name="281446223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281446223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281446223">(May 06 2022 at 14:28)</a>:</h4>
<p>I would take a look at how it's done in mathlib, but I'm skeptical that the common multiplication symbol <code>*</code> is used in these cases.</p>
<p>(not too related!) I remember Julian Berman posted a link to an amazing post where Andrej Bauer explained the layers of inferences needed for a computer to understand what we mean when we (informally) multiply a scalar number and a vector</p>
<p><del>@<strong>Julian Berman</strong> sorry to ping, but do you still have that link? I want to read it again</del> <a href="https://mathoverflow.net/a/376973">Found it</a>!</p>



<a name="281453628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281453628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281453628">(May 06 2022 at 15:14)</a>:</h4>
<p>Mathlib4 does not have definition of modules/group_action yet. It has rings and there</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>    <span class="c1">-- 4 has type A</span>
<span class="k">#check</span> <span class="o">((</span><span class="mi">4</span><span class="o">:</span><span class="n">Nat</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>   <span class="c1">-- output: ↑4 * a : A    i.e. (4:Nat) get cast to A and then multiply</span>
</code></pre></div>
<p>Also mathlib4 does not seem to even define <code>HAdd Nat A A</code>.</p>
<p>Mathlib3 uses <code>•</code> as it does not have heterogenous operations.</p>



<a name="281454866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281454866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281454866">(May 06 2022 at 15:24)</a>:</h4>
<p>I've been using HMul for something that's essentially a vector space, and it seemed like there was no way around the fact that you have to specify the types of numeric literals when used as scalars.</p>



<a name="281455595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281455595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281455595">(May 06 2022 at 15:30)</a>:</h4>
<p>Is there a special elaboration rule that when you have <code>2 * x</code> it will try to use the type of <code>x</code> to synthesize an <code>OfNat</code> instance for the <code>2</code>? I know that there's a default instance to get an <code>HMul</code> from a <code>Mul</code>, but that doesn't seem to be what's applying here.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[defaultInstance]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">α</span> <span class="n">α</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">hMul</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">Mul.mul</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="281455705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281455705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281455705">(May 06 2022 at 15:31)</a>:</h4>
<p>I was playing around with <code>defaultInstance</code> and was unable to get anything out of it.</p>



<a name="281455758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281455758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281455758">(May 06 2022 at 15:31)</a>:</h4>
<p>I do not understand elaboration at all, so I can't answer that.</p>



<a name="281456178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281456178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281456178">(May 06 2022 at 15:34)</a>:</h4>
<p>For example this hack works i.e. define a new type for each natural number, <code>NatLit n</code>, and notation <code># n</code> creates a value of that type</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">NatLit</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">|</span> <span class="n">val</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">NatLit</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">m.toUSize</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>
<span class="n">macro</span> <span class="s2">"#"</span> <span class="n">n</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">NatLit.val</span> <span class="o">(</span><span class="n">n</span><span class="o">:=</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="k">#check</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="bp">#</span><span class="mi">5</span>
</code></pre></div>



<a name="281456963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281456963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281456963">(May 06 2022 at 15:40)</a>:</h4>
<p>If you want that to feel less like a hack, you could think about <code>NatLit</code> as being a type of rank-0 arrays (using J terminology), and then you could require that broadcasting rules should only apply to actual arrays.</p>



<a name="281457079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281457079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281457079">(May 06 2022 at 15:41)</a>:</h4>
<p>Oh, I didn't read what <code>Idx</code> actually was. Never mind. I somehow thought it was a length-n array of indices.</p>



<a name="281457666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281457666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281457666">(May 06 2022 at 15:45)</a>:</h4>
<p>Yeah if you are working with arrays you can do something like that. Or when I want to multiply <code>ℝ -&gt; ℝ</code> by <code>2</code> I can cast <code>2</code> to <code>fun _ =&gt; (2:ℝ)</code>. But when working with a generic vector space <code>X</code> I can't meaningfully assign type <code>X</code> to <code>2</code>.</p>



<a name="281460946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281460946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281460946">(May 06 2022 at 16:12)</a>:</h4>
<p>Hijacking all numerical literals with macro like this does not work either:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span><span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="n">n</span><span class="o">:</span><span class="n">Lean.Parser.numLit</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">NatLit.val</span> <span class="o">(</span><span class="n">n</span><span class="o">:=</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>
</code></pre></div>
<p>Full code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Parser</span>

<span class="kd">structure</span> <span class="n">Idx</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">i.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">USize</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span> <span class="c1">--</span>

<span class="c1">---</span>

<span class="kd">inductive</span> <span class="n">NatLit</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">|</span> <span class="n">val</span>
<span class="n">macro</span><span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">high</span><span class="o">)</span> <span class="n">n</span><span class="o">:</span><span class="n">Lean.Parser.numLit</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">NatLit.val</span> <span class="o">(</span><span class="n">n</span><span class="o">:=</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Coe</span> <span class="o">(</span><span class="n">NatLit</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">i.toUSize</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Coe</span> <span class="o">(</span><span class="n">NatLit</span> <span class="n">i</span><span class="o">)</span> <span class="n">USize</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i.toUSize</span><span class="o">⟩</span>

<span class="c1">---</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">NatLit</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">m.toUSize</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>

<span class="c1">---</span>

<span class="k">#check</span> <span class="mi">5</span>                <span class="c1">-- of type NatLit 5</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span>     <span class="c1">-- still works</span>
<span class="k">#check</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">5</span> <span class="c1">-- does not work</span>
</code></pre></div>



<a name="281465240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281465240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281465240">(May 06 2022 at 16:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Idx</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">i.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i.toUSize</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">USize</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>

<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">((</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">num</span> <span class="o">:</span> <span class="n">Idx</span> <span class="bp">$</span><span class="n">s</span><span class="o">:</span><span class="n">num</span><span class="o">)</span> <span class="bp">+</span> <span class="bp">$</span><span class="n">s'</span><span class="o">:</span><span class="n">num</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">((</span><span class="bp">$</span><span class="n">n</span> <span class="o">:</span> <span class="n">Idx</span> <span class="bp">$</span><span class="n">s</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">$</span><span class="n">s'</span> <span class="o">:</span> <span class="n">USize</span><span class="o">))</span>

<span class="k">#check</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="c1">-- this works</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">5</span>  <span class="c1">-- works</span>
</code></pre></div>
<p>That works</p>



<a name="281465453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281465453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281465453">(May 06 2022 at 16:53)</a>:</h4>
<p>It is not general enough, it breaks on:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span> <span class="o">:=</span> <span class="mi">6</span>
<span class="k">#eval</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">5</span>
</code></pre></div>



<a name="281465865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281465865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281465865">(May 06 2022 at 16:56)</a>:</h4>
<p>I was trying an elaboration like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mySum</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Idx</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">n</span> <span class="bp">+</span> <span class="n">s</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab.Term</span> <span class="n">Meta</span> <span class="k">in</span>
<span class="n">elab</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="s2">" + "</span> <span class="n">b</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">a</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">b</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">ta</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">a</span>
  <span class="k">let</span> <span class="n">tb</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">b</span>
  <span class="c1">-- check `ta` and `tb`. if they match the specific types then</span>
  <span class="n">mkAppM</span> <span class="bp">``</span><span class="n">mySum</span> <span class="bp">#</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
  <span class="c1">-- otherwise, do the regular sum</span>
  <span class="n">mkAppM</span> <span class="bp">``</span><span class="n">HAdd</span> <span class="bp">#</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
</code></pre></div>
<p>But I couldn't make it work with ease. Someone else might be able to help you on that direction</p>



<a name="281468085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281468085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281468085">(May 06 2022 at 17:14)</a>:</h4>
<p>Thanks Arthur! I managed to get it working</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Parser</span>
<span class="kn">import</span> <span class="n">Lean.Elab</span>

<span class="kd">structure</span> <span class="n">Idx</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">i.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i.toUSize</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">USize</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span> <span class="c1">--</span>

<span class="c1">---</span>

<span class="kd">inductive</span> <span class="n">NatLit</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">|</span> <span class="n">val</span>
<span class="kd">def</span> <span class="n">natLit</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">NatLit</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">NatLit.val</span>

<span class="c1">---</span>

<span class="kd">instance</span> <span class="n">hadd</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">NatLit</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">m.toUSize</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab.Term</span> <span class="n">Meta</span> <span class="k">in</span>
<span class="n">elab</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="s2">" + "</span> <span class="n">b</span><span class="o">:</span><span class="n">Lean.Parser.numLit</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">b.toNat</span>
  <span class="k">let</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">a</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">b</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">ta</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">a</span>
  <span class="k">let</span> <span class="n">tb</span> <span class="bp">←</span> <span class="n">inferType</span> <span class="n">b</span>
  <span class="n">mkAppM</span> <span class="bp">``</span><span class="n">HAdd.hAdd</span> <span class="bp">#</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="bp">←</span> <span class="n">mkAppM</span> <span class="bp">``</span><span class="n">natLit</span> <span class="bp">#</span><span class="o">[</span><span class="n">mkNatLit</span> <span class="n">n</span><span class="o">])]</span> <span class="c1">--(← mkAppM ``natLit #[b])]</span>


<span class="k">#eval</span> <span class="mi">10</span> <span class="bp">+</span> <span class="mi">12</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">6</span> <span class="o">:</span> <span class="n">Idx</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">2</span>
</code></pre></div>



<a name="281468749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281468749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281468749">(May 06 2022 at 17:19)</a>:</h4>
<p>That's even simpler. No need for <code>inferType</code></p>



<a name="281479334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281479334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281479334">(May 06 2022 at 18:48)</a>:</h4>
<p>This is an interesting thread and it exposes limitations in the current elaboration method we use for arithmetic expressions. It is great to see you find a workaround. Note that it is important to set the right precedence otherwise it will affect the standard <code>+</code> notation. The <code>NatLit</code> trick is not needed for this particular example, but I can see it adds extra flexibility.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Parser</span>
<span class="kn">import</span> <span class="n">Lean.Elab</span>

<span class="kd">structure</span> <span class="n">Idx</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">i.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i.toUSize</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="n">USize</span> <span class="o">(</span><span class="n">Idx</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">i.1</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩⟩</span> <span class="c1">--</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab.Term</span> <span class="n">Meta</span> <span class="k">in</span>
<span class="n">elab</span><span class="o">:</span><span class="mi">65</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="s2">" + "</span> <span class="n">b</span><span class="o">:</span><span class="n">num</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">b.toNat</span>
  <span class="k">let</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">a</span> <span class="n">none</span>
  <span class="n">mkAppM</span> <span class="bp">``</span><span class="n">HAdd.hAdd</span> <span class="bp">#</span><span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="bp">←</span> <span class="n">mkAppM</span> <span class="bp">``</span><span class="n">Nat.toUSize</span> <span class="bp">#</span><span class="o">[</span><span class="n">mkNatLit</span> <span class="n">n</span><span class="o">])]</span>
</code></pre></div>



<a name="281481762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281481762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281481762">(May 06 2022 at 19:09)</a>:</h4>
<p>I want now to focus on the standard arithmetic elaboration function and gather ideas on how to improve it. <br>
Note that we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">x</span> <span class="bp">+</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">binop</span><span class="bp">%</span> <span class="n">HAdd.hAdd</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">x</span> <span class="bp">-</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">binop</span><span class="bp">%</span> <span class="n">HSub.hSub</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">x</span> <span class="bp">*</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">binop</span><span class="bp">%</span> <span class="n">HMul.hMul</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>
<span class="n">macro_rules</span> <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">x</span> <span class="bp">/</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">binop</span><span class="bp">%</span> <span class="n">HDiv.hDiv</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p><code>binop%</code> is an auxiliary notation that comes with its own elaboration function which is implemented in the file <code>src/Lean/Elab/Extra.lean</code>. This elaboration function builds a tree, analysis it, and then injects coercions where needed. The <code>analyze</code> function tries to find a "maximal type" using an order <code>A &lt; B</code> if there is a coercion from <code>A</code> to <code>B</code>. It also tracks whether there are uncomparable types. Moreover, terms that have unknown types (i.e., the type is a metavariable) are ignored when computing the maximal type. When applying the coercions, the unknown types will become the maximal type due to unification. For example, given <code>(x : _) (y : Int) (z : Nat)</code>, the term <code>z + y + 2 + x</code> is elaborated as  <code>Inf.ofNat z + y + 2 + x</code>, note that the <code>2</code> and <code>x</code> are elaborated as <code>Int</code>. The current approach passes a collection of tests mixing <code>Nat</code>, <code>Int</code>, <code>Rat</code> terms, and addresses counterintuitive behavior found in Lean 3. For example, Lean 3 fails to elaborate <code>z + y + 2 + x</code>.<br>
That being said, a side-effect of this approach is that the numeric literals will always have the type of the maximal type which is bad for <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span>'s example. A simple solution is to add a mechanism for marking types where numeric literals are skipped during the second step (coercion application). If we do that, then, we can mark the instance <code>HAdd (Idx n) USize (Idx n)</code> with priority higher than the instance <code>HAdd α α α</code>, and it should work.</p>



<a name="281482086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281482086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281482086">(May 06 2022 at 19:13)</a>:</h4>
<p>The drawback of the simple solution above is the extra complexity and more confusion.</p>



<a name="281482908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281482908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281482908">(May 06 2022 at 19:21)</a>:</h4>
<p>For <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span>'s example, it is sufficient to check whether the maximal type implements the homogenous instance <code>Add</code>, but it will not be sufficient for the vector space example <span class="user-mention" data-user-id="306601">@Kyle Miller</span> mentioned above.</p>



<a name="281527528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281527528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281527528">(May 07 2022 at 08:19)</a>:</h4>
<p>This is a bigger can of worms than I thought.</p>
<p>Using the maximal type might cause an  invisible performance issue. When you have an array <code>x</code> and write <code>x + 1</code>, you do not want to initialize a new array full of ones and add it to <code>x</code>. Even worse if you have component wise multiplication. Writing <code>2*x</code> might silently create an array full of twos and do component wise multiplication.</p>
<p>The answer to this might be: do not to define the coercion from the array's value type to an array. However, if you want to use the fact that arrays of some comm ring form an algebra you probably get such coercion(not sure if mathlib does that). At least you get <code>0</code> and <code>1</code> defined. So what should <code>x + 2*1</code> do?</p>



<a name="281527621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281527621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281527621">(May 07 2022 at 08:21)</a>:</h4>
<p>Well it should do scalar multiplication and then broadcasted addition.</p>



<a name="281527781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281527781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281527781">(May 07 2022 at 08:24)</a>:</h4>
<p>From this example I feel that the heuristic should be more like: "use the minimal type for which you can do the heterogenous operation". </p>
<p>Not sure if this would be good or bad  for expressions mixing Nat, Int, Rat, Real ...</p>



<a name="281528294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281528294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281528294">(May 07 2022 at 08:36)</a>:</h4>
<p>Just to comment that in mathlib3 we use different symbols for homogeneous multiplication <code>* : A -&gt; A -&gt; A</code> and heterogeneous multiplication <code>• : A -&gt; B -&gt; B</code> <a href="https://leanprover-community.github.io/mathlib_docs/find/has_scalar.smul">docs#has_scalar.smul</a> , and it's the latter which we use for a field acting on a vector space</p>



<a name="281536671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281536671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281536671">(May 07 2022 at 11:53)</a>:</h4>
<p>Right, I forgot that mathlib3 uses different notation for these and mathlib4 does not yet have group action defined.</p>
<p>If I understand it correctly, in Lean 3 it was not possible to use the same symbol. I'm curious what people think about using the same symbol for multiplication and scalar multiplication.</p>



<a name="281536754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281536754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281536754">(May 07 2022 at 11:54)</a>:</h4>
<p>I think I came up with a bunch of cases where it would behave really badly with respect to instance diamond, but I dont remember them just yet</p>



<a name="281536843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281536843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281536843">(May 07 2022 at 11:56)</a>:</h4>
<p>My opinion is that <code>HMul</code> is more likely to cause headaches due to instance search compared to the cost of having to use different symbols here and getting good type inference</p>



<a name="281537177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281537177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281537177">(May 07 2022 at 12:02)</a>:</h4>
<p>Here's the case I was thinking of (in lean3 I'm afraid):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HMul</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hmul</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span>

<span class="kn">export</span> <span class="n">HMul</span> <span class="o">(</span><span class="n">hmul</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="c1">-- hmul transfers elementwise on the right argument</span>
<span class="kd">instance</span> <span class="n">pi.right</span>
  <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">HMul</span> <span class="n">A</span> <span class="o">(</span><span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">A</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">C</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span><span class="o">,</span> <span class="n">hmul</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="n">i</span><span class="o">)⟩</span>

<span class="c1">-- hmul transfers elementwise on the left argument</span>
<span class="kd">instance</span> <span class="n">pi.left</span>
  <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">C</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">HMul</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="n">B</span> <span class="o">(</span><span class="n">C</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="n">B</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">C</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span><span class="o">,</span> <span class="n">hmul</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span> <span class="n">b</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">uh_oh</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">HMul</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">pi.left</span> <span class="o">:</span> <span class="n">HMul</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">))</span> <span class="bp">=</span> <span class="n">pi.right</span>  <span class="o">:=</span>
<span class="n">rfl</span> <span class="c1">-- fails</span>

<span class="kd">lemma</span> <span class="n">oh_no</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">HMul</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">pi.left</span> <span class="o">:</span> <span class="n">HMul</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">))</span> <span class="bp">=</span> <span class="n">pi.right</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">hmul</span><span class="o">],</span>
  <span class="gr">sorry</span> <span class="c1">-- `hmul (a i) (b j) = hmul (a j) (b i)`, which is not going to be true</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281537348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281537348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281537348">(May 07 2022 at 12:06)</a>:</h4>
<p>Note that <code>pi.right</code> is basically <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar">docs#pi.has_scalar</a></p>



<a name="281542075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281542075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281542075">(May 07 2022 at 14:01)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> </p>
<blockquote>
<p>The answer to this might be: do not to define the coercion from the array's value type to an array.</p>
</blockquote>
<p>Yes, if you have scalar multiplication for arrays, defining a coercion from values to arrays is going to create problems. For example, your <code>2*x</code> example would be ambiguous. That being said, I am not concerned about this example because as far as I remember, I have never used a system where there is a coercion from values to arrays.<br>
I am more interested in getting <code>2*x</code> to work without adding a type ascription on the 2 when we have an instance for scalar multiplication.</p>
<blockquote>
<p>However, if you want to use the fact that arrays of some comm ring form an algebra you probably get such coercion(not sure if mathlib does that). At least you get 0 and 1 defined. </p>
</blockquote>
<p>I think this is a not super common scenario, and we can work around it by having a definition that "arrays of some comm ring form an algebra", but not mark it as an instance, or have it as scoped instance. </p>
<blockquote>
<p>From this example I feel that the heuristic should be more like: "use the minimal type for which you can do the heterogenous operation".</p>
</blockquote>
<p>I am happy you are trying to help, but we cannot afford to spend time trying suggestions that do not come with any evidence that they would work. </p>
<p>Don't take me wrong, we want to improve the current approach and make it better, and we will be grateful for any help we can get.  It is very helpful to collect examples that we think should work but don't. Then, using the collected examples to test a new approach before suggesting them is even more useful.</p>



<a name="281542156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281542156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281542156">(May 07 2022 at 14:03)</a>:</h4>
<blockquote>
<p>If I understand it correctly, in Lean 3 it was not possible to use the same symbol. I'm curious what people think about using the same symbol for multiplication and scalar multiplication.</p>
</blockquote>
<p>Independently of what Mathlib decides to do, we are committed to supporting that in Lean. This can be done in many modern programming languages.</p>



<a name="281543551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281543551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281543551">(May 07 2022 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals/near/281527528">said</a>:</p>
<blockquote>
<p>However, if you want to use the fact that arrays of some comm ring form an algebra you probably get such coercion(not sure if mathlib does that). At least you get <code>0</code> and <code>1</code> defined. So what should <code>x + 2*1</code> do?</p>
</blockquote>
<p>In lean3 + mathlib, if <code>x : fin n -&gt; R</code>, then <code>x + 2*1</code> is defeq to <code>(fun i, x i + 2 * 1)</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>I don't know what the VM representation of that form of "array" is though.</p>



<a name="281546948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281546948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281546948">(May 07 2022 at 15:56)</a>:</h4>
<p>I recently noticed this unexpected behavior with chains of default instances:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HOp</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="n">where</span> <span class="n">hOp</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>

<span class="kd">class</span> <span class="n">LOp</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span> <span class="n">lOp</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span>

<span class="kd">class</span> <span class="n">Op</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="n">where</span> <span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">@[defaultInstance]</span>
<span class="kd">instance</span> <span class="n">inst1</span> <span class="o">[</span><span class="n">LOp</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">HOp</span> <span class="n">α</span> <span class="n">β</span> <span class="n">β</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">LOp.lOp</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">inst2</span> <span class="o">[</span><span class="n">Op</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">LOp</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Op.op</span><span class="o">⟩</span>

<span class="kd">infix</span><span class="o">:</span><span class="mi">75</span> <span class="s2">" ⋆ "</span> <span class="bp">=&gt;</span> <span class="n">HOp.hOp</span>

<span class="kn">section</span> <span class="n">Test</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">LOp</span> <span class="n">Nat</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">⋆</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- TC works</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">⋆</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- TC works</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">defaultInstance</span><span class="o">]</span> <span class="n">inst2</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">⋆</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- TC works</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">⋆</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- TC fails</span>

<span class="kd">end</span> <span class="n">Test</span>
</code></pre></div>
<p>It seems odd that adding a default instance should cause a working TC resolution to fail. If that did not happen, it would help with the issue in this thread.  I don't know if this is intended behavior.</p>



<a name="281548621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281548621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281548621">(May 07 2022 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="119741">@François G. Dorais</span> Yes, this is a current limitation of the default instance mechanism. When Lean finds an applicable default instance, it does not backtrack if the generated subproblems cannot be solved. I am currently trying to fix this issue.</p>



<a name="281549309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281549309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281549309">(May 07 2022 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals/near/281537177">said</a>:</p>
<blockquote>
<p>Here's the case I was thinking of (in lean3 I'm afraid):<br>
...</p>
</blockquote>
<p>This is exactly the edge case I ran into when playing with broadcasting. When you have an operation between square matrix and a vector, you do not know if you should treat it as a column or row vector.</p>



<a name="281549838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281549838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281549838">(May 07 2022 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="119741">@François G. Dorais</span> Lean now backtracks while trying to apply default instances. Your example now works with the following commit<br>
<a href="https://github.com/leanprover/lean4/commit/38baeaf373a19e57130dd7b003a2aaa67b527e6a">https://github.com/leanprover/lean4/commit/38baeaf373a19e57130dd7b003a2aaa67b527e6a</a></p>



<a name="281550105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281550105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281550105">(May 07 2022 at 17:05)</a>:</h4>
<blockquote>
<p>This is exactly the edge case I ran into when playing with broadcasting. When you have an operation between square matrix and a vector, you do not know if you should treat it as a column or row vector.</p>
</blockquote>
<p>In maths you would be able to figure this out by looking at whether you're writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>∗</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">M*v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> (column) or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">v*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> (row).</p>



<a name="281551649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281551649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281551649">(May 07 2022 at 17:37)</a>:</h4>
<p>Improved the <code>binop%</code> elaboration function. The following examples should work now</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[defaultInstance]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">α</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">hMul</span> <span class="n">a</span> <span class="n">as</span> <span class="o">:=</span> <span class="n">as.map</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="bp">·</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Mul</span> <span class="o">(</span><span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">mul</span> <span class="n">as</span> <span class="n">bs</span> <span class="o">:=</span> <span class="o">(</span><span class="n">as.zip</span> <span class="n">bs</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="k">fun</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>

<span class="k">#eval</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">#</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">f9</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="n">as</span> <span class="bp">*</span> <span class="n">bs</span>

<span class="kd">def</span> <span class="n">f10</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Int</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Int</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Int</span> <span class="o">:=</span>
  <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">as</span> <span class="bp">*</span> <span class="n">bs</span>

<span class="kd">def</span> <span class="n">f11</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Int</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Int</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Int</span> <span class="o">:=</span>
  <span class="mi">3</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">as</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">bs</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">f12</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">as.foldl</span> <span class="o">(</span><span class="n">init</span> <span class="o">:=</span> <span class="n">bs</span><span class="o">)</span> <span class="k">fun</span> <span class="n">bs</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">bs</span>
</code></pre></div>
<p>The commit has comments explaining the changes to <code>binop%</code><br>
<a href="https://github.com/leanprover/lean4/commit/af5e13e5345359a93f24c3831feec97d4619dbf0">https://github.com/leanprover/lean4/commit/af5e13e5345359a93f24c3831feec97d4619dbf0</a></p>



<a name="281558274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281558274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281558274">(May 07 2022 at 20:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>:</p>
<blockquote>
<p>In maths you would be able to figure this out by looking at whether you're writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>∗</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">M*v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> (column) or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">v*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> (row).</p>
</blockquote>
<p>I think <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> is talking about elementwise products (like <code>*</code> in numpy) not contraction (matrix) products like the mathematicians usually care about.</p>



<a name="281558386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281558386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281558386">(May 07 2022 at 20:11)</a>:</h4>
<p>The problem doesn't appear with numpy "broadcasting" because 2D arrays are first-class objects rather than arrays of arrays</p>



<a name="281794397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281794397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281794397">(May 10 2022 at 08:47)</a>:</h4>
<p>(I kind of hate numpy broadcasting for precisely that reason... this summer I plan to experiment with other APIs to find a more predictable syntax for a numpy-esque library, if anyone wants to share suggestions <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span>)</p>



<a name="281795324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281795324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281795324">(May 10 2022 at 08:55)</a>:</h4>
<p>(as an active numpy maintainer in a past life, I'd be very interested in seeing what you come up with!)</p>



<a name="281846836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281846836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281846836">(May 10 2022 at 16:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals/near/281549309">said</a>:</p>
<blockquote>
<p>This is exactly the edge case I ran into when playing with broadcasting. When you have an operation between square matrix and a vector, you do not know if you should treat it as a column or row vector.</p>
</blockquote>
<p>The J-style rule for broadcasting is that if you (hadamard) multiply a matrix and a vector, you end up doing the hadamard product of the vector with each row of the matrix. That's because the matrix is rank-2 (say with dimensions [a,b]) and the vector is rank-1 (say with dimensions [b]), so the vector gets lifted to a rank-2 array with dimensions [a,b] -- new dimensions are always added to the left.  If the matrix were square and you wanted the other behavior, you'd have to lift the vector yourself.</p>
<p>The "vector of" functor is a monad, and one way to interpret this is that broadcasting is that you repeatedly apply <code>pure</code> to one of the arguments to add dimensions to the left to make the arguments compatible, if possible. You can insert a dimension anywhere in an array using <code>pure</code>, <code>fmap pure</code>, <code>fmap (fmap pure)</code>, and so on, if you want to get other behavior.</p>



<a name="281847876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281847876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281847876">(May 10 2022 at 16:11)</a>:</h4>
<blockquote>
<p>The J-style rule for broadcasting is that if you (hadamard) multiply a matrix and a vector, you end up doing the hadamard product of the vector with each row of the matrix. </p>
</blockquote>
<p>Yes, this is the numpy rule too. The problem is that you end up in a mess when you're working with a matrix over some generic type <code>A</code>, and then someone sets <code>A</code> to the type of 1D arrays</p>



<a name="281848000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281848000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281848000">(May 10 2022 at 16:12)</a>:</h4>
<p>If you create a specific "nd container" object (like <a href="https://leanprover-community.github.io/mathlib_docs/find/holor">docs#holor</a>?) to represent your matrices / vectors etc then that problem goes away</p>



<a name="281851464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281851464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281851464">(May 10 2022 at 16:36)</a>:</h4>
<p>Interestingly, while still a problem, it's less of a problem for Lean than Python: if you resolve all the broadcasting inside a function's definition, it won't suddenly change behavior just because you pass in an array -- typeclasses don't respect referential transparency. In Python (and in J), broadcasting is resolved at runtime.</p>
<p>As far as I know, there are two basic solutions to this. The first is what you mention, a special multidimensional array type that guarantees that the dimensions are completely legible. The second is what J does, which is having a way to "box" a value so it won't participate in broadcasting anymore. The multidimensional array type records the span of all the indices itself, where the box records the divider between spans of indices.</p>



<a name="281917347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281917347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281917347">(May 11 2022 at 04:29)</a>:</h4>
<p>To answer whether to add dimensions to the left or right you decide between these two opposing requirements:</p>
<ol>
<li>If you have a scalar <code>r</code> and a function <code>f</code> both depending on a parameter <code>i : R</code> You want <code>(r * f) i = r i * f i</code> to hold even when <code>f</code>'s type is <code>R -&gt; R -&gt; S</code>.</li>
<li>If you have a function <code>f</code> depending on a parameter <code>i : R</code>  and function <code>g</code> not depending on it. You want <code>(f * g) i = f i * g</code></li>
</ol>
<p>I think 1. is adding dimension to the right and 2. is adding dimension to the left. Maybe it is the other way around, I always get confused.</p>
<p>Also I ended up with the "boxing" approach. You can define type synonym and provide different TC instances to modify default behavior.</p>



<a name="281918081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Heterogenous%20operation%20and%20literals/near/281918081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals.html#281918081">(May 11 2022 at 04:45)</a>:</h4>
<p>However, I had some type class issues so I abandoned my "clever" array indexing and thus didn't discover all the gotchas in my approach. I should revise it and start using it again and see if it holds up.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
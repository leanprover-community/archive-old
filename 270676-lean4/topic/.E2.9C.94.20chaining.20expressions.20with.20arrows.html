---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html">✔ chaining expressions with arrows</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="275816020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816020">(Mar 18 2022 at 15:13)</a>:</h4>
<p>Not completely sure if this is doing the right thing though from inspection of source code.</p>



<a name="275816051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816051">(Mar 18 2022 at 15:13)</a>:</h4>
<p>If there are no dependent arrows, you can just fold over <code>mkArrow</code></p>



<a name="275816188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816188">(Mar 18 2022 at 15:14)</a>:</h4>
<p>Choice between foldl and foldr left as an exercise to the reader :)</p>



<a name="275816221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816221">(Mar 18 2022 at 15:14)</a>:</h4>
<p>what does mkForallFVars do?</p>



<a name="275816620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816620">(Mar 18 2022 at 15:17)</a>:</h4>
<p>In this context there can be dependency</p>



<a name="275816664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816664">(Mar 18 2022 at 15:18)</a>:</h4>
<p><span class="user-mention" data-user-id="121918">@Edward Ayers</span> It takes an array of <code>Expr.fvar</code>s and a term that may contain those fvars, and binds them as universal quantifiers</p>



<a name="275816830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816830">(Mar 18 2022 at 15:19)</a>:</h4>
<p>(and the fvars' types may themselves reference previous fvars, as usual)</p>



<a name="275816907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275816907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275816907">(Mar 18 2022 at 15:19)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> Then it's not clear what your <code>es</code> contains</p>



<a name="275817301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275817301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275817301">(Mar 18 2022 at 15:22)</a>:</h4>
<p>Actually, the array passed to <code>mk{Forall,Lambda,Let}FVars</code> may now also contain unassigned metavariables with a recent change. The name is not perfectly accurate.</p>



<a name="275818042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275818042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275818042">(Mar 18 2022 at 15:27)</a>:</h4>
<p>Ooooh will it do a delayed abstraction in that case? (sorry for derailing your q <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> )</p>



<a name="275818862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275818862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275818862">(Mar 18 2022 at 15:32)</a>:</h4>
<p>No problem at all.</p>
<p>Folding with <code>mkArrow</code> seems to be working (kinda). But I'm still doing something wrong:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">def</span> <span class="n">Lean.Parser.Term.haveIdLhs'</span> <span class="o">:=</span>
  <span class="n">optional</span> <span class="o">(</span><span class="n">ident</span> <span class="bp">&gt;&gt;</span> <span class="n">many</span> <span class="o">(</span><span class="n">ppSpace</span> <span class="bp">&gt;&gt;</span>
    <span class="n">checkColGt</span> <span class="s2">"expected to be indented"</span> <span class="bp">&gt;&gt;</span>
    <span class="o">(</span><span class="n">simpleBinderWithoutType</span> <span class="bp">&lt;|&gt;</span> <span class="n">bracketedBinder</span><span class="o">)))</span> <span class="bp">&gt;&gt;</span> <span class="n">optType</span>

<span class="kn">namespace</span> <span class="n">Mathlib.Tactic</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab.Tactic</span> <span class="n">Meta</span>

<span class="n">syntax</span> <span class="s2">"have "</span> <span class="n">Parser.Term.haveIdLhs'</span> <span class="o">:</span> <span class="n">tactic</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">addToContext</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">TacticM</span> <span class="n">Unit</span> <span class="o">:=</span>
  <span class="n">liftMetaTactic</span> <span class="k">fun</span> <span class="n">mvarId</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">p</span> <span class="bp">←</span> <span class="n">mkFreshExprMVar</span> <span class="o">(</span><span class="n">userName</span> <span class="o">:=</span> <span class="n">name</span><span class="o">)</span> <span class="n">t</span>
    <span class="k">let</span> <span class="n">mvarIdNew</span> <span class="bp">←</span> <span class="n">assert</span> <span class="n">mvarId</span> <span class="n">name</span> <span class="n">t</span> <span class="n">p</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">mvarIdNew</span><span class="o">)</span> <span class="bp">←</span> <span class="n">intro1P</span> <span class="n">mvarIdNew</span>
    <span class="n">return</span> <span class="o">[</span><span class="n">p.mvarId</span><span class="bp">!</span><span class="o">,</span> <span class="n">mvarIdNew</span><span class="o">]</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">getName</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">:</span> <span class="n">Name</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="n">this</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n.getId</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">elabType</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">:</span> <span class="n">TacticM</span> <span class="n">Expr</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="n">mkFreshTypeMVar</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">t</span> <span class="bp">=&gt;</span> <span class="n">elabTerm</span> <span class="n">t</span> <span class="n">none</span>

<span class="n">elab_rules</span> <span class="o">:</span> <span class="n">tactic</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span><span class="k">have</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span><span class="o">]</span><span class="bp">?</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">withMainContext</span> <span class="k">do</span>
  <span class="n">addToContext</span> <span class="o">(</span><span class="n">getName</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">←</span> <span class="n">elabType</span> <span class="n">t</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span><span class="k">have</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span> <span class="bp">$</span><span class="n">bs</span><span class="bp">*</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">withMainContext</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">es</span> <span class="bp">←</span> <span class="n">Elab.Term.elabBinders</span> <span class="n">bs</span> <span class="bp">$</span> <span class="k">fun</span> <span class="n">es</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">es</span>
  <span class="k">let</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">es.foldrM</span> <span class="o">(</span><span class="n">init</span> <span class="o">:=</span> <span class="bp">←</span> <span class="n">elabType</span> <span class="n">t</span><span class="o">)</span> <span class="k">fun</span> <span class="n">eₗ</span> <span class="n">e</span><span class="bp">ᵣ</span> <span class="bp">=&gt;</span> <span class="n">mkArrow</span> <span class="n">eₗ</span> <span class="n">e</span><span class="bp">ᵣ</span>
  <span class="n">addToContext</span> <span class="n">n.getId</span> <span class="n">e</span>

<span class="k">#check</span> <span class="n">Expr</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">k</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="c1">-- case k</span>
  <span class="c1">-- ⊢ _uniq.4416 → _uniq.4418 → Nat</span>
  <span class="c1">-- k : _uniq.4416 → _uniq.4418 → Nat</span>
  <span class="c1">-- ⊢ True</span>
</code></pre></div>



<a name="275819230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275819230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275819230">(Mar 18 2022 at 15:34)</a>:</h4>
<p>If a function like <code>elabBinders</code> takes a closure instead of returning the value, you can assume there is usually a very good reason for that. In this case, because it returns an array of fvars (...bing!) that are only valid in the local context in which the closure is executed</p>



<a name="275819571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275819571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275819571">(Mar 18 2022 at 15:36)</a>:</h4>
<p><span class="user-mention" data-user-id="121918">@Edward Ayers</span> They are simply bound as if they were fvars. This behavior is mainly for the pattern matching compiler that needs to convert unsolved metavariables into pattern variables. Usually you'll want to solve all metavariables :) .</p>



<a name="275819752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275819752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275819752">(Mar 18 2022 at 15:38)</a>:</h4>
<p>See also <code>elabForall</code> for a very simple example of <code>elabBinders</code>+<code>mkForallFVars</code></p>



<a name="275820545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275820545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275820545">(Mar 18 2022 at 15:44)</a>:</h4>
<p>Now I'm running into some monadic trouble:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">def</span> <span class="n">Lean.Parser.Term.haveIdLhs'</span> <span class="o">:=</span>
  <span class="n">optional</span> <span class="o">(</span><span class="n">ident</span> <span class="bp">&gt;&gt;</span> <span class="n">many</span> <span class="o">(</span><span class="n">ppSpace</span> <span class="bp">&gt;&gt;</span>
    <span class="n">checkColGt</span> <span class="s2">"expected to be indented"</span> <span class="bp">&gt;&gt;</span>
    <span class="o">(</span><span class="n">simpleBinderWithoutType</span> <span class="bp">&lt;|&gt;</span> <span class="n">bracketedBinder</span><span class="o">)))</span> <span class="bp">&gt;&gt;</span> <span class="n">optType</span>

<span class="kn">namespace</span> <span class="n">Mathlib.Tactic</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab.Tactic</span> <span class="n">Meta</span>

<span class="n">syntax</span> <span class="s2">"have "</span> <span class="n">Parser.Term.haveIdLhs'</span> <span class="o">:</span> <span class="n">tactic</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">addToContext</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">TacticM</span> <span class="n">Unit</span> <span class="o">:=</span>
  <span class="n">liftMetaTactic</span> <span class="k">fun</span> <span class="n">mvarId</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">p</span> <span class="bp">←</span> <span class="n">mkFreshExprMVar</span> <span class="o">(</span><span class="n">userName</span> <span class="o">:=</span> <span class="n">name</span><span class="o">)</span> <span class="n">t</span>
    <span class="k">let</span> <span class="n">mvarIdNew</span> <span class="bp">←</span> <span class="n">assert</span> <span class="n">mvarId</span> <span class="n">name</span> <span class="n">t</span> <span class="n">p</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">mvarIdNew</span><span class="o">)</span> <span class="bp">←</span> <span class="n">intro1P</span> <span class="n">mvarIdNew</span>
    <span class="n">return</span> <span class="o">[</span><span class="n">p.mvarId</span><span class="bp">!</span><span class="o">,</span> <span class="n">mvarIdNew</span><span class="o">]</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">getName</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">:</span> <span class="n">Name</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="bp">`</span><span class="n">this</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n.getId</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">elabType</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">:</span> <span class="n">Elab.TermElabM</span> <span class="n">Expr</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="n">mkFreshTypeMVar</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">t</span> <span class="bp">=&gt;</span> <span class="n">elabTerm</span> <span class="n">t</span> <span class="n">none</span>

<span class="n">elab_rules</span> <span class="o">:</span> <span class="n">tactic</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span><span class="k">have</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span><span class="o">]</span><span class="bp">?</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">withMainContext</span> <span class="k">do</span>
  <span class="n">addToContext</span> <span class="o">(</span><span class="n">getName</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">←</span> <span class="n">elabType</span> <span class="n">t</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span><span class="k">have</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span> <span class="bp">$</span><span class="n">bs</span><span class="bp">*</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">withMainContext</span> <span class="k">do</span>
  <span class="n">Elab.Term.elabBinders</span> <span class="n">bs</span> <span class="bp">$</span> <span class="k">fun</span> <span class="n">es</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">es.foldrM</span> <span class="o">(</span><span class="n">init</span> <span class="o">:=</span> <span class="bp">←</span> <span class="n">elabType</span> <span class="n">t</span><span class="o">)</span> <span class="k">fun</span> <span class="n">eₗ</span> <span class="n">e</span><span class="bp">ᵣ</span> <span class="bp">=&gt;</span> <span class="n">mkArrow</span> <span class="n">eₗ</span> <span class="n">e</span><span class="bp">ᵣ</span>
    <span class="n">addToContext</span> <span class="n">n.getId</span> <span class="n">e</span>
    <span class="c1">-- type mismatch</span>
    <span class="c1">--   Mathlib.Tactic.addToContext (Syntax.getId n) e</span>
    <span class="c1">-- has type</span>
    <span class="c1">--   TacticM Unit : Type</span>
    <span class="c1">-- but is expected to have type</span>
    <span class="c1">--   Elab.TermElabM Unit : Type</span>
</code></pre></div>



<a name="275820590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275820590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275820590">(Mar 18 2022 at 15:45)</a>:</h4>
<p><code>addToContext</code> needs to run in <code>TacticM</code> :(</p>



<a name="275822102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275822102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275822102">(Mar 18 2022 at 15:56)</a>:</h4>
<p>So an example of the syntax you are matching is something like <code>have f (a : α) (b : β(a)) : γ a b</code>.<br>
<code>elabBinders bs</code> will add <code>a</code> and <code>b</code> to the TermElabM's context. <code>es</code> is going to be the fvars <code>[a,b]</code>so I don't think mkArrow is the right answer here. I think you want <code>mkForallFVar es (← elabType t)</code>.</p>



<a name="275822357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275822357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275822357">(Mar 18 2022 at 15:58)</a>:</h4>
<p>Once you have made <code>e</code> to be  <code>(a : α) → (b : β(a)) → γ a b</code>, you are done with the context with <code>a,b</code> so you can return <code>e</code> in the innermost <code>do</code> block. Then add e to the context in the outer do block.</p>



<a name="275822615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275822615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275822615">(Mar 18 2022 at 15:59)</a>:</h4>
<p>something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span><span class="k">have</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span> <span class="bp">$</span><span class="n">bs</span><span class="bp">*</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">withMainContext</span> <span class="k">do</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">Elab.Term.elabBinders</span> <span class="n">bs</span> <span class="bp">$</span> <span class="k">fun</span> <span class="n">es</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="n">mkForallFvars</span> <span class="n">es</span> <span class="o">(</span><span class="bp">←</span> <span class="n">elabType</span> <span class="n">t</span><span class="o">)</span>
  <span class="n">addToContext</span> <span class="n">n.getId</span> <span class="n">e</span>
</code></pre></div>



<a name="275823065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275823065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275823065">(Mar 18 2022 at 16:01)</a>:</h4>
<p>That worked like a charm:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">tactic</span><span class="bp">|</span><span class="k">have</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">ident</span> <span class="bp">$</span><span class="n">bs</span><span class="bp">*</span> <span class="bp">$</span><span class="o">[:</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">term</span><span class="o">]</span><span class="bp">?</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">withMainContext</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">Elab.Term.elabBinders</span> <span class="n">bs</span> <span class="bp">$</span> <span class="k">fun</span> <span class="n">es</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="n">mkForallFVars</span> <span class="n">es</span> <span class="o">(</span><span class="bp">←</span> <span class="n">elabType</span> <span class="n">t</span><span class="o">)</span>
    <span class="n">addToContext</span> <span class="n">n.getId</span> <span class="n">e</span>
</code></pre></div>
<p>(just fixed some typos)</p>



<a name="275823304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275823304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275823304">(Mar 18 2022 at 16:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">k</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="c1">-- case k</span>
  <span class="c1">-- ⊢ Nat → Nat → Nat</span>
  <span class="c1">-- k : Nat → Nat → Nat</span>
  <span class="c1">-- ⊢ True</span>
</code></pre></div>
<p>Thanks! <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span></p>



<a name="275823327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275823327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275823327">(Mar 18 2022 at 16:02)</a>:</h4>
<p>Yeah the tricky part is making sure that everything is running in the right context.</p>



<a name="275823682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275823682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275823682">(Mar 18 2022 at 16:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> has marked this topic as resolved.</p>



<a name="275823768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275823768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275823768">(Mar 18 2022 at 16:05)</a>:</h4>
<p>Can you check this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">γ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">γ</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="275824057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275824057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275824057">(Mar 18 2022 at 16:07)</a>:</h4>
<p>ah no nevermind because it is putting the goals the other way round so it won't work</p>



<a name="275824638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275824638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275824638">(Mar 18 2022 at 16:10)</a>:</h4>
<p>it works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">γ</span> <span class="n">a</span> <span class="n">b</span>
  <span class="c1">-- case f</span>
  <span class="c1">-- ⊢ (a : α) → (b : β a) → γ a b</span>
  <span class="c1">-- f : (a : α) → (b : β a) → γ a b</span>
  <span class="c1">-- ⊢ True</span>
</code></pre></div>



<a name="275838879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275838879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275838879">(Mar 18 2022 at 17:46)</a>:</h4>
<p>FYI that's not what it's supposed to do exactly; the metavariable for the first goal should be created inside the <code>elabBinders</code> context</p>



<a name="275846501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20chaining%20expressions%20with%20arrows/near/275846501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20chaining.20expressions.20with.20arrows.html#275846501">(Mar 18 2022 at 18:47)</a>:</h4>
<p>Alright, to keep the scopes clean, we can continue the discussion specific to the tactic in the <a href="#narrow/stream/287929-mathlib4/topic/expand.20.60have.60.20capabilities/near/275569867">mathlib4 stream's thread</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
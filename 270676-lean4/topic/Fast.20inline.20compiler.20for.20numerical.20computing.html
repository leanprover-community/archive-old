---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html">Fast inline compiler for numerical computing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="253789085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253789085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253789085">(Sep 17 2021 at 18:45)</a>:</h4>
<p>As a hobby project, I would like to do some scientific/numerical computing in Lean. The main lure of Lean for me is the ability to formalize the mathematics behind these computations and hopefully use it to transform the code either for optimization or differentiation. (One motivating example is C++ library Eigen for linear algebra, that builds expressions involving matrices and vectors. Then at compile time it finds optimal strategy how to evaluate. )</p>
<p>However as an interpreted language, it would be too slow for numerical computing. Thus I'm thinking of writing a specialized compiler to speed up inner most loops of those computations that would not box types but keep them inlined as much as possible.</p>
<p>I do not attempt to create a compiler for arbitrary Lean code, but maybe I would just restrict to only a handful of types and compile non-dependent functions.</p>
<p>My hope is to inline types like: </p>
<p>- <code>Float × Float</code> to <code>std::pair&lt;double, double&gt;</code> <br>
   - <code>Array (Float × Float)</code> to <code>std::vector&lt;std::pair&lt;double, double&gt;&gt;</code> (std::vector is probably not a smart choice, but something like it with areference counter)<br>
   - <code>Float^n</code> to <code>std::array&lt;double, n&gt;</code><br>
i.e. mainly any fixed size vectors and matrices can be inlined/unboxed and arrays of these types will store them inline/unboxed.</p>
<p>Is this a good idea to attempt? Can I use the Lean.Compile.IR module in Lean for this? Or do I have to write my own? Any suggestions where should I start?</p>



<a name="253791609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253791609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253791609">(Sep 17 2021 at 19:03)</a>:</h4>
<blockquote>
<p>However as an interpreted language, it would be too slow for numerical computing.</p>
</blockquote>
<p>Nit: Lean 4 is not (exclusively or primarily) an interpreted language</p>



<a name="253791866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253791866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253791866">(Sep 17 2021 at 19:05)</a>:</h4>
<p>You will have a lot of trouble with that <code>Float^n</code> example because <code>n</code> is not normally a compile time constant in lean</p>



<a name="253791940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253791940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253791940">(Sep 17 2021 at 19:05)</a>:</h4>
<p>in fact there isn't even really a concept of compile time constants in the lean language so that kind of transformation will not be easy</p>



<a name="253805413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253805413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253805413">(Sep 17 2021 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253791609">said</a>:</p>
<blockquote>
<blockquote>
<p>However as an interpreted language, it would be too slow for numerical computing.</p>
</blockquote>
<p>Nit: Lean 4 is not (exclusively or primarily) an interpreted language</p>
</blockquote>
<p>I would like to more strongly emphasis this point. Lean 4 is, for the perspective relevant to this question, a compiled language. Furthermore, Lean 4 is FAST. In fact, it is faster than many other functional programming languages and can be even be faster than other compiled languages in some cases. After all, a compiled Lean program is just a compiled  C program with some, usually negligible,  initialization . </p>
<p>To give an example, Lake (a build program for Lean written in Lean) is actually faster than using Make (a C program) for the same task.</p>



<a name="253805646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253805646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253805646">(Sep 17 2021 at 20:51)</a>:</h4>
<p>I think the aspect relevant to this question is that while lean is compiled, it has a (mostly) uniform data representation, which might incur performance costs in very high performance numerical computing applications. I'm not sure lean is ready to target that space, but it seems feasible to progressively expand the set of representations the compiler can handle</p>



<a name="253805731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253805731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253805731">(Sep 17 2021 at 20:51)</a>:</h4>
<p>Yeah, I was about to say: if you are doing certain kinds of numerical computing, you may be looking to do some GPU accelerated things or use SIMD vectors. In which case,  Lean does not yet support such things.</p>



<a name="253805983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253805983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253805983">(Sep 17 2021 at 20:53)</a>:</h4>
<p>However,  <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> , your post seems to suggest you want to map Lean objects to C++ data structures like <code>std::pair</code>, <code>std::vector</code>, or <code>std::array</code>, which are no more efficient than their Lean equivalents.</p>



<a name="253806337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253806337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253806337">(Sep 17 2021 at 20:56)</a>:</h4>
<p>In fact, the mappings you gave are more-or-less how those Lean types are defined (just in C rather than C++ terms).</p>



<a name="253810841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253810841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253810841">(Sep 17 2021 at 21:34)</a>:</h4>
<p>Ok, fair point that about Lean and being interpreted language, well I do not even know formal definition of what interpreted language is :) Anyway, it is more or less irrelevant to what I'm asking. </p>
<p>Well one simple example of application I want to do is a simulation of particles. For this you need have an array of particles position, <code>Array (Float × Float × Float)</code>, and at every time step you need to update these positions. I want really fast <code>Array.map</code> function that updates all particles. </p>
<p>Let's have a look at operations on <code>Float × Float</code> and what Lean actually compiles to.</p>
<p>Two simple functions, create a pair from two numbers and add two pairs together.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[inline, export vec2_mk]</span>
<span class="kd">def</span> <span class="n">vec2_mk</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Float</span> <span class="bp">×</span> <span class="n">Float</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">@[inline, export vec2_add]</span>
<span class="kd">def</span> <span class="n">vec2_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Float</span> <span class="bp">×</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Float</span> <span class="bp">×</span> <span class="n">Float</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a.1</span> <span class="bp">+</span> <span class="n">b.1</span><span class="o">,</span> <span class="n">a.2</span> <span class="bp">+</span> <span class="n">b.2</span><span class="o">)</span>
</code></pre></div>
<p>The compiled code for <code>vec2_mk</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">lean_object</span><span class="bp">*</span> <span class="n">vec2_mk</span><span class="o">(</span><span class="n">double</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">double</span> <span class="n">x_2</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">_start</span><span class="o">:</span>
    <span class="o">{</span>
      <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_3</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_4</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_5</span><span class="bp">;</span>
      <span class="n">x_3</span> <span class="bp">=</span> <span class="n">lean_box_float</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_box_float</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_5</span> <span class="bp">=</span> <span class="n">lean_alloc_ctor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_ctor_set</span><span class="o">(</span><span class="n">x_5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_ctor_set</span><span class="o">(</span><span class="n">x_5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x_4</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">x_5</span><span class="bp">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>
<p>Both <code> lean_box_float</code> and <code>lean_alloc_ctor</code> allocate memory on the heap. So if you have a <code>Array (Float × Float)</code> you do not have a contiguous block of <code>2*sizeof(double)*array_length</code> bytes but you have an array of pointers pointing all around the heap to pairs of doubles. (it is actually even worse, those doubles inside of a pair are boxed)</p>
<p>For numerical computing it is absolutely crucial to have data in a contiguous block of memory, as you need to utilize memory cache as much as possible. Quite often, you preload parts of a data from the heap to stack in a predictable manner and then you access it in what ever order you need.</p>
<p>The compile code for <code>vec2_add</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">lean_object</span><span class="bp">*</span> <span class="n">vec2_add</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_2</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">_start</span><span class="o">:</span>
    <span class="o">{</span>
      <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_3</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_4</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_5</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_6</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_7</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_8</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_9</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_10</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_11</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_12</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_13</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_14</span><span class="bp">;</span> <span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_15</span><span class="bp">;</span>
      <span class="n">x_3</span> <span class="bp">=</span> <span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">x_1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_inc</span><span class="o">(</span><span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_inc</span><span class="o">(</span><span class="n">x_4</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_5</span> <span class="bp">=</span> <span class="n">lean_unbox_float</span><span class="o">(</span><span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_dec</span><span class="o">(</span><span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_6</span> <span class="bp">=</span> <span class="n">lean_unbox_float</span><span class="o">(</span><span class="n">x_4</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_dec</span><span class="o">(</span><span class="n">x_4</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_7</span> <span class="bp">=</span> <span class="n">x_5</span> <span class="bp">+</span> <span class="n">x_6</span><span class="bp">;</span>
      <span class="n">x_8</span> <span class="bp">=</span> <span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">x_1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_inc</span><span class="o">(</span><span class="n">x_8</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_dec</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_9</span> <span class="bp">=</span> <span class="n">lean_ctor_get</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_inc</span><span class="o">(</span><span class="n">x_9</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_dec</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_10</span> <span class="bp">=</span> <span class="n">lean_unbox_float</span><span class="o">(</span><span class="n">x_8</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_dec</span><span class="o">(</span><span class="n">x_8</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_11</span> <span class="bp">=</span> <span class="n">lean_unbox_float</span><span class="o">(</span><span class="n">x_9</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_dec</span><span class="o">(</span><span class="n">x_9</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_12</span> <span class="bp">=</span> <span class="n">x_10</span> <span class="bp">+</span> <span class="n">x_11</span><span class="bp">;</span>
      <span class="n">x_13</span> <span class="bp">=</span> <span class="n">lean_box_float</span><span class="o">(</span><span class="n">x_7</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_14</span> <span class="bp">=</span> <span class="n">lean_box_float</span><span class="o">(</span><span class="n">x_12</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">x_15</span> <span class="bp">=</span> <span class="n">lean_alloc_ctor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_ctor_set</span><span class="o">(</span><span class="n">x_15</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x_13</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">lean_ctor_set</span><span class="o">(</span><span class="n">x_15</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x_14</span><span class="o">)</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">x_15</span><span class="bp">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>
<p>You have to first unbox all those floats, then you can add them and box them again. With all this you are touching heap and that is not acceptable for numerical computing.</p>
<p>I want these functions to compile to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="bp">&lt;</span><span class="n">double</span><span class="o">,</span> <span class="n">double</span><span class="bp">&gt;</span> <span class="n">vec2_mk</span><span class="o">(</span><span class="n">double</span> <span class="n">a</span><span class="o">,</span> <span class="n">double</span> <span class="n">b</span><span class="o">)</span>
<span class="o">{</span>
   <span class="n">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">}</span><span class="bp">;</span>
<span class="o">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="bp">&lt;</span><span class="n">double</span><span class="o">,</span> <span class="n">double</span><span class="bp">&gt;</span> <span class="n">vec2_add</span><span class="o">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="bp">&lt;</span><span class="n">double</span><span class="o">,</span> <span class="n">double</span><span class="bp">&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="bp">&lt;</span><span class="n">double</span><span class="o">,</span> <span class="n">double</span><span class="bp">&gt;</span> <span class="n">b</span><span class="o">)</span>
<span class="o">{</span>
   <span class="n">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">{</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="bp">&lt;</span><span class="mi">0</span><span class="bp">&gt;</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="bp">&lt;</span><span class="mi">1</span><span class="bp">&gt;</span><span class="o">(</span><span class="n">b</span><span class="o">)}</span><span class="bp">;</span>
<span class="o">}</span>
</code></pre></div>
<p>Actually, when you write a function <code>Float → Float</code> then it gets compiled nicely. An example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[inline, export foo]</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="o">((</span><span class="n">Float.sin</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">Float.cos</span> <span class="n">b</span><span class="o">))</span> <span class="bp">/</span> <span class="o">(</span><span class="n">Float.exp</span> <span class="n">a</span><span class="o">)</span>

<span class="n">double</span> <span class="n">foo</span><span class="o">(</span><span class="n">double</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">double</span> <span class="n">x_2</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">double</span> <span class="n">x_3</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_4</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_5</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_6</span><span class="bp">;</span> <span class="n">double</span> <span class="n">x_7</span><span class="bp">;</span>
<span class="n">x_3</span> <span class="bp">=</span> <span class="n">sin</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">cos</span><span class="o">(</span><span class="n">x_2</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_5</span> <span class="bp">=</span> <span class="n">x_3</span> <span class="bp">+</span> <span class="n">x_4</span><span class="bp">;</span>
<span class="n">x_6</span> <span class="bp">=</span> <span class="n">exp</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_7</span> <span class="bp">=</span> <span class="n">x_5</span> <span class="bp">/</span> <span class="n">x_6</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_7</span><span class="bp">;</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Concerning <code>Array T</code>, there is a specialized implementation for <code>Array UInt8 ~ lean_sarray_object</code> and <code>Array Char ~ lean_string_object</code>. For every other type <code>T</code>, elements in the array are boxed. However, there is <code>FloatArray</code> that is an array of floats that are not boxed! Maybe I can get inspired by it and implement other arrays I need.</p>



<a name="253811551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253811551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253811551">(Sep 17 2021 at 21:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253791866">said</a>:</p>
<blockquote>
<p>You will have a lot of trouble with that <code>Float^n</code> example because <code>n</code> is not normally a compile time constant in lean</p>
</blockquote>
<p>Yes this will be definitely a problem. But I can simply do <code>#eval</code> on an variable and see it it can be evaluated or not. Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">m</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="k">#eval</span> <span class="n">m</span> <span class="c1">-- 2</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">n</span> <span class="c1">-- Error: (kernel) declaration has free variable `_eval`</span>
</code></pre></div>
<p>Thus I might compile <code>Float^n</code> only if <code>#eval n</code> succeeds and use the value to turn it into <code>std::array&lt;double, n&gt;</code>.</p>



<a name="253811983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253811983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253811983">(Sep 17 2021 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> You can get better code if you don't use polymorphic structures. Example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">FloatVec2</span> <span class="n">where</span>
  <span class="n">a</span> <span class="o">:</span> <span class="n">Float</span>
  <span class="n">b</span> <span class="o">:</span> <span class="n">Float</span>

<span class="kd">@[inline, export vec2_mk]</span>
<span class="kd">def</span> <span class="n">vec2_mk</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">FloatVec2</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">}</span>

<span class="kd">@[inline, export vec2_add]</span>
<span class="kd">def</span> <span class="n">vec2_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">FloatVec2</span><span class="o">)</span> <span class="o">:</span> <span class="n">FloatVec2</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a.1</span> <span class="bp">+</span> <span class="n">b.1</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a.2</span> <span class="bp">+</span> <span class="n">b.2</span> <span class="o">}</span>
</code></pre></div>
<p>We also have <code>FloatArray</code>. Which is an array of unboxed float values. However, the library for <code>FloatArray</code> is currently very small since nobody is using this kind of array.</p>



<a name="253813012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253813012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253813012">(Sep 17 2021 at 21:58)</a>:</h4>
<p>Nice, this is probably because there is <code>IRType.struct</code> right? Maybe I can create <code>FloatVec2Array</code>, <code>FloatVec3Array</code> ... and if functions like <code>get</code> and <code>set</code> access element and component at the same time, I do not have to touch the heap.</p>



<a name="253813915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253813915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253813915">(Sep 17 2021 at 22:06)</a>:</h4>
<p>How far is lean from being able to do ad hoc monomorphization by using a macro to stamp out these array types and their libraries?</p>



<a name="253814023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253814023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253814023">(Sep 17 2021 at 22:07)</a>:</h4>
<p>My guess is that full C++/Rust style monomorphization will be out of scope for a long time</p>



<a name="253814269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253814269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253814269">(Sep 17 2021 at 22:10)</a>:</h4>
<p>Uniform data representation (aka pointers everywhere) is a necessity for languages that don't use monomorphization; just adding a bunch of additional data representations like <code>FloatVec2Array</code> without libraries and with an additional maintenance burden doesn't sound like a good idea</p>



<a name="253815021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253815021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253815021">(Sep 17 2021 at 22:16)</a>:</h4>
<p>Makes sense. One thing I'm thinking of is implementing a small compiler with monomorphization(didn't know the term before) that is able to compile certain subset of Lean expressions and types. This would be used mainly for tight loops or when writing kernels for GPU.</p>



<a name="253816253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816253">(Sep 17 2021 at 22:29)</a>:</h4>
<p>I think that writing your own compiler for this would be much more difficult than modifying / extending the lean compiler. Compilers have a lot of back end stuff that you would get for free if you modify an existing compiler.</p>



<a name="253816308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816308">(Sep 17 2021 at 22:29)</a>:</h4>
<p>Well, that's not to say that the "extension" isn't just a way to hook up more low level semi-compiled lean expressions to the C output, and your actual compiler produces the semi-compiled lean expressions</p>



<a name="253816419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816419">(Sep 17 2021 at 22:31)</a>:</h4>
<p>You might already have all the tools you need with enough calls to <code>extern</code> functions</p>



<a name="253816591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816591">(Sep 17 2021 at 22:33)</a>:</h4>
<p>But if your compiler produces an infinite family of different ABI types, like <code>array&lt;double, n&gt;</code> or <code>FloatVecNArray</code> (for many values of <code>n</code>), then I don't see how <code>lean.h</code> is supposed to support that</p>



<a name="253816716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816716">(Sep 17 2021 at 22:34)</a>:</h4>
<p>I would expect that for each type you would have to also supply conversion to/from <code>lean_object</code> such those two types of codes can communicate.</p>



<a name="253816755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816755">(Sep 17 2021 at 22:35)</a>:</h4>
<p>Put another way, I think the first thing to figure out is how to write lean code that has the performance characteristics you want, even if the code looks really ugly or low level. Then your compiler can be made to produce that ugly code from a more high level description</p>



<a name="253816777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816777">(Sep 17 2021 at 22:35)</a>:</h4>
<p>Where would your types be defined?</p>



<a name="253816860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253816860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253816860">(Sep 17 2021 at 22:36)</a>:</h4>
<p>AFAIK lean code never defines new types, all types used in generated code are defined in <code>lean.h</code></p>



<a name="253818095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818095">(Sep 17 2021 at 22:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253814023">said</a>:</p>
<blockquote>
<p>My guess is that full C++/Rust style monomorphization will be out of scope for a long time</p>
</blockquote>
<p>If you are talking about C++ templates (or Rust macros) -- they are both literally just macros. You could do everything they do (and more) with a macro In Lean.</p>



<a name="253818138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818138">(Sep 17 2021 at 22:53)</a>:</h4>
<p>I was thinking not about rust macros, but rather rust generics</p>



<a name="253818221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818221">(Sep 17 2021 at 22:54)</a>:</h4>
<p>rust macros are like lean macros, but rust generics are a whole type system thing that interfaces with the code generator</p>



<a name="253818232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818232">(Sep 17 2021 at 22:54)</a>:</h4>
<p>you would be hard pressed to do all that with a macro</p>



<a name="253818269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818269">(Sep 17 2021 at 22:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253816777">said</a>:</p>
<blockquote>
<p>Where would your types be defined?</p>
</blockquote>
<p>My initial attempt is along these lines:</p>
<p>Define a C++ equivalent for each type and function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">CppType</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span> <span class="n">typename</span> <span class="o">:</span> <span class="n">string</span> <span class="o">)</span>

<span class="c1">-- define type for Prod</span>
<span class="kd">instance</span> <span class="n">std_pair.CppType</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">CppType</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">CppType</span> <span class="n">B</span><span class="o">]</span> <span class="o">:</span> <span class="n">CppType</span> <span class="o">(</span><span class="n">A</span><span class="bp">×</span><span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">typename</span> <span class="o">:=</span> <span class="s2">"std::pair&lt;"</span> <span class="bp">++</span> <span class="n">CppType.typename</span> <span class="n">A</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">CppType.typename</span> <span class="n">B</span> <span class="bp">++</span> <span class="s2">"&gt;"</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="n">CppImpl</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">impl</span> <span class="o">:</span> <span class="n">string</span> <span class="o">}</span>

<span class="c1">--- Define functions for Prod</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">CppType</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">CppType</span> <span class="n">B</span><span class="o">]</span>
<span class="kd">instance</span>  <span class="o">:</span> <span class="n">CppImpl</span> <span class="o">(</span><span class="bp">@</span><span class="n">Prod.mk</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">impl</span> <span class="o">:=</span> <span class="s2">"std::make_pair"</span> <span class="o">}</span>
<span class="kd">instance</span>  <span class="o">:</span> <span class="n">CppImpl</span> <span class="o">(</span><span class="bp">@</span><span class="n">Prod.fst</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">impl</span> <span class="o">:=</span> <span class="s2">"std::get&lt;0&gt;"</span> <span class="o">}</span>
<span class="kd">instance</span>  <span class="o">:</span> <span class="n">CppImpl</span> <span class="o">(</span><span class="bp">@</span><span class="n">Prod.snd</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">impl</span> <span class="o">:=</span> <span class="s2">"std::get&lt;1&gt;"</span> <span class="o">}</span>
</code></pre></div>
<p>Once you define all the types you want to use and their functions, we can proceed with compiling an expression:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">pair_mk</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Float</span> <span class="bp">×</span> <span class="n">Float</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">compile</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">expr</span> <span class="bp">←</span> <span class="n">whnf</span> <span class="o">(</span><span class="n">mkConst</span> <span class="bp">`</span><span class="n">pair_mk</span><span class="o">)</span>
    <span class="bp">...</span> <span class="n">Now</span> <span class="n">you</span> <span class="n">can</span> <span class="n">traverse</span> <span class="n">the</span> <span class="n">expression</span> <span class="n">and</span> <span class="n">generate</span> <span class="n">C</span><span class="bp">++</span> <span class="n">code</span> <span class="kd">by</span> <span class="n">gluing</span> <span class="n">expression's</span> <span class="n">c</span><span class="bp">++</span> <span class="n">implementations.</span> <span class="bp">...</span>
</code></pre></div>
<p>This way I can generate some C++ code(still not working properly). I have no clue how to link it with the rest of the lean code.</p>
<p>The nice thing with this approach is that the C++ compiler will handle monomorphization for me.</p>



<a name="253818286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818286">(Sep 17 2021 at 22:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253818221">said</a>:</p>
<blockquote>
<p>rust macros are like lean macros, but rust generics are a whole type system thing that interfaces with the code generator</p>
</blockquote>
<p>Hobbes is an interesting example of a Haskell inspired language that does monomorphization for typeclasses <a href="https://github.com/morganstanley/hobbes">https://github.com/morganstanley/hobbes</a>, is that what you mean?</p>



<a name="253818375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818375">(Sep 17 2021 at 22:56)</a>:</h4>
<p>Note that lean already has some monomorphization in the form of "specialization" of functions to certain types and typeclass instances, which sounds similar to hobbes</p>



<a name="253818416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818416">(Sep 17 2021 at 22:57)</a>:</h4>
<p>but this is only an optimization, it doesn't (isn't supposed to) change observable behavior and it is not mandatory like C++/Rust monomorphization</p>



<a name="253818435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253818435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253818435">(Sep 17 2021 at 22:57)</a>:</h4>
<p>Yes, I think what is mostly missing is unboxed structs and possibly some more base types like Float32.</p>



<a name="253820792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253820792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253820792">(Sep 17 2021 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253818095">said</a>:</p>
<blockquote>
<p>If you are talking about C++ templates (or Rust macros) -- they are both literally just macros. You could do everything they do (and more) with a macro In Lean.</p>
</blockquote>
<p>Just for fun, I wrote an example of how one could do <code>def</code> templates in Lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Parser</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Parser</span> <span class="n">Command</span>
<span class="kn">open</span> <span class="n">Term</span> <span class="kn">hiding</span> <span class="n">ident</span>

<span class="kd">def</span> <span class="n">declBinder</span> <span class="o">:=</span>
  <span class="n">simpleBinderWithoutType</span> <span class="bp">&lt;|&gt;</span> <span class="n">bracketedBinder</span>

<span class="kd">def</span> <span class="n">declBinders</span> <span class="o">:=</span>
  <span class="n">many</span> <span class="o">(</span><span class="n">ppSpace</span> <span class="bp">&gt;&gt;</span> <span class="n">declBinder</span><span class="o">)</span>

<span class="kd">@[commandParser]</span>
<span class="kd">def</span> <span class="n">templateDefDecl</span> <span class="o">:=</span> <span class="n">leading_parser</span>
  <span class="s2">"template "</span> <span class="bp">&gt;&gt;</span> <span class="n">many1</span> <span class="n">Command.macroArg</span> <span class="bp">&gt;&gt;</span> <span class="s2">" def "</span> <span class="bp">&gt;&gt;</span>
  <span class="n">incQuotDepth</span> <span class="o">(</span><span class="n">ident</span> <span class="bp">&gt;&gt;</span> <span class="n">declBinders</span> <span class="bp">&gt;&gt;</span> <span class="o">(</span><span class="s2">" := "</span> <span class="bp">&lt;|&gt;</span> <span class="s2">" where "</span><span class="o">)</span> <span class="bp">&gt;&gt;</span> <span class="n">termParser</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">identAsStrLit</span> <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">Syntax</span><span class="o">)</span> <span class="o">:</span> <span class="n">Syntax</span> <span class="o">:=</span>
  <span class="n">Syntax.mkStrLit</span> <span class="o">(</span><span class="n">info</span> <span class="o">:=</span> <span class="n">SourceInfo.fromRef</span> <span class="n">id</span><span class="o">)</span> <span class="bp">&lt;|</span>
    <span class="n">id.getId.toString</span> <span class="o">(</span><span class="n">escape</span> <span class="o">:=</span> <span class="n">false</span><span class="o">)</span>

<span class="kd">@[macro templateDefDecl]</span>
<span class="kd">def</span> <span class="n">expandTemplateDefDecl</span> <span class="o">:</span> <span class="n">Macro</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">template</span> <span class="bp">$</span><span class="n">args</span><span class="bp">*</span> <span class="kd">def</span> <span class="bp">$</span><span class="n">id</span> <span class="bp">$</span><span class="n">bs</span><span class="bp">*</span> <span class="o">:=</span> <span class="bp">$</span><span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span>
  <span class="k">let</span> <span class="n">sym</span> <span class="o">:=</span> <span class="n">identAsStrLit</span> <span class="n">id</span>
  <span class="bp">`</span><span class="o">(</span><span class="n">macro</span> <span class="bp">$</span><span class="n">sym</span><span class="o">:</span><span class="n">strLit</span> <span class="s2">"["</span> <span class="bp">$</span><span class="n">args</span><span class="bp">*</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="k">fun</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">bs</span><span class="o">]</span><span class="bp">*</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="n">x</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Macro.throwUnsupported</span>

<span class="n">template</span> <span class="n">t</span><span class="o">:</span><span class="n">term</span> <span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">$</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span>
<span class="k">#check</span> <span class="n">add</span><span class="o">[</span><span class="n">UInt64</span><span class="o">]</span> <span class="mi">2</span> <span class="mi">3</span> <span class="c1">-- (fun a b =&gt; a + b) 2 3 : UInt64</span>
<span class="k">#eval</span> <span class="n">add</span><span class="o">[</span><span class="n">UInt64</span><span class="o">]</span> <span class="mi">2</span> <span class="mi">3</span> <span class="c1">-- 5</span>
</code></pre></div>



<a name="253821239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821239">(Sep 17 2021 at 23:34)</a>:</h4>
<p>oh boy, I can't wait for SFINAE</p>



<a name="253821647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821647">(Sep 17 2021 at 23:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130511">Christian Pehle</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253818435">said</a>:</p>
<blockquote>
<p>Yes, I think what is mostly missing is unboxed structs and possibly some more base types like Float32.</p>
</blockquote>
<p>Also, Lean already has unboxed doubles (that's what <code>Float</code> is) why do you particularly need an unboxed <code>float</code>?</p>



<a name="253821708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821708">(Sep 17 2021 at 23:41)</a>:</h4>
<p>Why not? Lots of calculations don't need high precision floating point and would rather get the boost in throughput</p>



<a name="253821774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821774">(Sep 17 2021 at 23:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> most systems are now 64-bit, thus 64-bit floating pointing arithmetic is just as fast (or faster) than 32-bit.</p>



<a name="253821790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821790">(Sep 17 2021 at 23:42)</a>:</h4>
<p>Also using <code>float</code> halfs the memory required compared to <code>double</code>.</p>



<a name="253821791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821791">(Sep 17 2021 at 23:42)</a>:</h4>
<p>SIMD float instructions are 2x faster on 32 bit</p>



<a name="253821814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821814">(Sep 17 2021 at 23:43)</a>:</h4>
<p>even if lean doesn't directly support SIMD, if the codegen is good enough you might be able to get autovectorization from the C compiler</p>



<a name="253821821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821821">(Sep 17 2021 at 23:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> yes, the key part there being SIMD instructions which require SIMD vectors which is whole different can of worms.</p>



<a name="253821910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821910">(Sep 17 2021 at 23:44)</a>:</h4>
<p>for instance, if you have a tight loop that doubles every element in a <code>FloatArray</code>, there is a high probability that will get autovectorized, and then you will be able to consume 2x more floats than doubles</p>



<a name="253821912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821912">(Sep 17 2021 at 23:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253821814">said</a>:</p>
<blockquote>
<p>even if lean doesn't directly support SIMD, if the codegen is good enough you might be able to get autovectorization from the C compiler</p>
</blockquote>
<p>Recently I was inspecting some generated assembly of C++ code I wrote. It had bunch of for loops <code>for(int i=0;i&lt;4;i++)</code> and I got vectorization automatically.</p>



<a name="253821963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253821963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253821963">(Sep 17 2021 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253821814">said</a>:</p>
<blockquote>
<p>even if lean doesn't directly support SIMD, if the codegen is good enough you might be able to get autovectorization from the C compiler</p>
</blockquote>
<p>iirc, auto-vectorization of floating point values is not on by default in most C compilers as that is another very different can of worms (as floating point rounding non-determinism then enters the picture).</p>



<a name="253822077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822077">(Sep 17 2021 at 23:47)</a>:</h4>
<p>however, I have never dug to deep into that ara, so I may be completely wrong there.</p>



<a name="253822274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822274">(Sep 17 2021 at 23:50)</a>:</h4>
<p><a href="https://www.godbolt.org/z/WGeqG835v">https://www.godbolt.org/z/WGeqG835v</a> seems to show that with a standard looking C++ loop you get autovectorization at <code>-O3</code></p>



<a name="253822465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822465">(Sep 17 2021 at 23:53)</a>:</h4>
<p><a href="https://www.godbolt.org/z/49EczhxET">https://www.godbolt.org/z/49EczhxET</a> &lt;- also in C</p>



<a name="253822566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822566">(Sep 17 2021 at 23:55)</a>:</h4>
<p>it is not clear whether an idiomatic lean loop will lower quite so beneficially as these C/C++ examples though. The most likely barrier to autovectorization of lean code is that all the jumps and function calls will not be inlined or inlined too late for the autovectorization recognizer to work</p>



<a name="253822575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822575">(Sep 17 2021 at 23:55)</a>:</h4>
<p>Welp, guess I was wrong. The fact that high optimization levels default to fast math surprises me.</p>



<a name="253822685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822685">(Sep 17 2021 at 23:57)</a>:</h4>
<p>well, they say that -O3 is living on the wrong side of the guard rail</p>



<a name="253822697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822697">(Sep 17 2021 at 23:57)</a>:</h4>
<p>the purpose of undefined behaviour is to basically enable these optimisations ;).</p>



<a name="253822765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822765">(Sep 17 2021 at 23:58)</a>:</h4>
<p><a href="https://godbolt.org/z/6vedK7WG3">https://godbolt.org/z/6vedK7WG3</a></p>



<a name="253822810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822810">(Sep 17 2021 at 23:59)</a>:</h4>
<p>I don't think there are any fast-math style reassociations going on here though <span class="user-mention" data-user-id="315577">@Mac</span></p>



<a name="253822816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822816">(Sep 17 2021 at 23:59)</a>:</h4>
<p>Ah, now that I think about it,  I may have been confusing <code>a * b + c</code> (add/mul or mul/add or whatever it is) with vectors.</p>



<a name="253822835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822835">(Sep 17 2021 at 23:59)</a>:</h4>
<p>doing 8 adds in parallel is still IEEE conforming</p>



<a name="253822995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253822995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253822995">(Sep 18 2021 at 00:01)</a>:</h4>
<p>anyway, I think this is the main reason people care about <code>float</code> these days. The memory savings is nice but the double throughput is huge</p>



<a name="253823020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823020">(Sep 18 2021 at 00:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> yep, that makes sense -- I was just under very mistaken assumptions.</p>



<a name="253823067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823067">(Sep 18 2021 at 00:02)</a>:</h4>
<p>plus some double ops are actually slower</p>



<a name="253823080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823080">(Sep 18 2021 at 00:02)</a>:</h4>
<p>I think having a <code>Float32</code> and <code>Float64</code> split in Lean would be great.</p>



<a name="253823145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823145">(Sep 18 2021 at 00:03)</a>:</h4>
<p>Though I think Lean tends to avoid floating point numbers as they are very difficult to reason about, which was Lean's original goal.</p>



<a name="253823206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823206">(Sep 18 2021 at 00:04)</a>:</h4>
<p>Indeed. I think <code>Float32</code> isn't any worse than <code>Float64</code> , but they are both pretty horrific for formal verification purposes</p>



<a name="253823212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823212">(Sep 18 2021 at 00:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253822816">said</a>:</p>
<blockquote>
<p>Ah, now that I think about it,  I may have been confusing <code>a * b + c</code> (add/mul or mul/add or whatever it is) with vectors.</p>
</blockquote>
<p><a href="https://godbolt.org/z/Txee8dGe1">https://godbolt.org/z/Txee8dGe1</a> it does that too automatically.</p>



<a name="253823293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823293">(Sep 18 2021 at 00:05)</a>:</h4>
<p><del>@<strong>Christian Pehle</strong> Sorry, no, I meant the single add-mul or mul-add instruction (or something like that --  I can't remember which it  was) not subsequent adds and muls on vectors.</del> Scratch that, I am blind -- that is what is doing. <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>
<p>However, note it does not do that on plain <code>-O3</code>, but only with the necessary flag (which is what I was originally talking about).</p>



<a name="253823348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823348">(Sep 18 2021 at 00:06)</a>:</h4>
<p>In particular <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> , you should consider carefully whether you will actually get something that you can prove properties about at the end of all this. You might end up in no better position than if you had just written the code in C++, if everything is just axiomatized / opaque</p>



<a name="253823441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823441">(Sep 18 2021 at 00:07)</a>:</h4>
<p><span class="user-mention" data-user-id="130511">@Christian Pehle</span> You did pass <code>-mfma</code> though, is that like a baby fast-math?</p>



<a name="253823655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823655">(Sep 18 2021 at 00:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253823293">said</a>:</p>
<blockquote>
<p><del>@<strong>Christian Pehle</strong> Sorry, no, I meant the single add-mul or mul-add instruction (or something like that --  I can't remember which it  was) not subsequent adds and muls on vectors.</del> Scratch that, I am blind -- that is what is doing. <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>
<p>However, note it does not do that on plain <code>-O3</code>, but only with the necessary flag (which is what I was originally talking about).</p>
</blockquote>
<p>Ah yeah but that only depends on the architecture that the compiler assumes by default. If you use a gcc compiled to the target architecture it will do that on <code>-O3</code> automatically (<a href="https://godbolt.org/z/3rKTaE74c">https://godbolt.org/z/3rKTaE74c</a>)</p>



<a name="253823731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823731">(Sep 18 2021 at 00:12)</a>:</h4>
<p><a href="https://stackoverflow.com/a/15933677/890016">https://stackoverflow.com/a/15933677/890016</a> says:</p>
<blockquote>
<p>The IEEE and C standards allow this when <code>#pragma STDC FP_CONTRACT ON</code> is in effect, and compilers are allowed to have it ON by default (but not all do). Gcc contracts into FMA by default (with the default <code>-std=gnu*</code>, but not <code>-std=c*</code>, e.g. <code>-std=c++14</code>). For Clang, it's only enabled with <code>-ffp-contract=fast</code>.</p>
</blockquote>



<a name="253823763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823763">(Sep 18 2021 at 00:13)</a>:</h4>
<p>Sorry about derailing the discussion with my optimization confusions. Back on topic:</p>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253818269">said</a>:</p>
<blockquote>
<p>My initial attempt is along these lines:</p>
<p>Define a C++ equivalent for each type and function:</p>
<p>[...]</p>
<p>This way I can generate some C++ code(still not working properly). I have no clue how to link it with the rest of the lean code.</p>
<p>The nice thing with this approach is that the C++ compiler will handle monomorphization for me.</p>
</blockquote>
<p>First, you should note that Lean outputs C, not C++. In fact, there is currently a big effort to drop C++ support entirely from Lean's compiler toolchain. Second, you can take a look at <a href="https://github.com/leanprover/lean4/blob/3d0967f75b725ed377504a0ff5e7a8a8726f5e1f/src/Lean/Compiler/IR/EmitC.lean"><code>EmitC.lean</code></a> to see how Lean currently goes about emitting C code.</p>



<a name="253823861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253823861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253823861">(Sep 18 2021 at 00:15)</a>:</h4>
<p>You could probably generate some cpp code and extern link to it from the lean-C code</p>



<a name="253824336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253824336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253824336">(Sep 18 2021 at 00:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253823861">said</a>:</p>
<blockquote>
<p>You could probably generate some cpp code and extern link to it from the lean-C code</p>
</blockquote>
<p>Yes that is exactly what I'm thinking of doing. Maybe I just generate the C++ code and use only that in my final application without involving Lean's C code entirely.</p>



<a name="253824651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253824651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253824651">(Sep 18 2021 at 00:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253823348">said</a>:</p>
<blockquote>
<p>In particular <span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> , you should consider carefully whether you will actually get something that you can prove properties about at the end of all this. You might end up in no better position than if you had just written the code in C++, if everything is just axiomatized / opaque</p>
</blockquote>
<p>Well I'm will assume that I'm working with reals and hope for the best when actually running with floats. My main interest is to transform the code while respecting the mathematics. For example, I want to turn <code>(A*B)*v</code> to <code>A*(B*v)</code> to save computation for A,B matrices and v vector. On the level of floats <code>(A*B)*v</code>  is not equal to <code>A*(B*v)</code>, but I do not really care about that too much as long as I do not get some catastrophic rounding errors.<br>
Doing these kind of optimizations in C++ is done with expression templates, for example the linear algebra library Eigen. I would like to take it a step further and do not only linear algebra but also calculus, differentiation etc. For a long time, I was trying doing it in C++, even switched to D for better templates. Now, I'm trying to do it in Lean and just generate the final C++ code. </p>
<p>One of my goals is to have code for finite elements where I can simply define energy as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">energy</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">Ω</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">∫</span> <span class="bp">∥∇</span><span class="n">u</span><span class="bp">∥²</span> <span class="n">dx</span>
</code></pre></div>
<p>That I can differentiate w.r.t. to <code>u</code>, assemble a finite dimensional system and find a minimizer.</p>



<a name="253824748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253824748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253824748">(Sep 18 2021 at 00:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253823731">said</a>:</p>
<blockquote>
<p><a href="https://stackoverflow.com/a/15933677/890016">https://stackoverflow.com/a/15933677/890016</a> says:</p>
<blockquote>
<p>The IEEE and C standards allow this when <code>#pragma STDC FP_CONTRACT ON</code> is in effect, and compilers are allowed to have it ON by default (but not all do). Gcc contracts into FMA by default (with the default <code>-std=gnu*</code>, but not <code>-std=c*</code>, e.g. <code>-std=c++14</code>). For Clang, it's only enabled with <code>-ffp-contract=fast</code>.</p>
</blockquote>
</blockquote>
<p>Note that this is for C (as can be seen here: <a href="https://godbolt.org/z/vrYzh39xn">https://godbolt.org/z/vrYzh39xn</a>). On C++ (which <span class="user-mention" data-user-id="130511">@Christian Pehle</span>  was using) it will fuse mul and add (as can be seen here: <a href="https://godbolt.org/z/sEf33fccc">https://godbolt.org/z/sEf33fccc</a>).</p>



<a name="253824949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253824949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253824949">(Sep 18 2021 at 00:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing/near/253824651">said</a>:</p>
<blockquote>
<p>Well I'm will assume that I'm working with reals and hope for the best when actually running with floats. </p>
</blockquote>
<p>Unless I am mistaken (which given my current track record in this tread is completely possible), this is not how Lean works. You cannot reason between types like this in Lean.</p>



<a name="253824988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253824988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253824988">(Sep 18 2021 at 00:35)</a>:</h4>
<p>Also, generally mathematical reasoning in Lean is non-computable so that is another hurdle with such an approach.</p>



<a name="253825014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825014">(Sep 18 2021 at 00:35)</a>:</h4>
<p>I just define an opaque type Real, define bunch of axioms defining them and when compiling Real will be turned to Float.</p>



<a name="253825085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825085">(Sep 18 2021 at 00:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>,  could that have soundness problems, because it feels like it could?</p>



<a name="253825104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825104">(Sep 18 2021 at 00:37)</a>:</h4>
<p>Oh yes</p>



<a name="253825171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825171">(Sep 18 2021 at 00:38)</a>:</h4>
<p>well I suppose it depends on the axioms but if you assume anything that isn't true about floats (and there are a lot of those) then you are on a very short path to unsoundness</p>



<a name="253825267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825267">(Sep 18 2021 at 00:40)</a>:</h4>
<p>But I'm not going to prove anything about what the program is actually doing in finite precision. I will be proving only what the program is doing in the idealized scenario of infinite precision.</p>



<a name="253825283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825283">(Sep 18 2021 at 00:40)</a>:</h4>
<p>Actually I should reword that: As long as the axioms are consistent with each other (for example, they match what the real numbers do) then you won't be able to prove <code>False</code> in lean; but if they are not consistent with what floats do then you can get programs that don't compute what they are supposed to, and type violations and crashes (possibly including C UB)</p>



<a name="253825314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825314">(Sep 18 2021 at 00:41)</a>:</h4>
<p>Yes, I'm aware of that.</p>



<a name="253825330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825330">(Sep 18 2021 at 00:41)</a>:</h4>
<p>in other words, you proved the correctness of a program that wasn't the one you ran</p>



<a name="253825338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825338">(Sep 18 2021 at 00:41)</a>:</h4>
<p>yes I know :)</p>



<a name="253825431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825431">(Sep 18 2021 at 00:43)</a>:</h4>
<p>My goal is not so much to prove correctness, but to optimize/transform/differentiate the code I write based on the underlining mathematics.</p>



<a name="253825446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825446">(Sep 18 2021 at 00:43)</a>:</h4>
<p>Remind me why you can't do that in C++?</p>



<a name="253825536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825536">(Sep 18 2021 at 00:44)</a>:</h4>
<p>I mean "Lean is nicer to work in" is a valid answer</p>



<a name="253825558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825558">(Sep 18 2021 at 00:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  You'd have to do both separately, which I imagine would be a bit of a  hassle. By doing both in Lean, you get a cheap representation of what the code you wrote was without have to remodel it in whatever proof system you are using.</p>



<a name="253825650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825650">(Sep 18 2021 at 00:46)</a>:</h4>
<p>To do differentiation, I need to work with some kind of  expressions. Sure, I can implement my own system in C++ but lean does that for me already. Furthermore, differentiation is hard. I do not want to constrain myself to purely smooth functions or convex or what ever subset of functions.</p>



<a name="253825732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825732">(Sep 18 2021 at 00:48)</a>:</h4>
<p>don't compilers have push button differentiation engines these days? Like <a href="https://enzyme.mit.edu/">enzyme</a></p>



<a name="253825784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825784">(Sep 18 2021 at 00:48)</a>:</h4>
<p>Like many differentiation packages just ignore that |x| is not differentiable at 0. Also I'm aware of only one language that can differentiate w.r.t. to a function.</p>



<a name="253825822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825822">(Sep 18 2021 at 00:49)</a>:</h4>
<p>in practice this is still an active area of research. there are a lot of tradeoffs and especially when it comes to optimisation in systems of ODEs and PDEs there are few/any compiler based approaches</p>



<a name="253825877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Fast%20inline%20compiler%20for%20numerical%20computing/near/253825877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Fast.20inline.20compiler.20for.20numerical.20computing.html#253825877">(Sep 18 2021 at 00:50)</a>:</h4>
<p>zygotę and Julia come close.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html">Treating `Float` as reals, inconsistent?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266578867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266578867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266578867">(Jan 01 2022 at 22:19)</a>:</h4>
<p>I would like to extract runable code from Lean code that is dealing with real numbers. A simple way of doing this is to just assume <a href="https://en.wikipedia.org/wiki/Construction_of_the_real_numbers#Axioms">axioms of real numbers</a> on top of <code>Float</code>. I'm curious if this can lead to inconsistencies? Can you prove <code>False</code> from it?</p>
<p>Here is a partial set of those axioms. I was lazy to write down all of them, but feel free to add any one of them if you can use it to prove <code>False</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">Float</span>

<span class="c1">-- Axioms of Field</span>
<span class="kd">axiom</span> <span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span>
<span class="c1">-- ...</span>

<span class="c1">-- Total order</span>
<span class="kd">axiom</span> <span class="n">self_leq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">x</span>
<span class="c1">-- ...</span>

<span class="c1">-- Compatibility of operations and inequality</span>
<span class="kd">axiom</span> <span class="n">leq_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span>
<span class="c1">-- ...</span>

<span class="c1">-- Axiomatic definition of supremum</span>
<span class="kd">def</span> <span class="n">upper_bound</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">A</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">bounded</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">upper_bound</span> <span class="n">A</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">supremum</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">upper_bound</span> <span class="n">A</span> <span class="n">s</span>
  <span class="bp">∧</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">upper_bound</span> <span class="n">A</span> <span class="n">h</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">h</span>

<span class="kd">constant</span> <span class="n">sup</span> <span class="o">:</span> <span class="o">{</span><span class="n">A</span> <span class="bp">//</span> <span class="n">bounded</span> <span class="n">A</span><span class="o">}</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="kd">axiom</span> <span class="n">real_sup</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">bounded</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">supremum</span> <span class="n">A</span> <span class="o">(</span><span class="n">sup</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩)</span>


<span class="c1">-- Axiomatic definition of some functions</span>
<span class="kd">def</span> <span class="n">Float.abs</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="bp">-</span><span class="n">x</span>
<span class="kd">axiom</span> <span class="n">sqrt_sqr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">Float.sqrt</span> <span class="n">x</span><span class="bp">*</span><span class="n">x</span> <span class="bp">=</span> <span class="n">x.abs</span>

<span class="kd">axiom</span> <span class="n">exp_of_zero</span> <span class="o">:</span> <span class="n">Float.exp</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="c1">-- This would require definition of derivative</span>
<span class="c1">-- axiom der_exp : der Float.exp = Float.exp</span>


<span class="c1">--- Challange: can you prove False?</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">False</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="266579566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266579566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266579566">(Jan 01 2022 at 22:32)</a>:</h4>
<p>Why not write a tactic which takes an expression representing a real and outputs a float? Just give it a dictionary like <code>real.exp -&gt; Float.exp</code>, <code>real.pi -&gt; 3.14</code> etc.</p>



<a name="266579966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266579966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266579966">(Jan 01 2022 at 22:41)</a>:</h4>
<p>How would you deal with something like <code>Array real</code>?</p>



<a name="266580460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266580460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266580460">(Jan 01 2022 at 22:53)</a>:</h4>
<p>Surely <code>nan &lt;= nan</code> is false?</p>



<a name="266580961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266580961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266580961">(Jan 01 2022 at 23:03)</a>:</h4>
<p>Sure it is, but give me a Lean proof of it.</p>



<a name="266581024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266581024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266581024">(Jan 01 2022 at 23:04)</a>:</h4>
<p>Assuming that NaN is somehow exposed in the API this should be possible since less equal is decidable for Float.</p>



<a name="266581040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266581040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266581040">(Jan 01 2022 at 23:05)</a>:</h4>
<p>And if NaN is not exposed in the API yet I guess it will be only a matter of time until it is.</p>



<a name="266581812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266581812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266581812">(Jan 01 2022 at 23:22)</a>:</h4>
<p>Can it be proved that there's a surjection from <code>nat</code> to <code>float</code>? Because with the axioms defining the reals you can prove there's no such surjection</p>



<a name="266582359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266582359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266582359">(Jan 01 2022 at 23:33)</a>:</h4>
<p>Can floating point operations be evaluated?  Floating point addition is not associative, so yes I think this could be used to prove false if floating point operations can be evaluated.<br>
If this is just for code generation though, I'm not sure that it matters.  Just don't use the axioms in files where you care about verification.</p>



<a name="266583111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266583111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266583111">(Jan 01 2022 at 23:56)</a>:</h4>
<p>Evaluation is actually not an issue since the <code>add</code> function is hidden behind a constant so it is not possible to prove anything about it, the only computable things about float are the order relations.</p>



<a name="266584434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266584434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266584434">(Jan 02 2022 at 00:23)</a>:</h4>
<p>As a general side remark, if it actually does turn out that treating <code>Float</code> as reals is an issue, we could, instead of using <code>double</code> from C just bind to an arbitrary precision library and let that one do the correct calculations for us right? That way we could still evaluate computation on reals properly.</p>



<a name="266597218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266597218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266597218">(Jan 02 2022 at 06:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F/near/266583111">said</a>:</p>
<blockquote>
<p>Evaluation is actually not an issue since the <code>add</code> function is hidden behind a constant so it is not possible to prove anything about it, the only computable things about float are the order relations.</p>
</blockquote>
<p>This is not necessarily true. You can use <code>nativeDecide</code> to prove things about opaque (<code>constant</code>) definitions based on their evaluation.</p>



<a name="266603090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266603090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266603090">(Jan 02 2022 at 08:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F/near/266597218">said</a>:</p>
<blockquote>
<p>This is not necessarily true. You can use <code>nativeDecide</code> to prove things about opaque (<code>constant</code>) definitions based on their evaluation.</p>
</blockquote>
<p>Great! The tactic <code>nativeDecide</code> answers my question, you can prove <code>False</code> when assuming:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">axiom</span> <span class="n">leq_antisymmetry</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="kd">axiom</span> <span class="n">leq_totality</span>     <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span>
<span class="kd">axiom</span> <span class="n">simplify1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
</code></pre></div>
<p>Here is the full proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">Float</span>

<span class="kd">axiom</span> <span class="n">leq_antisymmetry</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="kd">axiom</span> <span class="n">leq_totality</span>     <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span>
<span class="kd">axiom</span> <span class="n">simplify1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">dec</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">d</span> <span class="o">:</span> <span class="n">Decidable</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span> <span class="n">Decidable</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">d</span>

<span class="kn">open</span> <span class="n">Decidable</span> <span class="k">in</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Decidable</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">dec</span> <span class="o">(</span><span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">),</span> <span class="n">dec</span> <span class="o">(</span><span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">isTrue</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">isTrue</span> <span class="n">hyx</span> <span class="bp">=&gt;</span> <span class="n">isTrue</span> <span class="o">(</span><span class="n">leq_antisymmetry</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hxy</span> <span class="n">hyx</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">isFalse</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">isTrue</span> <span class="n">hyx</span> <span class="bp">=&gt;</span>
  <span class="n">isFalse</span> <span class="o">(</span><span class="kd">by</span> <span class="n">intro</span> <span class="n">xy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hxy</span><span class="bp">;</span> <span class="n">rw</span><span class="o">[</span><span class="n">xy</span><span class="o">]</span> <span class="n">at</span> <span class="n">hyx</span><span class="bp">;</span> <span class="n">rw</span><span class="o">[</span><span class="n">xy</span><span class="o">]</span><span class="bp">;</span> <span class="n">assumption</span> <span class="o">)</span>
<span class="bp">|</span> <span class="n">isTrue</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">isFalse</span> <span class="n">hyx</span> <span class="bp">=&gt;</span>
  <span class="n">isFalse</span> <span class="o">(</span><span class="kd">by</span> <span class="n">intro</span> <span class="n">xy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hyx</span><span class="bp">;</span> <span class="n">rw</span><span class="o">[</span><span class="n">xy</span><span class="o">]</span> <span class="n">at</span> <span class="n">hxy</span><span class="bp">;</span> <span class="n">rw</span><span class="o">[</span><span class="n">xy</span><span class="o">]</span><span class="bp">;</span> <span class="n">assumption</span> <span class="o">)</span>
<span class="bp">|</span> <span class="n">isFalse</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">isFalse</span> <span class="n">hyx</span> <span class="bp">=&gt;</span>
  <span class="n">isFalse</span> <span class="o">(</span><span class="kd">by</span> <span class="n">induction</span> <span class="o">(</span><span class="n">leq_totality</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
              <span class="n">intro</span> <span class="n">xy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hxy</span><span class="bp">;</span> <span class="n">assumption</span>
              <span class="n">intro</span> <span class="n">xy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hyx</span><span class="bp">;</span> <span class="n">assumption</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="mi">1</span><span class="bp">.</span><span class="mi">0</span>
<span class="kd">def</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="mi">10000000000000000</span>
<span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Float</span> <span class="o">:=</span> <span class="n">x</span><span class="bp">/</span><span class="n">n</span>

<span class="kd">theorem</span> <span class="n">hoho</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">nativeDecide</span>

<span class="kd">theorem</span> <span class="n">foo1</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">nativeDecide</span>
<span class="kd">theorem</span> <span class="n">foo2</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">simplify1</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">theorem</span> <span class="n">inconsistency</span> <span class="o">:</span> <span class="n">False</span> <span class="o">:=</span>
<span class="kd">by</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">0</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">nativeDecide</span>
  <span class="n">apply</span> <span class="n">h</span><span class="bp">;</span> <span class="n">rw</span><span class="o">[</span><span class="bp">←</span> <span class="n">foo1</span><span class="o">,</span> <span class="n">foo2</span><span class="o">]</span>
</code></pre></div>



<a name="266603213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266603213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266603213">(Jan 02 2022 at 08:49)</a>:</h4>
<p>One thing to note is that <code>nativeDecide</code> does rely on two axioms <code>ofReduceBool</code>/<code>ofReduceNat</code> (see <a href="https://github.com/leanprover/lean4/blob/e15a656fd2569c12b8e73da9be707f0a5f420bad/src/Init/Core.lean#L1039-L1069">here</a>) so you can avoid these inconsistencies if you ban theorems with those axioms.</p>



<a name="266603285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266603285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266603285">(Jan 02 2022 at 08:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F/near/266603213">said</a>:</p>
<blockquote>
<p>One thing to note is that <code>nativeDecide</code> does rely on two axioms <code>ofReduceBool</code>/<code>ofReduceNat</code> (see <a href="https://github.com/leanprover/lean4/blob/e15a656fd2569c12b8e73da9be707f0a5f420bad/src/Init/Core.lean#L1039-L1069">here</a>) so you can avoid these inconsistencies if you ban theorems with those axioms.</p>
</blockquote>
<p>So if I ban these axioms am I good to assume axioms of real numbers for <code>Float</code> type?</p>



<a name="266603541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266603541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266603541">(Jan 02 2022 at 08:58)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> looking at <a href="https://github.com/leanprover/lean4/blob/748c9ab73a4766d0891768d3f10de79f6ffe5230/src/Init/Data/Float.lean">the code</a> for <code>Float</code> it doesn't seem to me like it has any notable properties outside its native code, so you can probable safely assume just about anything about it outside that realm.</p>



<a name="266603560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266603560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266603560">(Jan 02 2022 at 08:59)</a>:</h4>
<p>And how do I ban axioms?</p>



<a name="266603823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266603823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266603823">(Jan 02 2022 at 09:04)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> you can use <code>#print axioms &lt;theorem_ident&gt;</code> to view the axioms used in a theorem. For example,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">axioms</span> <span class="n">inconsistency</span>
<span class="c">/-</span><span class="cm"> 'inconsistency' depends on axioms: [leq_antisymmetry, leq_totality, Lean.ofReduceBool, simplify1] -/</span>
</code></pre></div>
<p>As such, to check that the theorems you prove are not using <code>ofReduceBool</code> to ensure it is no dependent on the possible native inconsistences. With some metaprogramming work you could also probably automate this check (e.g., by creating a attribute that checks that the tagged theorem  does not use a given axiom).</p>



<a name="266611904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266611904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266611904">(Jan 02 2022 at 12:25)</a>:</h4>
<blockquote>
<p>A simple way of doing this is to just assume axioms of real numbers on top of <code>Float</code>.</p>
</blockquote>
<p>You shouldn't do this because it is a wrong model of floating-point numbers, and doesn't allow you to prove any useful properties about floating-point algorithms.  For example, addition is not associative so you need to sum floating-point numbers carefully to avoid cancellation errors.  And you want to be able to obtain bounds on the errors here.  In general, a good rule of thumb is to assume that every floating-point operation introduces a small error, and the specification only guarantees a bound on this error.  If you assume that <code>Float = ℝ</code>, then you cannot prove anything about the errors at all (since they are all zero).  So you'll have algorithms that will fail even though you've proven them correct.</p>



<a name="266612106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266612106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266612106">(Jan 02 2022 at 12:30)</a>:</h4>
<p>As others have already observed, you can consistently assume that <code>Float = ℝ</code> as long as you ignore the VM implementation (i.e., avoid <code>nativeDecide</code> and friends).  The reason is simply that <code>Float</code> and its operations are defined as constants, and there are no axioms about floating-point numbers (in core Lean) which would be false in the real numbers.</p>



<a name="266613941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266613941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266613941">(Jan 02 2022 at 13:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F/near/266611904">said</a>:</p>
<blockquote>
<blockquote>
<p>A simple way of doing this is to just assume axioms of real numbers on top of <code>Float</code>.</p>
</blockquote>
<p>You shouldn't do this because it is a wrong model of floating-point numbers, and doesn't allow you to prove any useful properties about floating-point algorithms.  For example, addition is not associative so you need to sum floating-point numbers carefully to avoid cancellation errors.  And you want to be able to obtain bounds on the errors here.  In general, a good rule of thumb is to assume that every floating-point operation introduces a small error, and the specification only guarantees a bound on this error.  If you assume that <code>Float = ℝ</code>, then you cannot prove anything about the errors at all (since they are all zero).  So you'll have algorithms that will fail even though you've proven them correct.</p>
</blockquote>
<p>This would be great if it works but please show me some useful error bounds for Congujate Gradient or GMRES, type of algorithms I care about, using this technique. Until then, I'm going to prove stuff for idealized machine that can do arithmetic on real numbers and follow best practices to avoid rounding errors.</p>



<a name="266614777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266614777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266614777">(Jan 02 2022 at 13:40)</a>:</h4>
<p>What you are suggesting is basically interval arithmetic. I have stumbled onto a <a href="https://arxiv.org/abs/2112.05235">recent paper</a> that even prove certain impossibility result of interval arithmetic in using neural networks for classification. (I didn't read the paper but the abstract seems to be pretty clear)</p>



<a name="266615020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266615020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266615020">(Jan 02 2022 at 13:47)</a>:</h4>
<p>I'm trying to build something like certigrad and I want to take similar approach to floats, see <a href="https://youtu.be/-A1tVNTHUFw?t=1316">Daniel's talk</a>.</p>
<div class="youtube-video message_inline_image"><a data-id="-A1tVNTHUFw" href="https://youtu.be/-A1tVNTHUFw?t=1316"><img src="https://uploads.zulipusercontent.net/6d07fe179932273a4296589d3ab71eead28bc6e3/68747470733a2f2f692e7974696d672e636f6d2f76692f2d413174564e54485546772f64656661756c742e6a7067"></a></div>



<a name="266615534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266615534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266615534">(Jan 02 2022 at 14:00)</a>:</h4>
<blockquote>
<p>please show me some useful error bounds for Congujate Gradient</p>
</blockquote>
<p>Conjugate gradient is an iterative method iirc, so the error bound for the result is trivial (convergence is the hard part and can fail in floating-point from what I understand).</p>



<a name="266616123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266616123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266616123">(Jan 02 2022 at 14:16)</a>:</h4>
<blockquote>
<p>What you are suggesting is basically interval arithmetic.</p>
</blockquote>
<p>Not completely, some floating-point operations have precise specifications (such as the sign function, or comparisons).  There it is perfectly fine to make case distinction instead of error bounds.  Interval arithmetic is much more limited in this regard, if you have an <code>x</code> that is close to zero, then interval arithmetic can only conclude that <code>-1 ≤ sgn x ≤ 1</code>.</p>



<a name="266616282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266616282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266616282">(Jan 02 2022 at 14:21)</a>:</h4>
<p>In infinite precision, CG gives you exact answer in at most n steps. In this sense, it is direct method. However, because you can stop after fewer steps and still get a good approximation people think about CG as an iterative method. In finite arithmetic, the convergence is delayed.</p>
<p>I studied this a long time ago, so I do not remember much. A quick Google search directed me to this <a href="https://chen.pw/research/cg/finite_precision_cg.html">article</a> to quote from it:</p>
<blockquote>
<p>As it turns out, nobody has actually ever proved that any of the Conjugate Variant methods used in practice actually satisfy these conditions. Any proof that a given method satisfies these properties would constitute a significant theoretical advancement in the understanding of the conjugate gradient algorithm in finite precision. Similarly, finding weaker conditions which provide some sort of convergence guarantees for a finite precision CG implementation would also be of significant importance.</p>
</blockquote>
<p>My point is that proving robustness in finite precision is so difficult that people can't even do it satisfactory with pen and paper for algorithm that is 13 lines of code! Therefore, attempting it in Lean is just lost battle.</p>



<a name="266616320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266616320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266616320">(Jan 02 2022 at 14:22)</a>:</h4>
<blockquote>
<p>I'm going to use Lean to prove stuff for idealized [numbers]</p>
</blockquote>
<p>One way to make this approach more principled would be to use a typeclass, make the functions polymorphic, and then use <code>Real</code> in proofs and <code>Float</code> when executing.  That is something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">FpOps</span> <span class="n">α</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="bp">....</span> <span class="n">where</span>
  <span class="n">sin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="n">cos</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">...</span>

<span class="kd">def</span> <span class="n">myFun</span> <span class="o">[</span><span class="n">FpOps</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">....</span>
</code></pre></div>



<a name="266616419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266616419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266616419">(Jan 02 2022 at 14:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F/near/266616320">said</a>:</p>
<blockquote>
<blockquote>
<p>I'm going to use Lean to prove stuff for idealized [numbers]</p>
</blockquote>
<p>One way to make this approach more principled would be to use a typeclass, make the functions polymorphic, and then use <code>Real</code> in proofs and <code>Float</code> when executing.  That is something like this:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">FpOps</span> <span class="n">α</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="bp">....</span> <span class="n">where</span>
  <span class="n">sin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="n">cos</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">...</span>

<span class="kd">def</span> <span class="n">myFun</span> <span class="o">[</span><span class="n">FpOps</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">....</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Yes, this is an alternative approach that I have to think about a bit more. However, I find it a bit too verbose. A bit longer counter argument is <a href="#narrow/stream/113489-new-members/topic/Patrick.20Johnstone.20.28mathematical.20optimizer.29/near/266567711">here</a> as we discussed it already in a different thread.</p>



<a name="266616539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266616539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266616539">(Jan 02 2022 at 14:28)</a>:</h4>
<p>Therefore, I'm not entirely sure what I'm gaining in doing so. By using <code>Float = ℝ</code> I loose <code>nativeDecide</code>, but I have never used <code>nativeDecide</code> or felt the need of using it. Any other reason for using the more verbose approach?</p>



<a name="266617193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266617193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266617193">(Jan 02 2022 at 14:46)</a>:</h4>
<p>In the other thread several people have suggested the polymorphic approach as well.  I really think that's the best option here if you don't want to do floating-point verification (which is indeed hairy).</p>



<a name="266617255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266617255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266617255">(Jan 02 2022 at 14:48)</a>:</h4>
<blockquote>
<p>Any other reason for using the more verbose approach?</p>
</blockquote>
<p>Here is a fun demo of what you can do if you postulate the wrong axioms for Float:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">axiom</span> <span class="n">A</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">==</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="k">then</span>
    <span class="k">if</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">==</span> <span class="mi">1</span> <span class="k">then</span>
      <span class="mi">1</span>
    <span class="k">else</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">False</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">at</span> <span class="n">h2</span><span class="bp">;</span> <span class="n">contradiction</span>
      <span class="c1">-- look, now we can safely cast the float to a string :-/</span>
      <span class="k">let</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">String</span> <span class="o">:=</span> <span class="n">cast</span> <span class="n">h.elim</span> <span class="n">x</span>
      <span class="n">x'.length</span>
  <span class="k">else</span>
    <span class="mi">3</span>

<span class="k">#eval</span> <span class="n">foo</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="mi">60</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span><span class="bp">.</span><span class="n">toFloat</span> <span class="c1">-- casts a float to a string</span>
</code></pre></div>



<a name="266618372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266618372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266618372">(Jan 02 2022 at 15:16)</a>:</h4>
<p>Exploiting a fact that at runtime you can reach provably unreachable branch, thus ability of proving False an opening a wormhole to a different dimension, does not follow best practices in my book :) You need to give me a better example to convince me.</p>



<a name="266628232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266628232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266628232">(Jan 02 2022 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> even after reading the previous thread you linked, what you are doing here still makes very little sense to me. If you want to prove things about an algorithm assuming that the values are reals, why not just do that proof on a version of the algorithm using reals? Alternatively, If you want to prove properties about an algorithm using floats, you need to model floats. Otherwise, you are not really proving anything about the actual algorithm. This is especially true as many floating point algorithms are useful (i.e., have the interesting properties they have) precisely because they used a fixed-length approximation instead of reals.</p>



<a name="266629367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266629367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266629367">(Jan 02 2022 at 19:35)</a>:</h4>
<p>If you have an algorithm defined with reals, how do you actually generate runable code where you replace reals with floats?</p>



<a name="266632039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266632039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266632039">(Jan 02 2022 at 20:42)</a>:</h4>
<p>Is this a Lean 3 question?  Where is your Lean 4 theory of reals defined?</p>



<a name="266657208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266657208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266657208">(Jan 03 2022 at 07:18)</a>:</h4>
<p>I'm using Lean 4 and currently I'm treating reals purely axiomatically until mathlib gets ported.</p>



<a name="266658154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266658154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266658154">(Jan 03 2022 at 07:37)</a>:</h4>
<p>Since you seem to primarily care about execution, why are you not just using the Lean 4 floating point numbers?</p>



<a name="266658257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266658257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266658257">(Jan 03 2022 at 07:39)</a>:</h4>
<p>He does just <code>def Real := Float</code> and then assumes the stuff necessary about his <code>Real</code> for his work.</p>



<a name="266693402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266693402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266693402">(Jan 03 2022 at 14:43)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span>  it might make sense to look into bindings to arb (<a href="https://arblib.org/using.html">https://arblib.org/using.html</a>), as far as I've <br>
understood the arithmetic used there produces "correct", albeit potentially worse than floating point error bounds. I've been looking into building an autograd library in Lean as well btw., but more towards the practical side of things, not so much focussed on provability.</p>



<a name="266696683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266696683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266696683">(Jan 03 2022 at 15:12)</a>:</h4>
<p><span class="user-mention" data-user-id="130511">@Christian Pehle</span>  I will have a look into arb, looks interesting. However, I'm more interested in speed then provable correctness, so I will definitely be using single or double floats.</p>
<p>We probably have similar goal, I'm not so much interested in proving correctness but use dependent types to help me do the math behind scientific computing, the prime example is automatic/symbolic differentiation.</p>
<p>I think I'm pretty far with automatic differentiation and I would like to make it public in few weeks or months. Currently, the best thing I'm capable of automatically deriving discrete Laplacian from discrete Dirichlet energy. Example of a theorem I can prove with <code>autograd</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">[</span><span class="n">NonZero</span> <span class="n">n</span><span class="o">]</span>
  <span class="o">:</span>
    <span class="bp">∇</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∥</span><span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">∥^</span><span class="mi">2</span><span class="o">)</span> <span class="n">g</span>
    <span class="bp">=</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">i</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="n">g</span> <span class="o">(</span><span class="n">i</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="n">g</span> <span class="n">i</span><span class="o">)))</span>
  <span class="o">:=</span>
<span class="kd">by</span> <span class="n">autograd</span><span class="bp">;</span> <span class="n">funext</span> <span class="n">i</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">done</span>
</code></pre></div>
<p>I really want <code>ring</code> tactic in Lean 4, then the result can be the nice <code>2*(g i) - g (i - 1) - g (i + 1)</code>. Now I'm trying to get the continuous version working: <code>∇ (λ (f : (ℝ ⟿ ℝ)) =&gt; (∫ t, ∥∇ f t∥^2)) g = - 2 * ∇ (∇ g)</code>. </p>
<p>Then I'm planning on doing forward and reverse mode differentiation. I already have basic definitions and the core theorem/rewrite rule proven, for forward mode operator <code>𝓣</code>:  <code>𝓣 (f ∘ g) = (𝓣 f ∘ 𝓣 g)</code> and for reverse mode operator <code>𝓑</code>: <code>𝓑 (f ∘ g) = (𝓑 f • 𝓑 g)</code>, <code>•</code> where composes functions normally but their gradients in reverse direction.</p>



<a name="266697646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266697646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266697646">(Jan 03 2022 at 15:21)</a>:</h4>
<p>Yeah I would definitely be interested to help out, although this would be a side project for me and not research, I've followed your progress a bit (based on the questions you asked) and it seems like a cool approach. I got a basic C++ backend working (currently PyTorch based) and looked into various ways of deriving autograd code based on the IR, roughly like Jax / Dex does it. It would take a ton of work to make this fully functional though, but I also strongly believe that Lean could be a really nice language for scientific computing.</p>



<a name="266701966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266701966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266701966">(Jan 03 2022 at 15:57)</a>:</h4>
<p>Clearly, assuming Float and Real are equivalent is going to let one prove false, but on the other hand, my impression is that make similar transformations on floating point code all the time.</p>



<a name="266704938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266704938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266704938">(Jan 03 2022 at 16:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110994">Joe Hendrix</span> <a href="#narrow/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F/near/266701966">said</a>:</p>
<blockquote>
<p>Clearly, assuming Float and Real are equivalent is going to let one prove false, but on the other hand, my impression is that make similar transformations on floating point code all the time.</p>
</blockquote>
<p>You can prove false when using the axiom <code>Lean.readuceBool</code>. If not, the current consensus is that you can't do it. The question is really subtle and depends on details on how Lean handles <code>Float</code>.</p>



<a name="266716672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266716672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266716672">(Jan 03 2022 at 17:58)</a>:</h4>
<p>What is subtle?  Are you proposing removing the <code>reduceBool</code> axiom to accommodate your work?</p>



<a name="266726195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266726195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266726195">(Jan 03 2022 at 19:22)</a>:</h4>
<p>By subtle I mean that from all those discussions It looks like that there is a difference between what people think how Lean handles floats and how it actually handles floats. Proving anything about floats, like <code>1.0 + 0.1 = 1.1</code>, requires <code>reduceBool</code> axiom(or <code>reduceNat</code>), proving <code>1.0 + 0.1 = 1.1</code> is not as straightforward as one might naively think. I'm definitely not for removing those axioms, but you can check what axioms are used. Thus, in my work I will make sure that I do not use these axioms, or at least in conjunction with axiomatic definition of reals over floats.</p>



<a name="266742055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Treating%20%60Float%60%20as%20reals%2C%20inconsistent%3F/near/266742055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Treating.20.60Float.60.20as.20reals.2C.20inconsistent.3F.html#266742055">(Jan 03 2022 at 22:04)</a>:</h4>
<p>It is interesting to see how Intel uses formal theorem proving on their floating point implementations: <a href="https://www.cl.cam.ac.uk/~jrh13/slides/jnao-02jun06/slides.pdf">https://www.cl.cam.ac.uk/~jrh13/slides/jnao-02jun06/slides.pdf</a> - might be fun to port those proofs top Lean.  And then if you also want to be able to deal with bit manipulations: <a href="https://dl.acm.org/doi/pdf/10.1145/2980983.2908107">https://dl.acm.org/doi/pdf/10.1145/2980983.2908107</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
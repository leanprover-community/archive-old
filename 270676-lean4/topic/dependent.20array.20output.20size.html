---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/dependent.20array.20output.20size.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html">dependent array output size</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257210063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257210063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257210063">(Oct 12 2021 at 14:16)</a>:</h4>
<p>I'm trying to add type safety to a hasher output</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> Ideally I want to guarantee the correct output size</span>
<span class="cm"> def Blake3Hash : Type := { r : Array UInt8 // r.size = BLAKE3_OUT_LEN }</span>
<span class="cm">But for now this seems to work</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">Array</span> <span class="n">UInt8</span>

<span class="kd">def</span> <span class="n">hash</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Blake3Hash</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">hasher</span> <span class="bp">←</span> <span class="n">initHasher</span>
  <span class="k">let</span> <span class="n">hasher</span> <span class="bp">←</span> <span class="n">hasherUpdate</span> <span class="n">hasher</span> <span class="n">input</span> <span class="o">(</span><span class="n">USize.ofNat</span> <span class="n">input.size</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">output</span> <span class="bp">←</span> <span class="n">hasherFinalize</span> <span class="n">hasher</span> <span class="o">(</span><span class="n">USize.ofNat</span> <span class="n">BLAKE3_OUT_LEN</span><span class="o">)</span>
  <span class="n">return</span> <span class="n">output.data</span>
</code></pre></div>
<p>How do I prove / assert that output data has length <code>BLAKE3_OUT_LEN</code>? In the lean source I see several places that a constrined type like <code> { r : Array UInt8 // r.size = BLAKE3_OUT_LEN } </code> can be filled by a tuple of the value and a tactic.</p>
<p>Something like:<br>
<code>return (output.data, by erw [Array.size]; apply data.property)</code><br>
But this (unsprisingly) leads to a hole:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">69</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
<span class="n">Blake3</span><span class="bp">&gt;</span>   <span class="n">pure</span> <span class="o">(</span><span class="n">output.data</span><span class="o">,</span> <span class="bp">?</span><span class="n">m.806</span><span class="o">)</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">argument</span>
<span class="n">Blake3</span><span class="bp">&gt;</span>   <span class="o">(</span><span class="n">output.data</span><span class="o">,</span> <span class="bp">?</span><span class="n">m.806</span><span class="o">)</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">has</span> <span class="n">type</span>
<span class="n">Blake3</span><span class="bp">&gt;</span>   <span class="n">Array</span> <span class="n">UInt8</span> <span class="bp">×</span> <span class="bp">?</span><span class="n">m.805</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="n">u.802</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
<span class="n">Blake3</span><span class="bp">&gt;</span>   <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">69</span><span class="o">:</span><span class="mi">31</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">tactic</span> <span class="bp">'</span><span class="n">rewrite'</span> <span class="n">failed</span><span class="o">,</span> <span class="n">equality</span> <span class="n">or</span> <span class="n">iff</span> <span class="n">proof</span> <span class="n">expected</span>
<span class="n">Blake3</span><span class="bp">&gt;</span>   <span class="n">Nat</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">input</span> <span class="o">:</span> <span class="n">ByteArray</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">hasher</span> <span class="o">:</span> <span class="n">Blake3Hasher</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="n">output</span> <span class="o">:</span> <span class="n">ByteArray</span>
<span class="n">Blake3</span><span class="bp">&gt;</span> <span class="bp">⊢</span> <span class="bp">?</span><span class="n">m.805</span>
</code></pre></div>



<a name="257210437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257210437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257210437">(Oct 12 2021 at 14:18)</a>:</h4>
<p>Why does <code>hash</code> have <code>IO _</code> as its return type? Shouldn't it be a pure function?</p>



<a name="257210659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257210659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257210659">(Oct 12 2021 at 14:20)</a>:</h4>
<p>I think it will be hard to prove something once you've wrapped yourself in the IO monad.</p>



<a name="257211476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257211476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257211476">(Oct 12 2021 at 14:25)</a>:</h4>
<blockquote>
<p><code>return (output.data, by erw [Array.size]; apply data.property)</code></p>
</blockquote>
<p>You're also using the wrong parentheses: <code>( )</code> is for products only, you need <code>⟨ ⟩</code> here.</p>



<a name="257211855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257211855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257211855">(Oct 12 2021 at 14:27)</a>:</h4>
<blockquote>
<p><code>def Blake3Hash : Type := Array UInt8</code></p>
</blockquote>
<p>Note that <code>Array UInt8</code> has a different runtime representation than <code>ByteArray</code> (which is more efficient).</p>



<a name="257212786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257212786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257212786">(Oct 12 2021 at 14:33)</a>:</h4>
<p>I'm guessing the hash function is implemented via FFI. In this case you can do a runtime check that the output size is correct using something like <code>if h : output.size = BLAKE3_OUT_LEN then ... else ...</code> with a panic in the <code>else</code> case.</p>



<a name="257213350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257213350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257213350">(Oct 12 2021 at 14:36)</a>:</h4>
<p>In the <code>then</code> case, you get the "proof" <code>h</code> that you need to build something of type <code>{ r : Array UInt8 // r.size = BLAKE3_OUT_LEN }</code>.</p>



<a name="257213761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257213761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257213761">(Oct 12 2021 at 14:38)</a>:</h4>
<p>Thanks. I were hoping it would be possible to do it purely.<br>
It's not easy to tell the difference between <code>( )</code> and <code>⟨ ⟩</code></p>



<a name="257214776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257214776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257214776">(Oct 12 2021 at 14:45)</a>:</h4>
<p>How do I go from the IO FFI monad stuff to the pure data? This is what I have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">hash</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">:</span> <span class="n">Blake3Hash</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span>
    <span class="k">let</span> <span class="n">hasher</span> <span class="bp">←</span> <span class="n">initHasher</span>
    <span class="k">let</span> <span class="n">hasher</span> <span class="bp">←</span> <span class="n">hasherUpdate</span> <span class="n">hasher</span> <span class="n">input</span> <span class="o">(</span><span class="n">USize.ofNat</span> <span class="n">input.size</span><span class="o">)</span>
    <span class="n">hasherFinalize</span> <span class="n">hasher</span> <span class="o">(</span><span class="n">USize.ofNat</span> <span class="n">BLAKE3_OUT_LEN</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">output.size</span> <span class="bp">=</span> <span class="n">BLAKE3_OUT_LEN</span>
  <span class="k">then</span> <span class="n">output.data</span>
  <span class="k">else</span> <span class="n">panic</span> <span class="s2">"Incorrect output size"</span>
</code></pre></div>



<a name="257220004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257220004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257220004">(Oct 12 2021 at 15:17)</a>:</h4>
<p>You need to return <code>IO Blake3Hash</code> if you are using IO functions</p>



<a name="257220121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257220121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257220121">(Oct 12 2021 at 15:18)</a>:</h4>
<p>Possibly you can cheat and make some non-IO extern functions if you have reason to believe they are pure</p>



<a name="257220580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257220580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257220580">(Oct 12 2021 at 15:21)</a>:</h4>
<p>You can also cheat even more and assume the FFI already returns the subtype with the proof, though this specific runtime check doesn't exactly look costly</p>



<a name="257222773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257222773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257222773">(Oct 12 2021 at 15:34)</a>:</h4>
<p>How do I do that? These functions are in essence pure, but somewhat stateful on the hasher. They don't do any real IO operations.</p>



<a name="257223106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257223106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257223106">(Oct 12 2021 at 15:36)</a>:</h4>
<p>Can I remove the IO monad from the FFI calls? That lead to errors previously.</p>



<a name="257223377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257223377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257223377">(Oct 12 2021 at 15:38)</a>:</h4>
<p><code>IO</code> enforces ordering and exactly-once execution. It looks like this API is using the hasher linearly, so that might not be an issue and you can drop the <code>IO</code>. You need to adjust the called functions of course.</p>



<a name="257377380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257377380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257377380">(Oct 13 2021 at 14:42)</a>:</h4>
<p>Removing IO leads to this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>   <span class="bp">&gt;</span>   <span class="n">Inhabited</span> <span class="n">Blake3Hasher</span>
       <span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">38</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
       <span class="bp">&gt;</span>   <span class="n">Inhabited</span> <span class="n">Blake3Hasher</span>
       <span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">41</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
       <span class="bp">&gt;</span>   <span class="n">Inhabited</span> <span class="n">Blake3Hasher</span>
       <span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">47</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
</code></pre></div>



<a name="257377555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257377555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257377555">(Oct 13 2021 at 14:43)</a>:</h4>
<p>Is this because I'm using a constant? How can I ensure the foreign type is Inhabited?</p>



<a name="257378101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257378101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257378101">(Oct 13 2021 at 14:46)</a>:</h4>
<p>You can use <code>PointedType</code> for that, see e.g. <a href="https://github.com/leanprover/lean4/blob/66fcfcce3716774dacbd35e1ea0f5c75356df311/tests/compiler/foreign/main.lean#L1-L3">https://github.com/leanprover/lean4/blob/66fcfcce3716774dacbd35e1ea0f5c75356df311/tests/compiler/foreign/main.lean#L1-L3</a></p>



<a name="257381638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257381638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257381638">(Oct 13 2021 at 15:06)</a>:</h4>
<p>That helped. Now I get another error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>       <span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">71</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">type</span> <span class="n">mismatch</span>
       <span class="bp">&gt;</span>   <span class="n">output</span>
       <span class="bp">&gt;</span> <span class="n">has</span> <span class="n">type</span>
       <span class="bp">&gt;</span>   <span class="n">ByteArray</span> <span class="o">:</span> <span class="kt">Type</span>
       <span class="bp">&gt;</span> <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
       <span class="bp">&gt;</span>   <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span>
       <span class="bp">&gt;</span> <span class="n">Blake3.lean</span><span class="o">:</span><span class="mi">73</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="kd">instance</span>
       <span class="bp">&gt;</span>   <span class="n">Inhabited</span> <span class="n">Blake3Hash</span>
</code></pre></div>
<p>where</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">r</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">UInt8</span> <span class="bp">//</span> <span class="n">r.size</span> <span class="bp">=</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="o">}</span>
</code></pre></div>
<p>Do I need to declare an Inhabited instance?</p>



<a name="257382187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257382187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257382187">(Oct 13 2021 at 15:10)</a>:</h4>
<p>Yes. There is no trivial Inhabited instance for Subtype since you need to prove something about the element.</p>



<a name="257382315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257382315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257382315">(Oct 13 2021 at 15:10)</a>:</h4>
<p>Btw, do you solely compile on the cmdline :) ? Not in an editor?</p>



<a name="257406668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257406668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257406668">(Oct 13 2021 at 17:39)</a>:</h4>
<p>I just use the cmdline for ease.</p>



<a name="257459411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257459411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257459411">(Oct 14 2021 at 00:19)</a>:</h4>
<p>How do I create an Inhabited instance?<br>
I've tried so far to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ByteArray</span> <span class="bp">//</span> <span class="n">r.size</span> <span class="bp">=</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="o">}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="n">Blake3Hash</span> <span class="n">where</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">List.replicate</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">toByteArray</span><span class="o">⟩</span>
</code></pre></div>
<p>I see that Subtype just needs a theorem proving the property of the ByteArray size. What is the simplest way and what is "the most explicit" way (For better understanding)?</p>



<a name="257461118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257461118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257461118">(Oct 14 2021 at 00:39)</a>:</h4>
<p>The proof will be rfl, or if not, rely on a theorem that the size of a toBytes of a replicate is what you expect.</p>



<a name="257461369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257461369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257461369">(Oct 14 2021 at 00:42)</a>:</h4>
<p>Presumably you want to fill in the <code>sorry</code> in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">List.to_ByteArray_size</span> <span class="o">:</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">List</span> <span class="n">UInt8</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L.toByteArray.size</span> <span class="bp">=</span> <span class="n">L.length</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">l</span> <span class="bp">=&gt;</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ByteArray</span> <span class="bp">//</span> <span class="n">r.size</span> <span class="bp">=</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="o">}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="n">Blake3Hash</span> <span class="n">where</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">List.replicate</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">toByteArray</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
</code></pre></div>



<a name="257462832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257462832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257462832">(Oct 14 2021 at 01:00)</a>:</h4>
<p>The API for <code>ByteArray</code> is missing essentially everything for proving things about it, as it hasn't been needed much yet. But the missing pieces are:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">ByteArray.size_empty</span> <span class="o">:</span> <span class="n">ByteArray.empty.size</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">ByteArray.size_push</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">UInt8</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">B.push</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">size</span> <span class="bp">=</span> <span class="n">B.size</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">B</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ByteArray.push</span><span class="o">,</span> <span class="n">ByteArray.size</span><span class="o">,</span> <span class="n">Array.size_push</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">List.to_ByteArray_size</span> <span class="o">:</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">List</span> <span class="n">UInt8</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L.toByteArray.size</span> <span class="bp">=</span> <span class="n">L.length</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">l</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">List.toByteArray</span><span class="o">,</span> <span class="n">to_ByteArray_loop_size</span><span class="o">]</span>
<span class="n">where</span> <span class="n">to_ByteArray_loop_size</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">List</span> <span class="n">UInt8</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">List.toByteArray.loop</span> <span class="n">L</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">size</span> <span class="bp">=</span> <span class="n">L.length</span> <span class="bp">+</span> <span class="n">B.size</span>
<span class="bp">|</span> <span class="o">[],</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">List.toByteArray.loop</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">l</span><span class="o">,</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">List.toByteArray.loop</span><span class="o">,</span> <span class="n">to_ByteArray_loop_size</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_succ</span><span class="o">,</span> <span class="n">Nat.succ_add</span><span class="o">]</span>

<span class="kd">constant</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">Blake3Hash</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ByteArray</span> <span class="bp">//</span> <span class="n">r.size</span> <span class="bp">=</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="o">}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="n">Blake3Hash</span> <span class="n">where</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">List.replicate</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">toByteArray</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
</code></pre></div>



<a name="257462898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257462898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257462898">(Oct 14 2021 at 01:00)</a>:</h4>
<p>(The proof of any obvious fact that conceivably could be proved by <code>simp</code> should be proved by <code>simp</code>, and if <code>simp</code> doesn't do it, you should add the missing <code>@[simp]</code> lemmas! :-)</p>



<a name="257465276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257465276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257465276">(Oct 14 2021 at 01:30)</a>:</h4>
<p>I would guess that <code>(List.replicate BLAKE3_OUT_LEN 0).toByteArray</code> is not a good way to initialize an array. Is there an <code>Array.mk</code>?</p>



<a name="257465704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257465704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257465704">(Oct 14 2021 at 01:36)</a>:</h4>
<p>Unfortunately <code>lean_alloc_sarray</code> is not exposed to lean</p>



<a name="257466549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257466549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257466549">(Oct 14 2021 at 01:44)</a>:</h4>
<p>The best function I can write with the current API is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ByteArray.fromElem</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">UInt8</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">ByteArray</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">rec</span> <span class="n">go</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">ByteArray</span> <span class="bp">→</span> <span class="n">ByteArray</span>
  <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr</span> <span class="bp">=&gt;</span> <span class="n">arr</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">arr</span> <span class="bp">=&gt;</span> <span class="n">arr.push</span> <span class="n">a</span>
  <span class="n">go</span> <span class="n">n</span> <span class="n">empty</span>
</code></pre></div>



<a name="257473688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257473688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257473688">(Oct 14 2021 at 03:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> there is <code>Array.mkEmpty</code> if you want to pre-allocate an array of a given size.</p>



<a name="257473767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257473767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257473767">(Oct 14 2021 at 03:26)</a>:</h4>
<p>That's not a scalar array though; you have to reallocate and copy everything over to turn it into a <code>ByteArray</code></p>



<a name="257484071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257484071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257484071">(Oct 14 2021 at 06:02)</a>:</h4>
<p><code>ByteArray.mkEmpty</code> then :) ?</p>



<a name="257484107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257484107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257484107">(Oct 14 2021 at 06:02)</a>:</h4>
<p><code>mkWithCapacity</code> would also be nice</p>



<a name="257484509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257484509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257484509">(Oct 14 2021 at 06:08)</a>:</h4>
<p>I'm not sure there are good use cases for <code>ByteArray.mk</code> in general. As you said, one should stick with scalar arrays from the beginning instead of converting to and from boxed arrays.</p>



<a name="257489583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257489583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257489583">(Oct 14 2021 at 07:09)</a>:</h4>
<p>I think <code>ByteArray.mk</code> is fine, like <code>toByteArray</code>; it's a conversion function in case you have an <code>Array UInt8</code> and need a <code>ByteArray</code></p>



<a name="257489607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257489607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257489607">(Oct 14 2021 at 07:09)</a>:</h4>
<p>it's just not the first function you should reach for</p>



<a name="257520876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257520876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anders Christiansen Sørby <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257520876">(Oct 14 2021 at 11:44)</a>:</h4>
<p>How do I use the hypothesis <code>h</code> in the <code>then</code> branch to ensure that this type checks?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">hash</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">:</span> <span class="n">Blake3Hash</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">hasher</span> <span class="o">:=</span> <span class="n">initHasher</span>
  <span class="k">let</span> <span class="n">hasher</span> <span class="o">:=</span> <span class="n">hasherUpdate</span> <span class="n">hasher</span> <span class="n">input</span> <span class="o">(</span><span class="n">USize.ofNat</span> <span class="n">input.size</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">:=</span> <span class="n">hasherFinalize</span> <span class="n">hasher</span> <span class="o">(</span><span class="n">USize.ofNat</span> <span class="n">BLAKE3_OUT_LEN</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">output.size</span> <span class="bp">=</span> <span class="n">BLAKE3_OUT_LEN</span> <span class="k">then</span>
    <span class="n">output</span>
  <span class="k">else</span>
    <span class="n">panic</span> <span class="s2">"Incorrect output size"</span>
</code></pre></div>



<a name="257525276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/dependent%20array%20output%20size/near/257525276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/dependent.20array.20output.20size.html#257525276">(Oct 14 2021 at 12:23)</a>:</h4>
<p>If you e.g. use a <code>_</code> placeholder or open a tactic block in the then branch, you should see that <code>h</code> is in the context with the expected type. I <em>highly</em> recommend using an editor extension to incrementally and interactively develop Lean code :) .</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
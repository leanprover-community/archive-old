---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/rfc.3A.20theorem.20names.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html">rfc: theorem names</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="237253623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237253623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237253623">(May 04 2021 at 01:03)</a>:</h4>
<p>There is a proposal for theorem names at <a href="https://github.com/leanprover/lean4/issues/402">https://github.com/leanprover/lean4/issues/402</a> The proposal is snake case but with camelCase for the components:</p>
<ul>
<li><code>nat_add_zero</code></li>
<li><code>axiom_of_choice</code></li>
<li><code>eq_punit</code></li>
<li><code>runCatch_pure</code></li>
<li><code>seqLeft_eq_bind</code></li>
</ul>
<p>Note that types (e.g. <code>Nat</code>, <code>Eq</code>) become lowercase. The known downside is that it cannot distinguish between e.g. <code>Or</code> and <code>or</code>, but this may acceptable in light of how bad the alternatives seem. If anybody sees any critical problems with this proposal, please share them in the GitHub issue.</p>



<a name="237254607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237254607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237254607">(May 04 2021 at 01:15)</a>:</h4>
<p>Why <code>nat_add_zero</code> instead of <code>Nat.add_zero</code>?</p>



<a name="237254630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237254630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237254630">(May 04 2021 at 01:16)</a>:</h4>
<p>specifically, why is it no longer in the <code>Nat</code> namespace?</p>



<a name="237254877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237254877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237254877">(May 04 2021 at 01:19)</a>:</h4>
<p>When you say "types became lowercase", do you mean <code>Nat</code> becomes <code>nat</code> like in lean 3? Or is this only for theorem names, not the actual type names?</p>



<a name="237255058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255058">(May 04 2021 at 01:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237254607">said</a>:</p>
<blockquote>
<p>Why <code>nat_add_zero</code> instead of <code>Nat.add_zero</code>?</p>
</blockquote>
<p>I just translated what happened to be in <code>Init</code> to the proposed style. <code>Nat.add_zero</code> is consistent with the proposal.</p>



<a name="237255117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255117">(May 04 2021 at 01:22)</a>:</h4>
<p>Whatever comes between the <code>_</code> would be camelCase.</p>



<a name="237255137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255137">(May 04 2021 at 01:23)</a>:</h4>
<p>So types, modules, and namespaces are all PascalCase?</p>



<a name="237255171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255171">(May 04 2021 at 01:23)</a>:</h4>
<p>Yes, and file names.</p>



<a name="237255409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255409">(May 04 2021 at 01:26)</a>:</h4>
<p>There will be a number of specific naming conflicts to resolve, no matter what the convention is. I guess the RFC isn't the appropriate place for this, although it might influence the choice</p>



<a name="237255470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255470">(May 04 2021 at 01:27)</a>:</h4>
<p>I'm broadly supportive of the plan though</p>



<a name="237255496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255496">(May 04 2021 at 01:28)</a>:</h4>
<p>It would be helpful to find other examples of the <code>Or_True</code>/<code>or_true</code> clash, besides just <code>Prop</code>/<code>Bool</code>.</p>



<a name="237255539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255539">(May 04 2021 at 01:28)</a>:</h4>
<p>Are we using <code>Title_Snake_Case</code> anywhere?</p>



<a name="237255546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255546">(May 04 2021 at 01:28)</a>:</h4>
<p>i.e. names that appear both uppercase as types and lowercase as values/functions</p>



<a name="237255592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255592">(May 04 2021 at 01:29)</a>:</h4>
<p>No, we are not using <code>Title_Snake_Case</code> anywhere. That is option (2) in the GitHub issue. It has very little support AFAICT, in part because of the issue I mentioned: connectives (and, or) and verbs (eq) are awkward capitalized.</p>



<a name="237255661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255661">(May 04 2021 at 01:30)</a>:</h4>
<p>when you say <code>Or_True</code> then are you referring to the theorem p \/ True = True?</p>



<a name="237255691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255691">(May 04 2021 at 01:30)</a>:</h4>
<p>Yes, and <code>or_true</code> is <code>p || true = true</code>.</p>



<a name="237255730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255730">(May 04 2021 at 01:31)</a>:</h4>
<p>That looks like <code>Bool.or_true</code></p>



<a name="237255805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255805">(May 04 2021 at 01:32)</a>:</h4>
<p>and I think something similar to this can avoid most of the name clashes about Prop/Bool</p>



<a name="237255829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255829">(May 04 2021 at 01:32)</a>:</h4>
<p>we could also go back to <code>tt</code>/<code>ff</code></p>



<a name="237255837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255837">(May 04 2021 at 01:32)</a>:</h4>
<p>I agree that <code>Bool.or_true</code> is a fine solution for that particular clash.</p>



<a name="237255922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237255922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237255922">(May 04 2021 at 01:33)</a>:</h4>
<p>The fact that <code>true</code> is blue and <code>True</code> isn't seems like it implicitly prefers <code>true</code>, which probably isn't the right default for mathematics</p>



<a name="237256046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256046">(May 04 2021 at 01:34)</a>:</h4>
<p>Well, maybe we can get by if we just use <code>⊤</code> and <code>⊥</code> for true and false, although those symbols are currently in use for lattices</p>



<a name="237256076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256076">(May 04 2021 at 01:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237255546">said</a>:</p>
<blockquote>
<p>i.e. names that appear both uppercase as types and lowercase as values/functions</p>
</blockquote>
<p>Here is one possible clash:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">EvalsTo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Program</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Value</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">def</span> <span class="n">evalsTo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Program</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">Value</span>

<span class="kd">theorem</span> <span class="n">evalsTo_of_evalsTo</span>
</code></pre></div>



<a name="237256121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256121">(May 04 2021 at 01:35)</a>:</h4>
<p>I would just use <code>EvalsTo</code> in the theorem name if there is a name clash like that</p>



<a name="237256168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256168">(May 04 2021 at 01:36)</a>:</h4>
<p>I think it's fine to just use that as a backup plan</p>



<a name="237256190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256190">(May 04 2021 at 01:36)</a>:</h4>
<p>there are quite a few backup plans in the mathlib naming convention</p>



<a name="237256238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256238">(May 04 2021 at 01:37)</a>:</h4>
<p>What about lowercasing <code>Prop</code>-valued types?</p>



<a name="237256240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256240">(May 04 2021 at 01:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237255922">said</a>:</p>
<blockquote>
<p>The fact that <code>true</code> is blue and <code>True</code> isn't seems like it implicitly prefers <code>true</code>, which probably isn't the right default for mathematics</p>
</blockquote>
<p>Neither are blue for me. Is that a VSCode thing? What does blue mean?</p>



<a name="237256249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256249">(May 04 2021 at 01:37)</a>:</h4>
<p>keyword I guess</p>



<a name="237256258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256258">(May 04 2021 at 01:37)</a>:</h4>
<p>even though it's not a keyword</p>



<a name="237256322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256322">(May 04 2021 at 01:38)</a>:</h4>
<p>Could be easy to just make <code>True</code> and <code>true</code> blue then</p>



<a name="237256357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256357">(May 04 2021 at 01:39)</a>:</h4>
<p><code>true</code> is apparently in the <code>constant.language.lean4</code> textmate scope</p>



<a name="237256370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256370">(May 04 2021 at 01:39)</a>:</h4>
<p>which is blue in my theme</p>



<a name="237256390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256390">(May 04 2021 at 01:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237256238">said</a>:</p>
<blockquote>
<p>What about lowercasing <code>Prop</code>-valued types?</p>
</blockquote>
<p>You mean <code>Prop</code>-valued inductive types?</p>



<a name="237256455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256455">(May 04 2021 at 01:40)</a>:</h4>
<p>defs too, although I guess most of them are inductive</p>



<a name="237256516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256516">(May 04 2021 at 01:41)</a>:</h4>
<p>someone pointed out earlier that propositions often feel more like functions than types</p>



<a name="237256781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256781">(May 04 2021 at 01:45)</a>:</h4>
<p>Would it be alright to take a poll? I think this is the sort of thing that deserves a decent size poll</p>



<a name="237256941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256941">(May 04 2021 at 01:47)</a>:</h4>
<p>Poll how?</p>



<a name="237256952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256952">(May 04 2021 at 01:47)</a>:</h4>
<p>zulip has a poll system</p>



<a name="237256963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237256963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237256963">(May 04 2021 at 01:47)</a>:</h4>
<p>it might not get enough people though</p>



<a name="237259513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237259513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237259513">(May 04 2021 at 02:26)</a>:</h4>
<p>(there may be more lurkers on this stream than you realise :-)</p>



<a name="237259651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237259651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237259651">(May 04 2021 at 02:29)</a>:</h4>
<p>Here is a copy of my comment on the issue:</p>
<blockquote>
<p>I personally prefer option 2, but option 3 is fine as well. However, since the major problem with 2 is ugly verbs, I would suggest mixing 2 and 3. That is, I would preserve the original casing for nouns and use lower camelCase for verbs (i.e. <code>Foo_and_Bar_iff_Rig</code> instead of <code>foo_and_bar_iff_rig</code> and <code>PUnit.eq_PUnit</code> instead of <code>PUnit.eq_punit</code>). I would then have the namespace a given theorem is in dictate the meaning of verbs. That is, <code>Bool.or_true</code> means Bool <code>or</code> and root <code>Foo_and_Bar_iff_Rig</code> means Prop <code>And</code> and <code>Iff</code>.</p>
</blockquote>
<p>I agree with <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  that namespace can help resolve some of the clashes. I, however, would also like to see casing preserved at least for nouns.</p>



<a name="237347114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237347114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Kent <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237347114">(May 04 2021 at 15:33)</a>:</h4>
<p>FWIW, I am biased towards more predictable and case preserving of names/types/etc, so I guess (2)?. (3) is not bad though and perhaps with namespaces adding additional clarity at times it would be quite nice.</p>
<p>W.r.t. not liking (2), I don't think I fully understand the objections. So far I've seen</p>
<ul>
<li>it is not aesthetically pleasing (I guess it just doesn't bother me in what I've seen so far <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span> ), and</li>
<li>"Option 2 ... does not abide by the rule that only values in Sort should be capitalized" mentioned by <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> in the <a href="https://github.com/leanprover/lean4/issues/402#issuecomment-831715013">GH issue</a> -- do these structures/classes in <code>Prop</code> also count as not abiding by this rule:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Iff</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">intro</span> <span class="o">::</span> <span class="o">(</span><span class="n">mp</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">mpr</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">class</span> <span class="kd">inductive</span> <span class="n">Nonempty</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nonempty</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">Subsingleton</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">intro</span> <span class="o">::</span> <span class="n">allEq</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kd">structure</span> <span class="n">Equivalence</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">refl</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span>
  <span class="n">symm</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span>
  <span class="n">trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">},</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span>
</code></pre></div>
<p>Or am I misunderstanding the naming rule w.r.t. values in <code>Sort</code> and <code>Prop</code>?</p>



<a name="237347722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237347722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237347722">(May 04 2021 at 15:36)</a>:</h4>
<p>What part do you mean, the class/structure names?</p>



<a name="237347760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237347760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237347760">(May 04 2021 at 15:36)</a>:</h4>
<p>Recall that <code>Prop == Sort 0</code> :)</p>



<a name="237348431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237348431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Kent <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237348431">(May 04 2021 at 15:41)</a>:</h4>
<p>Yes, the structure/class names was what I was referring to. I suppose I don't have an intuition clicking in my head yet for when the aforementioned rule that (2) violates applies in practice as I'm skimming Lean files and how option 2 relates.</p>



<a name="237348791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237348791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237348791">(May 04 2021 at 15:43)</a>:</h4>
<p>Said otherwise, the rule is that declarations that are types (not just <code>Type</code>s but also <code>Prop</code>s) should be capitalized. <code>Ne_Eq</code> is not a type.</p>



<a name="237359052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/237359052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Kent <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#237359052">(May 04 2021 at 16:43)</a>:</h4>
<p>I guess my vote is for (3) then <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="240110250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240110250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240110250">(May 24 2021 at 20:52)</a>:</h4>
<p>There seems to be consensus for (3). Anyone have any lingering concerns/suggestions before we merge?</p>



<a name="240134052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240134052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240134052">(May 25 2021 at 01:46)</a>:</h4>
<p>I've mentioned this in private messages (and briefly above), but just to put it out there more formally and gauge interest: I'd like to propose a variant of (3) in which types that are propositions (i.e. of type <code>Prop</code> or <code>... -&gt; Prop</code>, but not necessarily types defeq to that like <code>Set A</code>) are lowercase camel-cased, including in particular <code>eq</code>, <code>or</code>, <code>and</code>, <code>true</code>, <code>false</code>.</p>
<ul>
<li>We can tell at a glance whether a type is a type or a prop, which is important information due to the effects of proof irrelevance. Currently mathlib indicates this inconsistently using the <code>is_</code> prefix.</li>
<li>It avoids the issue with <code>eq</code> in theorems being capitalized differently than the type <code>Eq</code>.</li>
<li>It doesn't differ significantly from the current Haskell-ish convention for programming uses, where all the data types are actual types and so get the uppercase camel case style. In particular <code>Nat</code>, <code>Int</code> and such are still capitalized.</li>
<li>This does lead to a clash with <code>Bool.true</code>. Personally I'd be fine with returning to <code>Bool.tt</code> but I don't think this is a particularly important issue and would hate for the whole naming convention to get blocked for a reason like this.</li>
</ul>
<p>We can use this post as a <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> <span aria-label="-1" class="emoji emoji-1f44e" role="img" title="-1">:-1:</span> mini-poll, where <span aria-label="-1" class="emoji emoji-1f44e" role="img" title="-1">:-1:</span> means option (3) as originally written.</p>



<a name="240134668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240134668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240134668">(May 25 2021 at 01:59)</a>:</h4>
<p>Based on other off-channel discussions, I think <code>tt</code>/<code>ff</code> is widely considered unacceptable for programming and a non-starter. At some point, you proposed weird names for <code>Prop</code> <code>true</code>/<code>false</code> and always using notation for them.</p>



<a name="240134866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240134866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240134866">(May 25 2021 at 02:03)</a>:</h4>
<p>FWIW I don't think your first two points are that strong, since (a) you still don't know at a glance due to defeq, and (b) we will still have e.g. <code>Nat</code> referred to as <code>nat</code> in proof names. Also, this proposal would break the namespace/filename symmetry, since presumably filenames will still be capitalized but here there would be lowercase namespaces, e.g. <code>prime</code>.</p>



<a name="240135531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240135531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240135531">(May 25 2021 at 02:17)</a>:</h4>
<p>If <code>Bool.tt</code> isn't acceptable, using <code>True</code> for the prop is close enough for me. We might be able to use top and bot symbols but I expect that these will be overloaded for lattices, so for core lean just <code>True</code> and <code>False</code> for the props should do.</p>
<blockquote>
<p>(a) you still don't know at a glance due to defeq</p>
</blockquote>
<p>I still don't really follow this point. Just because two types are defeq doesn't mean they act the same; in lean 3 it makes quite a difference and there are many redefinitions of <code>quot.mk</code> for particular quotient types specifically so that they have a different syntactic type. The only thing that matters is the syntactic type, and for the edge cases we can leave it as a judgment call beyond the broad strokes of the naming convention.</p>



<a name="240135552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240135552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240135552">(May 25 2021 at 02:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>: When using option (3) it doesn't matter that much whether <code>Eq</code> is capitalized or not, right? We don't write <code>Eq</code>, since we use the infix notation <code>=</code>. And in all theorem names <code>..._eq...</code> will not be capitalized. <br>
So the main differences I see will be <code>namespace Eq</code> vs <code>namespace eq</code> and if we have to refer to a full name for some reason (<code>Eq.refl</code> vs <code>eq.refl</code>).<br>
If those are the main changes, I don't really care that much about this distinction. Maybe some full names are more common (<code>Or.elim</code>?) though.</p>



<a name="240135704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240135704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240135704">(May 25 2021 at 02:21)</a>:</h4>
<blockquote>
<p>(b) we will still have e.g. Nat referred to as nat in proof names.</p>
</blockquote>
<p>It's pretty rare for <code>Nat</code> to show up in the name of a theorem; it usually appears in the namespace of the theorem when the theorem is about a definition in the <code>Nat</code> namespace. I consider the exceptions rare enough to be acceptable.</p>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> Yes, the main place this shows up is in things like <code>Or.inl</code> and <code>Eq.symm</code>, although I think it will become more common as we start to get deeper into mathlib and encounter predicates and relations and prop-classes that have no notation</p>



<a name="240136200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240136200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240136200">(May 25 2021 at 02:31)</a>:</h4>
<p>Here is another argument in favor of <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>'s proposal: many functions returning <code>Prop</code> are decidable and used in programming in lieu of <code>Bool</code>s. Currently we have an exception in the naming conventions for these, e.g. <code>isValidChar</code>.</p>



<a name="240136363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240136363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240136363">(May 25 2021 at 02:35)</a>:</h4>
<p>FWIW I don't think <code>eq.refl</code> vs <code>Eq.refl</code> matters much though, and would probably rather <code>Eq.refl</code> for uniformity (e.g. making all namespaces and filenames PascalCase)</p>



<a name="240136549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240136549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240136549">(May 25 2021 at 02:38)</a>:</h4>
<p>If the type is called <code>eq</code> I think we should make the theorems <code>eq.refl</code> as well, because otherwise we will end up with inconsistency when using dot notation (unless the mechanism for dot notation is changed so that it doesn't depend on naming in this way). Note that it is already not the case that all namespaces are uppercase - internal definitions will use the name of the main definition with an additional name segment like <code>Namespace.mainDef.internalDef</code></p>



<a name="240136670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240136670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240136670">(May 25 2021 at 02:41)</a>:</h4>
<p>Regarding file names, I don't think we need to change anything - file/module names have never been related in any direct way to type names</p>



<a name="240136754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240136754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240136754">(May 25 2021 at 02:42)</a>:</h4>
<p>To clarify: I didn't mean <code>eq</code> together with <code>Eq.refl</code>, they should definitely agree.</p>



<a name="240136850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240136850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240136850">(May 25 2021 at 02:44)</a>:</h4>
<p>I'm not really sure whether project names (e.g. in the repo name and/or the <code>name = ...</code> in the toml) need to be capitalized though. Personally I would like these to be lowercase and unrelated to lean module names, but I'm not sure if leanpkg wants some agreement here</p>



<a name="240137091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240137091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240137091">(May 25 2021 at 02:50)</a>:</h4>
<blockquote>
<p>Note that it is already not the case that all namespaces are uppercase - internal definitions will use the name of the main definition with an additional name segment like <code>Namespace.mainDef.internalDef</code></p>
</blockquote>
<p>While these are namespaces in the technical sense, I think we should distinguish between these uses of namespaces for grouping vs namespaces for indicating that one definition/theorem is about the one with the parent name. The former kind of namespace is somewhat rare in mathlib but there are some like <code>category_theory</code> and these should be pascal case, and the latter kind of namespace should just follow the casing of the parent definition</p>



<a name="240137209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240137209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240137209">(May 25 2021 at 02:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240136200">said</a>:</p>
<blockquote>
<p>Here is another argument in favor of <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span>'s proposal: many functions returning <code>Prop</code> are decidable and used in programming in lieu of <code>Bool</code>s. Currently we have an exception in the naming conventions for these, e.g. <code>isValidChar</code>.</p>
</blockquote>
<p>I think that is a pretty strong argument in favor of Mario's proposal. And this exception could be drawn much further (<code>True</code> is definitely decidable, and <code>And</code> preserves decidability). In that case it seems simplest to make all propositions <code>camelCase</code>.</p>



<a name="240137446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240137446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240137446">(May 25 2021 at 02:59)</a>:</h4>
<p>Another solution to <code>True</code>/<code>true</code> that just occurred to me: we can have a notation <code>true</code> with a type-dependent elaborator that elaborates to <code>True</code> when the target type is <code>Prop</code> and <code>Bool.true</code> or its coercion otherwise. Lean 3 already makes it fairly transparent to use <code>true</code> for <code>tt</code> or vice versa, but the coercion that sneaks in bothers me and so I try to always use the right one. A type dependent elaborator would let me use <code>true</code> always with a good conscience</p>



<a name="240138488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240138488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240138488">(May 25 2021 at 03:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240137209">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240136200">said</a>:</p>
<blockquote>
<p>Here is another argument in favor of <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span>'s proposal: many functions returning <code>Prop</code> are decidable and used in programming in lieu of <code>Bool</code>s. Currently we have an exception in the naming conventions for these, e.g. <code>isValidChar</code>.</p>
</blockquote>
<p>I think that is a pretty strong argument in favor of Mario's proposal. And this exception could be drawn much further (<code>True</code> is definitely decidable, and <code>And</code> preserves decidability). In that case it seems simplest to make all propositions <code>camelCase</code>.</p>
</blockquote>
<p>Do you also agree with Mario's proposal that this should only extend to identifiers that syntactically return <code>Prop</code> and not to ones that return e.g. <code>Set</code>s? So it would be "bad style" to declare <code>isValidChar : Set Nat</code> and then use it as a boolean?</p>



<a name="240139061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139061">(May 25 2021 at 03:35)</a>:</h4>
<p>It's already bad style in mathlib to write <code>isValidChar x</code> if <code>isValidChar : Set Nat</code>. You would instead have <code>validChars : Set Nat</code> and <code>x \in validChars</code> to express that. (EDIT: <code>validChars</code> should be lowercase because it's not a type)</p>



<a name="240139113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139113">(May 25 2021 at 03:36)</a>:</h4>
<p>I don't know if we have a linter for that but we should</p>



<a name="240139244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139244">(May 25 2021 at 03:39)</a>:</h4>
<p>Huh? I thought you were specifically proposing <code>ValidChars : Set Nat</code>, i.e. you only camelCase things that syntactically return <code>Prop</code>.</p>



<a name="240139296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139296">(May 25 2021 at 03:40)</a>:</h4>
<p><span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> That last example has me wondering whether we need another exception to the rule to capitalize things of type <code>Set A</code> since they are "like" types even though they aren't, technically.</p>



<a name="240139361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139361">(May 25 2021 at 03:42)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> The rule is to capitalize things of type <code>Sort u</code> or <code>Type u</code> but not <code>Prop</code> or <code>OtherType</code>. Absent another exception that means that sets should be lowercase</p>



<a name="240139365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139365">(May 25 2021 at 03:42)</a>:</h4>
<p>Wasn't that exception in your proposal?</p>
<blockquote>
<p>I'd like to propose a variant of (3) in which types that are propositions (i.e. of type Prop or ... -&gt; Prop, but not necessarily types defeq to that like Set A) are lowercase camel-cased</p>
</blockquote>



<a name="240139451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139451">(May 25 2021 at 03:45)</a>:</h4>
<p>I think using <code>Set A</code> in that example was not a good choice, because if we "see though" the abbreviation then it has type <code>A -&gt; Prop</code> so it should be lowercase, and if we don't then it has type <code>Set A</code> which is not a universe so it should also be lowercase</p>



<a name="240139466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139466">(May 25 2021 at 03:45)</a>:</h4>
<p>what I meant to say by that example is that the naming convention does not "see through" abbreviations</p>



<a name="240139530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139530">(May 25 2021 at 03:47)</a>:</h4>
<p>Ah, thanks for clarifying. I understand now.</p>



<a name="240139587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139587">(May 25 2021 at 03:48)</a>:</h4>
<p>Slippery slope: if we were to capitalize things of type <code>Set A</code> since they are like types, wouldn't we also want to capitalize things of type <code>Submodule R M</code>, etc, since they are just as much like types?</p>



<a name="240139592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139592">(May 25 2021 at 03:48)</a>:</h4>
<p><del>What about capitalizing things that syntactically return something capitalized besides <code>Prop</code>?</del></p>



<a name="240139603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139603">(May 25 2021 at 03:49)</a>:</h4>
<p>that would include <code>Nat.add</code></p>



<a name="240139614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139614">(May 25 2021 at 03:49)</a>:</h4>
<p>Re: slippery slope, we could extend the rule (whatever it is) to things with a coe to sort</p>



<a name="240139723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139723">(May 25 2021 at 03:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240139361">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> The rule is to capitalize things of type <code>Sort u</code> or <code>Type u</code> but not <code>Prop</code> or <code>OtherType</code>. Absent another exception that means that sets should be lowercase</p>
</blockquote>
<p>I don't yet see a major problem with this. We can simplify the wording as <em>only capitalize things that syntactically return <code>Sort u</code> or <code>Type u</code></em>.</p>



<a name="240139726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139726">(May 25 2021 at 03:52)</a>:</h4>
<p>I don't have a well formed opinion on sets, submodules etc. Maybe lowercase is fine</p>



<a name="240139755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139755">(May 25 2021 at 03:53)</a>:</h4>
<p>I think it would be <em>a priori</em> reasonable to use decidable <code>Set</code>s in programming, i.e. <code>n \in validChars</code>.</p>



<a name="240139802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139802">(May 25 2021 at 03:54)</a>:</h4>
<p>I don't think that resolves the question though. Both capital and lowercase seem reasonable in that position</p>



<a name="240139827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139827">(May 25 2021 at 03:55)</a>:</h4>
<p>It would be behaving like a datastructure though (which would normally be camelCase), similar to how <code>isValidChar</code> would be behaving like a <code>Bool</code>-valued function.</p>



<a name="240139877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139877">(May 25 2021 at 03:56)</a>:</h4>
<p>One argument for the slippery slope version: if there is a coe to sort, then you can write <code>n: validChars</code> and with the lowercasing rule for props this makes <code>n</code> look like a proof of a proposition</p>



<a name="240139940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240139940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240139940">(May 25 2021 at 03:58)</a>:</h4>
<p>So to more formally state the slippery slope version: Only capitalize things that either syntactically return <code>Sort u</code> or <code>Type u</code>, or types that coerce to <code>Sort u</code> or <code>Type u</code>.</p>



<a name="240145702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240145702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240145702">(May 25 2021 at 06:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240137446">said</a>:</p>
<blockquote>
<p>Another solution to <code>True</code>/<code>true</code> that just occurred to me: we can have a notation <code>true</code> with a type-dependent elaborator that elaborates to <code>True</code> when the target type is <code>Prop</code> and <code>Bool.true</code> or its coercion otherwise. Lean 3 already makes it fairly transparent to use <code>true</code> for <code>tt</code> or vice versa, but the coercion that sneaks in bothers me and so I try to always use the right one. A type dependent elaborator would let me use <code>true</code> always with a good conscience</p>
</blockquote>
<p>What is wrong with following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">class</span> <span class="n">True</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="n">true</span> <span class="o">:</span> <span class="n">A</span>
<span class="kd">class</span> <span class="n">False</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span> <span class="o">:</span> <span class="n">A</span>

<span class="kn">export</span> <span class="n">True</span> <span class="o">(</span><span class="n">true</span><span class="o">)</span>
<span class="kn">export</span> <span class="n">False</span> <span class="o">(</span><span class="n">false</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">True</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Bool.true</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">False</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Bool.false</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">True</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">⟨</span><span class="kt">Prop</span><span class="bp">.</span><span class="n">true</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">False</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">⟨</span><span class="kt">Prop</span><span class="bp">.</span><span class="n">false</span><span class="o">⟩</span>
</code></pre></div>
<p>(I am not sure whether Prop's should be a default instance, but the idea in general seems sound).</p>



<a name="240145871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240145871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240145871">(May 25 2021 at 06:06)</a>:</h4>
<p>The issue is that we want the result to be syntactically either <code>True</code> or <code>Bool.true</code> depending on the context. Since there are coercions in both directions you can still use either one in the wrong context and get something equivalent to the right result, but it is syntactically incorrect (if you use <code>true : Prop</code> you get <code>true = true</code> and if you use <code>True : Bool</code> you get <code>decide True</code>)</p>



<a name="240145963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240145963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240145963">(May 25 2021 at 06:08)</a>:</h4>
<p>How does that relate to my class example?</p>



<a name="240145991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240145991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240145991">(May 25 2021 at 06:08)</a>:</h4>
<p>With an instance you would end up with the wrong answer in both cases, namely <code>@True.true Prop instTrueProp</code> and <code>@True.true Bool instTrueBool</code> instead of <code>True</code> and <code>Bool.true</code> respectively</p>



<a name="240146088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146088">(May 25 2021 at 06:10)</a>:</h4>
<p>Is that a problem?</p>



<a name="240146099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146099">(May 25 2021 at 06:10)</a>:</h4>
<p>They can be proved equivalent, right?</p>



<a name="240146122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146122">(May 25 2021 at 06:11)</a>:</h4>
<p>ex. <code>example : true = Prop.true := rfl</code> or <code>example : true = Bool.true := rfl</code></p>



<a name="240146720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146720">(May 25 2021 at 06:22)</a>:</h4>
<p>Furthemore, this seems to fit with the way Lean generally handles shared syntax (ex. the type classes for <code>Add</code>, <code>Mul</code>, etc.)</p>



<a name="240146781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146781">(May 25 2021 at 06:23)</a>:</h4>
<p>Yes, it causes problems for simp, rw and other tactics that look at the syntax of a term in order to decide what to do</p>



<a name="240146831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146831">(May 25 2021 at 06:24)</a>:</h4>
<p>I don't think the way to solve the issue of two ways to write <code>true</code> is to make four ways to write <code>true</code></p>



<a name="240146832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146832">(May 25 2021 at 06:24)</a>:</h4>
<p>Why isn't that also a sticking point for the math operators (and natural literals) then?</p>



<a name="240146894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146894">(May 25 2021 at 06:25)</a>:</h4>
<p>Sure you could make "true"/"false" custom syntax and do type-dependent elaboration as you said. But as Lean doesn't do that other syntax, but instead use type classes, it seems reasonable to use type classes here.</p>



<a name="240146947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146947">(May 25 2021 at 06:26)</a>:</h4>
<p>This is getting off topic for this thread</p>



<a name="240146957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240146957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240146957">(May 25 2021 at 06:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240146831">said</a>:</p>
<blockquote>
<p>I don't think the way to solve the issue of two ways to write <code>true</code> is to make four ways to write <code>true</code></p>
</blockquote>
<p>No, now there is really one way -- everything would just use the <code>true</code> from the type class. Just like everything uses the <code>hAdd</code> from <code>HAdd</code> when doing addition.</p>



<a name="240147019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147019">(May 25 2021 at 06:27)</a>:</h4>
<p>However, I am not denying there may be issues with that, it just seems reasonable to remain consistent with how this  kind of polymorphism is done elsewhere.</p>



<a name="240147066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147066">(May 25 2021 at 06:28)</a>:</h4>
<p>Any solution to this issue will be in mathlib anyway, lean core doesn't have to care</p>



<a name="240147072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147072">(May 25 2021 at 06:28)</a>:</h4>
<p>lean can just define <code>True</code> and <code>Bool.true</code></p>



<a name="240147095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147095">(May 25 2021 at 06:29)</a>:</h4>
<p><code>true</code> isn't notation (in lean core) so it doesn't make sense to have a notation typeclass for it (in lean core)</p>



<a name="240147096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147096">(May 25 2021 at 06:29)</a>:</h4>
<p>isn't the theorem names rfc about Lean core, though? so this will effect core.</p>



<a name="240147114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147114">(May 25 2021 at 06:29)</a>:</h4>
<p>This is not an rfc about typeclass true</p>



<a name="240147205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147205">(May 25 2021 at 06:30)</a>:</h4>
<p>I am simply suggesting that this would be one way to resolve the <code>true</code>/<code>True</code> and <code>false</code>/<code>False</code> problem that came up as a sticking point for option (3). This would unify them into a single <code>true</code>/<code>false</code> thus removing the clash.</p>



<a name="240147257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147257">(May 25 2021 at 06:31)</a>:</h4>
<p>your proposal is a lot more than a name change though, it needs separate discussion and this isn't the place for it</p>



<a name="240147347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147347">(May 25 2021 at 06:33)</a>:</h4>
<p>k, if you say so</p>



<a name="240147353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147353">(May 25 2021 at 06:33)</a>:</h4>
<p>regardless of the existence of alternate typeclasses, you would still need a name for <code>Prop.true</code> and <code>Bool.true</code>. We don't use <code>Prop</code> as a namespace elsewhere</p>



<a name="240147373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147373">(May 25 2021 at 06:33)</a>:</h4>
<p>current frontrunner seems to be <code>True</code> and <code>Bool.true</code></p>



<a name="240147441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147441">(May 25 2021 at 06:34)</a>:</h4>
<p>Personally, I do think that using <code>Prop</code> as a namespace would be a good idea and help mitigate a lot of these naming clashes.</p>



<a name="240147461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147461">(May 25 2021 at 06:35)</a>:</h4>
<p>As theorems that clash between <code>Bool</code> and <code>Prop</code> could go into their separate namespaces.</p>



<a name="240147527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147527">(May 25 2021 at 06:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240147373">said</a>:</p>
<blockquote>
<p>current frontrunner seems to be <code>True</code> and <code>Bool.true</code></p>
</blockquote>
<p>Well, yeah, because that is currently how it is set up and thus it is easiest to keep it that way.</p>



<a name="240147658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147658">(May 25 2021 at 06:38)</a>:</h4>
<p>Note that <code>true</code> and <code>Bool.true</code> aren't an option not because they clash directly, but because they clash when <code>Bool.true</code> is exported. That's why we're considering separate names like <code>true/tt</code> or <code>True/true</code>. <code>Prop.true</code>/<code>Bool.true</code> would similarly cause clashing exported names</p>



<a name="240147663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147663">(May 25 2021 at 06:38)</a>:</h4>
<p>I concur largely with what you said earlier, I think that since <code>Prop</code> "types" follow proof irrelevance it makes sense for them to be lower camelCase like objects instead of upper camelCase like types (and this is already some followed with things like <code>isValidChar</code>).</p>



<a name="240147699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147699">(May 25 2021 at 06:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240147658">said</a>:</p>
<blockquote>
<p>Note that <code>true</code> and <code>Bool.true</code> aren't an option not because they clash directly, but because they clash when <code>Bool.true</code> is exported. That's why we're considering separate names like <code>true/tt</code> or <code>True/true</code>. <code>Prop.true</code>/<code>Bool.true</code> would similarly cause clashing exported names</p>
</blockquote>
<p>Yes but if you had something like a type class to unify them you <em>wouldn't need to export them</em>.</p>



<a name="240147723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147723">(May 25 2021 at 06:39)</a>:</h4>
<p>Just like you don't need to export <code>Nat.add</code> or <code>Int.add</code> because <code>Add</code> unifies them.</p>



<a name="240147977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240147977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240147977">(May 25 2021 at 06:43)</a>:</h4>
<p>In fact, if they used namespace, you could potentially solve the syntactic problem by having <code>true : A</code> and <code>false : A</code> be elaborated to <code>A.true</code>/ <code>A.false</code> (ex. <code>Prop.true</code>/<code>Bool.true</code>).</p>



<a name="240158750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240158750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240158750">(May 25 2021 at 08:50)</a>:</h4>
<p>I have to say I like the current naming convention with capitalizing propositions for teaching. Using the same naming convention really drives home the whole "propositions are just types", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. I'd like to hear whether <span class="user-mention" data-user-id="110789">@Jakob von Raumer</span> and <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> agree.</p>



<a name="240158977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240158977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240158977">(May 25 2021 at 08:52)</a>:</h4>
<p>I agree that using <code>IsValidChar</code> in a conditional would probably look weird. On the other hand,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Char</span> <span class="n">where</span>
  <span class="n">val</span>   <span class="o">:</span> <span class="n">UInt32</span>
  <span class="n">valid</span> <span class="o">:</span> <span class="n">val.isValidChar</span>
</code></pre></div>
<p>also looks quite weird to me, with a camelcase ident right of <code>:</code>! I haven't really made up my mind about this yet.</p>



<a name="240159219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240159219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240159219">(May 25 2021 at 08:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158977">said</a>:</p>
<blockquote>
<p>also looks quite weird to me, with a camelcase ident right of <code>:</code>!</p>
</blockquote>
<p>It's also going to be lowercase if <code>Char.isValidChar : Char → Bool</code> is a Boolean.  This is only consistent.</p>



<a name="240160122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240160122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240160122">(May 25 2021 at 09:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158750">said</a>:</p>
<blockquote>
<p>Using the same naming convention really drives home the whole "propositions are just types", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. I'd like to hear whether <span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> and <span class="user-mention silent" data-user-id="221921">Marc Huisinga</span> agree.</p>
</blockquote>
<p>I'm not sure if students will really remember this any better if the naming convention mirrors it <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> <br>
One thing I've also noticed during the lab is that students sometimes confuse <code>False</code> with <code>false</code> and <code>True</code> with <code>true</code>. Not necessarily because they missunderstand the difference between <code>Bool</code> and <code>Prop</code>, but because they forget the exact name and write down the first thing that comes to their mind.</p>



<a name="240161960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240161960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240161960">(May 25 2021 at 09:25)</a>:</h4>
<p>Almost makes you wonder if we do need both <code>true</code> and <code>True</code> to begin with. We could have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">true.intro</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">def</span> <span class="n">false.elim</span> <span class="o">:</span> <span class="n">false</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">nomatch</span> <span class="n">h</span>
</code></pre></div>
<p>and together with pretty-printing away <code>= true</code> usage would basically stay the same. For efficiency and indexing reasons we might want to instead use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Bool.asProp</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">asProp</span> <span class="n">true</span>
</code></pre></div>
<p>but that would really be an implementation detail.</p>



<a name="240162579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240162579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240162579">(May 25 2021 at 09:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240161960">said</a>:</p>
<blockquote>
<p>Almost makes you wonder if we do need both <code>true</code> and <code>True</code> to begin with. </p>
</blockquote>
<p>Yeah I'd be behind that proposal. My students never use <code>Bool</code>, we could just scrap it completely.</p>



<a name="240169958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240169958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240169958">(May 25 2021 at 10:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> Or perhaps <code>Bool.AsProp</code>...</p>



<a name="240170770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240170770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240170770">(May 25 2021 at 11:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240161960">said</a>:</p>
<blockquote>
<p>Almost makes you wonder if we do need both <em>[<code>false</code> and <code>False</code>]</em> to begin with. </p>
</blockquote>
<p>For <code>False</code>, it is convenient to have dot-notation, i.e. <code>(not_lt_of_le h1 h2).elim</code> which wouldn't work out-of-the-box with a coercion from Bool.  But maybe there's a way to make dot-notation see through <code>Bool.asProp</code>.</p>



<a name="240171054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240171054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240171054">(May 25 2021 at 11:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> wouldn't <code>(not_lt_of_le h1 h2).asProp.elim</code> work?</p>



<a name="240171302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240171302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240171302">(May 25 2021 at 11:09)</a>:</h4>
<p>No? With the proposal, <code>not_lt_of_le h1 h2</code> would have the type <code>Bool.asProp false</code> (pretty-printed as <code>false</code>).  Dot-notation would then look for a declaration called <code>Bool.asProp.elim</code>.</p>



<a name="240171325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240171325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240171325">(May 25 2021 at 11:09)</a>:</h4>
<p>ah, gotcha</p>



<a name="240171457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240171457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240171457">(May 25 2021 at 11:10)</a>:</h4>
<p><code>elim</code> could potentially be a type class, but I guess that's completely besides the point.</p>



<a name="240172167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240172167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240172167">(May 25 2021 at 11:18)</a>:</h4>
<p>Why would it look for <code>Bool.elim</code>? This currently works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Bool.asProp</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">asProp</span> <span class="n">true</span>

<span class="kd">theorem</span> <span class="n">T</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">Bool.asProp</span> <span class="n">false</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Nat.noConfusion</span> <span class="n">h</span>

<span class="k">#reduce</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">T</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">recOn</span> <span class="o">(</span><span class="n">motive</span><span class="o">:=</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">_</span><span class="o">)</span> <span class="n">Empty</span>
<span class="c1">-- 0 = 1 → Bool.asProp.rec Empty (_ : Nat.noConfusionType (Bool.asProp false) 0 1)</span>
</code></pre></div>



<a name="240172710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240172710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240172710">(May 25 2021 at 11:24)</a>:</h4>
<p>Ah sorry, it would look for <em><code>Bool.asProp.elim</code></em> of course.  But that's still not helpful for false.elim (even if you manage to reuse the recursor) , since you need to provide lots of extra arguments to the recursor.</p>



<a name="240173872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240173872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240173872">(May 25 2021 at 11:36)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Bool.asProp</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">asProp</span> <span class="n">true</span>

<span class="kd">theorem</span> <span class="n">T</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">Bool.asProp</span> <span class="n">false</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Nat.noConfusion</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">Bool.asProp.elim</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span> <span class="o">:</span> <span class="n">false.asProp</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">nomatch</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span> <span class="o">:=</span> <span class="o">(</span><span class="n">T</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
</code></pre></div>



<a name="240174413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240174413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240174413">(May 25 2021 at 11:42)</a>:</h4>
<p>Calling it <code>elim</code> is a bit weird when it's not applicable to all <code>asProp</code>s. How about <code>exfalso</code>? Doesn't that make the proof script even more readable than before?</p>



<a name="240174481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240174481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240174481">(May 25 2021 at 11:43)</a>:</h4>
<p>Or <code>elimFalse</code> or...</p>



<a name="240174507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240174507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240174507">(May 25 2021 at 11:43)</a>:</h4>
<p><code>exfalso</code>'s actually a good name.  Although I'd still prefer dot-notation to see through the asProp.</p>



<a name="240174886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240174886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240174886">(May 25 2021 at 11:47)</a>:</h4>
<p>There was some discussion about a <code>[parent]</code> attribute that could be applied to structure fields for this, but it would need to be even more general in this case...</p>



<a name="240176204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240176204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240176204">(May 25 2021 at 12:00)</a>:</h4>
<p>Speaking of names: the constructor <code>Bool.asProp.true</code> should be protected or perhaps renamed <code>Bool.asProp.trivial</code>.</p>



<a name="240207269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240207269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240207269">(May 25 2021 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158750">said</a>:</p>
<blockquote>
<p>I have to say I like the current naming convention with capitalizing propositions for teaching. Using the same naming convention really drives home the whole "propositions are just types", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. </p>
</blockquote>
<p>For me this is a really strong argument against this naming convention. I try very hard to completely hide the whole "propositions are just types" crazyness to my students.</p>



<a name="240210516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240210516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240210516">(May 25 2021 at 16:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240207269">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158750">said</a>:</p>
<blockquote>
<p>I have to say I like the current naming convention with capitalizing propositions for teaching. Using the same naming convention really drives home the whole "propositions are just types", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. </p>
</blockquote>
<p>For me this is a really strong argument against this naming convention. I try very hard to completely hide the whole "propositions are just types" crazyness to my students.</p>
</blockquote>
<p>One example that came up in the course was that students proved properties about the natural numbers and then had to define monoids and instantiate Nat as a monoid.<br>
We explained that propositions are types (in the sense that we can use the same language to work with them) and showed examples of propositions and regular structures which only contain data.<br>
Given that information, we expected them to figure out that you can declare the monoid rules as fields of the structure as part of the exercise.<br>
Is that crazy, or would you instead not mention "propositions as types" at all and always introduce all Lean features separately, once for propositions and once for types, even if they are used in very similar ways?<br>
EDIT: I realize this is a bit off-topic <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="240210678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240210678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240210678">(May 25 2021 at 16:02)</a>:</h4>
<p>I'd like to cast a vote in favor of (at least trying out) the current proposal to reserve upper case for datatypes (and types like <code>Set</code> that are thought of as mathematical data). Teaching and constructive ideology aside, propositions aren't datatypes. Conflating them is confusing, and in practice it is often useful to be able to distinguish them easily. </p>
<p>As Patrick's remark indicates, mathematicians feel strongly about this. But it is also useful for computer scientists to distinguish between programming and verification, and to be able to tell at a glance whether they are dealing with a piece of code or a specification.</p>
<p>I don't know the best way to mediate between Prop and Bool. Sometimes <code>x &lt; y</code> is a branching condition and sometimes it is used as a specification. But whatever we do to finesse that, I think it is helpful to be mindful of the distinction.</p>



<a name="240211213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240211213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240211213">(May 25 2021 at 16:06)</a>:</h4>
<p>P.S. I have no problem with propositions as types -- it is useful as an analogy, and explaining commonalities in Lean syntax when writing code and proving theorems. All I am saying is that it is often helpful to distinguish them as well.</p>



<a name="240214965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240214965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240214965">(May 25 2021 at 16:33)</a>:</h4>
<p>Am I right in thinking that propositions _aren't_ types in Isabelle/HOL?</p>
<p>"define monoids" would be something that people in my course would find easy, because I define lots of structures very early on -- mathematics is full of structures. My students have probably never seen the <code>inductive</code> keyword though.</p>



<a name="240217043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240217043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240217043">(May 25 2021 at 16:48)</a>:</h4>
<blockquote>
<p>Am I right in thinking that propositions _aren't_ types in Isabelle/HOL?</p>
</blockquote>
<p>That's correct. In ZFC or HOL based systems (Isabelle/HOL, HOL Light, Mizar, Metamath) propositions are in a separate class from data / objects in the domain of discourse and you can't conflate them. Only DTT based systems (Coq, Agda, Lean) have propositions as types.</p>



<a name="240217950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240217950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240217950">(May 25 2021 at 16:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="221921">Marc Huisinga</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240160122">said</a>:</p>
<blockquote>
<p>One thing I've also noticed during the lab is that students sometimes confuse <code>False</code> with <code>false</code> and <code>True</code> with <code>true</code>. Not necessarily because they missunderstand the difference between <code>Bool</code> and <code>Prop</code>, but because they forget the exact name and write down the first thing that comes to their mind.</p>
</blockquote>
<p>This is the audience I'm trying to address with the proposal for a type dependent elaborator for the notation <code>true</code>. It doesn't come with an unexpander so it will still be printed as <code>True</code> (maybe this is debatable), but it's easier to do the right thing when you can just always write <code>true</code> and lean just inserts the right one.</p>



<a name="240218270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240218270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240218270">(May 25 2021 at 16:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240217043">said</a>:</p>
<blockquote>
<p>In ZFC or HOL based systems (Isabelle/HOL, HOL Light, Mizar, Metamath) propositions are in a separate class from data / objects in the domain of discourse and you can't conflate them.</p>
</blockquote>
<p>Which is not entirely true.  In the HOL systems, there is only a distinction between terms and types.  The Booleans are a type, and e.g. true has the type Boolean.  Just like the natural numbers are a type, and 0 has the type natural number.  And propositions are just terms of type Boolean.  (In metamath these are indeed different categories though.)</p>



<a name="240218407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240218407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240218407">(May 25 2021 at 16:58)</a>:</h4>
<p>Another category is proofs: these are completely separate in all non-DTT systems that I know of.</p>



<a name="240218433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240218433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240218433">(May 25 2021 at 16:58)</a>:</h4>
<p>ah, you are right. In HOL propositions are objects in the domain of discourse, but proofs are not</p>



<a name="240218824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240218824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240218824">(May 25 2021 at 17:02)</a>:</h4>
<p>Actually maybe I should say that propositions are like data but they have a different type (namely <code>Boolean</code> in HOL and <code>wff</code> in metamath). This is more surprising in metamath since there are only a handful of types, but it's approximately the same distinction</p>



<a name="240219409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240219409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240219409">(May 25 2021 at 17:06)</a>:</h4>
<p>In my teaching using Lean students don't define define anything. They don't even state lemmas. It's all about proofs (what else?).</p>



<a name="240219558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240219558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240219558">(May 25 2021 at 17:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240219409">said</a>:</p>
<blockquote>
<p>In my teaching using Lean students don't define define anything. They don't even state lemmas. It's all about proofs (what else?).</p>
</blockquote>
<p>But that's only half the fun! <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="240219684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240219684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240219684">(May 25 2021 at 17:08)</a>:</h4>
<p>My course is really using Lean as a tool towards learning how to write correct proofs on paper.</p>



<a name="240220027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240220027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240220027">(May 25 2021 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240210678">said</a>:</p>
<blockquote>
<p>But it is also useful for computer scientists to distinguish between programming and verification, and to be able to tell at a glance whether they are dealing with a piece of code or a specification.</p>
</blockquote>
<p>This is in fact nicely demonstrated at <code>Char</code>, where one really wants the information that the second field is erased and thus the entire structure is unboxed. So I suppose I just have to get used to it.</p>



<a name="240345212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240345212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240345212">(May 26 2021 at 15:40)</a>:</h4>
<p>Summary so far:</p>
<ul>
<li>Their seems to be consensus for the original (3), which is independent of the capitalization scheme for types/props.</li>
<li>There seems to be consensus to (a) capitalize definitions that syntactically return <code>Sort u</code> or <code>Type u</code> and (b) not to capitalize definitions that syntactically return <code>Prop</code>. One of the main benefits of the latter is that we are already lower-casing many of these anyway as special-cases, since decidable <code>Prop</code>s are frequently used like <code>Bool</code>s.</li>
<li>There does not seem to be consensus yet whether to capitalize definitions that return other types, which includes both defs that are def-eq to something returning <code>Prop</code> (e.g. <code>def mySet : Set Nat</code>) and ones that are not (e.g. <code>def MapToType α := α → Type; def foo : MapToType Nat</code>). Mario proposed the "slippery slope" addendum: <em>also capitalize defs that return types that coerce to <code>Sort u</code> or <code>Type u</code></em>. Another obvious candidate is the "semantic" approach of removing the "syntactic" qualifier from the original proposal. Note that these two proposal have the opposite behavior on the two examples above.</li>
<li>There are a few ways to deal with <code>true</code>, the simplest being to just capitalize the <code>Prop</code> versions. I think other variants could probably be considered separately from this issue.</li>
</ul>



<a name="240346958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240346958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240346958">(May 26 2021 at 15:53)</a>:</h4>
<p>Downside to slippery slope proposal: the presence of a coercion isn't as binary/definitive as either the syntactic or semantic checks. Somebody could add a <code>CoeSort</code> in some other file much later, or as a local instance, etc.</p>



<a name="240381716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240381716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240381716">(May 26 2021 at 19:55)</a>:</h4>
<blockquote>
<p>Somebody could add a CoeSort in some other file much later, or as a local instance, etc.</p>
</blockquote>
<p>I don't think these are very important considerations. The vast majority of the time whether something has a coe to sort or not is relatively integral to the type's expression and use. If <code>CoeSort</code> is added in a file much later, that's bad style, unless for whatever reason it is very difficult to set up the coercion in which case the whole file should be written with that in mind. If it's a local instance, then it doesn't count.</p>



<a name="240381833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240381833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240381833">(May 26 2021 at 19:55)</a>:</h4>
<p>Since we're talking about a naming convention here it's okay to have a solution for 90% of cases and leave the rest as judgment calls</p>



<a name="240384717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240384717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240384717">(May 26 2021 at 20:15)</a>:</h4>
<p>I agree this is unlikely to be an issue. I think I would still rather <code>foo : MapToType Nat</code> to be <code>Foo</code> though. How about slippery-slope + semantic, since they seem to be compatible. The rule would be <em>caps if it semantically returns <code>Sort u</code> or <code>Type u</code>, or if it coe-to-sorts to something that does</em>.</p>



<a name="240386374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240386374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240386374">(May 26 2021 at 20:27)</a>:</h4>
<p>The main issues I see with the semantic approach:</p>
<ul>
<li>Definitions can be arbitrarily stacked, so it can be unobvious and sometimes even surprising to discover that something, <em>ultimately</em>, boils down to a function to Type/Prop. This is well known as the "apply bug" in lean 3, where the <code>apply</code> tactic uses the number of pi types in the fully unfolded type of the applied lemma even though most of them are hidden to the user (and in some cases even explicitly marked as opaque using <code>@[irreducible]</code>). The purpose of definitions is to encapsulate complexity and we shouldn't be peeking behind the curtain.</li>
<li>Besides this, it can actually just be <em>difficult</em> to determine "at a glance" whether a type is such a definition, which means that people will be tempted to use a lower cost approximation to the naming convention, leading to inconsistency.</li>
<li>For abbreviations, there is a stronger argument for unfolding since the user is explicitly indicating that it should be unfolded. However that's a directive to lean, not to readers, and I would still be inclined to default to not unfolding in this case with exceptions added on a case-by-case basis.</li>
</ul>



<a name="240417551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240417551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240417551">(May 27 2021 at 03:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240386374">said</a>:</p>
<blockquote>
<ul>
<li>Definitions can be arbitrarily stacked, so it can be unobvious and sometimes even surprising to discover that something, <em>ultimately</em>, boils down to a function to Type/Prop.</li>
</ul>
</blockquote>
<p>Can you please clarify why this wouldn't be compositional? Why couldn't you just look at the capitalization of the syntactic return type?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Foo0</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="mi">3</span>
<span class="kd">def</span> <span class="n">Foo1</span> <span class="o">:</span> <span class="n">Foo0</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="kt">Type</span> <span class="mi">2</span>
<span class="kd">def</span> <span class="n">Foo2</span> <span class="o">:</span> <span class="n">Foo1</span> <span class="mi">0</span>   <span class="o">:=</span> <span class="kt">Type</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">Foo3</span> <span class="o">:</span> <span class="n">Foo2</span>     <span class="o">:=</span> <span class="kt">Type</span>
</code></pre></div>



<a name="240418302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240418302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240418302">(May 27 2021 at 03:59)</a>:</h4>
<p><code>Foo2</code> is capitalized the same as <code>Nat</code> but <code>def foo3 : Nat</code> and <code>def Foo3 : Foo2</code> have different capitalization</p>



<a name="240418393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240418393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240418393">(May 27 2021 at 04:01)</a>:</h4>
<p>To determine how <code>Foo3</code> needs to be capitalized you have to look at the definition (value) of <code>Foo2</code> and unfold everything there (your example is just <code>Type 1</code> so no additional unfolding is necessary)</p>



<a name="240418516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240418516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240418516">(May 27 2021 at 04:04)</a>:</h4>
<p>A bad case would be something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Foo0</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">def</span> <span class="n">Foo1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">Foo0</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">Foo2</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">Foo1</span> <span class="bp">-&gt;</span> <span class="n">Foo1</span>
<span class="kd">def</span> <span class="n">Bar</span> <span class="o">:</span> <span class="n">Foo2</span> <span class="o">:=</span> <span class="n">id</span>
</code></pre></div>
<p>to determine that <code>Bar</code> should be capitalized you need to look at the definition of <code>Foo0</code>, <code>Foo1</code> and <code>Foo2</code>, and none of the capitalization there helps</p>



<a name="240418596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240418596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240418596">(May 27 2021 at 04:06)</a>:</h4>
<p>Whoops, I confused myself. Thanks for clarifying. In that case I agree with the syntax + slippery-slope proposal. I will summarize it on the GitHub issue.</p>



<a name="240446334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240446334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240446334">(May 27 2021 at 10:34)</a>:</h4>
<p>Question: If we are proposing to capitalize any identifier that is syntactically in <code>Sort u</code> or <code>Type u</code>, wouldn't it make sense for <a href="https://leanprover.github.io/lean4/doc/autobound.html">auto bound implicit arguments</a> to auto bind single <strong>upper case</strong> letters as <code>Sort u</code>/<code>Type u</code> rather than single <strong>lower case</strong> letters (as having a lower case identifier syntactically in <code>Sort u</code>/<code>Type u</code> violates this style guide)?</p>



<a name="240446789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240446789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240446789">(May 27 2021 at 10:39)</a>:</h4>
<p>This RFC is about naming declarations. I haven't seen any proposals for changing our parameter naming scheme, which is to always use lowercase names, mostly Greek ones for type parameters.</p>



<a name="240447153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240447153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240447153">(May 27 2021 at 10:43)</a>:</h4>
<p>It's not exactly what we do in mathlib, where our style guide contains: "α, β, γ, ... for generic types. Types with a mathematical content are expressed with the usual mathematical notation, often with an upper case letter (G for a group, R for a ring, K or 𝕜 for a field, E for a vector space, ...)". </p>
<p>But it's arguably a mathlib thing, so none of the concern of core.</p>



<a name="240447235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240447235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240447235">(May 27 2021 at 10:44)</a>:</h4>
<p>It just seems a little odd to me to auto bind lower case ASCII letters as <code>Type u</code>/<code>Sort u</code> when every other instance of (syntactic) <code>Type u</code>/<code>Sort u</code> is going to be upper case (or a greek letter / unicode identifier).</p>



<a name="240447281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240447281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240447281">(May 27 2021 at 10:45)</a>:</h4>
<p>It feels inconsistent and symmetry breaking.</p>



<a name="240447626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240447626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240447626">(May 27 2021 at 10:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240447153">said</a>:</p>
<blockquote>
<p>But it's arguably a mathlib thing, so none of the concern of core.</p>
</blockquote>
<p>It is, insofar as <code>isValidAutoBoundImplicitName</code> cannot be overriden and rejects <code>K</code> as a valid name.</p>



<a name="240542438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240542438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240542438">(May 27 2021 at 23:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240447235">said</a>:</p>
<blockquote>
<p>It just seems a little odd to me to auto bind lower case ASCII letters as <code>Type u</code>/<code>Sort u</code> when every other instance of (syntactic) <code>Type u</code>/<code>Sort u</code> is going to be upper case (or a greek letter / unicode identifier).</p>
</blockquote>
<p>FWIW Haskell / ML also have this split: Type parameters are lowercase letters but types and type constructors are uppercase camel-case, as in <a href="https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Sequence.html"><code>Seq a</code></a> or <a href="https://ocaml.org/api/Seq.html"><code>'a Seq.t</code></a></p>



<a name="240551032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240551032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240551032">(May 28 2021 at 01:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240542438">said</a>:</p>
<blockquote>
<p>FWIW Haskell / ML also have this split: Type parameters are lowercase letters but types and type constructors are uppercase camel-case, as in <a href="https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Sequence.html"><code>Seq a</code></a> or <a href="https://ocaml.org/api/Seq.html"><code>'a Seq.t</code></a></p>
</blockquote>
<p>Yes, but, in Haskell, there is a split between the type and term namespaces. Type and term variables cannot clash or overshadow one another, making such usage more natural. As a result, one can (and many times does) have type specifications like <code>k :: k</code> (ala <code>k : k</code> in Lean), which is not possible in a dependently typed language like Lean.</p>



<a name="240551251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/240551251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#240551251">(May 28 2021 at 01:13)</a>:</h4>
<p>In fact, Haskell makes heavy use of this split in its <code>DataKinds</code> extension, where every term constructor <code>Foo</code> (in the term namespace) gets an automatically promoted type constructor also named <code>Foo</code> (in the type namespace).</p>



<a name="241511513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/241511513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#241511513">(Jun 04 2021 at 09:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240161960">said</a>:</p>
<blockquote>
<p>For efficiency and indexing reasons we might want to instead use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Bool.asProp</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">asProp</span> <span class="n">true</span>
</code></pre></div>
<p>but that would really be an implementation detail.</p>
</blockquote>
<p>Is there a reason why it is not currently implemented this way? My impression is that this coercion would be easier to use than <code>= true</code>, in general.</p>



<a name="241513631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/241513631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#241513631">(Jun 04 2021 at 09:58)</a>:</h4>
<p>We have a lot of tools for dealing with equality, and this inductive type is the same as what you would get by inlining the definition of <code>Eq true</code> as an inductive type, so I'm not sure there is much to be gained except maybe some visual brevity (which we can also address by using unexpanders)</p>



<a name="241513853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/rfc%3A%20theorem%20names/near/241513853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/rfc.3A.20theorem.20names.html#241513853">(Jun 04 2021 at 10:00)</a>:</h4>
<p>in particular, the main ways to interact with this would be to prove it when it's true via <code>⟨⟩</code> and eliminate it when it's false via <code>nomatch h</code> and that would work with either representation (and Eq also has another compact spelling for the first case, <code>rfl</code>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html">⊗ notation for types and elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="321310728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321310728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321310728">(Jan 14 2023 at 07:38)</a>:</h4>
<p>What would be a good way to define tensor product notation that would allow for <code>x ⊗ y</code> for a tensor product between two elements and <code>X ⊗ Y</code> for a tensor product between two vector spaces?</p>



<a name="321310851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321310851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321310851">(Jan 14 2023 at 07:39)</a>:</h4>
<p>Approach 1 - using <code>infix</code> notation</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Inhabited</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">opaque</span> <span class="n">TensorProduct</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">@[instance]</span>
<span class="kd">axiom</span> <span class="n">TensorProduct.instVec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="n">opaque</span> <span class="n">TensorProduct.tprod</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="c1">-- × has priority 35, we want X × Y ⊗ Z to bracket as X × (Y ⊗ Z)</span>
<span class="kd">infixr</span><span class="o">:</span><span class="mi">36</span> <span class="s2">" ⊗ "</span> <span class="bp">=&gt;</span> <span class="n">TensorProduct</span>

<span class="c1">-- * has priority 70, we want c * x ⊗ y to bracket as c * (x ⊗ y)</span>
<span class="kd">infixr</span><span class="o">:</span><span class="mi">71</span> <span class="s2">" ⊗ "</span> <span class="bp">=&gt;</span> <span class="n">TensorProduct.tprod</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">x</span> <span class="bp">⊗</span> <span class="n">y</span>
<span class="k">#check</span> <span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span> <span class="c1">-- error: ambiguous, possible interpretations</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
</code></pre></div>
<p>This has problem that pure <code>X ⊗ Y</code> causes ambiguity. It would probably cause problems all over the place.</p>



<a name="321311074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321311074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321311074">(Jan 14 2023 at 07:42)</a>:</h4>
<p>Approach 2 - using <code>elab</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">class</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Inhabited</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">opaque</span> <span class="n">TensorProduct</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">@[instance]</span>
<span class="kd">axiom</span> <span class="n">TensorProduct.instVec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="n">opaque</span> <span class="n">TensorProduct.tprod</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Term</span> <span class="n">Meta</span> <span class="k">in</span>
<span class="n">elab</span> <span class="n">x</span><span class="o">:</span><span class="n">term</span> <span class="s2">"⊗"</span> <span class="n">y</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">xval</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">x</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">yval</span> <span class="bp">←</span> <span class="n">elabTerm</span> <span class="n">y</span> <span class="n">none</span>
  <span class="k">let</span> <span class="n">val</span> <span class="bp">←</span> <span class="n">mkAppOptM</span> <span class="bp">`</span><span class="n">TensorProduct</span> <span class="bp">#</span><span class="o">[</span><span class="n">xval</span><span class="o">,</span><span class="n">yval</span><span class="o">,</span><span class="n">none</span><span class="o">,</span><span class="n">none</span><span class="o">]</span> <span class="bp">&lt;|&gt;</span> <span class="n">mkAppM</span> <span class="bp">`</span><span class="n">TensorProduct.tprod</span> <span class="bp">#</span><span class="o">[</span><span class="n">xval</span><span class="o">,</span><span class="n">yval</span><span class="o">]</span>
  <span class="n">pure</span> <span class="n">val</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">x</span> <span class="bp">⊗</span> <span class="n">y</span>
<span class="k">#check</span> <span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span>
</code></pre></div>
<p>Is there a way to have priority of 71 for <code>x ⊗ y</code> and priority 36 for <code>X ⊗ Y</code>? I expect that it is not possible, because at the moment of parsing you do not know if you do product between elements or types.</p>



<a name="321311211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321311211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321311211">(Jan 14 2023 at 07:44)</a>:</h4>
<p>Approach 3 - attempt at using class <code>OTimes</code> similar to <code>HAdd</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Inhabited</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">opaque</span> <span class="n">TensorProduct</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">@[instance]</span>
<span class="kd">axiom</span> <span class="n">TensorProduct.instVec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="n">opaque</span> <span class="n">TensorProduct.tprod</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">class</span> <span class="n">OTimes</span>  <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">otimes</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>

<span class="kd">infixr</span><span class="o">:</span><span class="mi">71</span> <span class="s2">" ⊗ "</span> <span class="bp">=&gt;</span> <span class="n">OTimes.otimes</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">OTimes</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="n">otimes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">X</span> <span class="o">:=</span> <span class="gr">sorry</span>  <span class="c1">-- hack</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Y</span> <span class="o">:=</span> <span class="gr">sorry</span>  <span class="c1">-- hack</span>
    <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">noncomputable</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">OTimes</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">(</span><span class="n">X</span><span class="bp">⊗</span><span class="n">Y</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">otimes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">TensorProduct.tprod</span> <span class="n">x</span> <span class="n">y</span>  <span class="c1">-- mismatch</span>
</code></pre></div>
<p>This seems to fail on many levels and I have no clue how to remedy it.</p>



<a name="321312494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321312494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321312494">(Jan 14 2023 at 08:01)</a>:</h4>
<p>I would claim that this is a bad idea for the same reason that unifying <code>A × B</code> and <code>(a, b)</code> is a bad idea</p>



<a name="321312706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321312706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321312706">(Jan 14 2023 at 08:03)</a>:</h4>
<p>But why is it a bad idea? On paper people do it all the time. At least for <code>⊗</code> not for <code>×</code>.</p>



<a name="321312827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321312827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321312827">(Jan 14 2023 at 08:05)</a>:</h4>
<p>On paper parsing can rely on the variable name. Lower case letters are values and upper case letters are types. But telling a computer to rely on that is a bad idea (I'm talking about you, Haskell).</p>



<a name="321312868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321312868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321312868">(Jan 14 2023 at 08:05)</a>:</h4>
<p>And Haskell uses (a,b) for both tuples and the product type.</p>



<a name="321312875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321312875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321312875">(Jan 14 2023 at 08:05)</a>:</h4>
<p>For <code>×</code> you might get into a trouble that you do not know if <code>A × B</code> means <code>A × B : Type</code> or <code>A × B : Type × Type</code>, this can't happen for <code>⊗</code> as <code>Type ⊗ Type</code> does not make sense.</p>



<a name="321312985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321312985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321312985">(Jan 14 2023 at 08:06)</a>:</h4>
<p>If you define <code>[Vec Type]</code> it would, right? Not saying that it is a good thing to do though</p>



<a name="321313159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321313159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321313159">(Jan 14 2023 at 08:08)</a>:</h4>
<p>Can you actually define <code>[Vec Type]</code>? As I mentioned, on paper <code>x ⊗ y</code> and <code>X ⊗ Y</code> are both used and I never got confused by it, so I do not see why a computer should get confused by it.</p>



<a name="321313169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321313169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321313169">(Jan 14 2023 at 08:08)</a>:</h4>
<p>So parsing would have to rely on what typeclass there is in the context? That's a really courageous decision. I think there is a miraculous chance that you can make everything work out, but pragmatically it causes trouble.</p>



<a name="321313265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321313265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321313265">(Jan 14 2023 at 08:10)</a>:</h4>
<blockquote>
<p>So parsing would have to rely on what typeclass there is in the context?</p>
</blockquote>
<p>Is that the case in approach 1 &amp; 2? I do not see that.</p>



<a name="321313326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321313326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321313326">(Jan 14 2023 at 08:10)</a>:</h4>
<p>The case where I can see this being problematic is where <code>x</code> has a <code>CoeSort</code> instance associated with it</p>



<a name="321313409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321313409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321313409">(Jan 14 2023 at 08:11)</a>:</h4>
<p>Admittedly I can't think of any case where such an <code>x</code> is also a vector space, but the <code>CoeSort</code> is enough to get annoying error messages when Lean guesses wrong</p>



<a name="321317327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321317327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321317327">(Jan 14 2023 at 08:50)</a>:</h4>
<p>Isn't this sort of the same as <code> α × β</code> vs <code>s ×ˢ t</code>? The latter certainly could be <code>s × t</code>, even considering <code>CoeSort</code></p>



<a name="321318263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321318263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321318263">(Jan 14 2023 at 09:00)</a>:</h4>
<p>The fact that this is commonplace in the human literature and that lean can't do it is pretty depressing</p>



<a name="321318835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321318835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321318835">(Jan 14 2023 at 09:05)</a>:</h4>
<p>I don't think this sort of thing is impossible to do in lean 4 with enough elbow grease. I think it's not advisable though</p>



<a name="321319020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321319020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321319020">(Jan 14 2023 at 09:07)</a>:</h4>
<p>you already get a decent approximation out of the box using overloaded notation, you just have to make sure that the vector space assumptions or whatever aren't available on <code>Type</code></p>



<a name="321323378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321323378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321323378">(Jan 14 2023 at 09:42)</a>:</h4>
<p>I will keep using the approach 2 and let's see what kind of problems I get myself into.</p>



<a name="321333966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321333966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321333966">(Jan 14 2023 at 10:59)</a>:</h4>
<p>I think the amount of work required to make it work well should be enough to fill a master thesis.</p>



<a name="321348005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321348005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321348005">(Jan 14 2023 at 12:22)</a>:</h4>
<p>Coq already has something like this</p>



<a name="321348253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321348253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321348253">(Jan 14 2023 at 12:24)</a>:</h4>
<p>I forget exactly how it works, but you can define notation that only applies when Coq is expecting a certain type of thing</p>



<a name="321348280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321348280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321348280">(Jan 14 2023 at 12:24)</a>:</h4>
<p>I think it's vaguely similar to Lean 4's syntactic categories</p>



<a name="321349402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321349402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321349402">(Jan 14 2023 at 12:32)</a>:</h4>
<p><a href="https://coq.inria.fr/refman/user-extensions/syntax-extensions.html#notation-scopes">https://coq.inria.fr/refman/user-extensions/syntax-extensions.html#notation-scopes</a></p>



<a name="321349448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321349448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321349448">(Jan 14 2023 at 12:32)</a>:</h4>
<p>I've seen it used to write e.g. <code>C -&gt; D</code> for functors from <code>C</code> to <code>D</code></p>



<a name="321353466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321353466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321353466">(Jan 14 2023 at 13:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404479">Trebor Huang</span> <a href="#narrow/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements/near/321333966">said</a>:</p>
<blockquote>
<p>I think the amount of work required to make it work well should be enough to fill a master thesis.</p>
</blockquote>
<p>Do you have an example where my second approach fails? I'm having a hard time seeing why is the problem so hard.</p>



<a name="321356216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321356216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321356216">(Jan 14 2023 at 13:23)</a>:</h4>
<p>A very simple example is when you are talking about monoidal structure on 2-categories.</p>



<a name="321356289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321356289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321356289">(Jan 14 2023 at 13:23)</a>:</h4>
<p>Of course you can just say we're not gonna use the tensor notation there. But similarly we can just avoid using tensor notation on elements here.</p>



<a name="321358639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321358639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321358639">(Jan 14 2023 at 13:41)</a>:</h4>
<p>Here's a version that mixes aspects of methods 2 and 3 to avoid inserting a typeclass function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">class</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Inhabited</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">opaque</span> <span class="n">TensorProduct</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">axiom</span> <span class="n">TensorProduct.tprod</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">class</span> <span class="n">OTimes</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">w</span><span class="o">)}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">outParam</span> <span class="n">γ</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Term</span> <span class="n">Meta</span> <span class="k">in</span>
<span class="n">elab</span> <span class="n">x</span><span class="o">:</span><span class="n">term</span> <span class="s2">"⊗"</span> <span class="n">y</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">withFreshMacroScope</span> <span class="k">do</span>
  <span class="n">_</span> <span class="bp">←</span> <span class="n">synthInstance</span> <span class="o">(</span><span class="bp">←</span> <span class="n">elabType</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="n">OTimes</span> <span class="bp">$</span><span class="n">x</span> <span class="bp">$</span><span class="n">y</span> <span class="bp">?</span><span class="n">m</span><span class="o">)))</span>
  <span class="n">elabTerm</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="bp">?</span><span class="n">m</span><span class="o">))</span> <span class="n">none</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">OTimes</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">(</span><span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">OTimes</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">TensorProduct.tprod</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span> <span class="c1">-- TensorProduct X Y : Type</span>
<span class="k">#check</span> <span class="n">x</span> <span class="bp">⊗</span> <span class="n">y</span> <span class="c1">-- TensorProduct.tprod x y : TensorProduct X Y</span>
</code></pre></div>



<a name="321379948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321379948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321379948">(Jan 14 2023 at 16:17)</a>:</h4>
<p>OOC, is there a reason not to do something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Inhabited</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">opaque</span> <span class="n">TensorProduct</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">@[instance]</span>
<span class="kd">axiom</span> <span class="n">TensorProduct.instVec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="n">opaque</span> <span class="n">TensorProduct.tprod</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">class</span> <span class="n">OTimes</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Sort</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">otimes</span> <span class="o">:</span> <span class="n">γ</span>

<span class="kd">infixr</span><span class="o">:</span><span class="mi">71</span> <span class="s2">" ⊗ "</span> <span class="bp">=&gt;</span> <span class="n">OTimes.otimes</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">OTimes</span> <span class="n">X</span> <span class="n">Y</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="n">otimes</span> <span class="o">:=</span> <span class="n">TensorProduct</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">noncomputable</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">OTimes</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">X</span><span class="bp">⊗</span><span class="n">Y</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">otimes</span> <span class="o">:=</span> <span class="n">TensorProduct.tprod</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">Vec</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span> <span class="c1">-- TensorProduct X Y : Type</span>
<span class="k">#check</span> <span class="n">x</span> <span class="bp">⊗</span> <span class="n">y</span> <span class="c1">-- TensorProduct.tprod x y : TensorProduct X Y</span>
</code></pre></div>



<a name="321385279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321385279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321385279">(Jan 14 2023 at 16:58)</a>:</h4>
<p>well your gloss on the <code>#check</code>s aren't quite correct, it actually says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span> <span class="c1">-- X ⊗ Y : Type</span>
<span class="k">#check</span> <span class="n">x</span> <span class="bp">⊗</span> <span class="n">y</span> <span class="c1">-- x ⊗ y : X ⊗ Y</span>
</code></pre></div>
<p>and if we turn off notation that is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span> <span class="c1">-- OTimes.otimes X Y : Type</span>
<span class="k">#check</span> <span class="n">x</span> <span class="bp">⊗</span> <span class="n">y</span> <span class="c1">-- OTimes.otimes x y : OTimes.otimes X Y</span>
</code></pre></div>



<a name="321385479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321385479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321385479">(Jan 14 2023 at 17:00)</a>:</h4>
<p>so the difference is that your version introduces an <code>otimes</code> function, while mine leaves no trace of the otimes machinery and unfolds directly to <code>TensorProduct</code> or <code>TensorProduct.tprod</code>, kind of like how coercion works</p>



<a name="321385802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321385802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321385802">(Jan 14 2023 at 17:02)</a>:</h4>
<p>right, so it's awkward to retrofit a new notation type class onto the existing tensor product API</p>



<a name="321386110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321386110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321386110">(Jan 14 2023 at 17:05)</a>:</h4>
<p>hm. so even though it is definitionally equal to to the TensorProduct/tprod, you'd have to go back and use the otimes notation in the API so that everything has a nice simp-normal form? or is there a different concern with the notation class</p>



<a name="321402949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%8A%97%20notation%20for%20types%20and%20elements/near/321402949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements.html#321402949">(Jan 14 2023 at 19:50)</a>:</h4>
<p>Yes, or just to rewrite with existing lemmas</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
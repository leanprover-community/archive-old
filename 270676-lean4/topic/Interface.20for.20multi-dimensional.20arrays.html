---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html">Interface for multi-dimensional arrays</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262868108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262868108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262868108">(Nov 27 2021 at 11:16)</a>:</h4>
<p>I wanted to experiment with interface for multi-dimensional arrays. My main goal was to write down some basic formulas with the least amount of boilerplate as possible. I think, I have achieved a pretty good result, some basic linear algebra stuff:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span>       <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">col</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">V1</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">row</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">V1</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">trace</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">‚Ñù</span>            <span class="o">:=</span> <span class="bp">‚àë</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
</code></pre></div>
<p>where <code>Vn</code> is a tensor of rank <code>n</code>(in this example every index has dimension 4) and <code>cmk</code> turns lambda into a tensor <code>Vn</code>. More complicated examples from <a href="https://en.wikipedia.org/wiki/List_of_formulas_in_Riemannian_geometry">general relativity</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="bp">Œì‚ÇÅ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V3</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">c</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">]</span> <span class="bp">+</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">c</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">a</span><span class="o">]</span> <span class="bp">-</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span>
<span class="kd">def</span> <span class="bp">Œì‚ÇÇ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V3</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">k</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">l</span><span class="o">,</span> <span class="n">g</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">l</span><span class="o">]</span><span class="bp">*</span><span class="o">(</span><span class="bp">Œì‚ÇÅ</span> <span class="n">g</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">R</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V4</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="bp">Œì</span> <span class="o">:</span> <span class="n">V3</span> <span class="o">:=</span> <span class="bp">Œì‚ÇÇ</span> <span class="n">g</span>
                                        <span class="o">(</span><span class="n">D‚ÇÉ</span> <span class="bp">Œì</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]</span> <span class="bp">+</span> <span class="o">(</span><span class="n">D‚ÇÉ</span> <span class="bp">Œì</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">i</span><span class="o">]</span> <span class="bp">+</span> <span class="bp">‚àë</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="bp">Œì</span><span class="o">[</span><span class="n">p</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">l</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">p</span><span class="o">]</span> <span class="bp">-</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">p</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">-</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">p</span><span class="o">])</span>
<span class="kd">def</span> <span class="bp">ùì°</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">SR</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="bp">‚àë</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">ùì°</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">G</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">ùì°</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">-</span> <span class="o">(</span><span class="n">SR</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span>
</code></pre></div>
<p>At heart of this is <code>NDArray</code> class:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">dims</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span>  <span class="n">where</span>
  <span class="n">get</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">‚Üí</span> <span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span>
  <span class="n">emk</span> <span class="o">:</span> <span class="o">(</span><span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">A</span>
</code></pre></div>
<p>That provides an interface to get an element of type <code>T</code> from <code>(a : A)</code> provided a multi-dimensional index and conversely can create the array given an element wise function.</p>
<p>I went for interface like design because <code>A</code> can store the multi-dimensional array in different ways. Column vs row major matrices, in CPU vs GPU memory, sparse/diagonal/block matrices etc. and I would like to have a common interface to all of these.</p>
<p>I would be happy for any comments, suggestions or critique.</p>



<a name="262868113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262868113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262868113">(Nov 27 2021 at 11:16)</a>:</h4>
<p>The full code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">NDArray</span>

  <span class="kd">def</span> <span class="n">Index</span> <span class="o">(</span><span class="n">dims</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">dims.size</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">dims</span><span class="o">[</span><span class="n">d</span><span class="o">])</span>

<span class="kd">end</span> <span class="n">NDArray</span>

<span class="c1">--- Type A is a NDArray with densions dims and value type T</span>
<span class="kd">class</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">dims</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span>  <span class="n">where</span>
  <span class="n">get</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">‚Üí</span> <span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span>     <span class="c1">-- get and element</span>
  <span class="n">emk</span> <span class="o">:</span> <span class="o">(</span><span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">A</span>   <span class="c1">-- elementa wise make</span>

<span class="c1">--- Automatically infering T and dims based on A</span>
<span class="kd">class</span> <span class="n">NDArrayData</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
  <span class="n">dims</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span>

<span class="c1">-- Is this good idea?</span>
<span class="kd">@[reducible]</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">dims</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span><span class="o">]</span> <span class="o">:</span> <span class="n">NDArrayData</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="n">T</span><span class="o">,</span> <span class="n">dims</span><span class="o">‚ü©</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">,</span> <span class="n">inline</span><span class="o">]</span> <span class="n">NDArrayData.T</span> <span class="n">NDArrayData.dims</span>

<span class="kn">namespace</span> <span class="n">NDArray</span>

  <span class="kn">namespace</span> <span class="n">Index</span>

    <span class="kd">def</span> <span class="n">toIndex1</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>

    <span class="kd">def</span> <span class="n">toIndex2</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n2</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">1</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i2</span>

    <span class="kd">def</span> <span class="n">toIndex3</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n2</span><span class="o">)</span> <span class="o">(</span><span class="n">i3</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n3</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">1</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i2</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">2</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i3</span>

    <span class="kd">def</span> <span class="n">toIndex4</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n2</span><span class="o">)</span> <span class="o">(</span><span class="n">i3</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n3</span><span class="o">)</span> <span class="o">(</span><span class="n">i4</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n4</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">n4</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">1</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i2</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">2</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i3</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">3</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i4</span>

    <span class="c1">-- How to generalize?</span>

  <span class="kd">end</span> <span class="n">Index</span>

  <span class="kd">@[reducible]</span>
  <span class="n">abbrev</span> <span class="n">scalarOf</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">NDArrayData</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span> <span class="n">NDArrayData.T</span> <span class="n">A</span>

  <span class="kd">@[reducible]</span>
  <span class="n">abbrev</span> <span class="n">dimsOf</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">NDArrayData</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span> <span class="n">NDArrayData.dims</span> <span class="n">A</span>


  <span class="c1">-- This can be turned into one macro once we have general toIndex‚Çô</span>
  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">NDArray.get</span> <span class="n">_</span> <span class="o">(</span><span class="n">scalarOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">dimsOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex1</span> <span class="bp">$</span><span class="n">i1</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">NDArray.get</span> <span class="n">_</span> <span class="o">(</span><span class="n">scalarOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">dimsOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex2</span> <span class="bp">$</span><span class="n">i1</span> <span class="bp">$</span><span class="n">i2</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i3</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">NDArray.get</span> <span class="n">_</span> <span class="o">(</span><span class="n">scalarOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">dimsOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex3</span> <span class="bp">$</span><span class="n">i1</span> <span class="bp">$</span><span class="n">i2</span> <span class="bp">$</span><span class="n">i3</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i3</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i4</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">NDArray.get</span> <span class="n">_</span> <span class="o">(</span><span class="n">scalarOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">dimsOf</span> <span class="bp">$</span><span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex4</span> <span class="bp">$</span><span class="n">i1</span> <span class="bp">$</span><span class="n">i2</span> <span class="bp">$</span><span class="n">i3</span> <span class="bp">$</span><span class="n">i4</span><span class="o">))</span>


  <span class="c1">-- Make NDArray from an arbitrary type</span>
  <span class="c1">-- Mainly used to create an array from lambdas like (Œª i j k =&gt; f i j k)</span>
  <span class="kn">section</span> <span class="n">CustomMk</span>
    <span class="kd">class</span> <span class="n">CustomMk</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span> <span class="n">customMk</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">A</span>

    <span class="kd">variable</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">]]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="n">A</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">]]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="n">A</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n1</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n2</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                             <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">]]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="n">A</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n1</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n2</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n3</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                 <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                 <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">n4</span><span class="o">]]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="n">A</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n1</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n2</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n3</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n4</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">n4</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                     <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                     <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                     <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">3</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="c1">--- ... and so on ...</span>

    <span class="kd">def</span> <span class="n">cmk</span> <span class="o">[</span><span class="n">CustomMk</span> <span class="n">A</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">CustomMk.customMk</span> <span class="n">a</span>

  <span class="kd">end</span> <span class="n">CustomMk</span>

<span class="kd">end</span> <span class="n">NDArray</span>


<span class="c1">-- Some auxiliary definitions</span>
<span class="kd">class</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">Œ±</span>

<span class="kd">instance</span> <span class="n">instOfNatZero</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">Œ±</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">0</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">Zero.zero</span>

<span class="kd">def</span> <span class="n">sum</span> <span class="o">{</span><span class="n">n</span> <span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span> <span class="bp">+</span> <span class="n">f</span> <span class="o">‚ü®</span><span class="n">i</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">‚ü©</span>
  <span class="n">r</span>

<span class="n">macro</span> <span class="s2">"‚àë"</span> <span class="n">xs</span><span class="o">:</span><span class="n">Lean.explicitBinders</span> <span class="s2">", "</span> <span class="n">b</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">Lean.expandExplicitBinders</span> <span class="bp">`</span><span class="n">sum</span> <span class="n">xs</span> <span class="n">b</span>

<span class="kn">section</span> <span class="n">Test</span>

    <span class="kn">open</span> <span class="n">NDArray</span>

    <span class="kd">constant</span> <span class="n">‚Ñù</span> <span class="o">:</span> <span class="kt">Type</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">Mul</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">Sub</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">Zero</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">constant</span> <span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span>
    <span class="kd">constant</span> <span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span>
    <span class="kd">constant</span> <span class="n">V3</span> <span class="o">:</span> <span class="kt">Type</span>
    <span class="kd">constant</span> <span class="n">V4</span> <span class="o">:</span> <span class="kt">Type</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">NDArray</span> <span class="n">V1</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">NDArray</span> <span class="n">V2</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">NDArray</span> <span class="n">V3</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="kd">instance</span> <span class="o">:</span> <span class="n">NDArray</span> <span class="n">V4</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="gr">sorry</span>

    <span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span>       <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">col</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">V1</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">row</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">V1</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">trace</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">‚Ñù</span>            <span class="o">:=</span> <span class="bp">‚àë</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">mul</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span>           <span class="o">:=</span> <span class="n">cmk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span><span class="bp">*</span><span class="n">B</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">])</span>

    <span class="kd">variable</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">V3</span><span class="o">]</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">V4</span><span class="o">]</span>
    <span class="kd">constant</span> <span class="n">D‚ÇÅ</span> <span class="o">:</span> <span class="n">V1</span> <span class="bp">‚Üí</span> <span class="n">V2</span>
    <span class="kd">constant</span> <span class="n">D‚ÇÇ</span> <span class="o">:</span> <span class="n">V2</span> <span class="bp">‚Üí</span> <span class="n">V3</span>
    <span class="kd">constant</span> <span class="n">D‚ÇÉ</span> <span class="o">:</span> <span class="n">V3</span> <span class="bp">‚Üí</span> <span class="n">V4</span>

    <span class="c1">-- General Relativity formulas</span>
    <span class="c1">-- https://en.wikipedia.org/wiki/List_of_formulas_in_Riemannian_geometry</span>

    <span class="kd">def</span> <span class="bp">Œì‚ÇÅ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V3</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">c</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">]</span> <span class="bp">+</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">c</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">a</span><span class="o">]</span> <span class="bp">-</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span>
    <span class="kd">def</span> <span class="bp">Œì‚ÇÇ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V3</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">k</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">l</span><span class="o">,</span> <span class="n">g</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">l</span><span class="o">]</span><span class="bp">*</span><span class="o">(</span><span class="bp">Œì‚ÇÅ</span> <span class="n">g</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">R</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V4</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="bp">Œì</span> <span class="o">:</span> <span class="n">V3</span> <span class="o">:=</span> <span class="bp">Œì‚ÇÇ</span> <span class="n">g</span>
                                            <span class="o">(</span><span class="n">D‚ÇÉ</span> <span class="bp">Œì</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]</span> <span class="bp">+</span> <span class="o">(</span><span class="n">D‚ÇÉ</span> <span class="bp">Œì</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">i</span><span class="o">]</span> <span class="bp">+</span> <span class="bp">‚àë</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="bp">Œì</span><span class="o">[</span><span class="n">p</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">l</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">p</span><span class="o">]</span> <span class="bp">-</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">p</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">-</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">p</span><span class="o">])</span>
    <span class="kd">def</span> <span class="bp">ùì°</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">SR</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="bp">‚àë</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">ùì°</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">G</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">ùì°</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">-</span> <span class="o">(</span><span class="n">SR</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span>

<span class="kd">end</span> <span class="n">Test</span>
</code></pre></div>



<a name="262868196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262868196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262868196">(Nov 27 2021 at 11:19)</a>:</h4>
<p>One concrete question is how to merge function <code>toIndex‚Çô</code> with macros defining notation <code>A[i,j,k]</code>? Right, now I have to write separate function and macro for each <code>A[i]</code>, <code>A[i,j]</code>, <code>A[i,j,k]</code>, ... Not a big deal, but it would be be nice to have one code handling any rank.</p>



<a name="262868200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262868200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262868200">(Nov 27 2021 at 11:19)</a>:</h4>
<p>The thing I do not like is that <code>cmk</code> needs to know the output type. For example this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
</code></pre></div>
<p>but this does not</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
</code></pre></div>
<p>As it is currently done, <code>cmk</code> needs to know the storage type for the output e.g. <code>V2</code>. In practice, this could be row major matrix or column major matrix or something completely different. Not sure what to do about it.</p>



<a name="262868844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262868844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262868844">(Nov 27 2021 at 11:39)</a>:</h4>
<p>Also all those tests break when <code>Vn</code> are declared with <code>variable</code> and not with <code>constant</code>. Not yet sure what is going on there.</p>



<a name="262886538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262886538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262886538">(Nov 27 2021 at 18:28)</a>:</h4>
<p>I have modified the definition of <code>NDArray</code> to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">‚Üí</span> <span class="n">Array</span> <span class="n">Nat</span> <span class="bp">‚Üí</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">get</span> <span class="o">{</span><span class="n">T</span> <span class="n">dims</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span>
  <span class="n">emk</span> <span class="o">{</span><span class="n">T</span> <span class="n">dims</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span>
</code></pre></div>
<p>and the code is a bit cleaner.</p>



<a name="262886540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262886540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262886540">(Nov 27 2021 at 18:29)</a>:</h4>
<p>Full code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Some auxiliary definitions</span>
<span class="kd">class</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">Œ±</span>

<span class="kd">instance</span> <span class="n">instOfNatZero</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">Œ±</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">0</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">Zero.zero</span>

<span class="kd">def</span> <span class="n">sum</span> <span class="o">{</span><span class="n">n</span> <span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span> <span class="bp">+</span> <span class="n">f</span> <span class="o">‚ü®</span><span class="n">i</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">‚ü©</span>
  <span class="n">r</span>

<span class="n">macro</span> <span class="s2">"‚àë"</span> <span class="n">xs</span><span class="o">:</span><span class="n">Lean.explicitBinders</span> <span class="s2">", "</span> <span class="n">b</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">Lean.expandExplicitBinders</span> <span class="bp">`</span><span class="n">sum</span> <span class="n">xs</span> <span class="n">b</span>

<span class="kn">namespace</span> <span class="n">NDArray</span>

  <span class="kd">def</span> <span class="n">Index</span> <span class="o">(</span><span class="n">dims</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">dims.size</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">dims</span><span class="o">[</span><span class="n">d</span><span class="o">])</span>

<span class="kd">end</span> <span class="n">NDArray</span>

<span class="c1">-- Do I want to have rank as explicit argument of `A` ??</span>
<span class="c1">--- Type A is a NDArray with densions dims and value type T</span>
<span class="kd">class</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">‚Üí</span> <span class="n">Array</span> <span class="n">Nat</span> <span class="bp">‚Üí</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">get</span> <span class="o">{</span><span class="n">T</span> <span class="n">dims</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span>
  <span class="n">emk</span> <span class="o">{</span><span class="n">T</span> <span class="n">dims</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">NDArray.Index</span> <span class="n">dims</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span>

<span class="kn">namespace</span> <span class="n">NDArray</span>

  <span class="kn">namespace</span> <span class="n">Index</span>
    <span class="kd">def</span> <span class="n">toIndex1</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>

    <span class="kd">def</span> <span class="n">toIndex2</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n2</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">1</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i2</span>

    <span class="kd">def</span> <span class="n">toIndex3</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n2</span><span class="o">)</span> <span class="o">(</span><span class="n">i3</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n3</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">1</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i2</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">2</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i3</span>

    <span class="kd">def</span> <span class="n">toIndex4</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n2</span><span class="o">)</span> <span class="o">(</span><span class="n">i3</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n3</span><span class="o">)</span> <span class="o">(</span><span class="n">i4</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n4</span><span class="o">)</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">n4</span><span class="o">]</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">0</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i1</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">1</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i2</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">2</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i3</span>
    <span class="bp">|</span> <span class="n">Fin.mk</span> <span class="mi">3</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">i4</span>

    <span class="c1">-- How to generalize?</span>

  <span class="kd">end</span> <span class="n">Index</span>

  <span class="c1">-- This can be turned into one macro once we have general toIndex‚Çô</span>
  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex1</span> <span class="bp">$</span><span class="n">i1</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex2</span> <span class="bp">$</span><span class="n">i1</span> <span class="bp">$</span><span class="n">i2</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i3</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex3</span> <span class="bp">$</span><span class="n">i1</span> <span class="bp">$</span><span class="n">i2</span> <span class="bp">$</span><span class="n">i3</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i3</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i4</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">a</span> <span class="o">(</span><span class="n">Index.toIndex4</span> <span class="bp">$</span><span class="n">i1</span> <span class="bp">$</span><span class="n">i2</span> <span class="bp">$</span><span class="n">i3</span> <span class="bp">$</span><span class="n">i4</span><span class="o">))</span>

  <span class="c1">-- Make NDArray from an arbitrary type</span>
  <span class="c1">-- Mainly used to create an array from lambdas like (Œª i j k =&gt; f i j k)</span>
  <span class="kn">section</span> <span class="n">CustomMk</span>
    <span class="kd">class</span> <span class="n">CustomMk</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">‚Üí</span> <span class="n">Array</span> <span class="n">Nat</span> <span class="bp">‚Üí</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span> <span class="n">dims</span><span class="o">)</span> <span class="n">where</span> <span class="n">customMk</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span>

    <span class="kd">variable</span> <span class="o">{</span><span class="n">A</span> <span class="n">T</span><span class="o">}</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n1</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n2</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span><span class="n">n2</span><span class="o">]</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                             <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n1</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n2</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n3</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span><span class="n">n2</span><span class="o">,</span><span class="n">n3</span><span class="o">]</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                 <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                 <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>
    <span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">CustomMk</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n1</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n2</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n3</span> <span class="bp">‚Üí</span> <span class="n">Fin</span> <span class="n">n4</span> <span class="bp">‚Üí</span> <span class="n">T</span><span class="o">)</span> <span class="n">A</span> <span class="n">T</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span><span class="n">n2</span><span class="o">,</span><span class="n">n3</span><span class="o">,</span><span class="n">n4</span><span class="o">]</span> <span class="o">:=</span>
             <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">NDArray.emk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Index</span> <span class="bp">#</span><span class="o">[</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">,</span> <span class="n">n4</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                     <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                     <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©)</span>
                                                                     <span class="o">(</span><span class="n">i</span> <span class="o">‚ü®</span><span class="mi">3</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">Array.size</span><span class="o">,</span> <span class="n">List.length</span><span class="o">]</span> <span class="n">done</span><span class="o">‚ü©))‚ü©</span>

    <span class="c1">--- ... and so on ...</span>

    <span class="kd">def</span> <span class="n">cmk</span> <span class="o">{</span><span class="n">Œ±</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span><span class="o">}</span> <span class="o">[</span><span class="n">CustomMk</span> <span class="n">Œ±</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="n">T</span> <span class="n">dims</span> <span class="o">:=</span> <span class="n">CustomMk.customMk</span> <span class="n">a</span>

  <span class="kd">end</span> <span class="n">CustomMk</span>

<span class="kd">end</span> <span class="n">NDArray</span>

<span class="kn">section</span> <span class="n">Test</span>

    <span class="kn">open</span> <span class="n">NDArray</span>

    <span class="kd">variable</span> <span class="o">{</span><span class="n">‚Ñù</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Add</span> <span class="n">‚Ñù</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">‚Ñù</span><span class="o">]</span> <span class="o">[</span><span class="n">Sub</span> <span class="n">‚Ñù</span><span class="o">]</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">‚Ñù</span><span class="o">]</span>
    <span class="kd">variable</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">‚Üí</span> <span class="n">Array</span> <span class="n">Nat</span> <span class="bp">‚Üí</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">V</span><span class="o">]</span>

    <span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">])</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">m</span><span class="o">,</span><span class="n">n</span><span class="o">]</span>  <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">col</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">])</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">row</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">])</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">mul</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">])</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">m</span><span class="o">,</span><span class="n">k</span><span class="o">])</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">k</span><span class="o">,</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span><span class="bp">*</span><span class="n">B</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">])</span>

    <span class="kd">variable</span> <span class="o">[</span><span class="bp">‚àÄ</span> <span class="n">dims</span><span class="o">,</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">V</span> <span class="n">‚Ñù</span> <span class="n">dims</span><span class="o">)]</span>
    <span class="kd">constant</span> <span class="n">D‚ÇÇ</span> <span class="o">:</span> <span class="o">(</span><span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">])</span> <span class="bp">‚Üí</span> <span class="o">(</span><span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">,</span><span class="mi">4</span><span class="o">])</span>
    <span class="kd">constant</span> <span class="n">D‚ÇÉ</span> <span class="o">:</span> <span class="o">(</span><span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">,</span><span class="n">k</span><span class="o">])</span> <span class="bp">‚Üí</span> <span class="o">(</span><span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="mi">4</span><span class="o">])</span>

    <span class="c1">-- General Relativity formulas</span>
    <span class="c1">-- https://en.wikipedia.org/wiki/List_of_formulas_in_Riemannian_geometry</span>

    <span class="kd">variable</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">])</span>

    <span class="kd">def</span> <span class="bp">Œì‚ÇÅ</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">c</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">]</span> <span class="bp">+</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">c</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">a</span><span class="o">]</span> <span class="bp">-</span> <span class="o">(</span><span class="n">D‚ÇÇ</span> <span class="n">g</span><span class="o">)[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">]</span>
    <span class="kd">def</span> <span class="bp">Œì‚ÇÇ</span> <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">k</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">l</span><span class="o">,</span> <span class="n">g</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">l</span><span class="o">]</span><span class="bp">*</span><span class="o">(</span><span class="bp">Œì‚ÇÅ</span> <span class="n">g</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">R</span>  <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="bp">Œì</span> <span class="o">:=</span> <span class="bp">Œì‚ÇÇ</span> <span class="n">g</span>
                                            <span class="o">(</span><span class="n">D‚ÇÉ</span> <span class="bp">Œì</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]</span> <span class="bp">+</span> <span class="o">(</span><span class="n">D‚ÇÉ</span> <span class="bp">Œì</span><span class="o">)[</span><span class="n">l</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">i</span><span class="o">]</span> <span class="bp">+</span> <span class="bp">‚àë</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="bp">Œì</span><span class="o">[</span><span class="n">p</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">l</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">p</span><span class="o">]</span> <span class="bp">-</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">p</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">-</span> <span class="bp">Œì</span><span class="o">[</span><span class="n">l</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">p</span><span class="o">])</span>
    <span class="kd">def</span> <span class="bp">ùì°</span>  <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="bp">‚àë</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">SR</span> <span class="o">:</span> <span class="n">‚Ñù</span> <span class="o">:=</span> <span class="bp">‚àë</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">ùì°</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span>
    <span class="kd">def</span> <span class="n">G</span>  <span class="o">:</span> <span class="n">V</span> <span class="n">‚Ñù</span> <span class="bp">#</span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">cmk</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">ùì°</span> <span class="n">g</span><span class="o">)[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">-</span> <span class="o">(</span><span class="n">SR</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span>

<span class="kd">end</span> <span class="n">Test</span>
</code></pre></div>



<a name="262888309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262888309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262888309">(Nov 27 2021 at 19:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays/near/262868196">said</a>:</p>
<blockquote>
<p>One concrete question is how to merge function <code>toIndex‚Çô</code> with macros defining notation <code>A[i,j,k]</code>? Right, now I have to write separate function and macro for each <code>A[i]</code>, <code>A[i,j]</code>, <code>A[i,j,k]</code>, ... Not a big deal, but it would be be nice to have one code handling any rank.</p>
</blockquote>
<p>If you switched to <code>A(i,j,k)</code>, you probably could implement this using a <code>CoeFun</code> instance for coercing arrays into functions with a tuple argument.  You could also probably use <code>CoeFun</code> to make <code>A i j k</code> work.</p>



<a name="262888540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262888540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262888540">(Nov 27 2021 at 19:19)</a>:</h4>
<p>You might also take a look at <a href="https://github.com/google-research/dex-lang">Dex</a>, which has some interesting ideas. It has multidimensional array types using a function-like arrow <code>v : n=&gt;m=&gt;(Fin 2)=&gt;Float</code>, and rather than limiting arrays to being indexed by elements of <code>Fin _</code>, they can be indexed by any finite enumerable type (that's what <code>n</code> and <code>m</code> are there).  So, in this example, that type is for arrays that are basically indexed by <code>n √ó m √ó Fin 2</code>.  To index into an array, you don't use the usual function application notation, but rather <code>v.i.j.k</code></p>



<a name="262888787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262888787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262888787">(Nov 27 2021 at 19:25)</a>:</h4>
<p>I see how to make <code>A i j k</code> work with <code>CoeFun</code> but I do not see how to make generic <code>A(i,j,k)</code>, assuming that here <code>A</code> is turned to <code>Fin n √ó Fin m √ó Fin k -&gt; R</code>.</p>



<a name="262888862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262888862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262888862">(Nov 27 2021 at 19:27)</a>:</h4>
<p>Thanks for the reference to Dex, I haven't heard of it and will have a look.</p>



<a name="262888913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262888913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262888913">(Nov 27 2021 at 19:28)</a>:</h4>
<p>For the having-multiple-storage-types problem, something that seems useful is being able to defer storage -- if you do <code>A + B + C</code>, ideally there'd be one outer loop that loads corresponding elements of the three arrays and adds them, rather than computing <code>A + B</code>, storing that, then adding <code>C</code>.  One way to do this is to treat all arrays as being functions that never store anything.  For example, you might implement transpose like this, where <code>V2</code> is just <code>Fin 4 -&gt; Fin 4 -&gt; R</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span> <span class="n">j</span> <span class="n">i</span>
</code></pre></div>
<p>and then when you want to actually save an intermediate result, you can use a function like <code>dense : V2 -&gt; V2</code> that saves intermediate results in some underlying <code>Array</code> and immediately turns it back into a function (thus memoizing results).  There's potential for accidental bad performance, though, if you forget to memoize results in key places.  For that, it might be good to have some type like <code>dV2</code> for a specifically dense vectors, and some coercions between <code>V2</code> and <code>dV2</code>.  Then you could write, for example,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">dV2</span> <span class="o">:=</span> <span class="n">transpose</span> <span class="n">a</span>
</code></pre></div>



<a name="262888916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262888916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262888916">(Nov 27 2021 at 19:29)</a>:</h4>
<p>Currently I'm restricting myself to <code>Fin n</code> because Lean 4 does not have <code>fintype</code> and right now I have different priorities then that.</p>



<a name="262889062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889062">(Nov 27 2021 at 19:32)</a>:</h4>
<p>The reason you might do this is for typechecking reasons, since it helps prevent you using indexes in the wrong spots when you write more generic functions.  You also probably wouldn't want <code>Fintype</code> anyway, but rather a type with a specific equivalence to <code>Fin n</code>.  I understand it not being high priority, though.</p>



<a name="262889125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889125">(Nov 27 2021 at 19:34)</a>:</h4>
<blockquote>
<p>I understand it not being high priority, though.</p>
</blockquote>
<p>I'm sure that someone else will do it for mathlib4 :) So I will just wait and get my part of the code ready.</p>



<a name="262889222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889222">(Nov 27 2021 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays/near/262888913">said</a>:</p>
<blockquote>
<p>For the having-multiple-storage-types problem, something that seems useful is being able to defer storage -- if you do <code>A + B + C</code>, ideally there'd be one outer loop that loads corresponding elements of the three arrays and adds them, rather than computing <code>A + B</code>, storing that, then adding <code>C</code>.  One way to do this is to treat all arrays as being functions that never store anything.  For example, you might implement transpose like this, where <code>V2</code> is just <code>Fin 4 -&gt; Fin 4 -&gt; R</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">V2</span><span class="o">)</span> <span class="o">:</span> <span class="n">V2</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">A</span> <span class="n">j</span> <span class="n">i</span>
</code></pre></div>
<p>and then when you want to actually save an intermediate result, you can use a function like <code>dense : V2 -&gt; V2</code> that saves intermediate results in some underlying <code>Array</code> and immediately turns it back into a function (thus memoizing results).  There's potential for accidental bad performance, though, if you forget to memoize results in key places.  For that, it might be good to have some type like <code>dV2</code> for a specifically dense vectors, and some coercions between <code>V2</code> and <code>dV2</code>.  Then you could write, for example,</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">b</span> <span class="o">:</span> <span class="n">dV2</span> <span class="o">:=</span> <span class="n">transpose</span> <span class="n">a</span>
</code></pre></div><br>
</p>
</blockquote>
<p>My idea to this problem is to take similar approach as <a href="https://halide-lang.org/">Halide</a> where you write the code in the most straight forward way and only then you decide how it should be evaluated.</p>
<p>I believe tactic mode can be used for that. Write the the code in a very simple way first and then apply bunch of <code>rw</code> tactics, or more specialized ones, to transform it into a faster implementation. The advantage is that you have a guarantee the code is doing what you indented.</p>



<a name="262889223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889223">(Nov 27 2021 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays/near/262888787">said</a>:</p>
<blockquote>
<p>I see how to make <code>A i j k</code> work with <code>CoeFun</code> but I do not see how to make generic <code>A(i,j,k)</code>, assuming that here <code>A</code> is turned to <code>Fin n √ó Fin m √ó Fin k -&gt; R</code>.</p>
</blockquote>
<p>Part of it would be making a function that converts <code>Array Nat</code> into a cartesian product of types, which I guess could actually replace your <code>Index</code> function, so then the implementation of <code>CoeFun</code> would be <code>NDArray.get</code>.</p>



<a name="262889282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889282">(Nov 27 2021 at 19:38)</a>:</h4>
<blockquote>
<p>Part of it would be making a function that converts Array Nat into a cartesian product of types </p>
</blockquote>
<p>That is the problem, I have no clue how to do that.</p>



<a name="262889461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889461">(Nov 27 2021 at 19:42)</a>:</h4>
<p>Here's some code from an experiment from a while back.  I don't know if it works (it's old, and I copy-pasted the relevant parts), but it has the equivalence stuff I was talking about.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Function.leftInverse</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Œ≤</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="bp">‚àÄ</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">Function.rightInverse</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Œ≤</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">Function.leftInverse</span> <span class="n">f</span> <span class="n">g</span>

<span class="kd">structure</span> <span class="n">Equiv</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ≤</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">toFun</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span>
    <span class="n">invFun</span> <span class="o">:</span> <span class="n">Œ≤</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span>
    <span class="n">leftInv</span> <span class="o">:</span> <span class="n">Function.leftInverse</span> <span class="n">invFun</span> <span class="n">toFun</span>
    <span class="n">rightInv</span> <span class="o">:</span> <span class="n">Function.rightInverse</span> <span class="n">invFun</span> <span class="n">toFun</span>

<span class="kd">infix</span><span class="o">:</span><span class="mi">25</span> <span class="s2">" ‚âÉ "</span> <span class="bp">=&gt;</span> <span class="n">Equiv</span>

<span class="kd">def</span> <span class="n">Equiv.symm</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚âÉ</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ≤</span> <span class="bp">‚âÉ</span> <span class="n">Œ±</span> <span class="n">where</span>
    <span class="n">toFun</span> <span class="o">:=</span> <span class="n">f.invFun</span>
    <span class="n">invFun</span> <span class="o">:=</span> <span class="n">f.toFun</span>
    <span class="n">leftInv</span> <span class="o">:=</span> <span class="n">f.rightInv</span>
    <span class="n">rightInv</span> <span class="o">:=</span> <span class="n">f.leftInv</span>

<span class="sd">/-- An equivalence "is" a function. -/</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ≤</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">CoeFun</span> <span class="o">(</span><span class="n">Equiv</span> <span class="n">Œ±</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">coe</span> <span class="o">:=</span> <span class="n">Equiv.toFun</span>

<span class="kd">class</span> <span class="n">Enumerable</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">card</span> <span class="o">:</span> <span class="n">Nat</span>
    <span class="n">enum</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚âÉ</span> <span class="n">Fin</span> <span class="n">card</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Enumerable</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">card</span> <span class="o">:=</span> <span class="n">n</span>
    <span class="n">enum</span> <span class="o">:=</span> <span class="o">{</span>
        <span class="n">toFun</span> <span class="o">:=</span> <span class="n">id</span>
        <span class="n">invFun</span> <span class="o">:=</span> <span class="n">id</span>
        <span class="n">leftInv</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
        <span class="n">rightInv</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
    <span class="o">}</span>

<span class="kn">section</span> <span class="n">CartesianProduct</span>

<span class="kd">theorem</span> <span class="n">cartEncodeProp</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">m</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">exfalso</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">Nat.notLtZero</span> <span class="n">_</span> <span class="n">hi</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="o">{</span>
        <span class="n">rw</span> <span class="n">Nat.succMul</span><span class="bp">;</span>
        <span class="n">exact</span> <span class="n">Nat.ltOfLeOfLt</span> <span class="o">(</span><span class="n">Nat.addLeAddRight</span> <span class="o">(</span><span class="n">Nat.mulLeMulRight</span> <span class="n">_</span> <span class="o">(</span><span class="n">Nat.leOfLtSucc</span> <span class="n">hi</span><span class="o">))</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">Nat.addLtAddLeft</span> <span class="n">hj</span> <span class="n">_</span><span class="o">)</span>
    <span class="o">}</span>

<span class="kd">def</span> <span class="n">cartDecode</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">Fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="o">))</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="n">m</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="o">‚ü®</span><span class="n">k</span><span class="o">,</span> <span class="n">h</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">k</span>
    <span class="o">(</span>
        <span class="o">‚ü®</span><span class="n">k</span> <span class="bp">/</span> <span class="n">m</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">‚ü©,</span>
        <span class="o">‚ü®</span><span class="n">k</span> <span class="bp">%</span> <span class="n">m</span><span class="o">,</span> <span class="n">Nat.modLt</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">m</span><span class="bp">;</span> <span class="n">exfalso</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">Nat.mulZero</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">Nat.notLtZero</span> <span class="n">_</span> <span class="n">h</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">Nat.succPos</span><span class="o">})‚ü©</span>
    <span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Enumerable</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">Enumerable</span> <span class="n">Œ≤</span><span class="o">]</span> <span class="o">:</span> <span class="n">Enumerable</span> <span class="o">(</span><span class="n">Œ±</span> <span class="bp">√ó</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">card</span> <span class="o">:=</span> <span class="n">Enumerable.card</span> <span class="n">Œ±</span> <span class="bp">*</span> <span class="n">Enumerable.card</span> <span class="n">Œ≤</span>
    <span class="n">enum</span> <span class="o">:=</span> <span class="o">{</span>
        <span class="n">toFun</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span>
            <span class="k">let</span> <span class="o">‚ü®</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">Enumerable.enum</span> <span class="n">a</span>
            <span class="k">let</span> <span class="o">‚ü®</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">Enumerable.enum</span> <span class="n">b</span>
            <span class="o">‚ü®</span><span class="n">i</span> <span class="bp">*</span> <span class="n">Enumerable.card</span> <span class="n">Œ≤</span> <span class="bp">+</span> <span class="n">j</span><span class="o">,</span> <span class="n">cartEncodeProp</span> <span class="n">hi</span> <span class="n">hj</span><span class="o">‚ü©</span>
        <span class="n">invFun</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">n</span> <span class="bp">=&gt;</span>
            <span class="k">let</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cartDecode</span> <span class="n">n</span>
            <span class="o">(</span><span class="n">Enumerable.enum.symm</span> <span class="n">i</span><span class="o">,</span> <span class="n">Enumerable.enum.symm</span> <span class="n">j</span><span class="o">)</span>
        <span class="n">leftInv</span> <span class="o">:=</span> <span class="gr">sorry</span>
        <span class="n">rightInv</span> <span class="o">:=</span> <span class="gr">sorry</span>
    <span class="o">}</span>

<span class="kd">end</span> <span class="n">CartesianProduct</span>

<span class="kd">def</span> <span class="n">Enumerable.listOf.aux</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Enumerable</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">List</span> <span class="n">Œ±</span>
<span class="bp">|</span> <span class="n">lo</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">lo</span><span class="o">,</span> <span class="o">(</span><span class="n">left</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">lo</span> <span class="bp">&lt;</span> <span class="n">Enumerable.card</span> <span class="n">Œ±</span> <span class="k">then</span>
        <span class="n">Enumerable.enum.symm</span> <span class="o">‚ü®</span><span class="n">lo</span><span class="o">,</span> <span class="n">h</span><span class="o">‚ü©</span> <span class="o">::</span> <span class="n">aux</span> <span class="n">Œ±</span> <span class="o">(</span><span class="n">lo</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">left</span>
    <span class="k">else</span> <span class="o">[]</span> <span class="c1">-- Shouldn't happen, but makes the definition easy.</span>

<span class="sd">/-- Create a list of every term in the Enumerable type in order. -/</span>
<span class="kd">def</span> <span class="n">Enumerable.listOf</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Enumerable</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Œ±</span> <span class="o">:=</span>
    <span class="n">Enumerable.listOf.aux</span> <span class="n">Œ±</span> <span class="mi">0</span> <span class="o">(</span><span class="n">Enumerable.card</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">Vec.sum</span> <span class="o">[</span><span class="n">Enumerable</span> <span class="n">Œπ</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">OfNat</span> <span class="n">Œ±</span> <span class="n">Nat.zero</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">mut</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">Enumerable.listOf</span> <span class="n">Œπ</span> <span class="k">do</span>
        <span class="n">s</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
    <span class="n">return</span> <span class="n">s</span>

<span class="sd">/-- A function-backed vector -/</span>
<span class="kd">structure</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">toFun</span> <span class="o">:</span> <span class="n">Œπ</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span>

<span class="n">macro</span> <span class="s2">"vec"</span> <span class="n">xs</span><span class="o">:</span><span class="n">Lean.explicitBinders</span> <span class="s2">" =&gt; "</span> <span class="n">b</span><span class="o">:</span><span class="n">term</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">Lean.expandExplicitBinders</span> <span class="bp">`</span><span class="n">Vec.mk</span> <span class="n">xs</span> <span class="n">b</span>

<span class="sd">/-- support `v[i]` notation. -/</span>
<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">Vec.getOp</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">(</span><span class="n">idx</span> <span class="o">:</span> <span class="n">Œπ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">self.toFun</span> <span class="n">idx</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">add</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">+</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Sub</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">Sub</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">sub</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">-</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">Mul</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">mul</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">*</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Div</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">Div</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">div</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">/</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">Vec</span>

<span class="kd">def</span> <span class="n">push</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œ∫</span> <span class="n">Œ±</span><span class="o">))</span> <span class="o">:</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">√ó</span> <span class="n">Œ∫</span><span class="o">)</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">p</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">p.1</span><span class="o">][</span><span class="n">p.2</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">pop</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Vec</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">√ó</span> <span class="n">Œ∫</span><span class="o">)</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œ∫</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)]</span>
<span class="kd">def</span> <span class="n">reindex</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Œ∫</span> <span class="bp">‚Üí</span> <span class="n">Œπ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œ∫</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">f</span> <span class="n">i</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Monad</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="n">map</span> <span class="n">f</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
    <span class="n">seq</span> <span class="n">f</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
    <span class="n">bind</span> <span class="n">v</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">])[</span><span class="n">i</span><span class="o">]</span> <span class="c1">-- diagonal (is this actually a monad law?)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">OfNat</span> <span class="n">Œ±</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">n</span> <span class="n">where</span>
    <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">OfNat.ofNat</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">transpose</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œ∫</span> <span class="n">Œ±</span><span class="o">))</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œ∫</span> <span class="o">(</span><span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vec</span> <span class="n">j</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>

<span class="kd">end</span> <span class="n">Vec</span>

<span class="kd">def</span> <span class="n">Vec.sum</span> <span class="o">[</span><span class="n">Enumerable</span> <span class="n">Œπ</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">OfNat</span> <span class="n">Œ±</span> <span class="n">Nat.zero</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">mut</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">Enumerable.listOf</span> <span class="n">Œπ</span> <span class="k">do</span>
        <span class="n">s</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
    <span class="n">return</span> <span class="n">s</span>
</code></pre></div>



<a name="262889543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889543">(Nov 27 2021 at 19:44)</a>:</h4>
<p>Well one way would be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">toFinProd</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">‚Üí</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">List.nil</span> <span class="bp">=&gt;</span> <span class="n">Unit</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">::</span> <span class="n">ns</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">√ó</span> <span class="n">toFinProd</span> <span class="n">ns</span>
</code></pre></div>
<p>but that turns <code>[n,m]</code> into <code>FIn n √ó (Fin m √ó Unit)</code>. At some point, I was playing around with types like that and I found them super painful to use.</p>



<a name="262889595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889595">(Nov 27 2021 at 19:45)</a>:</h4>
<p>If you special-case one-element lists, it gives you a nicer type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">toCart</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">‚Üí</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">Unit</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="o">::</span><span class="n">ns</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">√ó</span> <span class="n">toCart</span> <span class="n">ns</span>
</code></pre></div>



<a name="262889736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889736">(Nov 27 2021 at 19:49)</a>:</h4>
<p>I'm not sure, but you might need to make it <code>@[reducible]</code> or something to make sure Lean unfolds it for typeclass inference. It would be nicer if <code>toCart [3,4,5]</code> actually looked like <code>Fin 3 √ó Fin 4 √ó Fin 5</code>.</p>



<a name="262889848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889848">(Nov 27 2021 at 19:51)</a>:</h4>
<p>Ohh even getting the notation <code>A i j k</code> will involve something like <code>toCart</code>. You need to turn <code>d : List Nat</code> into <code>Fin d[0] -&gt; Fin d[1] -&gt; ... -. Fin d[n-1] -&gt; R</code>.</p>



<a name="262889991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262889991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262889991">(Nov 27 2021 at 19:54)</a>:</h4>
<p>Btw. thanks for the code but one big difference is that I definitely do not want to go the route of having matrices defined as <code>Vec Œπ (Vec Œ∫ Œ±)</code>. What about diagonal matrices, block matrices, sparse matrices etc.</p>



<a name="262890067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890067">(Nov 27 2021 at 19:56)</a>:</h4>
<p>The part of the code I didn't copy, since I didn't really get it to work right, was having things like <code>DenseVec</code> that can be used as a <code>Vec</code>.</p>



<a name="262890075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890075">(Nov 27 2021 at 19:56)</a>:</h4>
<p><code>Vec</code> is just the ideal mathematical type, and then there would be different concrete storage types.</p>



<a name="262890163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890163">(Nov 27 2021 at 19:59)</a>:</h4>
<p>Ohh I see, I wasn't thinking about the code in the right way. I have to keep staring at it :)</p>



<a name="262890331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890331">(Nov 27 2021 at 20:02)</a>:</h4>
<p>This might not matter for what you're doing, but something that I was sort of going for was to be able to do APL/J-style array computations, where you can think of your multidimensional array as being a multidimensional array of multidimensional arrays and broadcast function applications over each of the arrays.</p>



<a name="262890422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890422">(Nov 27 2021 at 20:03)</a>:</h4>
<p>At some point I would like to do something like that too, so getting something working would be nice.</p>



<a name="262890465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890465">(Nov 27 2021 at 20:04)</a>:</h4>
<p>How would you specify the storage type in your approach?</p>



<a name="262890564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890564">(Nov 27 2021 at 20:06)</a>:</h4>
<p>With your approach, you can easily do multidimensional arrays as <code>v : Vec (Fin 3 √ó Fin 4 √ó Fin 5) R</code>  then <code>v[(i,j,k)]</code> works and turning it into <code>v[i,j,k]</code> is just a simple macro.</p>



<a name="262890633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890633">(Nov 27 2021 at 20:08)</a>:</h4>
<p>I had imagined making types that can be coerced to <code>Vec</code>, so <code>DenseVec</code> might be a structure containing an <code>Array</code> of all the elements, or a <code>DiagonalMatrix</code> might be a structure containing an <code>Array</code> of just the diagonal elements.</p>



<a name="262890641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890641">(Nov 27 2021 at 20:08)</a>:</h4>
<p>A mix of yours and my approach would be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">‚Üí</span> <span class="n">Œπ</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span>     <span class="c1">-- get and element</span>
</code></pre></div>



<a name="262890796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890796">(Nov 27 2021 at 20:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays/near/262890633">said</a>:</p>
<blockquote>
<p>I had imagined making types that can be coerced to <code>Vec</code>, so <code>DenseVec</code> might be a structure containing an <code>Array</code> of all the elements, or a <code>DiagonalMatrix</code> might be a structure containing an <code>Array</code> of just the diagonal elements.</p>
</blockquote>
<p>Makes sense, so I'm curious which part you didn't manage to get working?</p>



<a name="262890871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890871">(Nov 27 2021 at 20:14)</a>:</h4>
<p>Here's another experiment for Lean 3 (though nothing about storage types): <a href="https://gist.github.com/kmill/5eb83cb5fd102e4242c2c8a53224ba13">https://gist.github.com/kmill/5eb83cb5fd102e4242c2c8a53224ba13</a></p>
<p>As an illustration, two kinds of matrix-vector products depending on whether the indices have been merged into a cartesian product:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">matvec</span> <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span> <span class="o">:=</span>
<span class="n">for</span> <span class="n">i</span><span class="o">,</span> <span class="n">vsum</span> <span class="n">for</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">v</span> <span class="n">j</span>

<span class="kd">def</span> <span class="n">matvec'</span> <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">√ó</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span> <span class="o">:=</span>
<span class="n">for</span> <span class="n">i</span><span class="o">,</span> <span class="n">vsum</span> <span class="n">for</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="n">v</span> <span class="n">j</span>
</code></pre></div>
<p>There are some operations for going back and forth between these representations:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vec.push</span> <span class="o">{</span><span class="n">Œπ‚ÇÅ</span> <span class="n">Œπ‚ÇÇ</span> <span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Œπ‚ÇÅ</span> <span class="bp">=&gt;</span> <span class="n">Œπ‚ÇÇ</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œπ‚ÇÅ</span> <span class="bp">√ó</span> <span class="n">Œπ‚ÇÇ</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span>
<span class="kd">def</span> <span class="n">vec.pop</span> <span class="o">{</span><span class="n">Œπ‚ÇÅ</span> <span class="n">Œπ‚ÇÇ</span> <span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Œπ‚ÇÅ</span> <span class="bp">√ó</span> <span class="n">Œπ‚ÇÇ</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œπ‚ÇÅ</span> <span class="bp">=&gt;</span> <span class="n">Œπ‚ÇÇ</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span>
</code></pre></div>
<p>Or using <code>applicative</code>-style for broadcasting addition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">addvec'</span> <span class="o">{</span><span class="n">r</span> <span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">Œ±</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">v</span> <span class="bp">&lt;*&gt;</span> <span class="n">w</span>
</code></pre></div>
<p>It also has an extremely fiddly notation (which would be easier in Lean 4) for slicing: <code>u‚ü¶(),j‚üß</code> and <code>u‚ü¶i,()‚üß</code>for a <code>u : a=&gt;b=&gt;c</code>.</p>



<a name="262890975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262890975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262890975">(Nov 27 2021 at 20:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays/near/262890796">said</a>:</p>
<blockquote>
<p>I'm curious which part you didn't manage to get working?</p>
</blockquote>
<p>Unfortunately, I don't really remember... I think it was something to do with the ergonomics of using a <code>DenseVec</code> in an expression, since Lean had no reason to try coercing it to a <code>Vec</code> for an operation like addition.  It looks like I had my own coercion class</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HasVec</span> <span class="o">(</span><span class="n">Œ≤</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">$</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">toVec</span> <span class="o">:</span> <span class="n">Œ≤</span> <span class="bp">‚Üí</span> <span class="n">Vec</span> <span class="n">Œπ</span> <span class="n">Œ±</span>
</code></pre></div>
<p>and then you'd write something like <code>2 * toVec d + toVec d'</code></p>



<a name="262891371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262891371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262891371">(Nov 27 2021 at 20:26)</a>:</h4>
<p>Wouldn't that get solved by using the</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">‚Üí</span> <span class="n">Œπ</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span>     <span class="c1">-- get and element</span>
</code></pre></div>
<p>An equivalent to <code>Vec</code> would be the instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">NDArray</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">Œπ</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">f</span><span class="o">‚ü©</span>
</code></pre></div>
<p>Then you are not relaying on coercion but on typeclasses. Addition would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">B</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="n">A</span> <span class="n">B</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>and you do not need the custom coercion <code>toVec</code>.</p>



<a name="262891522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262891522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262891522">(Nov 27 2021 at 20:30)</a>:</h4>
<p>Broadcasting addition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">A</span> <span class="n">I</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">NDArray</span> <span class="n">B</span> <span class="n">J</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="n">A</span> <span class="n">B</span> <span class="o">(</span><span class="n">I</span> <span class="bp">‚Üí</span> <span class="n">J</span> <span class="bp">‚Üí</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="262891540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262891540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262891540">(Nov 27 2021 at 20:31)</a>:</h4>
<p>I imagine that should work.   (I had tried something like that with <code>HAdd</code>, but this was shortly after the public release of Lean 4, and there may have potentially been some typeclass inference bugs I ran into that have since been patched.)</p>



<a name="262891747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262891747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262891747">(Nov 27 2021 at 20:36)</a>:</h4>
<p>I will play around with it a bit, scared of associativity of <code>√ó</code> though.</p>



<a name="262933965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262933965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262933965">(Nov 28 2021 at 15:21)</a>:</h4>
<p>I have done a quick experiment and this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">3</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="mi">2</span> <span class="bp">‚Ü¶</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">2</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="mi">5</span> <span class="bp">‚Ü¶</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">3</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="mi">5</span> <span class="bp">‚Ü¶</span> <span class="n">Nat</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">f</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="k">#check</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
<span class="k">#check</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">f</span>
<span class="k">#check</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">h</span>
</code></pre></div>
<p>where <code>Œ± ‚Ü¶ Œ≤</code> is just  <code>Œ± ‚Üí Œ≤</code> but it is a hint that element notation <code>f[i,j]</code> can be used.</p>



<a name="262934008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Interface%20for%20multi-dimensional%20arrays/near/262934008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Interface.20for.20multi-dimensional.20arrays.html#262934008">(Nov 28 2021 at 15:22)</a>:</h4>
<p>Full code </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">--- Container `C` with index set `Œπ` and element type `Œ±`</span>
<span class="kd">class</span> <span class="n">Cont</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">toFun</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">‚Üí</span> <span class="n">Œπ</span> <span class="bp">‚Üí</span> <span class="n">Œ±</span>

<span class="c1">--- Automatically infering T and dims based on A</span>
<span class="kd">class</span> <span class="n">ContData</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">indexType</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
  <span class="n">valueType</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span>

<span class="c1">-- Is this good idea?</span>
<span class="kd">@[reducible]</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">ContData</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="n">Œπ</span><span class="o">,</span> <span class="n">Œ±</span><span class="o">‚ü©</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">,</span> <span class="n">inline</span><span class="o">]</span> <span class="n">ContData.indexType</span> <span class="n">ContData.valueType</span>


<span class="kn">namespace</span> <span class="n">Cont</span>

  <span class="c1">-- Function that should be interpreted as a container</span>
  <span class="kd">def</span> <span class="n">ContFun</span> <span class="o">(</span><span class="n">Œ±</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span>
  <span class="kd">infix</span><span class="o">:</span><span class="mi">34</span> <span class="s2">" ‚Ü¶ "</span> <span class="bp">=&gt;</span> <span class="n">ContFun</span>

  <span class="kd">def</span> <span class="n">toCont</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:</span> <span class="n">Œ±</span> <span class="bp">‚Ü¶</span> <span class="n">Œ≤</span> <span class="o">:=</span> <span class="n">f</span>
  <span class="kd">instance</span> <span class="o">(</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">Cont</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">‚Ü¶</span> <span class="n">Œ±</span><span class="o">)</span> <span class="n">Œπ</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">f</span> <span class="bp">=&gt;</span> <span class="n">f</span><span class="o">‚ü©</span>

  <span class="kd">@[reducible]</span>
  <span class="n">abbrev</span> <span class="n">indexOf</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">ContData</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span> <span class="n">ContData.indexType</span> <span class="n">C</span>

  <span class="kd">@[reducible]</span>
  <span class="n">abbrev</span> <span class="n">valueOf</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">ContData</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span> <span class="n">ContData.valueType</span> <span class="n">C</span>

  <span class="kd">@[reducible]</span>
  <span class="n">abbrev</span> <span class="n">get</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span> <span class="o">[</span><span class="n">ContData</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C</span> <span class="o">(</span><span class="n">ContData.indexType</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">ContData.valueType</span> <span class="n">C</span><span class="o">)]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">toFun</span> <span class="n">_</span> <span class="o">(</span><span class="n">indexOf</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">valueOf</span> <span class="n">c</span><span class="o">)</span> <span class="n">_</span> <span class="n">c</span>

  <span class="n">macro</span> <span class="n">c</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span><span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">c</span> <span class="bp">$</span><span class="n">i1</span><span class="o">)</span>

  <span class="n">macro</span> <span class="n">c</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">c</span> <span class="o">(</span><span class="bp">$</span><span class="n">i1</span><span class="o">,</span><span class="bp">$</span><span class="n">i2</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">c</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i3</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">c</span> <span class="o">(</span><span class="bp">$</span><span class="n">i1</span><span class="o">,</span><span class="bp">$</span><span class="n">i2</span><span class="o">,</span><span class="bp">$</span><span class="n">i3</span><span class="o">))</span>

  <span class="n">macro</span> <span class="n">c</span><span class="o">:</span><span class="n">term</span> <span class="n">noWs</span> <span class="s2">"["</span> <span class="n">i1</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i2</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i3</span><span class="o">:</span><span class="n">term</span> <span class="s2">","</span> <span class="n">i4</span><span class="o">:</span><span class="n">term</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">get</span> <span class="bp">$</span><span class="n">c</span> <span class="o">(</span><span class="bp">$</span><span class="n">i1</span><span class="o">,</span><span class="bp">$</span><span class="n">i2</span><span class="o">,</span><span class="bp">$</span><span class="n">i3</span><span class="o">,</span><span class="bp">$</span><span class="n">i4</span><span class="o">))</span>


  <span class="kn">section</span> <span class="n">Arithmetics</span>

     <span class="kn">section</span> <span class="n">ElementWise</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">]</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">C'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u'</span><span class="o">}</span> <span class="o">{</span><span class="n">Œ±'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w'</span><span class="o">}</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C'</span> <span class="n">Œπ</span> <span class="n">Œ±'</span><span class="o">]</span>

       <span class="kd">instance</span> <span class="o">[</span><span class="n">HAdd</span> <span class="n">Œ±</span> <span class="n">Œ±'</span> <span class="n">Œ≤</span><span class="o">]</span> <span class="o">:</span> <span class="n">HAdd</span> <span class="n">C</span> <span class="n">C'</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">‚Ü¶</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">c</span> <span class="n">c'</span> <span class="bp">=&gt;</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">+</span> <span class="n">c'</span><span class="o">[</span><span class="n">i</span><span class="o">]‚ü©</span>

     <span class="kd">end</span> <span class="n">ElementWise</span>

     <span class="kn">section</span> <span class="n">Mul</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">Œπ</span> <span class="n">Œ∫</span> <span class="n">Œº</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C</span> <span class="o">(</span><span class="n">Œπ</span><span class="bp">√ó</span><span class="n">Œ∫</span><span class="o">)</span> <span class="n">Œ±</span><span class="o">]</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">C'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u'</span><span class="o">}</span> <span class="o">{</span><span class="n">Œ±'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w'</span><span class="o">}</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C'</span> <span class="o">(</span><span class="n">Œ∫</span><span class="bp">√ó</span><span class="n">Œº</span><span class="o">)</span> <span class="n">Œ±'</span><span class="o">]</span>

       <span class="c1">-- Just a prototype because I do not have a `Fintype` defined</span>
       <span class="kd">def</span> <span class="n">sum</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ≤</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">Œ±</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">Œ≤</span> <span class="o">:=</span> <span class="gr">sorry</span>

       <span class="kd">instance</span> <span class="o">[</span><span class="n">HMul</span> <span class="n">Œ±</span> <span class="n">Œ±'</span> <span class="n">Œ≤</span><span class="o">]</span> <span class="o">[</span><span class="n">Add</span> <span class="n">Œ≤</span><span class="o">]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">C</span> <span class="n">C'</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">√ó</span> <span class="n">Œº</span> <span class="bp">‚Ü¶</span> <span class="n">Œ≤</span><span class="o">)</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">c</span> <span class="n">c'</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">sum</span> <span class="bp">Œª</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">]</span> <span class="bp">*</span> <span class="n">c'</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">]‚ü©</span>

     <span class="kd">end</span> <span class="n">Mul</span>

     <span class="kn">section</span> <span class="n">Broadcasting</span>

       <span class="kd">variable</span> <span class="o">{</span><span class="n">Œπ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
       <span class="kd">variable</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">Cont</span> <span class="n">C</span> <span class="n">Œπ</span> <span class="n">Œ±</span><span class="o">]</span>

       <span class="kd">instance</span> <span class="o">[</span><span class="n">HMul</span> <span class="n">Œ±</span> <span class="n">Œ≤</span> <span class="n">Œ≥</span><span class="o">]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">C</span> <span class="n">Œ≤</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">‚Ü¶</span> <span class="n">Œ≥</span><span class="o">)</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">*</span><span class="n">b</span><span class="o">‚ü©</span>
       <span class="kd">instance</span> <span class="o">[</span><span class="n">HMul</span> <span class="n">Œ≤</span> <span class="n">Œ±</span> <span class="n">Œ≥</span><span class="o">]</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">Œ≤</span> <span class="n">C</span> <span class="o">(</span><span class="n">Œπ</span> <span class="bp">‚Ü¶</span> <span class="n">Œ≥</span><span class="o">)</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">b</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]‚ü©</span>


     <span class="kd">end</span> <span class="n">Broadcasting</span>

  <span class="kd">end</span> <span class="n">Arithmetics</span>

<span class="kd">end</span> <span class="n">Cont</span>


<span class="kd">variable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">3</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="mi">2</span> <span class="bp">‚Ü¶</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">2</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="mi">5</span> <span class="bp">‚Ü¶</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">3</span> <span class="bp">√ó</span> <span class="n">Fin</span> <span class="mi">5</span> <span class="bp">‚Ü¶</span> <span class="n">Nat</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">f</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="k">#check</span> <span class="bp">Œª</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=&gt;</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span>
<span class="k">#check</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">f</span>
<span class="k">#check</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">f</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">h</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
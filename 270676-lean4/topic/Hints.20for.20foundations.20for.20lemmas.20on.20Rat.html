---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html">Hints for foundations for lemmas on Rat</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="307014127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307014127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307014127">(Oct 30 2022 at 22:30)</a>:</h4>
<p>I'm a bit over my skis working on basic lemmas for <code>Rat</code>. In Lean 3 <code>mathlib</code>, <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/rat/defs.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/rat/defs.lean</a> most of the really basic lemmas are defined in terms of <code>num_denom_cases_on'</code>, e.g.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">add_zero</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">num_denom_cases_on'</span> <span class="n">a</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">d</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">zero_mk</span> <span class="n">d</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="bp">-</span><span class="n">zero_mk</span><span class="o">]</span>
</code></pre></div>
<p>and <code>num_denom_cases_on'</code> is defined in terms of <code>num_denom</code>, which relies on some definitional and implementation behavior that's different in Lean 4 (e.g., there's no <code>pnat</code>) and in terms of operators I don't understand (e.g. what's '/.'?)</p>
<p>In general <code>rat</code> and <code>Rat</code> are heavily pre-optimized, and <code>add</code> is inherently pretty complicated.</p>
<p>Some hints on the best Lean 4 equivalent for <code>num_denom_cases_on'</code> for the Lean 4 version of <code>Rat</code> would be greatly welcome.</p>



<a name="307014317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307014317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307014317">(Oct 30 2022 at 22:33)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat#doc">docs4#Rat</a> does this work?</p>



<a name="307014409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307014409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307014409">(Oct 30 2022 at 22:34)</a>:</h4>
<p>So it looks like all the data has been defined (addition, subtraction etc) but none of the proofs?</p>



<a name="307014727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307014727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307014727">(Oct 30 2022 at 22:39)</a>:</h4>
<p>Why not just sorry the proofs and make the <code>ring</code> instance?</p>



<a name="307015801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307015801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307015801">(Oct 30 2022 at 22:56)</a>:</h4>
<p>That would advance my project for sure but create a poor PR. If I had pointers to the hard bits I’d be happy to do the grunt work for a PR.</p>



<a name="307016274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307016274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307016274">(Oct 30 2022 at 23:02)</a>:</h4>
<p>I think we have transitioned to the point in mathlib4 where PRs should either be</p>
<ol>
<li>ports of entire files from mathlib3, faithfully preserving all their content and organisation</li>
<li>ad-hoc ports of material <em>only</em> if it is supporting tactic implementation.</li>
</ol>



<a name="307016394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307016394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307016394">(Oct 30 2022 at 23:04)</a>:</h4>
<p>So the ideal way to work on <code>data/rat/defs.lean</code> is first to run</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>cd src
leanproject import-graph --to data.rat.defs --exclude-tactics --port-status --reduce data.rat.defs.pdf
</code></pre></div>
<p>inside the mathlib repository.</p>



<a name="307016451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307016451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307016451">(Oct 30 2022 at 23:05)</a>:</h4>
<p>This produces <a href="/user_uploads/3121/TcC4kTW3IWeyeThxgvOCmTgR/data.rat.defs.pdf">data.rat.defs.pdf</a></p>



<a name="307016692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307016692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307016692">(Oct 30 2022 at 23:09)</a>:</h4>
<p>What’s confusing is that this has moved to Std4 &amp; the implementation details are just different enough that it’s not a mechanical port….</p>



<a name="307016966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307016966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307016966">(Oct 30 2022 at 23:14)</a>:</h4>
<p>Oh dear, I hadn't realised <code>Rat</code> was in <code>Std</code> already!</p>



<a name="307016989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307016989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307016989">(Oct 30 2022 at 23:15)</a>:</h4>
<p>Maybe the right choice is actually to backport this definition to mathlib3, so we can resume the "mechanical port".</p>



<a name="307022947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307022947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307022947">(Oct 31 2022 at 01:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> <a href="#narrow/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat/near/307014127">said</a>:</p>
<blockquote>
<p>in terms of operators I don't understand (e.g. what's '/.'?)</p>
</blockquote>
<p>Realized that this is <code>localized "infix (name := rat.mk) </code> /. <code>:70 := rat.mk" in rat</code> so I can just use <code>Rat.mk</code>.</p>



<a name="307031864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307031864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307031864">(Oct 31 2022 at 03:43)</a>:</h4>
<p>I'm sorta making progress here, but I'm confused.</p>
<p>Given that <code>/.</code> means <code>rat.mk</code> and <code>rat.mk</code> is sorta 'mkRat' in Lean 4 <code>Std4</code> (sorta because <code>mathlib</code> <code>rat</code> is defined in terms of <code>int</code> and <code>pnat</code>, where as <code>Rat</code> is <code>Int</code> and <code>Nat</code> &amp; <code>rat.mk</code> is <code>int -&gt; int -&gt; rat</code> whereas <code>mkRat</code> is <code>Int -&gt; Nat -&gt; Rat</code>, I decided to try to rewrite</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">num_denom</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">},</span> <span class="n">a.num</span> <span class="bp">/.</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">_</span><span class="bp">=</span><span class="mi">1</span><span class="o">)⟩</span> <span class="o">:=</span> <span class="k">show</span> <span class="n">mk_nat</span> <span class="n">n</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mk_nat</span><span class="o">,</span> <span class="n">ne_of_gt</span> <span class="n">h</span><span class="o">,</span> <span class="n">mk_pnat</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span>
</code></pre></div>
<p>as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">num_den</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">},</span> <span class="n">mkRat</span> <span class="n">a.num</span> <span class="n">a.den</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">_</span><span class="bp">=</span><span class="mi">1</span><span class="o">)⟩</span> <span class="bp">=&gt;</span> <span class="k">show</span> <span class="n">mkRat</span> <span class="n">n</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">_</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mkRat</span><span class="o">,</span> <span class="n">Nat.ne_of_gt</span> <span class="n">h</span><span class="o">,</span> <span class="n">mkRat</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span>
</code></pre></div>
<p>but the <code>net_of_gt</code> simplification isn't working, and it's confusing to me why it should work in <code>mathlib</code></p>
<p>It's spelled</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ne_of_gt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">he</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h</span> <span class="o">(</span><span class="n">he</span> <span class="bp">▸</span> <span class="n">lt_irrefl</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>in <code>mathlib</code></p>
<p>and </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ne_of_gt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ne_of_lt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">he</span> <span class="bp">=&gt;</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">he</span> <span class="bp">▸</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">Nat.lt_irrefl</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>In Lean 4</p>
<p>Since the type of <code>h</code> is … OH(!) the types in <code>mathlib</code> and Lean 4 differ.</p>
<p>In <code>mathlib</code> the corresponding type is <code>0 &lt; denom</code> and in Lean 4 it's <code>den ≠ 0</code> so back to the mines.</p>



<a name="307032208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307032208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307032208">(Oct 31 2022 at 03:49)</a>:</h4>
<p>So</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">num_den</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">},</span> <span class="n">mkRat</span> <span class="n">a.num</span> <span class="n">a.den</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">_</span><span class="bp">=</span><span class="mi">1</span><span class="o">)⟩</span> <span class="bp">=&gt;</span> <span class="k">show</span> <span class="n">mkRat</span> <span class="n">n</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">_</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mkRat</span><span class="o">,</span><span class="n">h</span><span class="o">,</span><span class="n">normalize</span><span class="o">,</span> <span class="n">maybeNormalize</span><span class="o">,</span><span class="n">c</span><span class="o">]</span>
</code></pre></div>
<p>closes the goal</p>
<p>Progress.</p>



<a name="307032555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307032555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307032555">(Oct 31 2022 at 03:57)</a>:</h4>
<p>I also now think I understand what that <code>simp</code> step is doing -- it's leading <code>Lean</code> down the path of understanding that <code>mkRat</code> is already pre-normalized by hypothesis.</p>



<a name="307036805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307036805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307036805">(Oct 31 2022 at 05:03)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/rat">docs#rat</a></p>



<a name="307036871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307036871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307036871">(Oct 31 2022 at 05:04)</a>:</h4>
<p>You've made the assertion more than once that in loan 3 <code>rat</code> is defined using <code>pnat</code> but I don't think it's true.</p>



<a name="307037522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307037522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307037522">(Oct 31 2022 at 05:13)</a>:</h4>
<p><code>rat</code> itself doesn't use <code>pnat</code>, but <code>rat.mk</code> uses <code>rat.mk_pnat</code></p>



<a name="307037610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307037610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307037610">(Oct 31 2022 at 05:14)</a>:</h4>
<p>Right -- the builtin constructor for rat is not <code>rat.mk</code>, it's <code>rat.mk'</code></p>



<a name="307037666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307037666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307037666">(Oct 31 2022 at 05:15)</a>:</h4>
<p>ah yeah, maybe we should do that too, so we can use <code>Rat.mk</code> for the smart constructor</p>



<a name="307037775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307037775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307037775">(Oct 31 2022 at 05:17)</a>:</h4>
<p>The current lean 4 file is based not on the original <code>data.rat.basic</code> but on lean 4's <code>Lean.Rat</code>, which has slightly more efficient operations. We should try to make it align with mathlib better where it's reasonable to do so</p>



<a name="307038007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307038007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307038007">(Oct 31 2022 at 05:19)</a>:</h4>
<p>We also have another tool for replacements, <code>@[csimp]</code> lemmas, which allow us to use a naive and simple-to-reason-about definition as the official definition and sequester the messy and efficient definition to an auxiliary. I don't usually bother though unless we care about the defeqs</p>



<a name="307132129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307132129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307132129">(Oct 31 2022 at 15:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat/near/307036871">said</a>:</p>
<blockquote>
<p>You've made the assertion more than once that in loan 3 <code>rat</code> is defined using <code>pnat</code> but I don't think it's true.</p>
</blockquote>
<p>Sorry, you are correct - as <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> notes, the path to construction goes through <code>pnat</code> but the <code>rat</code> itself is in terms of <code>nat</code> plus the assertion <code>pos : 0 &lt; denom</code></p>



<a name="307142954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307142954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307142954">(Oct 31 2022 at 16:05)</a>:</h4>
<p>Should the Lean 4 equivalent of <code>/.</code> for <code>Rat</code> be an <code>HDiv</code>?</p>



<a name="307144416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307144416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307144416">(Oct 31 2022 at 16:12)</a>:</h4>
<p>And…, how does one spell <code>@[elab_as_eliminator]</code> in Lean 4?</p>



<a name="307146724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307146724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307146724">(Oct 31 2022 at 16:23)</a>:</h4>
<p><code>@[elabAsElim]</code></p>



<a name="307152166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307152166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307152166">(Oct 31 2022 at 16:46)</a>:</h4>
<p><code>@[elab_as_elim]</code> for recent nightlies -- the naming convention for attributes has reverted to snake_case.</p>



<a name="307220891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307220891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307220891">(Oct 31 2022 at 23:22)</a>:</h4>
<p>The update in this adventure is that things are going mostly well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ext_iff</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">p.num</span> <span class="bp">=</span> <span class="n">q.num</span> <span class="bp">∧</span> <span class="n">p.den</span> <span class="bp">=</span> <span class="n">q.den</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">p</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">q</span><span class="bp">;</span> <span class="n">simp</span>

<span class="kd">@[ext]</span> <span class="kd">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">p.num</span> <span class="bp">=</span> <span class="n">q.num</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">p.den</span> <span class="bp">=</span> <span class="n">q.den</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">Rat.ext_iff.mpr</span> <span class="o">⟨</span><span class="n">hn</span><span class="o">,</span> <span class="n">hd</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">num_den</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">},</span> <span class="n">mkRat</span> <span class="n">a.num</span> <span class="n">a.den</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">_</span><span class="bp">=</span><span class="mi">1</span><span class="o">)⟩</span> <span class="bp">=&gt;</span> <span class="k">show</span> <span class="n">mkRat</span> <span class="n">n</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">_</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mkRat</span><span class="o">,</span><span class="n">h</span><span class="o">,</span><span class="n">normalize</span><span class="o">,</span> <span class="n">maybeNormalize</span><span class="o">,</span><span class="n">c</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">num_den'</span> <span class="o">:</span> <span class="o">(⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mkRat</span> <span class="n">n</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">num_den.symm</span>

<span class="sd">/-- Define a (dependent) function or prove `∀ r : Rat, p r` by dealing with rational</span>
<span class="sd">numbers of the form `mkRat n d` with `d ≠ 0` and coprime `n`, `d`. -/</span>
<span class="kd">@[elab_as_elim]</span> <span class="kd">def</span> <span class="n">num_denom_cases_on</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Rat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
 <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">d</span><span class="o">,</span> <span class="n">d</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="n">n.natAbs</span><span class="o">)</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">d</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">mkRat</span> <span class="n">n</span>  <span class="n">d</span><span class="o">)),</span> <span class="n">C</span> <span class="n">a</span>
 <span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">c</span><span class="o">⟩,</span> <span class="n">H</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">num_den'</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">n</span> <span class="n">d</span> <span class="n">h</span> <span class="n">c</span>

 <span class="sd">/-- Define a (dependent) function or prove `∀ r : Rat, p r` by dealing with rational</span>
<span class="sd">numbers of the form `n /. d` with `d ≠ 0`. -/</span>
<span class="kd">@[elab_as_elim]</span> <span class="kd">def</span> <span class="n">num_denom_cases_on'</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Rat</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
   <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Rat</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Int</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">Nat</span><span class="o">),</span> <span class="n">d</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">mkRat</span> <span class="n">n</span> <span class="n">d</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">num_denom_cases_on</span> <span class="n">a</span> <span class="bp">&lt;|</span> <span class="k">fun</span> <span class="n">n</span> <span class="n">d</span> <span class="n">h</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">H</span> <span class="n">n</span> <span class="n">d</span> <span class="n">h</span>
</code></pre></div>
<p>But things that should be easy like the analogue of </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">zero_mk</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">/.</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mk</span><span class="o">]</span>
</code></pre></div>
<p>end up being terrifying.</p>



<a name="307246289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307246289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307246289">(Nov 01 2022 at 04:47)</a>:</h4>
<p>I'm close, I think.</p>
<p>After</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">mk_zero</span><span class="o">:</span> <span class="o">(</span><span class="n">mkRat</span> <span class="mi">0</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mkRat</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mkRat</span><span class="o">,</span> <span class="n">normalize</span><span class="o">,</span> <span class="n">maybeNormalize</span><span class="o">,</span> <span class="n">Int.natAbs</span><span class="o">,</span> <span class="n">Nat.gcd_zero_left</span><span class="o">,</span> <span class="n">Int.zero_div</span><span class="o">]</span>
</code></pre></div>
<p>I'm down to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">case</span> <span class="n">succ</span>
<span class="n">n</span><span class="o">:</span> <span class="n">Nat</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">mk</span> <span class="mi">0</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="k">else</span> <span class="n">mk</span> <span class="mi">0</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">/</span> <span class="n">Nat.succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>
<p>which, since I already handled the zero case in the first <code>cases</code> branch, and since <code>Nat.succ n</code> is always &gt; 0, should resolve down to <code>mk 0 1=0</code> which should close by <code>rfl</code> but I'm stuck in how to tell Lean that.</p>



<a name="307256501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307256501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307256501">(Nov 01 2022 at 06:56)</a>:</h4>
<p>Assuming there's not yet a <code>splitIfs</code> tactic in lean 4, you want to do cases on n=0 and use <code>if_pos</code> and <code>if_neg</code> or whatever they're called in lean 4</p>



<a name="307256866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307256866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307256866">(Nov 01 2022 at 07:00)</a>:</h4>
<p><a href="#narrow/stream/116290-rss/topic/Recent.20Commits.20to.20mathlib4.3Amaster/near/307019140">There might be <code>split_ifs</code></a></p>



<a name="307259000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307259000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307259000">(Nov 01 2022 at 07:22)</a>:</h4>
<p>Yes, <code>split_ifs</code> landed in <a href="https://github.com/leanprover-community/mathlib4/pull/508">mathlib4#508</a>.</p>



<a name="307293688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307293688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307293688">(Nov 01 2022 at 11:44)</a>:</h4>
<p>Is <code>split_ifs</code> mostly intended for porting and otherwise should be covered by core <code>split</code> (which also handles <code>match</code>) in most cases? It would be great if such overlaps would be discussed in the doc strings.</p>



<a name="307309145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307309145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307309145">(Nov 01 2022 at 13:21)</a>:</h4>
<p>It is briefly mentioned in the doc-string at <a href="https://github.com/leanprover-community/mathlib4/pull/508/files#diff-42751ffdb8743d3ea4b619276a2600ccc8dd8476d972087dfcddb3bbfe52dc58R77">https://github.com/leanprover-community/mathlib4/pull/508/files#diff-42751ffdb8743d3ea4b619276a2600ccc8dd8476d972087dfcddb3bbfe52dc58R77</a>.</p>
<p>Perhaps it would be worthwhile to go through the test file, and annotate the use cases for which the core <code>split</code> suffices.</p>



<a name="307327947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307327947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307327947">(Nov 01 2022 at 14:42)</a>:</h4>
<p>Now I see that I should have taken care of this case earlier.</p>
<p>That branch descends from<br>
<code>Nat.gcd (Int.natAbs 0) (Nat.succ n)=1</code> so it suffices to prove <code>∀ n, Nat.gcd (Int.natAbs 0) (Nat.succ n) ≠ 1</code></p>



<a name="307332814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307332814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307332814">(Nov 01 2022 at 15:02)</a>:</h4>
<p>Oh, but that's not true.</p>



<a name="307332979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307332979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307332979">(Nov 01 2022 at 15:03)</a>:</h4>
<p>It is, however, only true in the exact case where the theorem is true.</p>



<a name="307358722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307358722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307358722">(Nov 01 2022 at 17:01)</a>:</h4>
<p>You generally don't want to unfold multiple definitions in a single theorem, so this should be broken into multiple theorems. I came up with this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.Rat</span>

<span class="kn">namespace</span> <span class="n">Rat</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">Int.ofNat_zero</span> <span class="n">Int.ofNat_one</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">maybeNormalize_eq</span> <span class="o">{</span><span class="n">num</span> <span class="n">den</span> <span class="n">g</span><span class="o">}</span> <span class="o">(</span><span class="n">den_nz</span> <span class="n">reduced</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">maybeNormalize</span> <span class="n">num</span> <span class="n">den</span> <span class="n">g</span> <span class="n">den_nz</span> <span class="n">reduced</span> <span class="bp">=</span>
    <span class="o">{</span> <span class="n">num</span> <span class="o">:=</span> <span class="n">num</span> <span class="bp">/</span> <span class="n">g</span><span class="o">,</span> <span class="n">den</span> <span class="o">:=</span> <span class="n">den</span> <span class="bp">/</span> <span class="n">g</span><span class="o">,</span> <span class="n">den_nz</span><span class="o">,</span> <span class="n">reduced</span> <span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">unfold</span> <span class="n">maybeNormalize</span> <span class="bp">&lt;;&gt;</span> <span class="n">split</span>
  <span class="bp">·</span> <span class="n">subst</span> <span class="n">g</span><span class="bp">;</span> <span class="n">simp</span>
  <span class="bp">·</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">normalize_zero</span> <span class="o">(</span><span class="n">nz</span><span class="o">)</span> <span class="o">:</span> <span class="n">normalize</span> <span class="mi">0</span> <span class="n">d</span> <span class="n">nz</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">normalize</span><span class="o">,</span> <span class="n">Int.zero_div</span><span class="o">,</span> <span class="n">Int.natAbs_zero</span><span class="o">,</span> <span class="n">Nat.div_self</span> <span class="o">(</span><span class="n">Nat.pos_of_ne_zero</span> <span class="n">nz</span><span class="o">)]</span><span class="bp">;</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">mk_zero</span> <span class="o">:</span> <span class="n">mkRat</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">unfold</span> <span class="n">mkRat</span><span class="bp">;</span> <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
</code></pre></div>



<a name="307362919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307362919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307362919">(Nov 01 2022 at 17:21)</a>:</h4>
<p>I love this!</p>



<a name="307598228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307598228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307598228">(Nov 02 2022 at 18:58)</a>:</h4>
<p>So update:</p>
<p>1) I hope my adventures here are useful -- aspirationally, I'd like to post a PR, but this may be beyond my capabilities at current levels of learning; less aspirationally, I'm hopeful that my struggles here in the differences between Lean 4 <code>Std4</code> and <code>mathlib</code> are helpful for the eventual refactor and reconciliation -- if this is all distracting, I'm happy to self-mute<br>
 2) I realize now most of the heavy lifting in the core lemmas in <code>mathlib</code> is done in theorems like <code>add_def</code> that prove the behavior and invariants of the core operations and those go through <code>lift_binop_eq</code>which has a particularly hairy signature...<br>
3) The signature of <code>rat</code> is in terms of <code>int</code>/<code>nat</code> with appropriate constraints on nonzero denominator, but the constructor goes <code>mk_pnat</code> and most of the <code>/.</code> heavy lifting is through <code>rat.mk</code> that is <code>int -&gt; int -&gt; rat</code>, and addressing that variation to Lean 4 makes signature modification for <code>lift_binop_eq</code> particularly hairy (that theorem assumes everything is <code>int</code>)</p>
<p>I <em>think</em> the pathway here is to recreate the <code>mathlib</code> equivalent for an <code>Int -&gt; Int -&gt; Rat</code> constructor,  &amp; try to port <code>lift_binop_eq</code> but happy to take any feedback....</p>



<a name="307600440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Hints%20for%20foundations%20for%20lemmas%20on%20Rat/near/307600440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Hints.20for.20foundations.20for.20lemmas.20on.20Rat.html#307600440">(Nov 02 2022 at 19:11)</a>:</h4>
<p>(FWIW, I think that core <code>Std4.Rat</code> should have the helper APIs and invariant lemmata on the core operations, and with that in place, proving the various algebraic lemmata  in, say <code>Std4.Rat.Basic</code> would be pretty trivial.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
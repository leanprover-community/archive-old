---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html">✔ Has the do notation changed recently?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264749014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264749014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Hunter <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264749014">(Dec 13 2021 at 18:21)</a>:</h4>
<p>Hello all, a piece of code stopped working since a few days ago after I updated Lean4 to the latest nightly (2021-12-13).<br>
<a href="https://github.com/tjhunter/advent_of_code_lean4_2021/blob/main/MyAdvent/AdventStd.lean#L72">https://github.com/tjhunter/advent_of_code_lean4_2021/blob/main/MyAdvent/AdventStd.lean#L72</a></p>
<p>The error I am getting is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">configuring</span> <span class="n">tim_advent</span> <span class="mi">0</span><span class="bp">.</span><span class="mi">1</span>
<span class="bp">&gt;</span> <span class="n">LEAN_PATH</span><span class="bp">=././</span><span class="n">build</span> <span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">tjhunter</span><span class="bp">/.</span><span class="n">elan</span><span class="bp">/</span><span class="n">toolchains</span><span class="bp">/</span><span class="n">leanprover</span><span class="c1">--lean4---nightly/bin/lean -o build/MyAdvent/AdventStd.olean -c build/temp/MyAdvent/AdventStd.c ./MyAdvent/AdventStd.lean</span>
<span class="bp">./</span><span class="n">MyAdvent</span><span class="bp">/</span><span class="n">AdventStd.lean</span><span class="o">:</span><span class="mi">72</span><span class="o">:</span><span class="mi">83</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="bp">'</span><span class="k">do</span><span class="bp">'</span> <span class="kd">notation</span><span class="o">,</span> <span class="n">expected</span> <span class="n">type</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">monad</span> <span class="n">application</span>
  <span class="n">Std.HashMap</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>Am I missing something?</p>



<a name="264749250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264749250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264749250">(Dec 13 2021 at 18:23)</a>:</h4>
<p>You need to prefix it with <code>Id.run </code> now.</p>



<a name="264751062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264751062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264751062">(Dec 13 2021 at 18:37)</a>:</h4>
<p>See <a href="https://github.com/leanprover/lean4/issues/770">https://github.com/leanprover/lean4/issues/770</a> for the discussion that motivated this change.</p>



<a name="264751649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264751649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tim Hunter <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264751649">(Dec 13 2021 at 18:42)</a>:</h4>
<p>Clear, thanks. As suggested in the ticket, updating the error message with a suggestion to use <a href="http://Id.run">Id.run</a> will be much appreciated by new users like me.</p>



<a name="264751654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264751654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264751654">(Dec 13 2021 at 18:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="460889">Tim Hunter</span> has marked this topic as resolved.</p>



<a name="264752517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264752517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264752517">(Dec 13 2021 at 18:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="460889">Tim Hunter</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264751649">said</a>:</p>
<blockquote>
<p>Clear, thanks. As suggested in the ticket, updating the error message with a suggestion to use <a href="http://Id.run">Id.run</a> will be much appreciated by new users like me.</p>
</blockquote>
<p>Thanks for the suggestion. We will do it.</p>



<a name="264799376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264799376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264799376">(Dec 14 2021 at 02:32)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> With the elimination of pure do blocks, does that mean that <code>Option</code> can become a monad again? IIRC the issue was that uses of <code>Option A</code> in do blocks were supposed to be promoted to <code>Id (Option A)</code> rather than <code>OptionM A</code>, but without pure do block promotion I think there is no ambiguity here anymore.</p>



<a name="264799503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264799503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264799503">(Dec 14 2021 at 02:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> No. The problem with <code>Option</code> being a monad still exists. In fact, it would create the same problems the pure <code>do</code> caused that motivated this change.</p>



<a name="264799571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264799571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264799571">(Dec 14 2021 at 02:35)</a>:</h4>
<p>Could you elaborate? If the context of the <code>do</code> keyword has a known monad type, then everything else inside should be interpretable unambiguously</p>



<a name="264799656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264799656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264799656">(Dec 14 2021 at 02:36)</a>:</h4>
<p>so if you want <code>Option</code> as a monad you do <code>def bla : Option A := do ...</code> and if you want it as data you do <code>def bla : Option A := Id.run do ...</code></p>



<a name="264799926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264799926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264799926">(Dec 14 2021 at 02:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264799656">said</a>:</p>
<blockquote>
<p>so if you want <code>Option</code> as a monad you do <code>def bla : Option A := do ...</code> and if you want it as data you do <code>def bla : Option A := Id.run do ...</code></p>
</blockquote>
<p>The whole point of the pure <code>do</code> change (as I understand it) is to expressly prohibit using <code>do</code> with "data" objects like <code>Option</code> so that users don't accidently stick a <code>do</code> on a function like <code>bla</code> expecting it to return <code>Option A</code> when it instead does  functional programming control flow magic with <code>Option</code>.</p>



<a name="264800067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264800067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264800067">(Dec 14 2021 at 02:43)</a>:</h4>
<p>The design goal is that <code>do</code> will give you the nice error you see now for types that are meant to be data (e.g., <code>Option</code>) and work in the usual functional way with types that are supposed to be control (e.g., <code>OptionT</code>/<code>OptionM</code>).</p>



<a name="264800158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264800158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264800158">(Dec 14 2021 at 02:44)</a>:</h4>
<p>I do, however, think it would probably be a good idea to some form of data analogue of the control flow type-classes so one can still write functions that are polymorphic over such types (without them being treated like control flow).</p>



<a name="264800271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264800271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264800271">(Dec 14 2021 at 02:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> We didn't decide yet, but we must do it before we release the first official version early next year.<br>
One good news is that we have already made many combinators more friendly to strict languages like Lean. Examples:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">OrElse</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">orElse</span>  <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">Seq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">seq</span>  <span class="o">:</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">f</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span>

<span class="kd">class</span> <span class="n">SeqLeft</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">seqLeft</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">SeqRight</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">seqRight</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span>
</code></pre></div>



<a name="264800611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264800611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264800611">(Dec 14 2021 at 02:51)</a>:</h4>
<p>Ah, that's good to hear. (I take it that <code>OrElse</code> is triggered, including the lazy evaluation, when you write <code>a &lt;|&gt; b</code> where <code>a, b : OptionM A</code>?) I tripped on an eager evaluation issue on <code>option A</code> just a few days ago in lean 3, it's something you have to watch out for even though <code>macroInline</code> makes it mostly work</p>



<a name="264800920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264800920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264800920">(Dec 14 2021 at 02:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264800611">said</a>:</p>
<blockquote>
<p>Ah, that's good to hear. (I take it that <code>OrElse</code> is triggered, including the lazy evaluation, when you write <code>a &lt;|&gt; b</code> where <code>a, b : OptionM A</code>?) </p>
</blockquote>
<p>Yes, the <code>&lt;|&gt;</code> notation takes care of it.</p>
<blockquote>
<p>I tripped on an eager evaluation issue on <code>option A</code> just a few days ago in lean 3, it's something you have to watch out for even though <code>macroInline</code> makes it mostly work</p>
</blockquote>
<p>We also hit this issue in the past.</p>



<a name="264801793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264801793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264801793">(Dec 14 2021 at 03:01)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> Yes, this is a valid concern. I don't have a good mental model for new users, and the kinds of mistakes they make, and how incomprehensible our error messages are to them. We have been trying to improve the error messages, but sometimes the improvement requires a considerable amount of work and extra bookkeeping.</p>



<a name="264801941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264801941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264801941">(Dec 14 2021 at 03:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264800271">said</a>:</p>
<blockquote>
<p>One good news is that we have already made many combinators more friendly to strict languages like Lean.</p>
</blockquote>
<p>Since you brought up these signatures, I wanted to ask about the logic behind them. While I get the desire for lazy evaluation (and embedding said lazy evaluation into operators like <code>&lt;|&gt;</code>), changing the signatures of the type-classes themselves mean that a lot of already lazy monads (e.g., <code>IO</code> or <code>ReaderT</code>) become doubly lazy (and thus, I presume, less efficient).</p>
<p>What was the rational behind not defining something like a <code>LazyT</code>/<code>LazyM</code> and just using that as the base monad for types like <code>OptionM</code>:.For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">LazyT</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">Unit</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">LazyT.mk</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Unit</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyT</span> <span class="n">m</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span>
<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">LazyT.run</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">LazyT</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">()</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Monad</span> <span class="n">m</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monad</span> <span class="o">(</span><span class="n">LazyT</span> <span class="n">m</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">pure</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="n">a</span>
  <span class="n">bind</span> <span class="n">x</span> <span class="n">f</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">bind</span> <span class="n">x.run</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">|&gt;.</span><span class="n">run</span>

<span class="n">abbrev</span> <span class="n">LazyM</span> <span class="o">:=</span> <span class="n">LazyT</span> <span class="n">Id</span>
<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">LazyM.run</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">LazyM</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">OptionM</span> <span class="o">:=</span> <span class="n">OptionT</span> <span class="n">LazyM</span>
</code></pre></div>



<a name="264801976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264801976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264801976">(Dec 14 2021 at 03:03)</a>:</h4>
<p>One thing that I didn't see come up in the linked issue, which I would have suggested if it had come up in a question here, is to use <code>pure</code> when constructing a <code>Nat</code>, since the goal is actually <code>Id Nat</code> which doesn't have a multiplication</p>



<a name="264802057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802057">(Dec 14 2021 at 03:03)</a>:</h4>
<p>in general, I find automatic <code>pure</code> insertion to be a convenience feature that doesn't always work, and I would suggest to write <code>pure</code> explicitly when there are weird type errors</p>



<a name="264802159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802159">(Dec 14 2021 at 03:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264801793">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> Yes, this is a valid concern. I don't have a good mental model for new users, and the kinds of mistakes they make, and how incomprehensible our error messages are to them.</p>
</blockquote>
<p>I am a new user, if you need a newbie to provide feedback on error messages</p>



<a name="264802316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802316">(Dec 14 2021 at 03:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> the entirely problem is that it is unintuitive to new users (and as your example demonstrated even advanced users get caught up in its idiosyncrasies) who have limited understanding of monads and all that magic. They expect <code>do</code> to work just like a normal imperative language (which amazingly, in Lean, it most of the time does) and that is where all the confusion stems from.  The idea of a magic <code>Id</code> just makes the whole thing that much more complex.</p>



<a name="264802476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802476">(Dec 14 2021 at 03:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264801941">said</a>:</p>
<blockquote>
<p>changing the signatures of the type-classes themselves mean that a lot of already lazy monads (e.g., <code>IO</code> or <code>ReaderT</code>) become doubly lazy (and thus, I presume, less efficient).</p>
</blockquote>
<p>In my mental model of the compiler, this should not be any less efficient. It means that you have two lambdas instead of one, which means a compiled function with two arguments, one of which is a dummy argument. Lean can sometimes eliminate these dummy arguments, but they often make it to C; but LLVM definitely knows how to eliminate unused arguments, so they should not have any cost in the final compiled result.</p>



<a name="264802611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802611">(Dec 14 2021 at 03:09)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> </p>
<blockquote>
<p>become doubly lazy (and thus, I presume, less efficient).</p>
</blockquote>
<p>Not really, the compiler eliminates the overhead.</p>
<blockquote>
<p>What was the rational behind not defining something like a LazyT/LazyM</p>
</blockquote>
<p>It doesn't prevent common mistakes and counterintuitive behavior. For example, in the following code</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="bp">&lt;|&gt;</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">expensive</span><span class="bp">;</span> <span class="n">b</span>
</code></pre></div>
<p><code>expensive</code> is only executed when <code>a</code> fails. This is not true for strict languages with the usual <code>orElse</code> type.<br>
With the new <code>orElse</code> type, we rely on the fact the compiler will not float <code>let</code> over lambdas.</p>



<a name="264802770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802770">(Dec 14 2021 at 03:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802476">said</a>:</p>
<blockquote>
<p>but LLVM definitely knows how to eliminate unused arguments, so they should not have any cost in the final compiled result.</p>
</blockquote>
<p>While it is true that LLVM/clang will generally be smart to inline these, the problem is that there are m any uses where this is irrelevant  For example, dynamically linked functions or functions called indirectly through pointers (the of latter which, as you might imagine, is quite common in functional programming languages).</p>



<a name="264802802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802802">(Dec 14 2021 at 03:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802159">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264801793">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> Yes, this is a valid concern. I don't have a good mental model for new users, and the kinds of mistakes they make, and how incomprehensible our error messages are to them.</p>
</blockquote>
<p>I am a new user, if you need a newbie to provide feedback on error messages</p>
</blockquote>
<p>Thanks, that is useful. If you find weird messages please create an issue on our repo. That being said, I am not sure you qualify as a newbie anymore, I have seen you posting advanced stuff :)</p>



<a name="264802951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802951">(Dec 14 2021 at 03:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802316">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> the entirely problem is that it is unintuitive to new users (and as your example demonstrated even advanced users get caught up in its idiosyncrasies) who have limited understanding of monads and all that magic. They expect <code>do</code> to work just like a normal imperative language (which amazingly, in Lean, it most of the time does) and that is where all the confusion stems from.  The idea of a magic <code>Id</code> just makes the whole thing that much more complex.</p>
</blockquote>
<p>If you want to make all actions "apparent", I think that means you have to give up the haskell style do notation <code>do act1; act2</code> in which <code>act1</code> can have monadic effects, and instead replace it with something like <code>do &lt;- act1; act2</code> which, like Rust's <code>?</code> operator, makes the fancy control flow explicit. I'm not actually proposing this, but it is worth considering since this seems like a conflict between the imperative and haskell-style traditions for how <code>do</code> should work.</p>



<a name="264802955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264802955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264802955">(Dec 14 2021 at 03:13)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> One clarification, in the message above "compiler" is referencing to the transformations performed by Lean, not LLVM.</p>



<a name="264803296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264803296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264803296">(Dec 14 2021 at 03:17)</a>:</h4>
<p>Personally, (having experience with haskell <code>do</code>,) I find <code>do act1; act2</code> to be clear enough for the case where <code>act1</code> and <code>act2</code> have effects, and requiring <code>do pure act1; pure act2</code> if you want to opt out of that behavior. Automatic <code>pure</code> insertion makes this syntax slightly ambiguous, which can be problematic when you want to return an <code>Option</code>, but I think asking the user to write <code>pure</code> explicitly in these cases is a reasonable compromise. (Note that it's usually a type error if you screw this up anyway, so lean still has your back in this scenario.)</p>



<a name="264804088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264804088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264804088">(Dec 14 2021 at 03:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802611">said</a>:</p>
<blockquote>
<p>It doesn't prevent common mistakes and counterintuitive behavior. For example, in the following code</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="bp">&lt;|&gt;</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">expensive</span><span class="bp">;</span> <span class="n">b</span>
</code></pre></div>
<p><code>expensive</code> is only executed when <code>a</code> fails. This is not true for strict languages with the usual <code>orElse</code> type.<br>
With the new <code>orElse</code> type, we rely on the fact the compiler will not float <code>let</code> over lambdas.</p>
</blockquote>
<p>Couldn't that still be handled by the macro/elaborator? Just using <code>LazyT</code> instead of changing the typeclass? For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">SeqRight</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">seqRight</span> <span class="o">:</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">β</span>

<span class="kd">notation</span><span class="o">:</span><span class="mi">60</span> <span class="n">a</span><span class="o">:</span><span class="mi">60</span> <span class="s2">" *&gt; "</span> <span class="n">b</span><span class="o">:</span><span class="mi">61</span> <span class="bp">=&gt;</span>
  <span class="n">LazyT.run</span> <span class="o">(</span><span class="n">SeqRight.seqRight</span> <span class="o">(</span><span class="n">LazyT.mk</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">LazyT.mk</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div>
<p>or for heterogenous operators like <code>HOrElse</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HOrElse</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">outParam</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">w</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">hOrElse</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">HOrElse</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">]</span> <span class="o">:</span> <span class="n">HOrElse</span> <span class="n">α</span> <span class="o">(</span><span class="n">LazyM</span> <span class="n">β</span><span class="o">)</span> <span class="n">γ</span> <span class="n">where</span>
  <span class="n">hOrElse</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">HOrElse.hOrElse</span> <span class="n">a</span> <span class="n">b.run</span>

<span class="kd">notation</span><span class="o">:</span><span class="mi">20</span> <span class="n">a</span><span class="o">:</span><span class="mi">21</span> <span class="s2">" &lt;|&gt; "</span> <span class="n">b</span><span class="o">:</span><span class="mi">20</span> <span class="bp">=&gt;</span>
  <span class="n">HOrElse.hOrElse</span> <span class="n">a</span> <span class="o">(</span><span class="n">LazyM.mk</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>



<a name="264804473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264804473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264804473">(Dec 14 2021 at 03:31)</a>:</h4>
<p>The <code>LazyT</code> idiom also enables the creation of a nice <code>lazy</code> macro for writing lazily evaluated code, e.g.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="s2">"lazy "</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">LazyM.mk</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">x</span>
<span class="n">macro</span> <span class="s2">"lazy_do "</span> <span class="n">x</span><span class="o">:</span><span class="n">doSeq</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="bp">``</span><span class="o">(</span><span class="n">LazyT.mk</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="bp">$</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="264804641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264804641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264804641">(Dec 14 2021 at 03:33)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> Your <code>&lt;|&gt;</code> macro seems to be assuming that the monad was built using <code>LazyT</code>. I have to go, but happy to explore the next time we meet online. Zulip is too inefficient to brainstorm this kind of encoding.</p>



<a name="264804815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264804815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264804815">(Dec 14 2021 at 03:35)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span>Ah, makes sense. Have a good night! Talk to you later! <span aria-label="goodnight" class="emoji emoji-1f31b" role="img" title="goodnight">:goodnight:</span></p>



<a name="264805583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264805583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264805583">(Dec 14 2021 at 03:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264803296">said</a>:</p>
<blockquote>
<p>Personally, (having experience with haskell <code>do</code>,) I find <code>do act1; act2</code> to be clear enough for the case where <code>act1</code> and <code>act2</code> have effects, and requiring <code>do pure act1; pure act2</code> if you want to opt out of that behavior.</p>
</blockquote>
<p>I'm sorry, but I am not sure I understand what you are getting at here. How does this relate to the discussion?</p>



<a name="264806075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264806075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264806075">(Dec 14 2021 at 03:49)</a>:</h4>
<p>You didn't spell out the issue you had with <code>Option</code> being a monad, but as I understand it the problem is that <code>do opt1; opt2</code> and <code>do pure opt1; opt2</code> do different things if <code>Option</code> is a monad (and <code>opt1, opt2 : Option A</code> and the expected type is <code>Option A</code>). The example in the issue is a variation on this where <code>do a</code> infers the type <code>Id Nat</code> for <code>a</code> when the <code>do</code> is in the <code>Id</code> monad, while the user was expecting it to have the type <code>Nat</code> (which it would have in <code>do pure a</code>).</p>



<a name="264806383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264806383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264806383">(Dec 14 2021 at 03:52)</a>:</h4>
<p>(I'm responding to <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264799926">your previous message</a> here, not the stuff about <code>&lt;|&gt;</code> laziness and <code>LazyT</code>, about which I have no opinion.)</p>



<a name="264809639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264809639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264809639">(Dec 14 2021 at 04:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264806075">said</a>:</p>
<blockquote>
<p>You didn't spell out the issue you had with <code>Option</code> being a monad, but as I understand it the problem is that <code>do opt1; opt2</code> and <code>do pure opt1; opt2</code> do different things if <code>Option</code> is a monad (and <code>opt1, opt2 : Option A</code> and the expected type is <code>Option A</code>).</p>
</blockquote>
<p>That is certainly one of the problems, though it is not one I had in mind. An example closer to what I was thinking is that things like <code>return none</code> would break in ways that would very much confuse users. However, you are right, that fact that <code>(do opt1; opt2) : Option a</code> could be accepted when the user is intending to treating <code>Option</code> as data but <code>opt1</code> is being interpreted as control is another issue.</p>
<p>On the <code>pure</code> front, I would probably advocate against <code>pure</code> auto-insertion altogether in <code>do</code> notation (and instead lead users to <code>return</code> as that is familiar to imperative programmers and avoids some of the more magical type errors that can arise due to <code>pure</code> auto-insertion).</p>



<a name="264809934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264809934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264809934">(Dec 14 2021 at 04:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264804641">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> Your <code>&lt;|&gt;</code> macro seems to be assuming that the monad was built using <code>LazyT</code>.</p>
</blockquote>
<p>When you see this, fyi, you are correct, my macro is wrong. The laziness needs to be nested deeper than I was adding it to provide the desired effect, so I will have to think a bit more about this.</p>



<a name="264811788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264811788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264811788">(Dec 14 2021 at 04:56)</a>:</h4>
<blockquote>
<p>An example closer to what I was thinking is that things like <code>return none</code> would break in ways that would very much confuse users.</p>
</blockquote>
<p>Could you define what it means to "break" here? What is the expected result? As I understand it, in an <code>Option</code> monad do block <code>return none</code> would not work (unless you are producing an <code>Option (Option A)</code>), and the correct way to "throw" in a do block is instead simply <code>none</code> (or <code>&lt;- none</code>).</p>



<a name="264812727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264812727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264812727">(Dec 14 2021 at 05:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> exactly, that is my point. One way to think of <code>do</code> notation is simple as a way to switch to imperative programming mode (like <code>by</code> switches to tactic mode). It is the way many new to Lean would think of it and I personally think that this is a fine conceptual model. Thus, I, as such a user, would see that my function returns "Option Nat" so would expect to <code>return none</code> from within my <code>do</code> block when I want to produce <code>none</code>. </p>
<p>Such a user may have no conception of monads or that <code>Option</code> is a monad, they simple see <code>do</code> as imperative block and see things like <code>OptionM</code> and <code>ExceptM</code> as ways of augmenting there function so that it can do things like fail or throw errors. They don't necessarily need to bridge the gap between <code>OptionM</code> the control flow tool and <code>Option</code> the data type. The goal of things like the <code>do</code> notation error is to help such users bridge the gap without need to understand all the monad magic.</p>



<a name="264812909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264812909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264812909">(Dec 14 2021 at 05:10)</a>:</h4>
<p>That sounds like an issue with the <code>return</code> command, not <code>Option</code></p>



<a name="264812955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264812955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264812955">(Dec 14 2021 at 05:10)</a>:</h4>
<p>It sounds like you want <code>return</code> to mean something different than it does</p>



<a name="264813024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813024">(Dec 14 2021 at 05:11)</a>:</h4>
<p>The semantics you want can easily be expressed as <code>return &lt;- act</code>, maybe you want this to be a separate keyword?</p>



<a name="264813029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813029">(Dec 14 2021 at 05:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> this isn't just about return, the same holds true for example with <code>do opt1; opt2</code> vs <code>do discard opt1; opt2</code></p>



<a name="264813132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813132">(Dec 14 2021 at 05:12)</a>:</h4>
<p>I'm kind of lost as to what you think this is supposed to mean</p>



<a name="264813149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813149">(Dec 14 2021 at 05:12)</a>:</h4>
<p>I know what haskell do notation does but you have some conflicting model and I don't know all the implications</p>



<a name="264813193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813193">(Dec 14 2021 at 05:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Sorry, I think I am sadly not making myself clear. My example was suppose to illustrate that such a user has a distinct separation between 'control' and 'data' -- thus they would be extremely confused that a data type is also control flow primitive.</p>



<a name="264813274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813274">(Dec 14 2021 at 05:14)</a>:</h4>
<p>it's not a control flow primitive, <code>do</code> and the syntactic constructs therein are the control flow primitives</p>



<a name="264813498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813498">(Dec 14 2021 at 05:16)</a>:</h4>
<p>It really stretches my comprehension to imagine that someone is writing lean <code>do</code> notation code without any idea of what a monad is, when the structure is lifted so directly from the haskell lineage</p>



<a name="264813562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813562">(Dec 14 2021 at 05:17)</a>:</h4>
<p>I'm sure you can muddle through it but the moment you need to understand anything about what's going on you have to address the monad stuff</p>



<a name="264813917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813917">(Dec 14 2021 at 05:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I don't agree. Lean's <code>do</code> notation looks just like modern imperative code. The only real oddity is the use of <code>&lt;-</code> for functions with side effects. Furthermore, monads can be thought of in two ways -- as control flow primitives or as properties of data types. Lean tends towards the former, Haskell tends towards the later. For example, Lean has no parallel to the <code>List</code> monad, because lists does not intuitive translate into a control flow structure (even though one can define a <code>Monad</code> instance for it).</p>



<a name="264813997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264813997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264813997">(Dec 14 2021 at 05:21)</a>:</h4>
<p>?? <code>List</code> can be made a monad in lean just as well as haskell</p>



<a name="264814065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814065">(Dec 14 2021 at 05:22)</a>:</h4>
<p>Call it <code>ListM</code> if it makes you feel better</p>



<a name="264814149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814149">(Dec 14 2021 at 05:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what control flow paradigm does <code>List</code> model in your view?</p>



<a name="264814160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814160">(Dec 14 2021 at 05:23)</a>:</h4>
<p>nondeterminism?</p>



<a name="264814170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814170">(Dec 14 2021 at 05:23)</a>:</h4>
<p>same as in haskell</p>



<a name="264814197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814197">(Dec 14 2021 at 05:23)</a>:</h4>
<p>well, not quite the same since haskell lists are maybe infinite</p>



<a name="264814319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814319">(Dec 14 2021 at 05:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what is the natural connection between the concept of a list and the concept of nondeterminism???</p>



<a name="264814361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814361">(Dec 14 2021 at 05:25)</a>:</h4>
<p>FYI, I have used the monad instance on <code>List</code> many times in lean 3 for e.g. proptest stuff</p>



<a name="264814442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814442">(Dec 14 2021 at 05:26)</a>:</h4>
<p>the list is the list of results of the computation, and you compose functions through foldMap</p>



<a name="264814562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814562">(Dec 14 2021 at 05:26)</a>:</h4>
<p>proptest meaning <code>do let a &lt;- [1:20]; let b &lt;- [1:20]; guard (a + b == b + a)</code></p>



<a name="264814575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814575">(Dec 14 2021 at 05:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Yes, obviously, the monad that can be defined using a list is useful; however, it is not intuitive related to the concept of a list. That is my point. It may have become that way to you do to your familiarity with functional programming, but someone without that expertise I highly doubt would ever draw that connection (without putting a lot of time in studying it).</p>



<a name="264814627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814627">(Dec 14 2021 at 05:28)</a>:</h4>
<p>After you read a monad tutorial this example will not seem that foreign, because it's usually one of the headliners</p>



<a name="264814643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814643">(Dec 14 2021 at 05:28)</a>:</h4>
<p>And yes, I think that users should read a monad tutorial in order to understand lean <code>do</code> notation</p>



<a name="264814655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814655">(Dec 14 2021 at 05:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I have used monads extensively  and done a lot of functional programming (and yes I have used the <code>List</code> monad). I still do not find it remotely intuitive. Useful, yes, intuitive no.</p>



<a name="264814670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814670">(Dec 14 2021 at 05:29)</a>:</h4>
<p>And given the general perception of Haskell code in the larger programming crowd, I do not think I am alone there.</p>



<a name="264814732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814732">(Dec 14 2021 at 05:30)</a>:</h4>
<p>Some monads aren't as crazy as that one, but if you really want to understand how things work you (the generic new lean user) should probably read up on monads</p>



<a name="264814766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814766">(Dec 14 2021 at 05:31)</a>:</h4>
<p>For the most part if you stick to <code>Option</code> and <code>Except</code> it's just error handling</p>



<a name="264814773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814773">(Dec 14 2021 at 05:31)</a>:</h4>
<p>so you learn the patterns for calling a function and throwing or catching</p>



<a name="264814815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814815">(Dec 14 2021 at 05:32)</a>:</h4>
<p>and <code>do act1; act2</code> is one of the patterns</p>



<a name="264814881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814881">(Dec 14 2021 at 05:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I feel like you are rating the simplicity of these concepts much higher than they general are to most people.</p>



<a name="264814938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814938">(Dec 14 2021 at 05:34)</a>:</h4>
<p>I'm not saying it's simple, I'm saying that you should front load at least a cursory understanding of monads when learning about lean do notation</p>



<a name="264814966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264814966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264814966">(Dec 14 2021 at 05:35)</a>:</h4>
<p>You are expecting users to acquire a very high level of understanding of the language before doing serious work. That is just not common in general use.</p>



<a name="264815047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815047">(Dec 14 2021 at 05:37)</a>:</h4>
<p>The alternative is to just get by with "it looks kind of like imperative code" and "Option/Except means failure", and then live with the fact that you might get errors you don't understand (and maybe this will be the trigger to learn more)</p>



<a name="264815133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815133">(Dec 14 2021 at 05:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264814938">said</a>:</p>
<blockquote>
<p>I'm saying that you should front load at least a cursory understanding of monads when learning about lean do notation</p>
</blockquote>
<p>And I'm saying the great thing about Lean is that you usually don't need to do that. I also saying there is much simpler understanding one can have of monads -- where one treats them just like control flow restrictions -- that requires virtually no understand of the formal concept of a monad at all. That is, use <code>OptionM</code> if your <code>do</code> code can fail, use <code>ExceptM</code> if your do code can <code>throw</code> excpetions, use <code>StateM</code> if there is some state you wish to keep track of, etc.</p>



<a name="264815162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815162">(Dec 14 2021 at 05:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264815047">said</a>:</p>
<blockquote>
<p>The alternative is to just get by with "it looks kind of like imperative code" and "Option/Except means failure", and then live with the fact that you might get errors you don't understand (and maybe this will be the trigger to learn more)</p>
</blockquote>
<p>The other alternative, which I am advocating (and which Lean currently does), is split the data from the control and then you will never get confusing errors and you can still do serious work without needing to fully understanding the theory behind everything.</p>



<a name="264815238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815238">(Dec 14 2021 at 05:41)</a>:</h4>
<p>I keep thinking about the Rust analogue here. <code>Option&lt;T&gt;</code> is just data, and it works with <code>?</code> (the control). I don't understand this "split the control from the data" thing since all types classify data. <code>OptionM A</code> is still just data</p>



<a name="264815317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815317">(Dec 14 2021 at 05:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264815238">said</a>:</p>
<blockquote>
<p>I keep thinking about the Rust analogue here. <code>Option&lt;T&gt;</code> is just data, and it works with <code>?</code> (the control).</p>
</blockquote>
<p><code>?</code> is essentially <code>liftOption</code>/<code>liftExcept</code> in Rust (i.e., it lifts data into control).</p>



<a name="264815323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815323">(Dec 14 2021 at 05:43)</a>:</h4>
<p><code>?</code> is lean's <code>&lt;- act</code></p>



<a name="264815370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815370">(Dec 14 2021 at 05:44)</a>:</h4>
<p>There is no lifting involved, it is performing a control flow operation</p>



<a name="264815377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815377">(Dec 14 2021 at 05:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264815323">said</a>:</p>
<blockquote>
<p><code>?</code> is lean's <code>&lt;- act</code></p>
</blockquote>
<p>How so? In my view, the closest analog to <code>&lt;- act</code> in Lean is <code>act()</code> in Rust.</p>



<a name="264815405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815405">(Dec 14 2021 at 05:45)</a>:</h4>
<p>I would say <code>act()</code> is like <code>act</code> and <code>act()?</code> is like <code>&lt;- act</code> or <code>do ... act; ...</code></p>



<a name="264815455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815455">(Dec 14 2021 at 05:46)</a>:</h4>
<p><code>act()</code> in rust doesn't throw</p>



<a name="264815544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815544">(Dec 14 2021 at 05:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> How? A function call <code>act()</code> in Rust evaluates to a value and is side-effecting. That is exactly what <code>&lt;- act</code> does in Lean. <code>x?</code> in Rust either evaluates to <code>x</code>'s value or throws its error. Just like <code>&lt;- liftExcept x</code> does in Lean.</p>



<a name="264815566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815566">(Dec 14 2021 at 05:49)</a>:</h4>
<p>I'm focusing on the error propagation case in rust, ignoring things like global state and panics so that <code>act()</code> with no arguments is a pure function</p>



<a name="264815665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815665">(Dec 14 2021 at 05:50)</a>:</h4>
<p>i.e. rust computations that map to <code>Option</code> or <code>Expect</code>, not <code>StateM</code></p>



<a name="264815677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815677">(Dec 14 2021 at 05:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'm not. The whole point is that Rust's functions are <em>im</em>pure (and thus would translate to monadic actions or functions of monadic actions), reducing them to such things would, in my view, be a degenerate case (similar to the ring where <code>0 = 1</code>).</p>



<a name="264815739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815739">(Dec 14 2021 at 05:52)</a>:</h4>
<p>Typical lean computations consist mainly of pure functions; those functions would still be pure if transliterated to rust</p>



<a name="264815755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815755">(Dec 14 2021 at 05:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> have you seen the Lean or Lake codebase?</p>



<a name="264815765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815765">(Dec 14 2021 at 05:52)</a>:</h4>
<p><span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="264815776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815776">(Dec 14 2021 at 05:53)</a>:</h4>
<p>We are talking about the <code>Option</code> monad here</p>



<a name="264815781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815781">(Dec 14 2021 at 05:53)</a>:</h4>
<p>yes there are more complicated monads</p>



<a name="264815783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815783">(Dec 14 2021 at 05:53)</a>:</h4>
<p>I was talking generally about monads and <code>do</code> notation. <code>Option</code> was just an example.</p>



<a name="264815838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815838">(Dec 14 2021 at 05:54)</a>:</h4>
<p>For complex monads auto-<code>pure</code> promotion isn't usually a problem</p>



<a name="264815852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815852">(Dec 14 2021 at 05:54)</a>:</h4>
<p><code>Option</code> is not just an example, it is the primary instance of "confusing control with data" that was your original issue</p>



<a name="264815865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264815865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264815865">(Dec 14 2021 at 05:55)</a>:</h4>
<p>I don't think there are similar issues with <code>MetaM</code></p>



<a name="264816288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264816288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264816288">(Dec 14 2021 at 06:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I feel like we are talking at cross paths and have completely different mental models of the topic. I think there should be a separate between control and data and I see monads primary as a control structure that operate on data types. Yes, these controls structures are implemented using the data versions, but they are conceptually distinct. I see <code>do</code> notation as means of writing imperative code which is then translated to its corresponding control structures (i.e., monads). </p>
<p>I think these concepts should be treated distinctly and not overlap. While data and control can be converted between one another, this should happen explicitly (e.g., through functions <code>mk</code>, <code>run</code>, etc.) not implicitly (through things like pure <code>do</code> notation, merging data and control, or the auto insertion of pure). </p>
<p>I also believe, and have the experience dealing with students (both when I was an undergrad and now as a teacher) that suggests this  creates less confusion, reduces errors, makes the ones that occur easier to diagnose, and simplifies the concepts for new learners.</p>



<a name="264816472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264816472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264816472">(Dec 14 2021 at 06:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Also, I hope I am not coming off as too antagonistic or argumentative. If I do, please alert me so I can tone it down.  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="264817280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817280">(Dec 14 2021 at 06:23)</a>:</h4>
<p>Any convenience feature like coercion is bound to be a tradeoff between ease of learning and ease of use. You mention "pure do notation, merging data and control, or the auto insertion of pure" but to me these are in different categories:</p>
<ul>
<li>"merging data and control", in the sense <code>Option = OptionM</code>, is not a problem in the absence of other coercion features. There are no syntactic or semantic problems that arise, and haskell (and lean 3) show that it is quite feasible to make this work.</li>
<li>"pure do notation" is an instance of coercion, that is, changing one type to another in the face of a type error. Personally I think this is a feature of marginal convenience which can be used to write misleading code (e.g. using pure <code>do</code> to create an <code>Option A</code>), so I'm not sad to see it go.</li>
<li>"auto insertion of pure" is also an instance of coercion, but it's usually not too problematic. But I can imagine code style guides of the future advising to avoid it, and I would avoid it first when diagnosing a type error.</li>
</ul>
<p>I can see that it's possible to have none of "my favorite types" have monad instances and instead just have dedicated types for everything, but I also don't see any reason to do so. <code>Option</code> and <code>OptionM</code> are the same thing and treating them the same is not misleading, it's a strength of type theory. To beat a rusty horse, why is it that Rust can get away with only one <code>Option&lt;T&gt;</code> type instead of <code>Option</code> and <code>OptionM</code>? It's used for both data (people put <code>Option</code> in data structures) and control (in functions returning <code>Option</code> using the <code>?</code> operator).</p>



<a name="264817660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817660">(Dec 14 2021 at 06:30)</a>:</h4>
<p>Re: argumentative, I'm fine with it but I think we're nearing saturation here, and we've already generated too much discussion for Leo to make use of. We'll probably just need to agree to disagree.</p>



<a name="264817686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817686">(Dec 14 2021 at 06:31)</a>:</h4>
<p>Can someone point me to a longer writeup that differentiates data from control? As far as I work, based on what data I have, I choose to do different things, often via casing. Having something like Option Int just tells me that, in python speak, I have a <code>int | None</code> so I better case on it. Similarly with <code>List</code> or <code>Set</code>.</p>



<a name="264817703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817703">(Dec 14 2021 at 06:31)</a>:</h4>
<p>I think that's the "data" viewpoint</p>



<a name="264817725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817725">(Dec 14 2021 at 06:31)</a>:</h4>
<p>The "control" viewpoint is that <code>OptionM</code> is a monad where you can throw a <code>none</code>-error</p>



<a name="264817805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817805">(Dec 14 2021 at 06:33)</a>:</h4>
<p>I see, and the <code>none</code> has no value of its own, just as a sentinel value of some sort of behavior that isn't tagged with any additional information. And it's up to the receiver of this <code>none</code> to choose what to do with it?</p>



<a name="264817808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817808">(Dec 14 2021 at 06:33)</a>:</h4>
<p>Alternatively, the "data" viewpoint is what you get from the constructors and recursor, and the "control" viewpoint is what you get from the monad instance</p>



<a name="264817828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817828">(Dec 14 2021 at 06:33)</a>:</h4>
<p>You wouldn't normally case on a <code>OptionM</code></p>



<a name="264817896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264817896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264817896">(Dec 14 2021 at 06:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264817725">said</a>:</p>
<blockquote>
<p>The "control" viewpoint is that <code>OptionM</code> is a monad where you can throw a <code>none</code>-error</p>
</blockquote>
<p>I would say its a type where you  can fail (via <code>failure</code>)</p>



<a name="264818767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264818767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264818767">(Dec 14 2021 at 06:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264817280">said</a>:</p>
<blockquote>
<p>I can see that it's possible to have none of "my favorite types" have monad instances and instead just have dedicated types for everything, but I also don't see any reason to do so. <code>Option</code> and <code>OptionM</code> are the same thing and treating them the same is not misleading, it's a strength of type theory. To beat a rusty horse, why is it that Rust can get away with only one <code>Option&lt;T&gt;</code> type instead of <code>Option</code> and <code>OptionM</code>? It's used for both data (people put <code>Option</code> in data structures) and control (in functions returning <code>Option</code> using the <code>?</code> operator).</p>
</blockquote>
<ol>
<li>
<p>"<code>Option</code> and <code>OptionM</code> are the same thing ." Not in my in my view. I see <code>Option</code> <code>OptionM</code> as distinct concepts, just as I see a natural number, an integer, and a bitfield as different concepts (even if they can all be represented as a string of bits).</p>
</li>
<li>
<p>On type thoery: its a strength of type theory because type theory is a not a paraconsistent logic and thus wants to keep its number of primitives limited so that it can more easily ensure consistency. This is not a problem in downstream abstractions (like programming) where having a large number of conceptual different (though implementation-equivalent types) is an asset. In fact, having a small number of distinguishable data types is often considered a disadvantage  in programming.</p>
</li>
<li>
<p>On Rust, as stated earlier, I disagree that Rust gets away with both. There is no conceptual distinction between data types used for control and data types used for data in Rust because the former doesn't exist. Control flow is not a first-order concept, it is part of the language. Control flow as data  (e.g., monads) is a concept largely unique to functional programming. Other languages just have data. Such data can include functions (or more precisely, procedures), as a function, by itself, is not control flow -- it is the invoking of the function (and generating its corresponding side effects) that constitutes control flow.</p>
</li>
</ol>
<p>But this is where I guess we have to agree to disagree -- we have kind of got into a bit repetitive back and forth at this point.  <span aria-label="laughter tears" class="emoji emoji-1f602" role="img" title="laughter tears">:laughter_tears:</span></p>



<a name="264827058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264827058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264827058">(Dec 14 2021 at 08:52)</a>:</h4>
<p>A practical question related to this - coming from scala, I was a bit puzzled that <code>Option</code> had <code>bind</code> but <code>do</code> did not work. Whatever the deeper reasons, is there any reason to prefer <code>Option</code> to <code>OptionM</code>, or would it be fine to just use <code>OptionM</code> where I would use <code>Option</code> in scala.</p>



<a name="264827254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264827254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264827254">(Dec 14 2021 at 08:54)</a>:</h4>
<p>I suppose the theorems one would like to use are proved for <code>List</code>, <code>Option</code> etc rather than their mondaic counterparts.</p>



<a name="264828848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264828848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264828848">(Dec 14 2021 at 09:09)</a>:</h4>
<p><span class="user-mention" data-user-id="266304">@Siddhartha Gadgil</span> <code>OptionM</code> should work fine wherever you want a monad. The Lean core also already has some theorems for monads in <a href="https://github.com/leanprover/lean4/blob/26a225e230e41de4c227bd2b51ee2fed304ccf25/src/Init/Control/Lawful.lean"><code>Init.Control.Lawful</code></a> and one can use <code>simp</code> to easily convert to and from the monadic counterparts, so it shouldn't create too much of hurdle for theorem proving.</p>



<a name="264830327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264830327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264830327">(Dec 14 2021 at 09:23)</a>:</h4>
<p>To chime in with my experience as mainly C++ programmer with a limited experience with functional languages.<br>
For a long time I treated <code>do</code> blocks exactly as a way to do imperative programming. I think is an amazing feature that you can write familiar for loops with mutable variables. Only when I started messing with meta programming I was forced to read up on monads a bit more carefully.</p>



<a name="264832942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264832942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264832942">(Dec 14 2021 at 09:48)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> Do you feel this is still true with this newest change? I'd say that any introduction to <code>do</code> that does not talk about what the <code>Id.run</code> in <code>Id.run do ...</code> actually <em>means</em> is... questionable. Though even if it just tells you to "always use <code>Id.run do</code> until we get to the monad chapter", that <em>still</em> avoids any confusion with a potential <code>Option</code> monad.</p>



<a name="264833873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264833873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264833873">(Dec 14 2021 at 09:57)</a>:</h4>
<p>Ultimately the issue here (to me) seems to come down to two conflicting views of <code>do</code>, one being that it "should just work like imperative code up to a certain complexity" and the other that "users should have to know about what a monad is and what it does to use it properly"? And both views sound perfectly valid from my point of view, the first one would make writing Lean for newbies easier and force them to take a look at the details later like e.g. <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> described and the second one would force this threshold upon new users but once you get it everything past that is easy. So I'd say it essentially comes down to how the learning curve for Lean 4 should look?</p>



<a name="264834257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264834257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264834257">(Dec 14 2021 at 10:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> I still do not know how I feel about this change. I didn't switch to the latest version because of this reason(and because some problems with lake).<br>
I agree that introducing <code>Id.run do</code> without talking what <code>Id.run</code> is really bad. However, the necessity of adding <code>do</code> when you want to just have <code>let mut ...</code> was already a bit hard to swallow and feels a bit like java's <code>public static void main</code>. Being forced to write <code>Id run do</code> is definitely going in the java direction.</p>



<a name="264836039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264836039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264836039">(Dec 14 2021 at 10:20)</a>:</h4>
<p>For example, I'm still do not fully understand how for loop with mutable variables work.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">10</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">i</span>
  <span class="n">s</span>
</code></pre></div>
<p>Inside of the for loop you are in a state monad holding <code>s</code>, right? Why do you need to spell out <code>Id</code> monad explicitly but not the monad in the for loop. Due to my lack of understanding of the inner workings I find this a bit confusing.</p>



<a name="264836331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264836331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264836331">(Dec 14 2021 at 10:23)</a>:</h4>
<p>Ah, that is a good example. There is nothing "natural" about using imperative programming inside a purely functional language, so you should think of (the first) <code>do</code> as entering a "domain-specific language". At the second <code>do</code> you are already inside the DSL, so no need to re-specify the monad; it's just part of the <code>for</code> syntax.</p>



<a name="264836789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264836789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264836789">(Dec 14 2021 at 10:27)</a>:</h4>
<p>Good way to think about it! Maybe switching to the python's <code>for i in [0:10]:</code> would remove this confusion. Not sure if I like the look of <code>[0:10]:</code> though. Is it actually necessary to have a trailing symbol like <code>do</code> or <code>:</code> in <code>for</code> notation?</p>



<a name="264863074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264863074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264863074">(Dec 14 2021 at 14:15)</a>:</h4>
<p>What would the one line version look like?</p>



<a name="264864999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264864999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264864999">(Dec 14 2021 at 14:29)</a>:</h4>
<blockquote>
<p>What would the one line version look like?</p>
</blockquote>
<p>What is wrong with: <code>for i in [0:10]  (f i)</code> ?</p>



<a name="264865566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264865566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264865566">(Dec 14 2021 at 14:32)</a>:</h4>
<p>That won't work without a delimiter. You don't want to apply <code>(f i)</code> to <code>[0:10]</code>.</p>



<a name="264865628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264865628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264865628">(Dec 14 2021 at 14:33)</a>:</h4>
<p>How does it know what the assignment is? The one liner is a strange example because you can just express it purely as a fold, no need for a mut var</p>



<a name="264866913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264866913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264866913">(Dec 14 2021 at 14:40)</a>:</h4>
<p>I'd agree that the <code>do</code> delimiter in the <code>for</code> loop is a bit confusing if you don't already know how to interpret it but a delimiter like <code>:</code> would (to me) feel  out of place as well compared to the rest of the Lean syntax</p>



<a name="264869005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869005">(Dec 14 2021 at 14:54)</a>:</h4>
<p>The do in for is not that confusing if you know the other confusing use of do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">7</span>
  <span class="k">do</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">3</span>
  <span class="n">pure</span> <span class="n">x</span>
</code></pre></div>



<a name="264869084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869084">(Dec 14 2021 at 14:54)</a>:</h4>
<p>Note that <code>do x</code> is of course completely different than <code>(do x)</code>. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="264869111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869111">(Dec 14 2021 at 14:54)</a>:</h4>
<p>Hm, I had absolutely no idea that <code>do</code>'s could have different semantics. And I suspect this is not very good from a standpoint of programming languages design (taking the fact that I was surprised by it, for instance).<br>
I was approaching <code>do</code>'s with the same spirit that Tomas pointed out: telling Lean that I wanted to use mutable variables in a more imperative style. Would it be too radical to propose different keywords for such usages of <code>do</code>?</p>



<a name="264869260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869260">(Dec 14 2021 at 14:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264869005">said</a>:</p>
<blockquote>
<p>The do in for is not that confusing if you know the other confusing use of do:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">7</span>
  <span class="k">do</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">3</span>
  <span class="n">pure</span> <span class="n">x</span>
</code></pre></div><br>
</p>
</blockquote>
<p>isn't the do here just a noop?</p>



<a name="264869396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869396">(Dec 14 2021 at 14:56)</a>:</h4>
<p>At least the result is just 24 as I would expect if the do wasnt there...</p>



<a name="264869400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869400">(Dec 14 2021 at 14:56)</a>:</h4>
<p>Yes, it doesn't do anything.  The interesting thing is that is expanded into the parent do, so you can assign variables etc., which you couldn't do if that do was a term.</p>



<a name="264869643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264869643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264869643">(Dec 14 2021 at 14:58)</a>:</h4>
<p>I approached <code>do</code> like Haskell <code>do</code> but with <code>mut</code> and <code>for</code> + a bit more implicit stuff and that has worked quite well so far.</p>



<a name="264870066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870066">(Dec 14 2021 at 15:00)</a>:</h4>
<p>it's not completely a no-op, right? I would expect that it is a scope, so that <code>let y := 37</code> inside the inner <code>do</code> is no longer valid outside it</p>



<a name="264870199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870199">(Dec 14 2021 at 15:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">7</span>
  <span class="k">do</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">3</span>
     <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">42</span>
  <span class="n">pure</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p><span aria-label="smirk" class="emoji emoji-1f60f" role="img" title="smirk">:smirk:</span></p>



<a name="264870228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870228">(Dec 14 2021 at 15:01)</a>:</h4>
<p>A noop indeed, the wonders of <code>do</code>.</p>



<a name="264870297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870297">(Dec 14 2021 at 15:01)</a>:</h4>
<p>maybe it should be called <code>don't</code></p>



<a name="264870724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870724">(Dec 14 2021 at 15:04)</a>:</h4>
<p>Maybe we could make the distinction between monadic <code>do</code> and pure <code>do</code> notation both more apparent and easy to understand if we have something like an <code>imp</code> (as in imperative) keyword that desugars to <code>Id.run do</code>. That way the new users don't have to care about <code>Id.run do</code> but the pure and impure do blocks are still clearly different.</p>



<a name="264870813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870813">(Dec 14 2021 at 15:05)</a>:</h4>
<p>that was already proposed in the GH issue under the name <code>puredo</code></p>



<a name="264870857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870857">(Dec 14 2021 at 15:05)</a>:</h4>
<p>(In case anybody with commit access is reading this: please don't remove or neuter the nested do, it's useful when you're writing doElem-macros.  Though renaming it might reduce the confusion.)</p>



<a name="264870990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264870990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264870990">(Dec 14 2021 at 15:06)</a>:</h4>
<p>For macro use it could be renamed to <code>do%</code> or something</p>



<a name="264871063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264871063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264871063">(Dec 14 2021 at 15:06)</a>:</h4>
<p>but I'm in no hurry to change anything here. It's mostly just a useless oddity</p>



<a name="264871227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264871227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264871227">(Dec 14 2021 at 15:08)</a>:</h4>
<p>On weird error messages, this one used to say something along the lines of "can't use &lt;- outside of a do":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">myFun</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">q</span> <span class="bp">←</span> <span class="o">(</span><span class="mi">10</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="n">n</span> <span class="bp">+</span> <span class="n">q</span>
</code></pre></div>
<p>Now it underlines the <code>←</code> in red and says <code>expected '|'</code> <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="264871451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264871451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264871451">(Dec 14 2021 at 15:09)</a>:</h4>
<p>That error message is technically correct, although it should probably say "... <code>or ':='</code>"</p>



<a name="264871862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264871862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264871862">(Dec 14 2021 at 15:12)</a>:</h4>
<p><code>:=</code> indeed works, but <code>|</code> seems to require a bit more gymnastic (which I still couldn't figure out)</p>



<a name="264871952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264871952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264871952">(Dec 14 2021 at 15:12)</a>:</h4>
<p>it's talking about definitions like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">q</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">q</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="n">q</span> <span class="mi">0</span>
</code></pre></div>



<a name="264872353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264872353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Taucher <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264872353">(Dec 14 2021 at 15:15)</a>:</h4>
<p>Taking a different direction to understand the use of <code>monoids</code>, <code>do</code> and such. </p>
<p>Is there a way to just draw the Abstract Syntax Tree with the type annotations so that it could be understood that way?</p>



<a name="264872436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264872436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264872436">(Dec 14 2021 at 15:16)</a>:</h4>
<p>Ah, then Lean was expecting me to define a function <code>q</code>? That's way off of what I wanted to do. I just wanted to point out that I preferred the previous message talking about the impossibility of using <code>←</code></p>



<a name="264872637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264872637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264872637">(Dec 14 2021 at 15:17)</a>:</h4>
<p><span class="user-mention" data-user-id="366057">@Eric Taucher</span>  The easiest way to get a sense for how do compilation works is to <code>#print</code> the examples</p>



<a name="264872816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264872816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264872816">(Dec 14 2021 at 15:18)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> Yes, it would make sense to add <code>let x &lt;- t; e</code> to the grammar just for the purpose of better error messages</p>



<a name="264872832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264872832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264872832">(Dec 14 2021 at 15:18)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span>  The error message hasn't changed, you're mixing this up with <code>let q := ← 10</code> which did and still gives the helpful error message.</p>



<a name="264873174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264873174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264873174">(Dec 14 2021 at 15:21)</a>:</h4>
<p>Oh, thanks!</p>



<a name="264876317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264876317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264876317">(Dec 14 2021 at 15:41)</a>:</h4>
<p>I've created <a href="https://github.com/leanprover/lean4/issues/874">this issue</a> as proposed by Leo</p>



<a name="264876359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264876359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264876359">(Dec 14 2021 at 15:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264872637">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="366057">Eric Taucher</span>  The easiest way to get a sense for how do compilation works is to <code>#print</code> the examples</p>
</blockquote>
<p>Yes it works quite well, but it failed me when I tried to figure out what is the inferred monad in <code>ForIn</code> when you write the simple for loop with a mutable variable.</p>
<p>I still do not know what that monad is and I want to find out :)</p>



<a name="264876736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264876736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264876736">(Dec 14 2021 at 15:44)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> The monad doesn't actually change. Instead, the body of the for loop is compiled to something like <code>a -&gt; m a</code> and passed to the <code>ForIn</code> function</p>



<a name="264876759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264876759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264876759">(Dec 14 2021 at 15:44)</a>:</h4>
<p>Haskell Wiki's type class o pedia goes into some nice detail about the type classes that are around in Lean (and also some that arent yet) <a href="https://wiki.haskell.org/Typeclassopedia">https://wiki.haskell.org/Typeclassopedia</a></p>
<p>The quick explanation is  that it's "just" a type with two operations (<code>pure</code> aka <code>return</code> and <code>bind</code> aka <code>&gt;&gt;=</code> plus a resulting sequence operation aka <code>&gt;&gt;</code>) which you can compose to get lots of interesting behaviour</p>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span></p>



<a name="264876814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264876814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264876814">(Dec 14 2021 at 15:44)</a>:</h4>
<p>(it's a little more complicated than that because you can also early return from a for loop and the monad result reflects this)</p>



<a name="264876918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264876918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264876918">(Dec 14 2021 at 15:45)</a>:</h4>
<p>The type <code>a</code> in the <code>forIn</code> depends on what <code>let mut</code> are in scope and changed in the loop</p>



<a name="264877255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264877255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264877255">(Dec 14 2021 at 15:47)</a>:</h4>
<p>It looks like I was thinking about <code>ForIn</code> with mutable variables in an incorrect way. My expectation was that it creates <code>StateM</code> with mutable variables as the state.</p>



<a name="264877638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264877638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264877638">(Dec 14 2021 at 15:50)</a>:</h4>
<p>There are some parts of the inner function of a <code>forIn</code> that could be represented with a monad transformer, but it would mess up type inference inside the block to actually change the monad, because it is an implementation detail, the user still wants to be in whatever monad they were in to begin with</p>



<a name="264877908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264877908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264877908">(Dec 14 2021 at 15:52)</a>:</h4>
<p>Plus, it is more flexible for the compiler to just thread the arguments around rather than using some <code>getRef</code> and <code>setRef</code> stuff</p>



<a name="264878005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264878005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264878005">(Dec 14 2021 at 15:53)</a>:</h4>
<p>(this is roughly analogous to how LLVM prefers all its variables to be in SSA registers rather than memory)</p>



<a name="264888800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264888800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264888800">(Dec 14 2021 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264871227">said</a>:</p>
<blockquote>
<p>On weird error messages, this one used to say something along the lines of "can't use &lt;- outside of a do":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">myFun</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">q</span> <span class="bp">←</span> <span class="o">(</span><span class="mi">10</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="n">n</span> <span class="bp">+</span> <span class="n">q</span>
</code></pre></div>
<p>Now it underlines the <code>←</code> in red and says <code>expected '|'</code> <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>
</blockquote>
<p>Pushed a fix for this issue. It now produces <code>expected ':=' or '|'</code>.</p>



<a name="264891923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264891923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264891923">(Dec 14 2021 at 17:16)</a>:</h4>
<p>I've closed <a href="https://github.com/leanprover/lean4/issues/874">this issue</a> then</p>



<a name="264892329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264892329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264892329">(Dec 14 2021 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264891923">said</a>:</p>
<blockquote>
<p>I've closed <a href="https://github.com/leanprover/lean4/issues/874">this issue</a> then</p>
</blockquote>
<p>Thanks.</p>



<a name="264901055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264901055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264901055">(Dec 14 2021 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264834257">said</a>:</p>
<blockquote>
<p>I agree that introducing <code>Id.run do</code> without talking what <code>Id.run</code> is really bad. However, the necessity of adding <code>do</code> when you want to just have <code>let mut ...</code> was already a bit hard to swallow and feels a bit like java's <code>public static void main</code>. </p>
</blockquote>
<p>I like to think of <code>Id.run do ...</code> as run the following imperative code in a pure context (no external state / no side effects). <code>OptionM.run do ...</code> then adds the ability to fail as a side effect, <code>StateM.run s do ....</code> adds some state, etc. I do think name <code>Id</code> is a little opaque to new users -- I would prefer something like <code>PureM</code> instead. A keyword like <code>pure_do</code> could also work, though I think special case syntax sugar just makes it hard to intuit how to swap in other monads like <code>OptionM</code> when you want a less than pure context. </p>
<p>On the <code>let mut ...</code> note, I agree that it is very verbose. I would suggest using <code>var</code> as the keyword instead.</p>



<a name="264914896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264914896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264914896">(Dec 14 2021 at 19:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264814319">said</a>:</p>
<blockquote>
<p>what is the natural connection between the concept of a list and the concept of nondeterminism???</p>
</blockquote>
<p>A small digression: When I was learning Haskell, at some point I thought it would be interesting to try and implement some concepts from SICP. One project is the <code>amb</code> ("ambivalence") operator, which lets you do backtracking search, and after a couple hours of experimentation writing a monad for this and then simplifying what I had, I realized after all that the algebraic data type I got was just List with a crudely written bind operator.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">data</span> <span class="n">Amb</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">Choose</span> <span class="o">{</span> <span class="n">choice</span> <span class="o">::</span> <span class="n">x</span><span class="o">,</span> <span class="n">failure</span> <span class="o">::</span> <span class="o">(</span><span class="n">Amb</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="bp">|</span> <span class="n">Failed</span>
</code></pre></div>
<p>This in some way relies on laziness, though, and it's probably better to think of it as being a <em>co</em>inductive type (well, unless you want to make sure an <code>Amb</code> computation does indeed eventually end in <code>Failed</code> if you keep backtracking).  The <code>failure</code> case is not supposed to be evaluated unless you need it -- it's meant to be the continuation for backtracking.</p>
<p>I wasn't originally sharing this to make any particular point, but I guess I hadn't really appreciated how Lean's list monad is more eager than you'd want for this application, so it's not so useful for nondeterminism when you want <em>some</em> answer instead of <em>all</em> answers.  (The list monad is still great for list comprehensions, though.)</p>



<a name="264926776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264926776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264926776">(Dec 14 2021 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264901055">said</a>:</p>
<blockquote>
<p>On the <code>let mut ...</code> note, I agree that it is very verbose. I would suggest using <code>var</code> as the keyword instead.</p>
</blockquote>
<p>I second that. Or simply <code>mut</code> instead of <code>let mut</code></p>



<a name="264944449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/%E2%9C%94%20Has%20the%20do%20notation%20changed%20recently%3F/near/264944449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F.html#264944449">(Dec 14 2021 at 23:31)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> just to clarify, my point wasn't that the connection didn't exist, but that the connection is not intuitive and it is largely just a result of the fact that they happen to share the same structure / representation than there being any real  conceptually connection. </p>
<p>It is kind of like Frege's distinction between "sense" and "reference". Just because two concepts have the same representation (the same "referent" in the analogy) doesn't mean they are the same concept (are used in the same "sense"). </p>
<p>One example of this in Lean already is the distinction between <code>Sum</code> and <code>Except</code>. In Haskell, these are both <code>Either</code> but in Lean they are distinct because <code>Sum</code> does not come with  a strict connotation of one side being an error and the other side being a value whereas <code>Except</code> does impose that distinction.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Float.2Efloor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html">Float.floor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257821615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257821615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257821615">(Oct 16 2021 at 10:41)</a>:</h4>
<p>Is there some kind of flooring function for <code>Float</code> (preferably returning a <code>Nat</code>)?<br>
I'm trying and struggling to express the <a href="https://en.wikipedia.org/wiki/Pairing_function#Inverting_the_Cantor_pairing_function">inverse to Cantor's pairing function</a>.</p>



<a name="257821699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257821699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257821699">(Oct 16 2021 at 10:42)</a>:</h4>
<p>Whatever does <code>Float</code> have to do with Cantor's pairing function? You know that there are infinitely many naturals but only finitely many floats, right?</p>



<a name="257821822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257821822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257821822">(Oct 16 2021 at 10:45)</a>:</h4>
<p>The <em>inverse</em> to Cantor's pairing function requires a square root and a floor. So I was just looking for something in Lean 4 that allows me to take a square root.<br>
I'm not trying to prove any theorems about the definition.</p>



<a name="257821950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257821950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257821950">(Oct 16 2021 at 10:47)</a>:</h4>
<p>The inverse to Cantor's pairing function does not <em>require</em> floats (or reals). Your reference for it does. Just use <code>nat.sqrt</code>. Port it from Lean 3, I doubt it's in Lean 4 yet but it would be a fun exercise.</p>



<a name="257822149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> František Silváši <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822149">(Oct 16 2021 at 10:50)</a>:</h4>
<p>For <code>floor</code> you can always cheat if you don't mind the linear complexity. <code>def poorMansFloor (x : Float) := x.toString.takeWhile (·≠'.')</code></p>



<a name="257822393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822393">(Oct 16 2021 at 10:55)</a>:</h4>
<p>Just glancing over the Wikipedia ref you posted, it seems that the issue is that given a natural <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> you want to find <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z=\pi(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>. The definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is "some triangular number, + y", and the triangular number is the largest triangular number which is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\leq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>. So what you _really_ need is a good algorithm to find the largest triangular number (i.e. number of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>w</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">w(w+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>) which is at most <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>. So you need to find the largest natural <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>w</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>≤</mo><mn>8</mn><mi>z</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(2w+1)^2\leq 8z+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. You don't need floats or reals for that, you could knock up a dumb algorithm easily and a smarter algorithm with some work.</p>



<a name="257822400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xubai Wang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822400">(Oct 16 2021 at 10:55)</a>:</h4>
<p>You can also use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Float.toNat</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">x.toUInt64.toNat</span>
</code></pre></div>
<p>but it seems that <code>Float</code> is not meant for mathematical use.</p>



<a name="257822479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822479">(Oct 16 2021 at 10:56)</a>:</h4>
<p>For example you could start with 1 and then keep adding powers of 2 and backtrack when you go over.</p>



<a name="257822507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822507">(Oct 16 2021 at 10:57)</a>:</h4>
<p>(the dumb algorithm is just to start with 1 and then keep adding 2 until you go over)</p>



<a name="257822627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822627">(Oct 16 2021 at 10:59)</a>:</h4>
<p>FYI the inverse to cantor's pairing function is implemented in lean 3, see <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.unpair/src">src#nat.unpair</a></p>



<a name="257822736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822736">(Oct 16 2021 at 11:00)</a>:</h4>
<p>also <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.sqrt/src">src#nat.sqrt</a> if you are interested in how to do sqrt without floats</p>



<a name="257822752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822752">(Oct 16 2021 at 11:00)</a>:</h4>
<p>Looking at the Lean code that looks to me at first sight like it's a different bijection to the one on the Wikipedia page.</p>



<a name="257822755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822755">(Oct 16 2021 at 11:00)</a>:</h4>
<p>Thanks for all the feedback <span aria-label="blush" class="emoji emoji-1f60a" role="img" title="blush">:blush:</span><br>
My purpose for this is really just to have a method for iterating over all tuples in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>26</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^{26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">26</span></span></span></span></span></span></span></span></span></span></span></span>.<br>
So I thought a generalized inverse pairing function would do the job :D</p>



<a name="257822789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822789">(Oct 16 2021 at 11:01)</a>:</h4>
<p>Oh, actually that's true, this is the box-shaped bijection, not the diagonal one. It just changes a couple constants</p>



<a name="257822880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822880">(Oct 16 2021 at 11:02)</a>:</h4>
<p>Note that for high dimensions, iterating the unpairing function results in (inverse) superexponential growth, so you get really biased coverage</p>



<a name="257822885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822885">(Oct 16 2021 at 11:02)</a>:</h4>
<p>Awesome! <code>unpair</code> is perfect for my purposes.</p>



<a name="257822930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822930">(Oct 16 2021 at 11:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Float.2Efloor/near/257822880">said</a>:</p>
<blockquote>
<p>Note that for high dimensions, iterating the unpairing function results in (inverse) superexponential growth, so you get really biased coverage</p>
</blockquote>
<p>What does that mean?</p>



<a name="257822974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257822974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257822974">(Oct 16 2021 at 11:04)</a>:</h4>
<p>The Lean bijection is more convenient than the Wikipedia definition because you don't need "largest odd integer whose square is &lt;= n", you need "largest integer whose square is &lt;= n" , and there's already a name for that.</p>



<a name="257823103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823103">(Oct 16 2021 at 11:06)</a>:</h4>
<p>If you map <code>n0, ..., n25</code> to <code>(((n0, n1), ... n25)</code> then if each <code>ni</code> is O(k) then <code>(n0, n1)</code> is O(k^2), <code>((n0, n1), n2)</code> is O((k^2)^2), and so on so that <code>(((n0, n1), ... n25)</code> is O(k^(2^25))</p>



<a name="257823147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823147">(Oct 16 2021 at 11:07)</a>:</h4>
<p>Which means that if you won't hit (3,3,3, ..., 3) until about 3^(2^25)</p>



<a name="257823241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823241">(Oct 16 2021 at 11:08)</a>:</h4>
<p>Hmmm... I guess I didn't consider the number of combinations <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="257823262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823262">(Oct 16 2021 at 11:09)</a>:</h4>
<p>A much more balanced way to hit the numbers is to convert every number into binary and then read a sequence like <code>101,10,111,...,1000</code> as a number written in ternary on the alphabet <code>0 1 ,</code></p>



<a name="257823343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823343">(Oct 16 2021 at 11:10)</a>:</h4>
<p>I think that is within a constant factor of optimal; you can do a bit better to encode the fact that there are exactly 25 <code>,</code>'s</p>



<a name="257823358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823358">(Oct 16 2021 at 11:11)</a>:</h4>
<p>but depending on what you are doing that may or may not be important</p>



<a name="257823449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823449">(Oct 16 2021 at 11:12)</a>:</h4>
<p>Ok now I'm not sure if we're talking about the same thing <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span><br>
I have a function with 26 inputs <code>f (a b c ... x y z : Nat) : Int</code> and would like to systematically go through all input combinations (I'm aware that there are infinitely many).</p>



<a name="257823459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823459">(Oct 16 2021 at 11:12)</a>:</h4>
<p>Yes, that's what I'm talking about too</p>



<a name="257823477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823477">(Oct 16 2021 at 11:13)</a>:</h4>
<p>I'm pointing out that within such functions, there is still a notion of optimality, where we ask that for small inputs we want small outputs</p>



<a name="257823542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823542">(Oct 16 2021 at 11:14)</a>:</h4>
<p>you get okay results with iterated unpairing if you split the coordinates in a balanced way</p>



<a name="257823565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823565">(Oct 16 2021 at 11:14)</a>:</h4>
<p>Ahhh, now I get it</p>



<a name="257823594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823594">(Oct 16 2021 at 11:15)</a>:</h4>
<p>for a lot of theoretical purposes, it literally doesn't matter at all what the growth rate of the function is, in which case iterated unpairing is the simplest implementation</p>



<a name="257823612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823612">(Oct 16 2021 at 11:15)</a>:</h4>
<p>and in fact that's what mathlib does in its <code>encodable</code> instances</p>



<a name="257823617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823617">(Oct 16 2021 at 11:15)</a>:</h4>
<p>Now I just have to figure out how to convert <code>Nat</code> into a list of ternary digits</p>



<a name="257823663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823663">(Oct 16 2021 at 11:16)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/encodable.encode_list/src">src#encodable.encode_list</a></p>



<a name="257823722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823722">(Oct 16 2021 at 11:17)</a>:</h4>
<p>see <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.digits/src">src#nat.digits</a> for converting a nat into a list of digits</p>



<a name="257823796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823796">(Oct 16 2021 at 11:18)</a>:</h4>
<p>Another variation is the high-dimensional analogue of cantor's bijection, where you iterate over the level sets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>x</mi><mn>25</mn></msub><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x_0+x_1+x_2+...+x_{25}=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">25</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p>



<a name="257823818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823818">(Oct 16 2021 at 11:19)</a>:</h4>
<p>I think you need inverse nth roots to express the inverse function though</p>



<a name="257823898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257823898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257823898">(Oct 16 2021 at 11:20)</a>:</h4>
<p>Iterate over max&lt;=k rather than sum&lt;=k to make the inverse function nicer</p>



<a name="257824095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824095">(Oct 16 2021 at 11:23)</a>:</h4>
<p>Actually, I don't get it ....<br>
If I have a natural number <code>n</code> that I want to convert into a 26-tuple <code>(a, b, c, ..., x, y, z)</code>, I first interpret <code>n</code> as ternary over symbols <code>0</code>, <code>1</code> and <code>,</code>. Let's say <code>n = 01,1,001</code>. How do I extract <code>a</code> to <code>z</code> from this? Since <code>n</code>'s representation doesn't contain 25 <code>,</code>s I don't know where to "split" <code>n</code>.</p>



<a name="257824211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824211">(Oct 16 2021 at 11:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/270676-lean4/topic/Float.2Efloor/near/257823898">said</a>:</p>
<blockquote>
<p>Iterate over max&lt;=k rather than sum&lt;=k to make the inverse function nicer</p>
</blockquote>
<p>I think you need the inverse nth root regardless, because the volume of a 26 dimensional box and a 26 dimensional simplex both grows as n^26</p>



<a name="257824230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824230">(Oct 16 2021 at 11:25)</a>:</h4>
<p>yes, but with the triangular one you need more than 26th root, you need "inverse of some random degree 26 polynomial"</p>



<a name="257824291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824291">(Oct 16 2021 at 11:26)</a>:</h4>
<p>like we needed inverse of triangular number for the Wikipedia version, but we could complete the square.</p>



<a name="257824299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824299">(Oct 16 2021 at 11:26)</a>:</h4>
<p>aha</p>



<a name="257824309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824309">(Oct 16 2021 at 11:26)</a>:</h4>
<p>yes, that will be a problem for d &gt;= 5</p>



<a name="257824315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824315">(Oct 16 2021 at 11:26)</a>:</h4>
<p>:-)</p>



<a name="257824347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824347">(Oct 16 2021 at 11:27)</a>:</h4>
<p>Given that 3^26 is quite a big number, maybe a table of small values will be fine :-)</p>



<a name="257824407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824407">(Oct 16 2021 at 11:28)</a>:</h4>
<p><span class="user-mention" data-user-id="372804">@Marcus Rossel</span> Are you allowed to have a partial inverse, because that will make things easier. You can just reject inputs that don't have 25 <code>,</code>'s</p>



<a name="257824455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824455">(Oct 16 2021 at 11:29)</a>:</h4>
<p>One way to enforce this is with some kind of stars-and-bars way of enumerating exactly where to place the commas. But at that point the high dimensional cantor is looking like a simpler solution</p>



<a name="257824906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257824906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257824906">(Oct 16 2021 at 11:37)</a>:</h4>
<p>Actually balanced <code>unpair</code> is much simpler. You are off from optimal by a polynomial factor depending on the amount of unbalance in the tree, which can't be perfect because 26 isn't a power of two, but that should only be something like O(n^0.4) or so from optimal, which is probably passable for practical use (certainly it's much better than n^(2^25))</p>



<a name="257825136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Float.floor/near/257825136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Float.2Efloor.html#257825136">(Oct 16 2021 at 11:40)</a>:</h4>
<p>If you have 26 elements of O(k), then the result is O(k^32), where the optimal is O(k^26), so it's off by a factor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>13</mn></mrow></msup><mo stretchy="false">)</mo><mo>≤</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>0.24</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{3/13}) \le O(n^{0.24})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3/13</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.24</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
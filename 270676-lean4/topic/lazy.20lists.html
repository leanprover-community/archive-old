---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/lazy.20lists.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html">lazy lists</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271084530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271084530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271084530">(Feb 08 2022 at 05:55)</a>:</h4>
<p>Hey, just wondering if there's already an implementation of lazy lists using Thunks in lean4. Seems to be mentioned in <a href="https://leanprover.github.io/lean4/doc/thunk.html">https://leanprover.github.io/lean4/doc/thunk.html</a> but I can't find anything</p>



<a name="271084633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271084633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271084633">(Feb 08 2022 at 05:57)</a>:</h4>
<p>oh, wait, GitHub search to the rescue: <a href="https://github.com/leanprover/lean4/blob/d0996fb9450dc37230adea9d10ecfdf10330ef67/tests/playground/lazylist.lean">https://github.com/leanprover/lean4/blob/d0996fb9450dc37230adea9d10ecfdf10330ef67/tests/playground/lazylist.lean</a></p>



<a name="271084714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271084714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271084714">(Feb 08 2022 at 05:58)</a>:</h4>
<p>It's a bit unfortunate that everything is partial here, but I don't know how else it'd be defined. Hm.</p>



<a name="271085141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085141">(Feb 08 2022 at 06:05)</a>:</h4>
<p>I don't think anything there needs to be partial</p>



<a name="271085745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085745">(Feb 08 2022 at 06:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/lazy.20lists/near/271085141">said</a>:</p>
<blockquote>
<p>I don't think anything there needs to be partial</p>
</blockquote>
<p>Yeah, the issue seems to be that Lean can't prove that a lazylist is not an infinite stack of Delayed constructors. But I can't think of how to (a) prove that, if structural recursion won't, nor (b) how to build an infinite stack of Delayed constructors in Lean</p>



<a name="271085789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085789">(Feb 08 2022 at 06:17)</a>:</h4>
<p>Structural recursion will prove it, but structural recursion on nested inductives has poor support right now</p>



<a name="271085798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085798">(Feb 08 2022 at 06:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">height</span> <span class="o">(</span><span class="n">ll</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">LazyList.rec</span> <span class="o">(</span><span class="n">motive_1</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">motive_2</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="n">α</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="o">())</span> <span class="n">ll</span>
</code></pre></div>



<a name="271085808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085808">(Feb 08 2022 at 06:17)</a>:</h4>
<p>you can prove everything decreasing by this measure</p>



<a name="271085907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085907">(Feb 08 2022 at 06:19)</a>:</h4>
<p>ahh, cool. does the noncomputability relax the requirements for structural recursion?</p>



<a name="271085916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085916">(Feb 08 2022 at 06:19)</a>:</h4>
<p>no, it's just an artifact of the fact that code generation has not yet been implemented for <code>T.rec</code> functions</p>



<a name="271085978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271085978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271085978">(Feb 08 2022 at 06:20)</a>:</h4>
<p>Huh, okay. Will keep in mind</p>



<a name="271086003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271086003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271086003">(Feb 08 2022 at 06:20)</a>:</h4>
<p><code>T.rec</code> is the underlying axiomatic principle for structural recursion. The equation compiler (and the <code>induction</code> tactic) is the frontend so you don't have to use it directly like this</p>



<a name="271086054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271086054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271086054">(Feb 08 2022 at 06:22)</a>:</h4>
<p>So then which recursor has code generation been implemented for..?</p>



<a name="271086099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271086099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271086099">(Feb 08 2022 at 06:22)</a>:</h4>
<p>none</p>



<a name="271086145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271086145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271086145">(Feb 08 2022 at 06:23)</a>:</h4>
<p>If you use <code>T.rec</code> directly, you will always be forced to mark the function <code>noncomputable</code> unless you use <code>implementedBy</code> to redirect the compiler to a different definition with a compilable implementation</p>



<a name="271086343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271086343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271086343">(Feb 08 2022 at 06:26)</a>:</h4>
<p>oh. huh. but the equation compiler generates a compilable implementation, which is why most user-defined recursive functions remain computable?</p>



<a name="271087908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271087908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271087908">(Feb 08 2022 at 06:52)</a>:</h4>
<p>Right. The equations of an equation compiler definition are interpreted "directly", in the manner of a general recursive function without regard to termination</p>



<a name="271087941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271087941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271087941">(Feb 08 2022 at 06:53)</a>:</h4>
<p>Here's a translation of the <code>LazyList</code> file to modern lean 4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2019 Microsoft Corporation. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Author: Leonardo de Moura</span>
<span class="cm">-/</span>

<span class="kd">inductive</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Thunk</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span>

<span class="kd">@[extern cpp inline "#2"]</span>
<span class="kd">def</span> <span class="n">List.toLazy</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">[]</span>     <span class="bp">=&gt;</span> <span class="n">LazyList.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">LazyList.cons</span> <span class="n">h</span> <span class="o">(</span><span class="n">toLazy</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">LazyList</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Inhabited</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">nil</span><span class="o">⟩</span>

<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">pure</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">height</span> <span class="o">(</span><span class="n">ll</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">LazyList.rec</span> <span class="o">(</span><span class="n">motive_1</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">motive_2</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Nat</span><span class="o">)</span>
    <span class="n">α</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="o">())</span> <span class="n">ll</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_nil</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.nil</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_cons</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.cons</span> <span class="n">α</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="n">l.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">height_delayed</span> <span class="o">(</span><span class="n">as</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">LazyList.delayed</span> <span class="n">α</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">height</span> <span class="bp">=</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">=</span> <span class="o">⟨</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">as.get</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">cases</span> <span class="n">as</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">_</span> <span class="n">fn</span> <span class="bp">=&gt;</span> <span class="n">apply</span> <span class="n">congrArg</span><span class="bp">;</span> <span class="n">funext</span> <span class="o">()</span><span class="bp">;</span> <span class="n">rfl</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span><span class="bp">;</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">get</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">get</span> <span class="n">as.get</span>
<span class="bp">|</span> <span class="n">other</span>        <span class="bp">=&gt;</span> <span class="n">other</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">isEmpty</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Bool</span>
<span class="bp">|</span> <span class="n">nil</span>          <span class="bp">=&gt;</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>   <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">isEmpty</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">toList</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span>          <span class="bp">=&gt;</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span>  <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">toList</span> <span class="n">as</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">toList</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">head</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span>          <span class="bp">=&gt;</span> <span class="n">default</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span>  <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">head</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">tail</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span>          <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span>  <span class="bp">=&gt;</span> <span class="n">as</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">tail</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">append</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Unit</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">,</span>        <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">bs</span> <span class="o">()</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span>  <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">append</span> <span class="n">as</span> <span class="n">bs</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span><span class="o">,</span> <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">append</span> <span class="n">as.get</span> <span class="n">bs</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Append</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">LazyList.append</span> <span class="n">x</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">y</span><span class="o">)⟩</span>

<span class="kd">def</span> <span class="n">interleave</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">,</span>        <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">bs</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span>  <span class="n">bs</span> <span class="bp">=&gt;</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">bs.height</span> <span class="bp">+</span> <span class="n">as.height</span> <span class="bp">&lt;</span> <span class="n">as.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_comm</span><span class="o">,</span> <span class="n">Nat.add_right_comm</span><span class="o">]</span><span class="bp">;</span> <span class="n">decreasing_tactic</span>
  <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">interleave</span> <span class="n">bs</span> <span class="n">as</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span><span class="o">,</span> <span class="n">bs</span> <span class="bp">=&gt;</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="bp">&lt;</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_right_comm</span><span class="o">]</span><span class="bp">;</span> <span class="n">decreasing_tactic</span>
  <span class="n">interleave</span> <span class="n">as.get</span> <span class="n">bs</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">as.height</span> <span class="bp">+</span> <span class="n">bs.height</span>

<span class="kd">@[specialize]</span> <span class="kd">def</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">as</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">map</span> <span class="n">f</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">@[specialize]</span> <span class="kd">def</span> <span class="n">map₂</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">δ</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span> <span class="n">cons</span> <span class="n">b</span> <span class="n">bs</span> <span class="bp">=&gt;</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as.height</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="bp">&lt;</span> <span class="n">as.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_right_comm</span> <span class="n">as.height</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">Nat.lt_trans</span> <span class="o">(</span><span class="n">Nat.lt_succ_self</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">Nat.lt_succ_self</span> <span class="n">_</span><span class="o">)</span>
 <span class="n">cons</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">map₂</span> <span class="n">f</span> <span class="n">as</span> <span class="n">bs</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span><span class="o">,</span> <span class="n">bs</span> <span class="bp">=&gt;</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="bp">&lt;</span> <span class="n">as.get.height</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">bs.height</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_right_comm</span><span class="o">]</span><span class="bp">;</span> <span class="n">decreasing_tactic</span>
  <span class="n">map₂</span> <span class="n">f</span> <span class="n">as.get</span> <span class="n">bs</span>
<span class="bp">|</span> <span class="n">as</span><span class="o">,</span> <span class="n">delayed</span> <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">map₂</span> <span class="n">f</span> <span class="n">as</span> <span class="n">bs.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">as.height</span> <span class="bp">+</span> <span class="n">bs.height</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">zip</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">map₂</span> <span class="n">Prod.mk</span>

<span class="kd">def</span> <span class="n">join</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">join</span> <span class="n">as</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">join</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">@[inline]</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">bind</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">β</span> <span class="o">:=</span>
<span class="n">join</span> <span class="o">(</span><span class="n">x.map</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">isMonad</span> <span class="o">:</span> <span class="n">Monad</span> <span class="n">LazyList</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pure</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">LazyList.pure</span><span class="o">,</span> <span class="n">bind</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">LazyList.bind</span><span class="o">,</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">LazyList.map</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Alternative</span> <span class="n">LazyList</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">failure</span> <span class="o">:=</span> <span class="n">nil</span>
  <span class="n">orElse</span>  <span class="o">:=</span> <span class="k">fun</span> <span class="n">as</span> <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">LazyList.append</span> <span class="n">as</span> <span class="n">bs</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">approx</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">approx</span> <span class="n">i</span> <span class="n">as</span>
<span class="bp">|</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">approx</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">@[specialize]</span> <span class="n">partial</span> <span class="kd">def</span> <span class="n">iterate</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">x</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">iterate</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span>

<span class="kd">@[specialize]</span> <span class="n">partial</span> <span class="kd">def</span> <span class="n">iterate₂</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">x</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">iterate₂</span> <span class="n">f</span> <span class="n">y</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)))</span>

<span class="kd">@[specialize]</span> <span class="kd">def</span> <span class="n">filter</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">nil</span>          <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span>  <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">p</span> <span class="n">a</span> <span class="k">then</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">filter</span> <span class="n">p</span> <span class="n">as</span><span class="o">))</span> <span class="k">else</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">as</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">cycle</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="n">xs</span> <span class="bp">++</span> <span class="n">delayed</span> <span class="o">(</span><span class="n">cycle</span> <span class="n">xs</span><span class="o">)</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">repeat</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">repeat</span> <span class="n">a</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">inits</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span>        <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">nil</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span>  <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">nil</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span> <span class="o">(</span><span class="n">inits</span> <span class="n">as</span><span class="o">)))</span>
<span class="bp">|</span> <span class="n">delayed</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">inits</span> <span class="n">as.get</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">addOpenBracket</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">String</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">s.isEmpty</span> <span class="k">then</span> <span class="s2">"["</span> <span class="k">else</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">approxToStringAux</span> <span class="o">[</span><span class="n">ToString</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span>   <span class="n">nil</span><span class="o">,</span>        <span class="n">r</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">if</span> <span class="n">r.isEmpty</span> <span class="k">then</span> <span class="s2">"["</span> <span class="k">else</span> <span class="n">r</span><span class="o">)</span> <span class="bp">++</span> <span class="s2">"]"</span>
<span class="bp">|</span> <span class="mi">0</span><span class="o">,</span>   <span class="n">_</span><span class="o">,</span>          <span class="n">r</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="k">if</span> <span class="n">r.isEmpty</span> <span class="k">then</span> <span class="s2">"["</span> <span class="k">else</span> <span class="n">r</span><span class="o">)</span> <span class="bp">++</span> <span class="s2">", ..]"</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">,</span>  <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">approxToStringAux</span> <span class="n">n</span> <span class="n">as</span> <span class="o">((</span><span class="k">if</span> <span class="n">r.isEmpty</span> <span class="k">then</span> <span class="s2">"["</span> <span class="k">else</span> <span class="n">r</span> <span class="bp">++</span> <span class="s2">", "</span><span class="o">)</span> <span class="bp">++</span> <span class="n">toString</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span><span class="o">,</span>   <span class="n">delayed</span> <span class="n">as</span><span class="o">,</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">approxToStringAux</span> <span class="n">n</span> <span class="n">as.get</span> <span class="n">r</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">n</span> <span class="n">as</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">as.height</span>

<span class="kd">def</span> <span class="n">approxToString</span> <span class="o">[</span><span class="n">ToString</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">:</span> <span class="n">String</span> <span class="o">:=</span>
<span class="n">as.approxToStringAux</span> <span class="n">n</span> <span class="s2">""</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">ToString</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">LazyList</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">approxToString</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">LazyList</span>

<span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">Nat</span> <span class="o">:=</span>
<span class="n">LazyList.iterate₂</span> <span class="o">(</span><span class="bp">·+·</span><span class="o">)</span> <span class="mi">0</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">tst</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">String</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">x</span> <span class="bp">←</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">toLazy</span>
  <span class="k">let</span> <span class="n">y</span> <span class="bp">←</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span><span class="bp">.</span><span class="n">toLazy</span>
  <span class="c1">-- dbgTrace (toString x ++ " " ++ toString y) $ λ _,</span>
  <span class="n">guard</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">5</span><span class="o">)</span>
  <span class="n">pure</span> <span class="o">(</span><span class="n">toString</span> <span class="n">x</span> <span class="bp">++</span> <span class="s2">" + "</span> <span class="bp">++</span> <span class="n">toString</span> <span class="n">y</span> <span class="bp">++</span> <span class="s2">" = "</span> <span class="bp">++</span> <span class="n">toString</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">LazyList</span>

<span class="kd">def</span> <span class="n">iota</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">UInt32</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">UInt32</span> <span class="o">:=</span>
<span class="n">iterate</span> <span class="o">(</span><span class="bp">·+</span><span class="mi">1</span><span class="o">)</span> <span class="n">i</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">sieve</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">UInt32</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">UInt32</span>
<span class="bp">|</span> <span class="n">nil</span>          <span class="bp">=&gt;</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span><span class="o">)</span>  <span class="bp">=&gt;</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">delayed</span> <span class="o">(</span><span class="n">sieve</span> <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">b</span> <span class="bp">%</span> <span class="n">a</span> <span class="bp">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">as</span><span class="o">)))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">delayed</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">sieve</span> <span class="n">as.get</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">primes</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">UInt32</span> <span class="o">:=</span>
<span class="n">sieve</span> <span class="o">(</span><span class="n">iota</span> <span class="mi">2</span><span class="o">)</span>

<span class="k">#eval</span> <span class="k">show</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="k">from</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="c1">-- IO.println $ tst.isEmpty,</span>
  <span class="c1">-- IO.println $ [1, 2, 3].toLazy.cycle,</span>
  <span class="c1">-- IO.println $ [1, 2, 3].toLazy.cycle.inits,</span>
  <span class="c1">-- IO.println $ ((iota.filter (λ v, v % 5 == 0)).approx 50000).foldl (+) 0,</span>
  <span class="n">IO.println</span> <span class="bp">$</span> <span class="o">(</span><span class="n">primes.approx</span> <span class="mi">2000</span><span class="o">)</span><span class="bp">.</span><span class="n">foldl</span> <span class="o">(</span><span class="bp">·+·</span><span class="o">)</span> <span class="mi">0</span>
  <span class="c1">-- IO.println $ tst.head,</span>
  <span class="c1">-- IO.println $ fib.interleave (iota.map (+100)),</span>
  <span class="c1">-- IO.println $ ((iota.map (+10)).filter (λ v, v % 2 == 0)),</span>
  <span class="n">pure</span> <span class="o">()</span>
</code></pre></div>



<a name="271088041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271088041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271088041">(Feb 08 2022 at 06:54)</a>:</h4>
<p>The only functions that had to remain <code>partial</code> are the ones that are truly infinite lists, like <code>iterate</code>, <code>cycle</code>, <code>repeat</code> and (unfortunately) <code>sieve</code> and <code>primes</code></p>



<a name="271088059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271088059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271088059">(Feb 08 2022 at 06:55)</a>:</h4>
<p>because lean can prove that every <code>LazyList</code> is finite</p>



<a name="271088137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271088137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271088137">(Feb 08 2022 at 06:56)</a>:</h4>
<p>It would be an interesting challenge to see if it's possible to get the same performance characteristics from an implementation that is provably coinductive</p>



<a name="271108904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271108904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271108904">(Feb 08 2022 at 10:41)</a>:</h4>
<p>I would suggest to use <code>implementedBy</code> instead of <code>extern</code>.  The <code>extern</code> produces an unconditional FFI call (and doesn't work in the same file), while the following <code>implementedBy</code> is optimized away completely.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">private</span> <span class="n">unsafe</span> <span class="kd">def</span> <span class="n">List.toLazyUnsafe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">LazyList</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">unsafeCast</span> <span class="n">xs</span>

<span class="kd">@[implementedBy List.toLazyUnsafe]</span>
<span class="kd">def</span> <span class="n">List.toLazy</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">LazyList</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="o">[]</span>     <span class="bp">=&gt;</span> <span class="n">LazyList.nil</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">LazyList.cons</span> <span class="n">h</span> <span class="o">(</span><span class="n">toLazy</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>



<a name="271162673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271162673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271162673">(Feb 08 2022 at 17:32)</a>:</h4>
<p>On a kinda similar note,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">take</span> <span class="o">[</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stream</span> <span class="n">ρ</span> <span class="n">τ</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ρ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">τ</span> <span class="bp">×</span> <span class="n">ρ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="o">([],</span> <span class="n">s</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">S.next</span><span class="bp">?</span> <span class="n">s</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">([],</span> <span class="n">s</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">rest</span><span class="o">)</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">L</span><span class="o">,</span><span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">take</span> <span class="n">rest</span> <span class="n">n</span>
    <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">L</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span>
</code></pre></div>
<p>this definition (with the built-in <code>Stream</code>) compiles fine, but trying to <code>simp</code> on <code>take</code> fails with<br>
<code>failed to generate equational theorem for 'Stream.take'</code><br>
is this another place where I should just manually prove the lemma here?</p>



<a name="271205807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271205807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271205807">(Feb 08 2022 at 23:12)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> I pushed a fix for the issue above.</p>



<a name="271225036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271225036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271225036">(Feb 09 2022 at 03:08)</a>:</h4>
<p>Awesome, thanks very much!</p>



<a name="271736976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lazy%20lists/near/271736976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lazy.20lists.html#271736976">(Feb 13 2022 at 09:25)</a>:</h4>
<p>LazyList is working great :)</p>
<p>I implemented amortized O(1) queues with and without laziness. The ephemeral test uses the queues linearly, while the persistent test targets the worst case persistent access:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Ephemeral</span> <span class="n">Test</span>
<span class="n">Eager</span><span class="o">:</span>  <span class="mi">124</span><span class="n">ms</span>
<span class="n">Lazy</span><span class="o">:</span> <span class="mi">287</span><span class="n">ms</span>

<span class="n">Persistent</span> <span class="n">Test</span>
<span class="n">Eager</span><span class="o">:</span>  <span class="mi">884</span><span class="n">ms</span>
<span class="n">Lazy</span><span class="o">:</span> <span class="mi">1</span><span class="n">ms</span>
</code></pre></div>
<p>Some overhead with the lazy one, in exchange for worst-case O(1) even with persistent usage!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
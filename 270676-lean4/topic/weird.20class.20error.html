---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/weird.20class.20error.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html">weird class error</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260524730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/260524730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#260524730">(Nov 06 2021 at 17:03)</a>:</h4>
<p>On nightly-2021-11-06, I expected the following piece of code to type check:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">C</span> <span class="n">where</span> <span class="n">c</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="kd">class</span> <span class="n">D</span> <span class="kd">extends</span> <span class="n">C</span>
<span class="kd">def</span> <span class="n">fc</span> <span class="o">[</span><span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">C.c</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">fd</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">C.c</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>However, <code>fd</code> does not compile with the following error message:</p>
<div class="codehilite" data-code-language="error"><pre><span></span><code>  D.toC
argument has type
  D
but function has type
  [self : D] → C
</code></pre></div>
<p>Is this a bug or do I misunderstand something?<br>
When I replace extends by a manual instance, I still see the error.<br>
When I replace Sort u by Prop, or by any type with a fixed universe, the error goes away.<br>
Thanks for suggestions...</p>



<a name="261053825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261053825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261053825">(Nov 10 2021 at 20:59)</a>:</h4>
<p>Hi, here is perhaps a more convincing mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">C</span> <span class="n">where</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kd">class</span> <span class="n">D</span> <span class="kd">extends</span> <span class="n">C</span>
<span class="kd">def</span> <span class="n">a</span> <span class="o">[</span><span class="n">C</span><span class="o">]</span> <span class="o">:=</span> <span class="n">C.f</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">b</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:=</span> <span class="n">D.toC.f</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">c</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:=</span> <span class="n">C.f</span> <span class="n">Nat</span>
</code></pre></div>
<p>Oddly, b compiles but not c and I can't figure out why. I might be wrong but it looks like a bug to me. Any idea what could be wrong?</p>
<p>To give more context I was trying to formalize Nat's with a philosophy of avoiding inductive types completely.<br>
But the problem is that my Nat class extends Nat_induction, and then I got stuck so I reduced my problem to the above mwe.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Zero</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">N</span>
<span class="kn">export</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Succ</span> <span class="n">where</span>
  <span class="n">succ</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kn">export</span> <span class="n">Succ</span> <span class="o">(</span><span class="n">succ</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Succ_Not_Zero</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span>
  <span class="n">succ_not_zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">zero</span>
<span class="kn">export</span> <span class="n">Succ_Not_Zero</span> <span class="o">(</span><span class="n">succ_not_zero</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Eq_Of_Succ_Eq_Succ</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span>
  <span class="n">eq_of_succ_eq_succ</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span>
<span class="kn">export</span> <span class="n">Eq_Of_Succ_Eq_Succ</span> <span class="o">(</span><span class="n">eq_of_succ_eq_succ</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Nat_Induction</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span>
  <span class="n">nat_induction</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span>
    <span class="o">(</span><span class="n">P0</span> <span class="o">:</span> <span class="n">P</span> <span class="n">zero</span><span class="o">)</span>
    <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">))</span>
    <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span>
<span class="kn">export</span> <span class="n">Nat_Induction</span> <span class="o">(</span><span class="n">nat_induction</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kn">section</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Natural</span>
<span class="kd">extends</span> <span class="n">Zero</span> <span class="n">N</span><span class="o">,</span> <span class="n">Succ</span> <span class="n">N</span><span class="o">,</span> <span class="n">Succ_Not_Zero</span> <span class="n">N</span><span class="o">,</span> <span class="n">Eq_Of_Succ_Eq_Succ</span> <span class="n">N</span><span class="o">,</span> <span class="n">Nat_Induction</span> <span class="n">N</span>
<span class="kd">end</span>

<span class="kn">section</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">Natural</span> <span class="n">ℕ</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">pred_with_proof</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">zero</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Σ'</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="kd">by</span>
  <span class="n">revert</span> <span class="n">h</span>
  <span class="k">let</span> <span class="n">P</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">k</span> <span class="bp">≠</span> <span class="n">zero</span> <span class="bp">→</span> <span class="bp">Σ'</span> <span class="n">m</span><span class="o">,</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">nat_induction</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="bp">;</span> <span class="n">exact</span> <span class="n">False.elim</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="n">n</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">zero</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">pred_with_proof</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span>
<span class="kd">end</span>
</code></pre></div>
<p>pred_with_proof  will fail to type check...</p>
<p>Thanks in advance for any suggestions you might have ...</p>



<a name="261114105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261114105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261114105">(Nov 11 2021 at 10:10)</a>:</h4>
<p><code>class</code>es are inductive types ;-) The difference is that they only have one constructor.</p>



<a name="261136509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261136509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261136509">(Nov 11 2021 at 13:55)</a>:</h4>
<p>I think <code>nat_induction</code> does not mean what you think it means</p>



<a name="261137019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261137019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261137019">(Nov 11 2021 at 14:00)</a>:</h4>
<p>The class <code>Nat_Induction</code> has two universe levels, one for <code>N</code> and one for the universe level that you can eliminate into</p>



<a name="261137432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261137432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261137432">(Nov 11 2021 at 14:03)</a>:</h4>
<p>Maybe you already realize this... but it's pretty suspect; for example how could Lean figure out that the instance <code>Natural ℕ</code> in <code>pred_with_proof</code> has to be of the level that allows elimination into the type <code>ℕ</code>? I mean we can see this because we know that <code>[Natural ℕ]</code> is intended to discharge the class assumption in the single use of <code>nat_induction</code>, but Lean doesn't think this way</p>



<a name="261137654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261137654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261137654">(Nov 11 2021 at 14:05)</a>:</h4>
<p>The behavior in your original post still seems strange though--I don't get an error with the Lean 3 translation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">(</span><span class="n">c</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">D</span> <span class="kd">extends</span> <span class="n">C</span>
<span class="kd">def</span> <span class="n">fc</span> <span class="o">[</span><span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">C.c</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">fd</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">C.c</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="261162612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261162612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261162612">(Nov 11 2021 at 17:29)</a>:</h4>
<p>Classes might be implemented as inductive types under the hood, but I like to think of them as an orthogonal system separate from inductive types that lean provides.</p>
<p>The reason I put a Sort _ in nat_induction instead of a Prop, is just because I saw that Nat.rec signature uses a Sort _. I essentially copied Nat.rec's signature. I acknowledge that my naming conventions are kind of inaccurate here and there.<br>
I am aware that there are 2 universes in nat_induction but I didn't really understand why according to you that would be an issue. To help lean with the nat_induction call I am giving the return type : P n explicitly. Alternatively I could be explicit about P and say (P := P) </p>
<p>If this was an issue about universes, why would b type check and not c in the below example on lean4 nightly-2021-11-10 ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">C</span> <span class="n">where</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kd">class</span> <span class="n">D</span> <span class="kd">extends</span> <span class="n">C</span>
<span class="kd">def</span> <span class="n">a</span> <span class="o">[</span><span class="n">C</span><span class="o">]</span> <span class="o">:=</span> <span class="n">C.f</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">b</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:=</span> <span class="n">D.toC.f</span> <span class="n">Nat</span>
<span class="kd">def</span> <span class="n">c</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:=</span> <span class="n">C.f</span> <span class="n">Nat</span>
</code></pre></div>
<p>All the universes revolving around c also revolve around b as I understand it.</p>
<p>I'll translate my longer code to lean3 to get clearer ideas when I find some time.<br>
Thank you for your comments.</p>



<a name="261166363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261166363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261166363">(Nov 11 2021 at 18:01)</a>:</h4>
<p>What I mean is the <em>class</em> <code>Nat_Induction</code> itself (and hence also the class <code>Natural</code>) has two universe parameters, and Lean won't guess which universe level instantiation of <code>Natural</code> you want to provide when you write <code>variable {ℕ} [Natural ℕ]</code>.</p>



<a name="261166503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261166503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261166503">(Nov 11 2021 at 18:02)</a>:</h4>
<p>I'm guessing what you want/expect is for <code>nat_induction</code> to be quantified over <em>all</em> universes like <code>Nat.rec</code> is, but it's not.</p>



<a name="261166765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261166765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261166765">(Nov 11 2021 at 18:05)</a>:</h4>
<p>In this example with <code>a b c</code>, it's clear that you mean <code>def a [C.{1}] := C.f Nat</code>, <code>def b [D.{1}] := ...</code>, <code>def c [D.{1}] := ...</code>, but I'm not sure why Lean figures that out in some cases but not others.</p>



<a name="261167549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261167549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261167549">(Nov 11 2021 at 18:12)</a>:</h4>
<p>Actually we have (or used to have?) a similar issue in the category theory library, where it's hard to predict when you need to include universe variables, but maybe it was fixed?</p>



<a name="261176041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261176041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261176041">(Nov 11 2021 at 19:34)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> the error in your original post is likely a bug with Lean. Since <code>D</code> is a class, its auto-generated <code>self</code> parameters for fields are tagged as synthetic (i.e.,  using<code>[self : D]</code> for the binder). This results in the signature of <code>D.toC</code> being <code>[self : D] -&gt; C</code> (with no explicit parameter). The automatic structure to parent conversion, however , is mistaking trying to insert an invalid <code>D.toC d</code> argument. In code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fd</span> <span class="o">[</span><span class="n">D</span><span class="o">]</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">C.c</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="c1">-- (mistakenly) elaborates to roughly</span>
<span class="kd">def</span> <span class="n">fd</span> <span class="o">[</span><span class="n">d</span> <span class="o">:</span> <span class="n">D</span><span class="o">]</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">C.c</span> <span class="o">(</span><span class="n">self</span> <span class="o">:=</span> <span class="n">D.toC</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="261366626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261366626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261366626">(Nov 13 2021 at 15:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  I see what you mean now. Thanks for clarifying. </p>
<p>Is there a way to quantify a universe variable in a class method? Or is there a reason its not possible?  I tried to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">nat_induction.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span>
</code></pre></div>
<p>in the class definition but it gives me some "invalid field" error.<br>
The v universe seems to always get attached to the class itself which isn't what I want.</p>



<a name="261367098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261367098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261367098">(Nov 13 2021 at 15:58)</a>:</h4>
<p>Since the universe of the class must be at least as large as those of the class fields, you would need an ordinal as the universe level (as well as being able to quantify over universe levels at that position in the first place), which Lean does not support.</p>



<a name="261367434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261367434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261367434">(Nov 13 2021 at 16:04)</a>:</h4>
<p>I see ... So inductive types are in a way more expressive than type classes because they define some functions with universe quantifications</p>



<a name="261367536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261367536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261367536">(Nov 13 2021 at 16:06)</a>:</h4>
<p>I might ask a stupid question but, why does a class need to have a type? Couldn't it be a type-less set of requirements?</p>



<a name="261367993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261367993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261367993">(Nov 13 2021 at 16:17)</a>:</h4>
<p>In Lean's type theory, everything needs to have a type. There might well be other set-ups where you can avoid this I guess.</p>



<a name="261368228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368228">(Nov 13 2021 at 16:23)</a>:</h4>
<p>Interestingly, Coq's modules are not first-class values and thus do not have a type and <em>can</em> quantify like this even without ordinal universes. But one consequence of that is that they need special kernel support.</p>



<a name="261368298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368298">(Nov 13 2021 at 16:24)</a>:</h4>
<p>You could get rid of the classes by just passing everything directly, but you still can't abstract over universe-polymorphic values.</p>



<a name="261368379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368379">(Nov 13 2021 at 16:27)</a>:</h4>
<p>You <em>could</em> statically "abstract" over universe polymorphic values though using a macro that produce a version of the class for each universe (like C++'s templates), but that isn't exactly in the spirit of Lean's type theory. That is, it would (in general) be better (and easier) to adapt one's approach to Lean's style, than try and force it to do what one wants.</p>



<a name="261368516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368516">(Nov 13 2021 at 16:30)</a>:</h4>
<p>Is there like a good example or situation showing why it's useful for a typeclass to have a type? I don't really have one in mind, that's why I was just wondering...</p>



<a name="261368777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368777">(Nov 13 2021 at 16:37)</a>:</h4>
<p>It makes the kernel smaller, because you don't need special kernel support for them.</p>



<a name="261368843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368843">(Nov 13 2021 at 16:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="403214">Michael Jam</span> <a href="#narrow/stream/270676-lean4/topic/weird.20class.20error/near/261368516">said</a>:</p>
<blockquote>
<p>Is there like a good example or situation showing why it's useful for a typeclass to have a type? I don't really have one in mind, that's why I was just wondering...</p>
</blockquote>
<p>How exactly are your proposing for them to not have a type?</p>



<a name="261368874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368874">(Nov 13 2021 at 16:39)</a>:</h4>
<p>What you are saying really is "why do we use Lean's type theory instead of another type theory?" Other programs use other type theories.</p>



<a name="261368884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368884">(Nov 13 2021 at 16:39)</a>:</h4>
<p>OK so its mostly a reason of implementation. I guess as you were saying it's because they are implemented as inductive types under the hood, so all the inductive type machinery can be reused.</p>



<a name="261368938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368938">(Nov 13 2021 at 16:40)</a>:</h4>
<p>Note that type classes in Lean 4 (if not in <code>Prop</code>) are data that can be passed around to functions and are thus compiled. Types in Lean provide info to the compiler as to the representation of the object in memory. Without a type for the class, Lean would have no way of knowing how to compile them.</p>



<a name="261368964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368964">(Nov 13 2021 at 16:41)</a>:</h4>
<p>I mean, type classes in Haskell do not have a type either. It's not unimaginable, just very unlikely to change.</p>



<a name="261368967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368967">(Nov 13 2021 at 16:41)</a>:</h4>
<p>Is the typeclass system part of Lean's type theory itself? isn't it external?</p>



<a name="261368968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368968">(Nov 13 2021 at 16:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> ah, yes they do?</p>



<a name="261368971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261368971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261368971">(Nov 13 2021 at 16:41)</a>:</h4>
<p>type classes in GHC are functions of the kind <code>Constraint</code></p>



<a name="261369038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369038">(Nov 13 2021 at 16:42)</a>:</h4>
<p>I take the +1 from a GHC dev to say that constraints really are not types in any reasonable sense</p>



<a name="261369043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369043">(Nov 13 2021 at 16:43)</a>:</h4>
<p>Well, mainly GHC is not Haskell.</p>



<a name="261369051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369051">(Nov 13 2021 at 16:43)</a>:</h4>
<p><code>Eq a</code> isn't a type.</p>



<a name="261369060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369060">(Nov 13 2021 at 16:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> what do you mean by that?</p>



<a name="261369114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369114">(Nov 13 2021 at 16:44)</a>:</h4>
<p>The point that I think you're making is that there are sensible languages which don't treat classes and types as the same, and consequently have special-purpose mechanisms for passing instances (<code>Eq a =&gt;</code>), or constructing values (<code>instance Eq a</code>), etc.</p>



<a name="261369204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369204">(Nov 13 2021 at 16:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  But Lean does have special purpose mechanisms for type classes and does treat them differently. For example, you can't use a synthetic binder for a non-class object.</p>



<a name="261369282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369282">(Nov 13 2021 at 16:48)</a>:</h4>
<p>I don't see a significant difference in the way that GHC and Lean conceptual think of type classes (at a type theory level). They, however, do have different ideas of how type classes should be used (GHC's single instance resolution vs Lean's tabled multi-instance resolution).</p>



<a name="261369299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369299">(Nov 13 2021 at 16:49)</a>:</h4>
<p>This doesn't seem like a good-faith discussion to me, so I'm going to drop it.</p>



<a name="261369392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261369392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261369392">(Nov 13 2021 at 16:51)</a>:</h4>
<p>Huh? I am entirely confused. It appears that I have come off badly, but I am not really sure why. However, I do apologize if that is the case.</p>



<a name="261370502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261370502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261370502">(Nov 13 2021 at 17:15)</a>:</h4>
<p>Maybe there was a language issue about what it means to be (or to have) a type. In any case, I don't think the discussion was useful. The point is just that it's perfectly sensible to separate the world of values and types from the world of instances and classes. For example, Haskell (as defined by the language standard) works this way. Lean doesn't do this, and that is unlikely to change.</p>



<a name="261378515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261378515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261378515">(Nov 13 2021 at 20:28)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> For you <code>pred_with_proof</code> example, on an old version of Lean 4 (<code>lean4:nightly-2021-06-02</code>) I don't see any errors. (Maybe there are no errors because of a bug that's long been corrected.)</p>



<a name="261378656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261378656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261378656">(Nov 13 2021 at 20:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="403214">Michael Jam</span> <a href="#narrow/stream/270676-lean4/topic/weird.20class.20error/near/261367434">said</a>:</p>
<blockquote>
<p>I see ... So inductive types are in a way more expressive than type classes because they define some functions with universe quantifications</p>
</blockquote>
<p>I think this is only in the sense that every universe quantification has to come first in a type.  For class members, there's an implicit class instance argument, and since universe quantification has to come before that argument, the class has to be dependent on that universe level.</p>
<p>There's nothing really special with universe quantifications that inductive types can do, I think.  All this means is that you have to give instances that quantify over the universe variables (i.e., there's a separate <code>Nat_induction</code> class for every single substitution of universe variables), but you're liable to run into typeclass inference issues since it's easy to get into situations where Lean's going to fail to find instances. It won't fill in universe metavariables for you without some reason to.</p>



<a name="261379144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261379144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261379144">(Nov 13 2021 at 20:44)</a>:</h4>
<p>I guess (very) the awkward thing is that your proofs have to take <code>Nat_induction</code> instances for every universe variable that a proof depends on, rather than just a single instance, if you want to use classes for something like this.</p>



<a name="261379184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261379184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261379184">(Nov 13 2021 at 20:45)</a>:</h4>
<p>That's a limitation of the type system, though -- you can't make a function that takes a universe-polymorphic function as an argument.</p>



<a name="261386221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261386221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261386221">(Nov 13 2021 at 23:28)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> For what it's worth, a reason you don't need recursors using the typeclass system is that if you had one, it's possible to prove that your type is isomorphic to some inductive type, so you can instead have a typeclass that holds a proof of equivalence.  The recursor then becomes a theorem, and that theorem is able to quantify over universe variables.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Equiv</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
  <span class="n">inv_fun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="n">left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">inv_fun</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>
  <span class="n">right_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">inv_fun</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kn">section</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Zero</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">N</span>
<span class="kn">export</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">Succ</span> <span class="n">where</span>
  <span class="n">succ</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kn">export</span> <span class="n">Succ</span> <span class="o">(</span><span class="n">succ</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Nat_Induction</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="n">where</span>
  <span class="n">from_nat</span> <span class="o">:</span> <span class="n">Equiv</span> <span class="n">Nat</span> <span class="n">N</span>
  <span class="n">zero_eq</span> <span class="o">:</span> <span class="n">from_nat.to_fun</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">zero</span>
  <span class="n">succ_eq</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">from_nat.to_fun</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">from_nat.to_fun</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">nat_induction</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Nat_Induction</span> <span class="n">N</span><span class="o">]</span>
  <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">_</span><span class="o">}</span>
  <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">zero</span><span class="o">)</span>
  <span class="o">(</span><span class="n">succ</span> <span class="o">:</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">k</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">))</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="gr">sorry</span>
  <span class="c1">-- prove this by induction on Nat_Induction.from_nat.inv_fun n</span>

<span class="kd">theorem</span> <span class="n">succ_not_zero</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Nat_Induction</span> <span class="n">N</span><span class="o">]</span>
   <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">zero</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">eq_of_succ_eq_succ</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Succ</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">Nat_Induction</span> <span class="n">N</span><span class="o">]</span>
  <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span>
</code></pre></div>



<a name="261569020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261569020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261569020">(Nov 15 2021 at 22:26)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> and <span class="user-mention" data-user-id="315577">@Mac</span>, did you open a bug report for the erroneous explicit argument? I'm asking because I keep running into a somewhat similar issue and I'm wondering whether it is the same bug or not. Here is an MWE (though probably not completely minimal):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">A</span>

<span class="kd">class</span> <span class="n">B</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">outParam</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">C</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">B</span> <span class="n">a</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">class</span> <span class="n">D</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">B</span> <span class="n">a</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">C</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">E</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="n">where</span>
<span class="o">[</span><span class="n">c</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">B</span> <span class="n">a</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">C</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">B</span> <span class="n">a</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">C</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">e.c</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">d</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">E</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">B</span> <span class="n">a</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">D</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>On the last line, with <code>lean4:nightly-2021-11-12</code> I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">instC</span> <span class="n">a</span>
<span class="n">argument</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">E</span> <span class="n">a</span>
<span class="n">but</span> <span class="n">function</span> <span class="n">has</span> <span class="n">type</span>
  <span class="o">[</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span> <span class="n">a</span><span class="o">]</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="bp">→</span> <span class="o">[</span><span class="n">inst</span> <span class="o">:</span> <span class="n">B</span> <span class="n">a</span> <span class="n">α</span><span class="o">]</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">α</span>
</code></pre></div>



<a name="261569700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261569700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261569700">(Nov 15 2021 at 22:32)</a>:</h4>
<p><span class="user-mention" data-user-id="198266">@Sebastian Reichelt</span> no, I did not. And yeah, that looks like it is probably the same error.</p>



<a name="261574698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/weird%20class%20error/near/261574698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Reichelt <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/weird.20class.20error.html#261574698">(Nov 15 2021 at 23:14)</a>:</h4>
<p>Thank you. I've reported it as <a href="https://github.com/leanprover/lean4/issues/796">https://github.com/leanprover/lean4/issues/796</a> now.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/indent.20after.20have.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html">indent after have</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303953106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303953106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303953106">(Oct 14 2022 at 02:21)</a>:</h4>
<p>What does the indent after the have mean in this lean3 proof?  If I try this in lean4 I get  syntax error <code>expected '|'</code> ?  If I remove the indent then I get the error (it seems the indent is not required in lean3)...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">add_lt_add_right</span> <span class="o">(</span><span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="n">he</span> <span class="bp">?</span><span class="n">m.3947</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">?</span><span class="n">m.3947</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="bp">?</span><span class="n">m.3947</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>The lean3 proof I'm porting:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="o">[</span><span class="n">nat_num_game</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">c</span> <span class="k">with</span> <span class="n">d</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">lt_irrefl</span> <span class="mi">0</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">clear</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">d</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">succ_mul</span><span class="o">,</span><span class="n">zero_mul</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">succ_mul</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">succ_mul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">succ_mul</span> <span class="o">(</span><span class="n">succ</span> <span class="n">e</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">add_lt_add_right</span> <span class="n">_</span> <span class="n">_</span> <span class="n">he</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lt_trans</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span> <span class="n">_</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">add_lt_add_right</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kd">end</span>
</code></pre></div>
<p>For repro see  <a href="https://github.com/leanprover/lean4-samples/blob/main/NaturalNumbers/InequalityWorld/Level8.lean">Level 18</a></p>



<a name="303954368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303954368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303954368">(Oct 14 2022 at 02:36)</a>:</h4>
<p>Never mind I just found the <code>have</code> tactic documentation in <a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html">https://leanprover.github.io/theorem_proving_in_lean4/tactics.html</a>.</p>
<p>So the answer is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>      <span class="k">let</span> <span class="n">h</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">exact</span> <span class="n">add_lt_add_right</span> <span class="n">_</span> <span class="n">_</span> <span class="n">he</span> <span class="n">_</span>
</code></pre></div>



<a name="303955582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303955582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303955582">(Oct 14 2022 at 02:50)</a>:</h4>
<p>In lean 3, the <code>have</code> tactic has an optional <code>:=</code> argument, and if you omit it it produces two goals. In mathlib the first goal is usually surrounded by <code>{ }</code>, but some people also just indent the subproof without using the braces (since as we've established they are not strictly necessary).</p>



<a name="303957256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303957256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303957256">(Oct 14 2022 at 03:14)</a>:</h4>
<p>Ok, now I have done all of NNG except one last proof.  I'm stuck on defining <code>mul_le_mul</code> for <code>lemma le_mul</code> which is defined in lean3 using a calc proof. When I port that to Lean4</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">MyNat</span><span class="o">}</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_b</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_c</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hac</span> <span class="n">nn_b</span>
    <span class="n">_</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">hbd</span> <span class="n">nn_c</span>
</code></pre></div>
<p>I'm getting an error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="bp">'</span><span class="k">calc</span><span class="bp">'</span> <span class="n">step</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="bp">`</span><span class="n">Trans</span><span class="bp">`</span> <span class="kd">instance</span>
  <span class="n">Trans</span> <span class="n">LE.le</span> <span class="n">LE.le</span> <span class="bp">?</span><span class="n">m.4473</span>
</code></pre></div>
<p>So what type instance do I need to create for calc to be happy?  I see these instances in the prelude:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Trans</span> <span class="n">Eq</span> <span class="n">r</span> <span class="n">r</span> <span class="n">where</span>
  <span class="n">trans</span> <span class="n">heq</span> <span class="n">h'</span> <span class="o">:=</span> <span class="n">heq</span> <span class="bp">▸</span> <span class="n">h'</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Trans</span> <span class="n">r</span> <span class="n">Eq</span> <span class="n">r</span> <span class="n">where</span>
  <span class="n">trans</span> <span class="n">h'</span> <span class="n">heq</span> <span class="o">:=</span> <span class="n">heq</span> <span class="bp">▸</span> <span class="n">h'</span>
</code></pre></div>
<p>but  it seems to be looking for a Trans on LE.le (rather than on Eq) , and I don't know how to make that work with my custom <code>MyNat</code> type? I already have this but it didn't help:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">LE</span> <span class="n">MyNat</span> <span class="n">where</span>
  <span class="n">le</span> <span class="o">:=</span> <span class="n">MyNat.le</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>
</code></pre></div>



<a name="303957303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303957303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303957303">(Oct 14 2022 at 03:16)</a>:</h4>
<p>It says - you need an instance of the form <code>Trans LE.le LE.le ?m.4473</code></p>



<a name="303957361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303957361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303957361">(Oct 14 2022 at 03:16)</a>:</h4>
<p>also relevant is that those <code>LE.le</code> applications are over <code>MyNat</code> (if you hover over the error message you should be able to see this)</p>



<a name="303958395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303958395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303958395">(Oct 14 2022 at 03:34)</a>:</h4>
<p>Ah, thanks for the hint, I just found these in mathlibe Order.lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Trans</span> <span class="n">α</span> <span class="n">α</span> <span class="n">α</span> <span class="n">LE.le</span> <span class="n">LE.le</span> <span class="n">LE.le</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">le_trans</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Trans</span> <span class="n">α</span> <span class="n">α</span> <span class="n">α</span> <span class="n">LT.lt</span> <span class="n">LE.le</span> <span class="n">LT.lt</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">lt_of_lt_of_le</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="bp">@</span><span class="n">Trans</span> <span class="n">α</span> <span class="n">α</span> <span class="n">α</span> <span class="n">LE.le</span> <span class="n">LT.lt</span> <span class="n">LT.lt</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">lt_of_le_of_lt</span><span class="o">⟩</span>
</code></pre></div>
<p>yikes, sorting through all this now...</p>



<a name="303958798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303958798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303958798">(Oct 14 2022 at 03:40)</a>:</h4>
<p>Basically, calc sees that you have given it two proofs, of <code>R x y</code> and <code>S y z</code> for some relations <code>R</code> and <code>S</code>, and we're asking it to prove <code>T x z</code> for some relation <code>T</code> not provided. So it uses those instances to say "how can I combine a proof of <code>R</code> and a proof of <code>S</code>, what relation does the transitive thing have?" And that's exactly what the instance says. You just have to give it your proof of <code>MyNat.le_trans</code> and then calc can use it</p>



<a name="303958895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303958895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303958895">(Oct 14 2022 at 03:42)</a>:</h4>
<p>that way you can write things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">calc</span>
  <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="n">y</span> <span class="bp">&lt;=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span>
  <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and it somehow is able to figure out that this is supposed to be a proof of <code>x &lt; w</code></p>



<a name="303960083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960083">(Oct 14 2022 at 03:59)</a>:</h4>
<p>Ok, I think I made some progress, the NNG was dependent on level 5 doing this instance which I had commented out:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">structure_helper</span>
</code></pre></div>
<p>so I've replaced this with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">Preorder</span> <span class="n">MyNat</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="n">le_refl_mynat</span><span class="o">,</span> <span class="n">le_trans</span><span class="o">,</span> <span class="n">lt</span><span class="o">⟩</span>
</code></pre></div>
<p>and now I'm getting a different error from the <code>calc</code> proof, it doesn't like my hac and hbd terms:</p>
<p><a href="/user_uploads/3121/gpc-1EqEpPGAqt_uXJ7YxaRb/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/gpc-1EqEpPGAqt_uXJ7YxaRb/image.png" title="image.png"><img src="/user_uploads/3121/gpc-1EqEpPGAqt_uXJ7YxaRb/image.png"></a></div><p>but they were ported directly from the lean3 versions and work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">MyNat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hab</span>
  <span class="n">intro</span> <span class="n">h0</span>
  <span class="n">cases</span> <span class="n">hab</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="n">d</span> <span class="n">hd</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">hd</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">]</span>
    <span class="n">use</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span>

<span class="kd">theorem</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">MyNat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hab</span>
  <span class="n">intro</span> <span class="n">h0</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">]</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span> <span class="n">b</span><span class="o">]</span>
  <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_left</span>
  <span class="n">assumption</span>
  <span class="n">assumption</span>
</code></pre></div>
<p>I get this error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hac</span>
<span class="n">argument</span>
  <span class="n">hac</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">MyNat</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>
<p>I found the <code>Nat.mul_le_mul</code> theorem which is completely different, so I'm trying that route, but it appears I need to boot up a huge chunk of theorems on MyNat for that to work...</p>



<a name="303960216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960216">(Oct 14 2022 at 04:01)</a>:</h4>
<p>You have explicit arguments in <code>mul_le_mul_of_nonneg_left</code>; NNG probably uses implicit arguments <code>{a b c : MyNat}</code></p>



<a name="303960344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960344">(Oct 14 2022 at 04:02)</a>:</h4>
<p>Nope, I ported it as directly as possible, and NNG lean3 has </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="o">[</span><span class="n">nat_num_game</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hab</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="303960433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960433">(Oct 14 2022 at 04:04)</a>:</h4>
<p>Is it actually using that theorem?</p>



<a name="303960438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960438">(Oct 14 2022 at 04:04)</a>:</h4>
<p>there is another theorem with that name in core lean</p>



<a name="303960481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960481">(Oct 14 2022 at 04:05)</a>:</h4>
<p>what does the theorem you are currently porting look like in lean 3?</p>



<a name="303960613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960613">(Oct 14 2022 at 04:07)</a>:</h4>
<p>It's in the same file, but there is this intermediate thing, does this change the game?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">ordered_semiring</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_left</span><span class="o">,</span>
  <span class="n">mul_le_mul_of_nonneg_right</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_right</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_left</span> <span class="o">:=</span> <span class="n">mul_lt_mul_of_pos_left</span><span class="o">,</span>
  <span class="n">mul_lt_mul_of_pos_right</span> <span class="o">:=</span> <span class="n">mul_lt_mul_of_pos_right</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">mynat.semiring</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">mynat.ordered_cancel_comm_monoid</span>
<span class="o">}</span>
</code></pre></div>
<p>and the lean3 proof I'm porting is this one from <a href="https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/game/world10/level18a.lean">level18a</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">le_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="o">[</span><span class="n">nat_num_game</span><span class="o">]</span>
<span class="n">intros</span> <span class="n">hab</span> <span class="n">hcd</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">t</span> <span class="n">Ht</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">zero_mul</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">zero_le</span><span class="o">,</span>
<span class="k">have</span> <span class="n">cz</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">zero_le</span><span class="o">,</span>
<span class="k">have</span> <span class="n">bz</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">zero_le</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">mul_le_mul</span> <span class="n">hab</span> <span class="n">hcd</span> <span class="n">cz</span> <span class="n">bz</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="303960675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960675">(Oct 14 2022 at 04:08)</a>:</h4>
<p>yes, instances are something to pay attention to</p>



<a name="303960702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960702">(Oct 14 2022 at 04:08)</a>:</h4>
<p>and indeed it explains the behavior - <code>ordered_semiring</code> is the typeclass that would make the <code>mul_le_mul_of_nonneg_left</code> lemma from core work on <code>mynat</code></p>



<a name="303960730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960730">(Oct 14 2022 at 04:09)</a>:</h4>
<p>That's not going to work in lean 4 until sufficiently much of mathlib4 is ported</p>



<a name="303960751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960751">(Oct 14 2022 at 04:09)</a>:</h4>
<p>Oh, and the mathlib3 implementation of mu_le_mul is more general it operates on any alpha, whereas I fixed mine to MyNat...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_b</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_c</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span>
<span class="k">calc</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hac</span> <span class="n">nn_b</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">hbd</span> <span class="n">nn_c</span>
</code></pre></div>



<a name="303960756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960756">(Oct 14 2022 at 04:09)</a>:</h4>
<p>but the easy solution in your case is just to make the arguments implicit or use <code>_ _ _</code> in the theorem application</p>



<a name="303960822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960822">(Oct 14 2022 at 04:11)</a>:</h4>
<p>right, that instance is saying that since you proved some basic facts about &lt;= and *, a whole bunch of other facts follow from that like <code>mul_le_mul</code></p>



<a name="303960899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960899">(Oct 14 2022 at 04:12)</a>:</h4>
<p>You won't be able to use the typeclass or suite of theorems since they don't exist yet in lean 4, but hopefully NNG isn't making too much use of them? It's basically cheating from the NNG perspective</p>



<a name="303960908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960908">(Oct 14 2022 at 04:12)</a>:</h4>
<p>yeah, I thought so, when F12 jumped to Ordered_ring.lean which is the same name as that instance <code>ordered_semiring</code>.  But I figured I could cheat and jump straight to <code>mul_le_mul</code>, and so long as I could provide that then <code>lemma le_mul</code> should be happy without the full <code>ordered_semiring</code>...</p>



<a name="303960909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960909">(Oct 14 2022 at 04:12)</a>:</h4>
<p>it could actually be a mistake in the lean 3 code</p>



<a name="303960945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303960945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303960945">(Oct 14 2022 at 04:13)</a>:</h4>
<p>The lean3 level18a.lean compiles with no errors though.</p>



<a name="303961029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303961029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303961029">(Oct 14 2022 at 04:14)</a>:</h4>
<p>so perhaps I'd be better off giving  up on <code>mul_le_mul</code> and find another way to complete <code>lemma le_mul</code>...</p>



<a name="303961050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303961050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303961050">(Oct 14 2022 at 04:15)</a>:</h4>
<p>I have this to complete:<br>
<a href="/user_uploads/3121/09W9gDlDJRqW2gA9LOzaGdL0/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/09W9gDlDJRqW2gA9LOzaGdL0/image.png" title="image.png"><img src="/user_uploads/3121/09W9gDlDJRqW2gA9LOzaGdL0/image.png"></a></div>



<a name="303961086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303961086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303961086">(Oct 14 2022 at 04:15)</a>:</h4>
<p>You should be able to prove <code>mul_le_mul</code> exactly the way it was done in <code>ordered_ring.lean</code></p>



<a name="303961140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303961140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303961140">(Oct 14 2022 at 04:16)</a>:</h4>
<p>it's just transitivity on <code>mul_le_mul_of_nonneg_right</code> and <code>mul_le_mul_of_nonneg_left</code></p>



<a name="303961166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303961166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303961166">(Oct 14 2022 at 04:16)</a>:</h4>
<p>which you must have proved previously since they are inputs to the <code>ordered_ring</code> instance</p>



<a name="303961425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303961425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303961425">(Oct 14 2022 at 04:21)</a>:</h4>
<p>That's what I was trying to do with this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">MyNat</span><span class="o">}</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_b</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_c</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hac</span> <span class="n">nn_c</span>
    <span class="n">_</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">hbd</span> <span class="n">nn_b</span>
</code></pre></div>
<p>But perhaps I can prove it without using <code>calc</code> and then skip the needs for the Trans instance...</p>



<a name="303962150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962150">(Oct 14 2022 at 04:33)</a>:</h4>
<p>Is there a reason you don't want the Trans instance?</p>



<a name="303962227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962227">(Oct 14 2022 at 04:34)</a>:</h4>
<p>Note that the <code>Trans LE LE LE</code> instance holds in general for any <code>Preorder</code> so you can hide it in whatever library is defining <code>Preorder</code></p>



<a name="303962269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962269">(Oct 14 2022 at 04:35)</a>:</h4>
<p>the proof without calc just combines those two theorems using <code>le_trans</code></p>



<a name="303962285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962285">(Oct 14 2022 at 04:35)</a>:</h4>
<p>Oh, I finally got what you were talking about with <code>_ _ _ </code> and so I'm trying this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">MyNat</span><span class="o">}</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_b</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_c</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hac</span> <span class="n">nn_c</span>
    <span class="n">_</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hbd</span> <span class="n">nn_b</span>
</code></pre></div>
<p>But now it complains about the <code>nn_c</code> term and the <code>nn_b</code> term saying</p>
<p><a href="/user_uploads/3121/dR8ogPeIbLJPokmGY1QfOuDv/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/dR8ogPeIbLJPokmGY1QfOuDv/image.png" title="image.png"><img src="/user_uploads/3121/dR8ogPeIbLJPokmGY1QfOuDv/image.png"></a></div>



<a name="303962361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962361">(Oct 14 2022 at 04:36)</a>:</h4>
<p>PS: I remember now something about lean3 allowing terms to go unspecified inside a proof making those arguments implicit, but lean4 doesn't allow that.</p>



<a name="303962618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962618">(Oct 14 2022 at 04:40)</a>:</h4>
<p>Oh hey, I just got it trying random things, turns out I just had to switch the terms for some reason and this works in lean4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">MyNat</span><span class="o">}</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_b</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_c</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hac</span> <span class="n">nn_b</span>
    <span class="n">_</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hbd</span> <span class="n">nn_c</span>
</code></pre></div>
<p>So with that all proofs are ported from NNG :-) (but there's still some todo work items to do with these "instances" which NNG calls collectibles.</p>



<a name="303962665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303962665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303962665">(Oct 14 2022 at 04:41)</a>:</h4>
<p>See <a href="https://lovettsoftware.com/NaturalNumbers/InequalityWorld/Level18.lean.html">https://lovettsoftware.com/NaturalNumbers/InequalityWorld/Level18.lean.html</a>, they all work now.</p>



<a name="303963093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303963093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303963093">(Oct 14 2022 at 04:49)</a>:</h4>
<blockquote>
<p>turns out I just had to switch the terms for some reason</p>
</blockquote>
<p>did you or NNG perhaps interchange the meanings of <code>mul_le_mul_of_nonneg_left</code> and <code>mul_le_mul_of_nonneg_right</code>? It's not really obvious which way around is supposed to be "left"</p>



<a name="303963237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303963237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303963237">(Oct 14 2022 at 04:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="434989">Chris Lovett</span> <a href="#narrow/stream/270676-lean4/topic/indent.20after.20have/near/303962361">said</a>:</p>
<blockquote>
<p>PS: I remember now something about lean3 allowing terms to go unspecified inside a proof making those arguments implicit, but lean4 doesn't allow that.</p>
</blockquote>
<p>not sure what this is a reference to. Perhaps the fact that <code>refine foo _</code> doesn't work where <code>refine' foo _</code> does?</p>



<a name="303963263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303963263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303963263">(Oct 14 2022 at 04:51)</a>:</h4>
<p>No the reason I needed to add the _ _ _ in <code>mul_le_mul_of_nonneg_right _ _ _ hac nn_b</code> but it was not needed in lean3 version.</p>



<a name="303963576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303963576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303963576">(Oct 14 2022 at 04:56)</a>:</h4>
<p>Never mind, somehow in my messing around I must have switched them or mistyped them or something, the lean3 semiring has them in the same order with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_le_mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_b</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">nn_c</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:=</span>
<span class="k">calc</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hac</span> <span class="n">nn_b</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="o">:</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">hbd</span> <span class="n">nn_c</span>
</code></pre></div>
<p>we we're all good now.</p>



<a name="303965195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303965195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303965195">(Oct 14 2022 at 05:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="434989">Chris Lovett</span> <a href="#narrow/stream/270676-lean4/topic/indent.20after.20have/near/303963263">said</a>:</p>
<blockquote>
<p>No the reason I needed to add the _ _ _ in <code>mul_le_mul_of_nonneg_right _ _ _ hac nn_b</code> but it was not needed in lean3 version.</p>
</blockquote>
<p>The reason you needed to add that is because in your version of the theorem the <code>a b c</code> arguments are in <code>()</code> binders. In the lean 3 version (in the <code>ordered_ring.lean</code> file, not in NNG since the NNG is referencing the version from <code>ordered_ring.lean</code>) they are in <code>{}</code> binders</p>



<a name="303995783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/303995783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#303995783">(Oct 14 2022 at 09:41)</a>:</h4>
<p>Right but in NNG they redefined <code>mul_le_mul_of_nonneg_right</code> the same way I did (because I just ported it from there).</p>



<a name="304158634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/indent%20after%20have/near/304158634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/indent.20after.20have.html#304158634">(Oct 15 2022 at 06:51)</a>:</h4>
<p>It might be the case that I made up my own binders and it might be the case that the choice of binders changed in lean 3 since I made the game (about three years ago). Binders are something I don't teach.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html">Destructor of Inductive Types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="294428943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Destructor%20of%20Inductive%20Types/near/294428943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yicheng Qian <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html#294428943">(Aug 20 2022 at 11:34)</a>:</h4>
<p>I was a Coq user and have just begun working on a project in Lean. I'm trying to understand Lean based on my experience with Coq, and encountered multiple problems related to destructors of inductive types.<br>
In Coq, there is a <code>match ... in ... return ... with | ... | ... | ...</code> clause which does dependent pattern matching, and recursors of inductive types are defined using the <code>match ... in ... return ... with | ... | ... | ...</code> clause and the <code>fix</code> keyword.<br>
On the contrary, (it seems to me that) the match expressions in Lean are defined using recursors of the inductive types, and the recursor <code>&lt;indtype&gt;.rec</code> is "atomic".  However, the behaviour of Lean's <code>match ... with | ... | ... | ...</code> clause and structural recursion makes me very confused.</p>
<p>The first thing that confuses me is that Lean sometimes does not recognize decreasing arguments of recursive functions. Consider <code>Acc</code> (the accessibility predicate, used to define well-foundedness)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Acc</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">x</span>
</code></pre></div>
<p>In Coq, the predicate is defined as follows</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Inductive</span> <span class="n">Acc</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">Acc_intro</span> <span class="o">:</span> <span class="o">(</span><span class="k">forall</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">Acc</span> <span class="n">R</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Acc</span> <span class="n">R</span> <span class="n">x.</span>
</code></pre></div>
<p>and the destructor of this predicate is defined as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Definition</span> <span class="n">Acc_rect'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Type</span><span class="o">)</span>
   <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="k">forall</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">Acc</span> <span class="n">R</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="k">forall</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">Acc</span> <span class="n">R</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">fix</span> <span class="n">F</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">R</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span><span class="n">struct</span> <span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">Acc_intro</span> <span class="n">_</span> <span class="n">Q</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="n">Q</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">F</span> <span class="n">y</span> <span class="o">(</span><span class="n">Q</span> <span class="n">y</span> <span class="n">r</span><span class="o">))</span>
  <span class="kd">end</span><span class="bp">.</span>
</code></pre></div>
<p>However, when I tried to define the same thing in Lean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Acc_rec'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
               <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span>
               <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span>
                       <span class="o">((</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Ry</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">y</span> <span class="n">Ry</span><span class="o">)</span> <span class="bp">→</span>
                       <span class="o">(</span><span class="n">Rx</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">x</span> <span class="n">Rx</span><span class="o">)</span>
               <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">a</span> <span class="n">t</span>
  <span class="bp">|</span> <span class="n">Acc.intro</span> <span class="n">a'</span> <span class="n">Q</span> <span class="bp">=&gt;</span> <span class="n">H</span> <span class="n">a'</span> <span class="n">Q</span> <span class="o">(</span><span class="k">fun</span> <span class="n">y</span> <span class="n">Hr</span> <span class="n">Ry</span> <span class="bp">=&gt;</span> <span class="n">Acc_rec'</span> <span class="n">motive</span> <span class="n">H</span> <span class="n">y</span> <span class="o">(</span><span class="n">Q</span> <span class="n">y</span> <span class="n">Hr</span><span class="o">))</span> <span class="o">(</span><span class="n">Acc.intro</span> <span class="n">a'</span> <span class="n">Q</span><span class="o">)</span>
</code></pre></div>
<p>It produces the error message</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">fail</span> <span class="n">to</span> <span class="k">show</span> <span class="n">termination</span> <span class="n">for</span>
    <span class="n">Acc_rec'</span>
  <span class="k">with</span> <span class="n">errors</span>
  <span class="n">structural</span> <span class="n">recursion</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span>

  <span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">termination</span><span class="o">,</span> <span class="n">use</span> <span class="bp">`</span><span class="n">termination_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">well</span><span class="bp">-</span><span class="n">founded</span> <span class="n">relation</span>
</code></pre></div>
<p>which (if I'm right) indicates that it didn't recognize the decreasing argument <code>(t : Acc r a)</code>.<br>
I know that the predicate <code>Acc.rec</code> is automatically generated by Lean and there is no need to define it by hand. But the problem is that Lean did not recognize the decreasing argument, which makes me confused.</p>



<a name="294454003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Destructor%20of%20Inductive%20Types/near/294454003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html#294454003">(Aug 20 2022 at 15:20)</a>:</h4>
<p>Yes, lean's equation compiler does not support direct structural recursion</p>



<a name="294454292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Destructor%20of%20Inductive%20Types/near/294454292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html#294454292">(Aug 20 2022 at 15:22)</a>:</h4>
<p>which is counterintuitive since this is the simplest kind of recursion. It supports "bounded recursion", which is like structural recursion except it also allows doing  multiple layers of inductive constructors at once, and well founded recursion which is where you recurse on a well founded type with a measure function</p>



<a name="294454472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Destructor%20of%20Inductive%20Types/near/294454472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html#294454472">(Aug 20 2022 at 15:24)</a>:</h4>
<p>However, neither of those methods apply here: bounded recursion only works for "regular inductives" which are not in Prop, and well founded recursion in default configuration will attempt to use recursion on a natural number "height" function which is not powerful enough to show Acc is well founded</p>



<a name="294454510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Destructor%20of%20Inductive%20Types/near/294454510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html#294454510">(Aug 20 2022 at 15:25)</a>:</h4>
<p>The simplest way to do direct structural recursion in lean is to use the <code>induction</code> tactic instead of the equation compiler</p>



<a name="294454715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Destructor%20of%20Inductive%20Types/near/294454715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Destructor.20of.20Inductive.20Types.html#294454715">(Aug 20 2022 at 15:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Acc_rec'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
               <span class="o">(</span><span class="n">motive</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span>
               <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span>
                       <span class="o">((</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Ry</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">y</span> <span class="n">Ry</span><span class="o">)</span> <span class="bp">→</span>
                       <span class="o">(</span><span class="n">Rx</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">x</span> <span class="n">Rx</span><span class="o">)</span>
               <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">r</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">a</span> <span class="n">t</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">t</span>
  <span class="n">induction</span> <span class="n">t</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="n">a'</span> <span class="n">Q</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">a'</span> <span class="n">Q</span> <span class="o">(</span><span class="k">fun</span> <span class="n">y</span> <span class="n">Hr</span> <span class="n">Ry</span> <span class="bp">=&gt;</span> <span class="n">ih</span> <span class="n">y</span> <span class="n">Hr</span><span class="o">)</span> <span class="o">(</span><span class="n">Acc.intro</span> <span class="n">a'</span> <span class="n">Q</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
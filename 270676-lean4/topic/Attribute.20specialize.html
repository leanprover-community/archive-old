---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Attribute.20specialize.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html">Attribute specialize</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221797702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221797702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221797702">(Jan 06 2021 at 17:41)</a>:</h4>
<p>What does the new attribute <code>@[specialize]</code> do?</p>



<a name="221803005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221803005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221803005">(Jan 06 2021 at 18:23)</a>:</h4>
<p>It is an instruction to the compiler. If you write a function <code>def foo {m a} [Monad m] : Int -&gt; m a</code>, the straightforward way to generate code is to make it a higher-order function that takes <code>bind</code> and <code>pure</code> as parameter. Invoking parameters is typically slow and <code>foo</code> can be made more efficient if new code is generated by the compiler for every monad with which <code>foo</code> is being called.</p>



<a name="221803106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221803106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221803106">(Jan 06 2021 at 18:24)</a>:</h4>
<p>This is useful in general when taking type class instances as parameter but also when simply taking functions as parameters.</p>



<a name="221805784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221805784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221805784">(Jan 06 2021 at 18:45)</a>:</h4>
<p>Interesting! How do I find out what specializations the compiler has generated? Will it inline small functions? What happens to functions when I provide a second function with a more specific type signature? (I am just now starting to read about the details of Lean 4...)</p>



<a name="221806137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806137">(Jan 06 2021 at 18:49)</a>:</h4>
<p>There are options you can set (something like <code>set_option compiler.ir true</code>, I don't remember the exact name of the option) that causes the output of various stages of the compiler to be printed out</p>



<a name="221806196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806196">(Jan 06 2021 at 18:50)</a>:</h4>
<p>It is extremely useful when you want to make sure that large data structures are actually used in a linear manner (and that destructive updates are enabled)</p>



<a name="221806310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806310">(Jan 06 2021 at 18:50)</a>:</h4>
<p>What do you mean by "when I provide a second function"? What does the second function do?</p>



<a name="221806561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806561">(Jan 06 2021 at 18:52)</a>:</h4>
<p>ahh, I am thinking in terms of C++, like how the compiler chooses the correct template specialization</p>



<a name="221806766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806766">(Jan 06 2021 at 18:54)</a>:</h4>
<p>I guess as a 1st order approximation you can take <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html#specialize-pragma">https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html#specialize-pragma</a> as the documentation</p>



<a name="221806778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806778">(Jan 06 2021 at 18:54)</a>:</h4>
<p>I realize it came out yesterday so if the answer is: read the source code, that is OK</p>



<a name="221806859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221806859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221806859">(Jan 06 2021 at 18:55)</a>:</h4>
<p>Ah! I see! This is not like template specialization. With template specialization, the user provides different "versions" of the same declaration. Here, the compiler see your definition of <code>mmap</code> (for instance), sees that you use it with the state monad and generates code for <code>mmap</code> that specifically uses your state monad. That is to say that calls to <code>bind</code> and <code>pure</code> are statically bound instead of dynamically bound.</p>



<a name="221808217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/221808217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#221808217">(Jan 06 2021 at 19:06)</a>:</h4>
<p>Actually, in the case of <code>mmap f</code>, you can specialize further and bind statically the exact function <code>f</code> being passed as a parameter. That function is often a lambda abstraction and the specialization also saves us from allocating a thunk at run time</p>



<a name="222052644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Attribute%20specialize/near/222052644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Attribute.20specialize.html#222052644">(Jan 08 2021 at 09:40)</a>:</h4>
<p>Thank you Simon, this is very helpful!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
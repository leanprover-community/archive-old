---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html">using higher-order functions on inductive types: termination</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="275174999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275174999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275174999">(Mar 13 2022 at 21:04)</a>:</h4>
<p>I'm trying to prove termination on a function on an inductively-defined type. The problem is that my function uses higher-order functions, e.g. <code>map</code>, for which it seems Lean (understandably) doesn't know that they are well-behaved w.r.t induction. Here's an MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">TreeNode</span> <span class="o">:=</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">TreeNode</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">TreeNode</span>

<span class="kn">open</span> <span class="n">TreeNode</span> <span class="k">in</span> <span class="kd">def</span> <span class="n">treeToList</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span>
 <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="n">name</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span> <span class="bp">=&gt;</span> <span class="n">name</span> <span class="o">::</span> <span class="n">List.join</span> <span class="o">(</span><span class="n">children.map</span> <span class="n">treeToList</span><span class="o">)</span>
</code></pre></div>
<p>Here, Lean won't be able to prove termination. Obviously, I can just add <code>partial</code> and be done with it, but I don't want to, for obvious reasons. For this simple example I can also just rewrite it to do it "manually", e.g. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">TreeNode</span> <span class="k">in</span> <span class="kd">def</span> <span class="n">treeToList</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span>
 <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="n">name</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">rest</span><span class="o">)</span> <span class="bp">=&gt;</span>  <span class="n">treeToList</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">rest</span><span class="o">)</span> <span class="bp">++</span> <span class="n">treeToList</span> <span class="n">c</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
</code></pre></div>
<p>But I guess it kind of breaks the point of using higher-order-functions if I can't use them for programming. This seems to be a pattern that should be common, so I'm hoping someone else has encountered it before. Is there a nice way to deal with it?</p>
<p>I also tried defining the depth of my inductive type to prove termination using well-founded recursion, but I can't figure out what I'm doing wrong there :/  If I write something like: <br>
<code>termination_by _ =&gt; t.depth</code>, I get a message that says <code>unexpected occurrence of recursive application</code>. For this MWE it would look something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">TreeNode</span> <span class="k">in</span> <span class="kd">def</span> <span class="n">TreeNode.depth</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">rest</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">rest</span><span class="o">))</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">_</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="kn">open</span> <span class="n">TreeNode</span> <span class="k">in</span> <span class="kd">def</span> <span class="n">treeToList</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span>
 <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="n">name</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span> <span class="bp">=&gt;</span>  <span class="n">name</span> <span class="o">::</span> <span class="n">List.join</span> <span class="o">(</span><span class="n">children.map</span> <span class="n">treeToList</span><span class="o">)</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">t.depth</span>
</code></pre></div>
<p>and that tells me </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unexpected</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="n">recursive</span> <span class="n">application</span>
  <span class="n">treeToList</span>
</code></pre></div>
<p>(and won't let me prove it's actually decreasing with <code>decreasing_by</code> either, it seems to break already with the line above).</p>
<p>Can someone help me understand what I'm doing wrong and/or even point me to how to deal with this pattern more generally (using higher-order functions on inductively-defined types)? Thanks!</p>



<a name="275175103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275175103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275175103">(Mar 13 2022 at 21:07)</a>:</h4>
<p>I think using well-founded recursion is the right move in general, but a limitation is that you must actually <em>apply</em> the function recursively (not pass it to a HOF)</p>



<a name="275175118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275175118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275175118">(Mar 13 2022 at 21:07)</a>:</h4>
<p>So here if you do <code>children.map (fun T =&gt; treeToList T)</code> it should give a better error message</p>



<a name="275175175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275175175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275175175">(Mar 13 2022 at 21:08)</a>:</h4>
<p>In particular that you need to prove the <code>T</code> there has depth &lt; the depth of <code>t</code></p>



<a name="275175217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275175217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275175217">(Mar 13 2022 at 21:10)</a>:</h4>
<p>(And doing that is also hard in general, but my first instinct would be to somehow map <code>children</code> to a list of children with proof that their depths are strictly smaller?)</p>



<a name="275175302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275175302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275175302">(Mar 13 2022 at 21:11)</a>:</h4>
<p>interesting, yes, that extra lambda there actually helps, thanks! it's kind of strange that it would need that <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> <br>
<span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275175118">said</a>:</p>
<blockquote>
<p>So here if you do <code>children.map (fun T =&gt; treeToList T)</code> it should give a better error message</p>
</blockquote>



<a name="275175448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275175448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275175448">(Mar 13 2022 at 21:15)</a>:</h4>
<p>Yeah...  Lean won't do the eta expansion automatically, and also requires that recursive calls are fully applied.</p>
<p>The error message is pretty unhelpful there, it might be worth improving? <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span></p>



<a name="275176517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275176517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275176517">(Mar 13 2022 at 21:44)</a>:</h4>
<p>The error message after that eta expansion is much more helpful! I'm pretty puzzled by the proof obligation term though :/ In my actual example it has some <code>sorryAx</code>. In the MWE I was using here it doesn't, but it's still pretty confusing: it doesn't seem to have the equality of the pattern match:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">termination</span><span class="o">,</span> <span class="n">possible</span> <span class="n">solutions</span><span class="o">:</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="k">have</span><span class="bp">`-</span><span class="n">expressions</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">the</span> <span class="n">remaining</span> <span class="n">goals</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">termination_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">different</span> <span class="n">well</span><span class="bp">-</span><span class="n">founded</span> <span class="n">relation</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">decreasing_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specity</span> <span class="n">your</span> <span class="n">own</span> <span class="n">tactic</span> <span class="n">for</span> <span class="n">discharging</span> <span class="n">this</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">goal</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="bp">‚ä¢</span> <span class="n">depth</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span>
</code></pre></div>
<p>I think I might not quite understand the input to <code>decreasing_by</code>, I thought it was a function of the inputs to some type that has a well-founded relation? But why won't it understand that the input <code>t : TreeNode</code> in this simple example here is the same as the pattern-matched <code>mkNode name children</code>?</p>



<a name="275176676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275176676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275176676">(Mar 13 2022 at 21:48)</a>:</h4>
<p>by the way, when copy-pasting that Zulip noticed there's a typo there (specity -&gt; specify), seems to come from <a href="https://github.com/leanprover/lean4/blob/fa0964c07e70bd3ad546a18d9c450c9c27d29920/src/Init/WFTactics.lean#L24">https://github.com/leanprover/lean4/blob/fa0964c07e70bd3ad546a18d9c450c9c27d29920/src/Init/WFTactics.lean#L24</a> <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span></p>



<a name="275176699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275176699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275176699">(Mar 13 2022 at 21:49)</a>:</h4>
<p><code>t</code> is the element of <code>children</code>. <code>decreasing_by</code> is where you provide a proof that <code>depth t &lt; depth (mkNode name children)</code>, <code>termination_by</code> is where you specify what relation you want to use.</p>



<a name="275176847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275176847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275176847">(Mar 13 2022 at 21:52)</a>:</h4>
<p><span class="user-mention" data-user-id="228466">@Chris B</span> how do you know that <code>t</code> is an element of <code>children</code>?  where does it say that?</p>



<a name="275176952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275176952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275176952">(Mar 13 2022 at 21:55)</a>:</h4>
<p>I thought you were using  the eta expanded<code>(fun t =&gt; treeToList t)</code>, my bad. What is the definition you're working with now?</p>



<a name="275176961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275176961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275176961">(Mar 13 2022 at 21:55)</a>:</h4>
<p>You can preserve a hypothesis about the matched element with  <code>match ht:t with</code>.</p>



<a name="275177472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275177472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275177472">(Mar 13 2022 at 22:05)</a>:</h4>
<p>Yep, you're right about that! I am using that eta expanded <code>(fun t =&gt; treeToList t)</code>.  The problem is then that it's not in my hypotheses then in <code>decreasing_by</code>. That's a great suggestion, preserving it with the <code>match ht:t with</code>, thanks! That actually shows that indeed it wants me to prove two entirely unrelated terms to be decreasing. It then shows as: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">x</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">ht</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span>
<span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="bp">‚ä¢</span> <span class="n">depth</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span>
</code></pre></div>



<a name="275177744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275177744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275177744">(Mar 13 2022 at 22:10)</a>:</h4>
<p>There seems to be something strange going on there :/ if I try to do an induction over <code>t</code>, it will then again relate the two to each other, but in a way that doesn't make sense.  This seems really confusing, is that maybe a hygiene bug? Concretely, the code: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">TreeNode</span> <span class="k">in</span> <span class="kd">def</span> <span class="n">treeToList</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span>
 <span class="k">match</span> <span class="n">ht</span><span class="o">:</span><span class="n">t</span> <span class="k">with</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="n">name</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span> <span class="bp">=&gt;</span> <span class="n">name</span> <span class="o">::</span> <span class="n">List.join</span> <span class="o">(</span><span class="n">children.map</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">t</span> <span class="bp">=&gt;</span> <span class="n">treeToList</span> <span class="n">t</span><span class="o">))</span>
<span class="n">termination_by</span> <span class="n">treeToList</span> <span class="n">t</span> <span class="bp">=&gt;</span> <span class="n">TreeNode.depth</span> <span class="n">t</span>
<span class="n">decreasing_by</span> <span class="o">{</span>
<span class="n">simp_wf</span>
<span class="n">induction</span> <span class="n">t</span>
<span class="o">}</span>
</code></pre></div>
<p>will give this state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unsolved</span> <span class="n">goals</span>
<span class="n">case</span> <span class="n">mkLeaf</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">ht</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="bp">‚ä¢</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkLeaf</span> <span class="n">name</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span>

<span class="n">case</span> <span class="n">mkNode</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">ht</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span>
<span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">children_ih</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.40538</span> <span class="n">children</span>
<span class="bp">‚ä¢</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span>

<span class="n">case</span> <span class="n">nil</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">ht</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span>
<span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="bp">‚ä¢</span> <span class="bp">?</span><span class="n">m.40538</span> <span class="o">[]</span>

<span class="n">case</span> <span class="n">cons</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">ht</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span>
<span class="n">t</span> <span class="n">head</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">tail</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">head_ih</span> <span class="o">:</span> <span class="n">depth</span> <span class="n">head</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span>
<span class="n">tail_ih</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m.40538</span> <span class="n">tail</span>
<span class="bp">‚ä¢</span> <span class="bp">?</span><span class="n">m.40538</span> <span class="o">(</span><span class="n">head</span> <span class="o">::</span> <span class="n">tail</span><span class="o">)</span>
</code></pre></div>
<p>And why does it also have cases for <code>t</code> being a <code>List TreeNode</code>?</p>



<a name="275183671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275183671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275183671">(Mar 14 2022 at 00:32)</a>:</h4>
<p>Hrm, this isn't a bug, but there's a lot of complexity here. If you write <code>decreasing_by sorry</code> you can see the proof obligation there, and it should be something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">depth</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="n">t</span><span class="bp">‚úù</span>
</code></pre></div>



<a name="275183759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275183759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275183759">(Mar 14 2022 at 00:35)</a>:</h4>
<p>We don't have any useful information in context because, a priori, the <code>t</code> in the lambda could be arbitrary. You have to find a way to communicate to within the lambda that the depth of <code>t</code> in the lambda is strictly smaller, i.e. that <code>map</code> only calls the function on elements of the list</p>



<a name="275184627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275184627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275184627">(Mar 14 2022 at 00:57)</a>:</h4>
<p>This definition (not in Std) might be helpful:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">def</span> <span class="n">List.map_sub</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">œÑ</span> <span class="bp">‚Üí</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">List</span> <span class="n">œÑ</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="o">(</span><span class="bp">‚àÄ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">‚àà</span> <span class="n">L</span> <span class="bp">‚Üí</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="bp">‚Üí</span> <span class="n">List</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">œÑ</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">x</span> <span class="o">}</span>
  <span class="bp">|</span> <span class="o">[]</span>      <span class="bp">=&gt;</span> <span class="bp">Œª</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">t</span><span class="o">::</span><span class="n">ts</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">Œª</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="o">‚ü®</span><span class="n">t</span><span class="o">,</span> <span class="n">h</span> <span class="n">t</span> <span class="o">(</span><span class="n">Mem.head</span> <span class="n">_</span> <span class="n">_</span><span class="o">)‚ü©</span> <span class="o">::</span>
    <span class="n">map_sub</span> <span class="n">ts</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">x</span> <span class="n">mem</span> <span class="bp">=&gt;</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">Mem.tail</span> <span class="n">_</span> <span class="n">mem</span><span class="o">))</span>
</code></pre></div>
<p>which lets you subtype the members of a list by some property (e.g. having depth less than the parent node). Then you would have access to a proof of that property within the lambda that you make the recursive call at.</p>
<p>This might be a terrible way to go about it though, I'm not sure.</p>



<a name="275184831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275184831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275184831">(Mar 14 2022 at 01:01)</a>:</h4>
<p>The easier way to do this would be to index your NodeTree type on its depth, but I don't think that's a good solution either.</p>



<a name="275184885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275184885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275184885">(Mar 14 2022 at 01:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275183671">said</a>:</p>
<blockquote>
<p>Hrm, this isn't a bug, but there's a lot of complexity here. If you write <code>decreasing_by sorry</code> you can see the proof obligation there, and it should be something like</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">depth</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="n">t</span><span class="bp">‚úù</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Oh I just saw you had sent this already <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> sorry</p>



<a name="275184971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275184971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275184971">(Mar 14 2022 at 01:05)</a>:</h4>
<p>Oh, another way to get this to prove termination is via a mutually recursive definition, where you have a mutually recursive definition that essentially computes <code>children.map treeToList</code> but by explicitly recursing on <code>children</code></p>



<a name="275184979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275184979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275184979">(Mar 14 2022 at 01:05)</a>:</h4>
<p>But I really don't like that solution, because rewriting map is annoying.</p>



<a name="275184983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275184983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275184983">(Mar 14 2022 at 01:05)</a>:</h4>
<p>I mean, the <code>TreeNode</code> example is just the simplest example that shows the problem. I can't imagine this is a very far-fetched pattern here, but I'm starting to think there might be some problem in Lean underlying this. Perhaps because <code>List</code> is itself an inductive type? If I try to compute the simplest example it already breaks:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#reduce</span> <span class="n">TreeNode.depth</span> <span class="o">(</span><span class="n">TreeNode.mkNode</span> <span class="s2">"foo"</span> <span class="o">[</span><span class="n">TreeNode.mkLeaf</span> <span class="s2">"bar"</span><span class="o">])</span>
</code></pre></div>
<p>will yield: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">maximum</span> <span class="n">recursion</span> <span class="n">depth</span> <span class="n">has</span> <span class="n">been</span> <span class="n">reached</span> <span class="o">(</span><span class="n">use</span> <span class="bp">`</span><span class="kd">set_option</span> <span class="n">maxRecDepth</span> <span class="bp">&lt;</span><span class="n">num</span><span class="bp">&gt;`</span> <span class="n">to</span> <span class="n">increase</span> <span class="n">limit</span><span class="o">)</span>
</code></pre></div>
<p>Even though the individual patterns all work well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#reduce</span> <span class="n">TreeNode.depth</span> <span class="o">(</span><span class="n">TreeNode.mkLeaf</span> <span class="s2">"bar"</span><span class="o">)</span>
<span class="k">#reduce</span> <span class="n">TreeNode.depth</span> <span class="o">(</span><span class="n">TreeNode.mkNode</span> <span class="s2">"foo"</span> <span class="o">[])</span>
<span class="k">#reduce</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">max</span> <span class="o">(</span><span class="n">TreeNode.depth</span> <span class="o">(</span><span class="n">TreeNode.mkLeaf</span> <span class="s2">"bar"</span><span class="o">))</span> <span class="o">(</span><span class="n">TreeNode.depth</span> <span class="o">(</span><span class="n">TreeNode.mkNode</span> <span class="s2">"foo"</span> <span class="o">[]))</span>
</code></pre></div>



<a name="275185454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275185454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275185454">(Mar 14 2022 at 01:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315434">Andr√©s Goens</span> <a href="#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275184983">said</a>:</p>
<blockquote>
<p>I can't imagine this is a very far-fetched pattern here, but I'm starting to think there might be some problem in Lean underlying this. Perhaps because <code>List</code> is itself an inductive type? </p>
</blockquote>
<p>This construction is called a nested inductive and it is indeed more complex than a regular inductive. Lean 4 has much better fundamental support for nested and mutual inductives than lean 3, and the developers have said that making these usable is one of their goals. While the kernel stuff is in place, I think they've mentioned elsewhere that polishing this part of the developer experience is further back in the queue (your example also uses well-founded recursion, which is in the same boat). Keep in mind you're using software that has not seen its first official stable release.</p>



<a name="275185531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275185531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275185531">(Mar 14 2022 at 01:19)</a>:</h4>
<p>The <code>#reduce</code> example works for me on <code>m3</code> by the way.</p>



<a name="275185697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275185697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275185697">(Mar 14 2022 at 01:23)</a>:</h4>
<p>Sure, I'm aware it's WIP! I'm not complaining at all, just trying to understand things :) thanks for the pointer to nested inductives.</p>



<a name="275185752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275185752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275185752">(Mar 14 2022 at 01:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="228466">Chris B</span> <a href="#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275185531">said</a>:</p>
<blockquote>
<p>The <code>#reduce</code> example works for me on <code>m3</code> by the way.</p>
</blockquote>
<p>interesting! sorry, what's <code>m3</code> <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> ?</p>



<a name="275185820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275185820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275185820">(Mar 14 2022 at 01:26)</a>:</h4>
<p>I didn't take it as a complaint, just saying "it will probably work better in the near future". <code>m3</code> is  milestone3, the version of lean; v4.0.0-m3.</p>



<a name="275186043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275186043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275186043">(Mar 14 2022 at 01:32)</a>:</h4>
<p>huh, interesting, it doesn't work with the latest nightly for me</p>



<a name="275186126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275186126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275186126">(Mar 14 2022 at 01:35)</a>:</h4>
<p>(which I guess it does hint at a bug)</p>



<a name="275186363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275186363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275186363">(Mar 14 2022 at 01:41)</a>:</h4>
<p>Also <code>#reduce</code> uses the kernel (which is very slow), if you use <code>#eval</code> it'll likely execute fine</p>



<a name="275188648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275188648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275188648">(Mar 14 2022 at 02:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315434">Andr√©s Goens</span> <a href="#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275177472">said</a>:</p>
<blockquote>
<p>Yep, you're right about that! I am using that eta expanded <code>(fun t =&gt; treeToList t)</code>.  The problem is then that it's not in my hypotheses then in <code>decreasing_by</code>. That's a great suggestion, preserving it with the <code>match ht:t with</code>, thanks! That actually shows that indeed it wants me to prove two entirely unrelated terms to be decreasing. It then shows as: </p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">x</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
<span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span>
<span class="n">ht</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span>
<span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span>
<span class="bp">‚ä¢</span> <span class="n">depth</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">depth</span> <span class="o">(</span><span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This goal is not provable, and this is basically why lean has trouble with using <code>List.map</code> in this way. <code>List.map</code> takes a function on all trees, so you can't do a recursive call because you don't know that the tree it is being called on is related to the list you are mapping. You need to use something like <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap">docs#list.pmap</a> instead (not sure whether this exists in lean4 / mathlib4 yet)</p>



<a name="275208151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275208151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andr√©s Goens <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275208151">(Mar 14 2022 at 09:01)</a>:</h4>
<p>that's insightful, thanks! is that a fundamental problem (i.e. it wouldn't work because of the underlying type theory and nested inductives or something), or is it more an engineering one (it's just hard to create the right goal in this context and they developers have not come to that yet)?</p>



<a name="275211598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275211598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275211598">(Mar 14 2022 at 09:35)</a>:</h4>
<p>Coq and Agda both support nested inductives, in the sense that the example in your initial post would compile as-is. So it's not a problem with the type theory but 'just' requires lots of engineering.</p>



<a name="275253508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275253508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275253508">(Mar 14 2022 at 15:36)</a>:</h4>
<p>Thanks for pointing out the typos and poor error messages. We are going to improve them.</p>
<p>Here is the approach we are going to use in Lean to make this king of example easy to write:<br>
<a href="https://github.com/leanprover/lean4/blob/master/tests/lean/run/combinatorsAndWF.lean">https://github.com/leanprover/lean4/blob/master/tests/lean/run/combinatorsAndWF.lean</a><br>
It includes a very similar example.</p>
<p><span class="user-mention" data-user-id="256311">@Jannis Limperg</span> Recall that both Coq and Agda include a termination checker in the kernel, and a lot of engineering is only really needed in Lean.</p>



<a name="275255575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275255575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275255575">(Mar 14 2022 at 15:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275253508">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> Recall that both Coq and Agda include a termination checker in the kernel, and a lot of engineering is only really needed in Lean.</p>
</blockquote>
<p>Yes, absolutely. I appreciate that you're keeping a lot of complexity out of the kernel with this approach.</p>



<a name="275258119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/using%20higher-order%20functions%20on%20inductive%20types%3A%20termination/near/275258119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination.html#275258119">(Mar 14 2022 at 16:05)</a>:</h4>
<p>BTW, the <code>for in do</code> notation already has support for <code>for h : c in cs do ...</code> where <code>h : c ‚àà cs</code>.  It is not very convenient for this example because it is pure code, but we can write it as follows</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">TreeNode</span> <span class="o">:=</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">TreeNode</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">children</span> <span class="o">:</span> <span class="n">List</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">TreeNode</span>

<span class="kn">open</span> <span class="n">TreeNode</span> <span class="k">in</span>
<span class="kd">def</span> <span class="n">treeToList</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span>
 <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
 <span class="bp">|</span> <span class="n">mkLeaf</span> <span class="n">name</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
 <span class="bp">|</span> <span class="n">mkNode</span> <span class="n">name</span> <span class="n">children</span> <span class="bp">=&gt;</span> <span class="n">Id.run</span> <span class="k">do</span>
   <span class="k">let</span> <span class="n">mut</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">[</span><span class="n">name</span><span class="o">]</span>
   <span class="n">for</span> <span class="n">h</span> <span class="o">:</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="k">do</span>
     <span class="c1">-- We will not this the following `have` in the future</span>
     <span class="k">have</span> <span class="o">:</span> <span class="n">sizeOf</span> <span class="n">child</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeOf</span> <span class="n">name</span> <span class="bp">+</span> <span class="n">sizeOf</span> <span class="n">children</span> <span class="o">:=</span> <span class="n">Nat.lt_trans</span> <span class="o">(</span><span class="n">List.sizeOf_lt_of_mem</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp_arith</span><span class="o">)</span>
     <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span> <span class="bp">++</span> <span class="n">treeToList</span> <span class="n">child</span>
   <span class="n">return</span> <span class="n">r</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
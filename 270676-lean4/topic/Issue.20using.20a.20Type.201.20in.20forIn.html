---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html">Issue using a Type 1 in forIn</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273711165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273711165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273711165">(Mar 01 2022 at 21:12)</a>:</h4>
<p>Weird test case, but here's an MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Node</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Node2</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span>

<span class="kd">inductive</span> <span class="n">FingerTree</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Empty</span> <span class="o">{</span><span class="n">τ</span><span class="o">}</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">Deep</span> <span class="o">{</span><span class="n">τ</span><span class="o">}</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="o">(</span><span class="n">Node</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span>

<span class="kd">def</span> <span class="n">FingerTree.snoc</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">τ</span><span class="o">)</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">testAll</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">q</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">FingerTree.Empty</span>

  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="mi">100</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">q</span> <span class="o">:=</span> <span class="n">FingerTree.snoc</span> <span class="n">q</span> <span class="n">i</span>
</code></pre></div>
<p>I have a type for finger trees (much more complicated than here) which are indexed by a <code>Type u</code> (and therefore needs to live in <code>Type (u+1)</code>). Thought this would be fine. But now I can't use it in test cases I'm writing! (this works fine if it's in Type u instead)</p>



<a name="273711376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273711376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273711376">(Mar 01 2022 at 21:14)</a>:</h4>
<p>It also works fine if the last line isn't in a <code>for</code>, so I think something must be up with the signature of <code>forIn</code></p>



<a name="273711509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273711509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273711509">(Mar 01 2022 at 21:15)</a>:</h4>
<p>I can probably (?) rewrite this to be indexed by <code>Nat</code> instead of the type itself, to avoid the increase in universe level, but this definition is much more elegant so I'd like to keep it if possible</p>



<a name="273743070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273743070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273743070">(Mar 02 2022 at 02:15)</a>:</h4>
<p>Some remarks:</p>
<ul>
<li><code>IO</code> is <strong>not</strong> universe polymorphic, and has type <code>Type -&gt; Type</code></li>
<li><code>for ... in ... do</code> notation uses an auxiliary type class <code>ForIn</code>, and this type class forces the elements being updated to be in the universe taken by the monad. <code>testAll</code> function is equivalent to</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">testAll</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">FingerTree.Empty</span><span class="bp">;</span>
  <span class="k">let</span> <span class="n">col</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">start</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">stop</span> <span class="o">:=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">step</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">Std.Range</span><span class="o">}</span><span class="bp">;</span>
  <span class="k">let</span> <span class="n">q</span> <span class="bp">←</span> <span class="n">forIn</span> <span class="n">col</span> <span class="n">q</span> <span class="k">fun</span> <span class="n">i</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="o">(</span><span class="n">ForInStep.yield</span> <span class="o">(</span><span class="n">FingerTree.snoc</span> <span class="n">q</span> <span class="n">i</span><span class="o">))</span>
  <span class="n">pure</span> <span class="n">PUnit.unit</span>
</code></pre></div>
<ul>
<li>The same example will work with a universe polymorphic monad, but a slightly more complicated example will not without universe lifts which are a pain to use. </li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">testAll'</span> <span class="o">:</span> <span class="n">Id</span> <span class="n">PUnit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">q</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">FingerTree.Empty</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="mi">100</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">q</span> <span class="o">:=</span> <span class="n">FingerTree.snoc</span> <span class="n">q</span> <span class="n">i</span>
</code></pre></div>
<p>The following fails</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">testAll'</span> <span class="o">:</span> <span class="n">Id</span> <span class="n">PUnit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">q</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">FingerTree.Empty</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">s</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="mi">100</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">q</span> <span class="o">:=</span> <span class="n">FingerTree.snoc</span> <span class="n">q</span> <span class="n">i</span> <span class="c1">-- q : FingerTree Nat is in Type 1</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">i</span>  <span class="c1">-- s : Nat is in Type</span>
</code></pre></div>
<ul>
<li>The universe bump at <code>FingerTree</code> is quite annoying. If I remember correctly Coq has an extension that allows us to avoid the bump.</li>
</ul>



<a name="273751853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273751853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273751853">(Mar 02 2022 at 04:01)</a>:</h4>
<p>Hm. Okay. So the goal should really be to get <code>FingerTree</code> within the same universe as its input</p>
<p>I did redefine it a bit to index the family on height <code>Nat</code> instead of the node type, which compiles, but is super annoying to work with. As you said in Coq the definition just works:<br>
<a href="https://github.com/coq-contribs/finger-tree/blob/master/DependentFingerTree.v#L154">https://github.com/coq-contribs/finger-tree/blob/master/DependentFingerTree.v#L154</a></p>
<p>I'll look around for some documentation of Coq's universe constraint generation</p>



<a name="273752113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273752113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273752113">(Mar 02 2022 at 04:04)</a>:</h4>
<p>It should be possible to make the nat indexed finger tree work mostly painlessly with the right setup. What does your version look like?</p>



<a name="273752660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273752660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273752660">(Mar 02 2022 at 04:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">NodeTree</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Node</span> <span class="o">(</span><span class="n">NodeTree</span> <span class="n">τ</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">FingerTree</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">Empty</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">Single</span> <span class="o">:</span> <span class="n">NodeTree</span> <span class="n">τ</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">Deep</span> <span class="o">:</span> <span class="n">Digit</span> <span class="o">(</span><span class="n">NodeTree</span> <span class="n">τ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Digit</span> <span class="o">(</span><span class="n">NodeTree</span> <span class="n">τ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="n">n</span>
</code></pre></div>
<p>It's .. fine? I guess? Since unification gives us essentially the same type signatures</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">cons</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">NodeTree</span> <span class="n">τ</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="n">n</span>
</code></pre></div>
<p>can unify to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">cons</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="mi">0</span>
</code></pre></div>



<a name="273753353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273753353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273753353">(Mar 02 2022 at 04:21)</a>:</h4>
<p>You might also consider using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">NodeTree</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">NodeTree</span> <span class="o">(</span><span class="n">Node</span> <span class="n">τ</span><span class="o">)</span> <span class="n">n</span>
</code></pre></div>
<p>which might work better for defeq</p>



<a name="273755335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273755335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273755335">(Mar 02 2022 at 04:49)</a>:</h4>
<p>Hrm, I think <code>Node (NodeTree ...)</code> is working better because I can peel off the nodes one layer at a time pretty easily. But now I'm having issue trying to get Lean simplifying <code>NodeTree τ 0</code> to <code>τ</code> consistently without explicit casts <span aria-label="concerned" class="emoji emoji-1f615" role="img" title="concerned">:concerned:</span></p>



<a name="273755351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273755351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273755351">(Mar 02 2022 at 04:49)</a>:</h4>
<p>I'll see how far I can take this though</p>



<a name="273757131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273757131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273757131">(Mar 02 2022 at 05:14)</a>:</h4>
<p>What is your application? Maybe there is another approach altogether that doesn't involve these type changing shenanigans</p>



<a name="273758440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273758440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273758440">(Mar 02 2022 at 05:36)</a>:</h4>
<p>For finger trees, I would go with a slightly less strongly typed version for the base operations, and enforce the structural constraints separately:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Node</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_1</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">_2</span> <span class="o">:</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">_3</span> <span class="o">:</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Node</span> <span class="n">τ</span>

<span class="kd">inductive</span> <span class="n">Digit</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_1</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Digit</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">_2</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Digit</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">_3</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Digit</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">_4</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Digit</span> <span class="n">τ</span>

<span class="kd">inductive</span> <span class="n">FingerTree</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">single</span> <span class="o">:</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span>
<span class="bp">|</span> <span class="n">deep</span> <span class="o">:</span> <span class="n">Digit</span> <span class="o">(</span><span class="n">Node</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Digit</span> <span class="o">(</span><span class="n">Node</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">FingerTree</span> <span class="n">τ</span>

<span class="kd">def</span> <span class="n">Node.isRegular</span> <span class="o">:</span> <span class="n">Node</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Node._1</span> <span class="n">_</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">False</span>
<span class="bp">|</span> <span class="n">Node._2</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">b.isRegular</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">Node._3</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">b.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">c.isRegular</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">Digit.isRegular</span> <span class="o">:</span> <span class="n">Digit</span> <span class="o">(</span><span class="n">Node</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Digit._1</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">Digit._2</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">b.isRegular</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">Digit._3</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">b.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">c.isRegular</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">Digit._4</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">b.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">c.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">d.isRegular</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">FingerTree.isRegular</span> <span class="o">:</span> <span class="n">FingerTree</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">FingerTree.empty</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">True</span>
<span class="bp">|</span> <span class="n">FingerTree.single</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">FingerTree.deep</span> <span class="n">a</span> <span class="n">m</span> <span class="n">b</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">a.isRegular</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">m.isRegular</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">b.isRegular</span> <span class="n">n</span>
</code></pre></div>



<a name="273836879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273836879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273836879">(Mar 02 2022 at 16:45)</a>:</h4>
<p>Goal is to implement fast vectors :) the version indexed by tau is quite elegant IMO, so I'm trying to preserve that as much as possible. The nat-indexed trees have been okay so far, no major issues yet.</p>
<p>I suspect externally enforcing the constraints would be a pain, because you'd end up with lots of unreachable branches. But if I can't get the nat indexed version to work I'll try that out</p>



<a name="273856282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273856282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273856282">(Mar 02 2022 at 18:40)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> I think if you want fast vectors you should build on <code>Array</code>, not trees</p>



<a name="273856518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273856518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273856518">(Mar 02 2022 at 18:42)</a>:</h4>
<blockquote>
<p>I suspect externally enforcing the constraints would be a pain, because you'd end up with lots of unreachable branches. But if I can't get the nat indexed version to work I'll try that out</p>
</blockquote>
<p>If you have the regularity condition as a hypothesis, you can prove the unreachable branches are unreachable (and the equation compiler will often allow you to omit these branches)</p>



<a name="273856885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273856885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273856885">(Mar 02 2022 at 18:44)</a>:</h4>
<p>Do you know if that means the compiler compiler will emit code that skips the branches at runtime?</p>



<a name="273856900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273856900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273856900">(Mar 02 2022 at 18:45)</a>:</h4>
<p>But if you can write the code without the regularity condition as a hypothesis and just prove that the straightforward implementation preserves the regularity conditions, I think that would be even better</p>



<a name="273857059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273857059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273857059">(Mar 02 2022 at 18:46)</a>:</h4>
<p>If it's a two-way branch vs three I don't think there is any difference</p>



<a name="273857194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273857194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273857194">(Mar 02 2022 at 18:47)</a>:</h4>
<p>It's probably just wishful thinking on my part that <code>false.rec</code> compiles to C UB which is useful for optimization. More likely it's all a runtime unreachable check</p>



<a name="273857267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273857267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273857267">(Mar 02 2022 at 18:47)</a>:</h4>
<p>Generated Lean code is pretty defensive</p>



<a name="273857400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273857400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273857400">(Mar 02 2022 at 18:48)</a>:</h4>
<p>I wish there was a mode to allow lean to actually trust its dynamic semantics and proofs</p>



<a name="273857655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273857655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273857655">(Mar 02 2022 at 18:50)</a>:</h4>
<p>Although, it is possible to refactor an if statement with an unreachable branch into a have statement, which is zero-cost and leaves no branch</p>



<a name="273858250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273858250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273858250">(Mar 02 2022 at 18:54)</a>:</h4>
<p>Apparently False.rec is UB already:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.compiler.ir.result</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="mi">10</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">100</span> <span class="k">then</span>
    <span class="n">nomatch</span> <span class="k">show</span> <span class="n">False</span> <span class="k">from</span> <span class="gr">sorry</span>
  <span class="k">else</span>
    <span class="mi">42</span>

<span class="k">#eval</span> <span class="n">foo</span> <span class="mi">3</span> <span class="c1">-- returns 42 although 10 * 3 &lt; 100</span>
</code></pre></div>



<a name="273858613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273858613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273858613">(Mar 02 2022 at 18:56)</a>:</h4>
<p>I recall fantasizing early in lean 4 about autogenerated functions <code>T.discr : T -&gt; Nat</code> and <code>T.get_0_1 : (t : T) -&gt; t.discr = 0 -&gt; A</code> (the first projection of the first variant of the inductive type <code>T</code>) which would compile to the good things, which you could use to implement more efficient and flexible variations on <code>match</code></p>



<a name="273859113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273859113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273859113">(Mar 02 2022 at 18:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> It's certainly UB according to the lean compiler (it uses <code>csimp</code> lemmas and other things that rely on the general soundness of lean code), but I don't think it transmits that UB to the C code. My guess is that the optimization you are observing happens in lean (well, the IR trace indicates as much)</p>



<a name="273860532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273860532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273860532">(Mar 02 2022 at 19:07)</a>:</h4>
<p>Oh right, this optimization certainly happens on the Lean side.  Unreachable instructions that are not optimized away are compiled to panics.</p>



<a name="273861996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273861996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273861996">(Mar 02 2022 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273856518">said</a>:</p>
<blockquote>
<blockquote>
<p>I suspect externally enforcing the constraints would be a pain, because you'd end up with lots of unreachable branches. But if I can't get the nat indexed version to work I'll try that out</p>
</blockquote>
<p>If you have the regularity condition as a hypothesis, you can prove the unreachable branches are unreachable (and the equation compiler will often allow you to omit these branches)</p>
</blockquote>
<p>Is the lean4 equation compiler better in that regard than the lean 3 one? I remember having difficulty getting lean 3 to do it automatically on a different project. Might be user error though <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="273862346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273862346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273862346">(Mar 02 2022 at 19:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273856282">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> I think if you want fast vectors you should build on <code>Array</code>, not trees</p>
</blockquote>
<p>Yeah, heavily depends on the use case. For persistent use, trees will vastly outperform arrays, and for very large vectors it can be beneficial to not have a contiguous memory allocation and instead have some fragmentation. I'm aiming to replicate Scala's vector implementation, which is a wide radix-balanced finger tree or something (whatever that means). So these finger trees are just a step towards replicating that</p>



<a name="273862427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273862427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273862427">(Mar 02 2022 at 19:21)</a>:</h4>
<p>Here are some examples of the equation compiler being helpful:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Foo</span> <span class="bp">|</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">B</span> <span class="bp">|</span> <span class="n">C</span>

<span class="kd">def</span> <span class="n">is_A</span> <span class="o">:</span> <span class="n">Foo</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Foo.A</span> <span class="bp">=&gt;</span> <span class="n">True</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">False</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_A</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">Foo.A</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Foo</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">≠</span> <span class="n">Foo.A</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">Foo.B</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">Foo.C</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
</code></pre></div>



<a name="273862854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273862854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273862854">(Mar 02 2022 at 19:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273862346">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273856282">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> I think if you want fast vectors you should build on <code>Array</code>, not trees</p>
</blockquote>
<p>Yeah, heavily depends on the use case. For persistent use, trees will vastly outperform arrays, and for very large vectors it can be beneficial to not have a contiguous memory allocation and instead have some fragmentation. I'm aiming to replicate Scala's vector implementation, which is a wide radix-balanced finger tree or something (whatever that means). So these finger trees are just a step towards replicating that</p>
</blockquote>
<p>Naturally. Did you mean <em>persistent</em> vectors? One of the reasons FP languages rely so much on persistent data structures is that they do imperative ones badly, but I think lean is fairly good at native support for imperative data structures, and imperative data structures usually outperform persistent ones when persistence isn't a requirement</p>



<a name="273863086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863086">(Mar 02 2022 at 19:25)</a>:</h4>
<p>In fact, I wonder whether <code>Array A</code> would be a better choice than <code>Digit A</code> in the finger tree implementation</p>



<a name="273863327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863327">(Mar 02 2022 at 19:27)</a>:</h4>
<p>Totally agreed, I'm pretty impressed overall with lean 4 handling imperative code. Hoping to get some benchmarks today RE: how much faster Array is than this finger tree for ephemeral use</p>



<a name="273863330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863330">(Mar 02 2022 at 19:27)</a>:</h4>
<p>Personally, I would look to Rust to find data structures that match lean's requirements</p>



<a name="273863431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863431">(Mar 02 2022 at 19:28)</a>:</h4>
<p>like, maybe B-trees are where it's at</p>



<a name="273863529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863529">(Mar 02 2022 at 19:29)</a>:</h4>
<p>As an aside, is there a reason Array models a <code>List A</code> instead of <code>Vector A n</code>? Non-resizable native arrays would be super nice for some of my stuff :/</p>



<a name="273863563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863563">(Mar 02 2022 at 19:29)</a>:</h4>
<p>like I totally would use array if i could say <code>Array A 4</code> instead of <code>Digit A</code></p>



<a name="273863914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273863914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273863914">(Mar 02 2022 at 19:31)</a>:</h4>
<p>That's the way it was in lean 3, and I don't have the whole story for what happened in lean 4. it's possible that the extra index causes bad code generation, but it's definitely annoying when <code>n</code> is supposed to be fixed or known externally</p>



<a name="273864015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273864015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273864015">(Mar 02 2022 at 19:32)</a>:</h4>
<p>Although I'm not sure that fixed length arrays would be a suitable substitute for <code>Digit A</code> since it can have length 1-4</p>



<a name="273864033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273864033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273864033">(Mar 02 2022 at 19:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273863431">said</a>:</p>
<blockquote>
<p>like, maybe B-trees are where it's at</p>
</blockquote>
<p>Agreed. I think long term the right approach is to have two collection hierarchies, one for persistent structures and one for ephemeral structures. But I kinda wish there were some way to enforce linear usage of ephemeral structures like you can in Rust.</p>
<p>With the current status quo if you use an array persistently you just get hit with bad performance without any indication why...</p>



<a name="273864192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273864192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273864192">(Mar 02 2022 at 19:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273864015">said</a>:</p>
<blockquote>
<p>Although I'm not sure that fixed length arrays would be a suitable substitute for <code>Digit A</code> since it can have length 1-4</p>
</blockquote>
<p>Fair point -- I assume Lean's arrays store their length, which I think means <code>Digit A</code> is faster &amp; more compact? Unclear</p>



<a name="273864523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273864523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273864523">(Mar 02 2022 at 19:36)</a>:</h4>
<p>Lemme finish up this FingerTree implementation and then get some quick benchmarks of its performance against Array</p>



<a name="273865634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273865634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273865634">(Mar 02 2022 at 19:44)</a>:</h4>
<blockquote>
<p>With the current status quo if you use an array persistently you just get hit with bad performance without any indication why...</p>
</blockquote>
<p>You can use <code>dbgTraceIfShared</code> to detect non-persistent use</p>



<a name="273865733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273865733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273865733">(Mar 02 2022 at 19:44)</a>:</h4>
<p>I wonder if you can panic in a <code>dbgTraceIfShared</code> message</p>



<a name="273896552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273896552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273896552">(Mar 02 2022 at 23:39)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> regarding finger trees in general, are you familiar with Claessen's <a href="https://www.cs.tufts.edu/~nr/cs257/archive/koen-claessen/finger-trees.pdf">paper</a>? It explains them quite nicely. I implemented it the other day <a href="https://github.com/Vtec234/lean4-bits/blob/0d9340285b208553e0e0b31acfb2c9097ff4546a/fingerTree.lean">here</a>. The code is untested and unverified, thus possibly buggy. In case it is of any use to you, though, feel free to use any of it. (It does have the annoying universe bump.)</p>



<a name="273900933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273900933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273900933">(Mar 03 2022 at 00:18)</a>:</h4>
<p>Oh, that's awesome! The paper is really nice too, I think I'll go back and delete Digit 4 now that it's unnecessary <span aria-label="confetti" class="emoji emoji-1f38a" role="img" title="confetti">:confetti:</span></p>



<a name="273905553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/273905553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#273905553">(Mar 03 2022 at 01:02)</a>:</h4>
<p>Preliminary speed results:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>           <span class="bp">|</span> <span class="n">Ephemeral</span>  <span class="bp">|</span> <span class="n">Persistent</span>
<span class="n">FingerTree</span> <span class="bp">|</span> <span class="mi">604</span>        <span class="bp">|</span> <span class="mi">1</span>
<span class="n">Array</span>      <span class="bp">|</span> <span class="mi">127</span>        <span class="bp">|</span> <span class="mi">39</span>
</code></pre></div>
<p>so around 5x as slow in the ephemeral case (which just pushes many elements and then pops them in order). I'm actually surprised it's not slower, given that these are not very wide trees. A much wider tree should narrow that gap quite a lot</p>



<a name="277842212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277842212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277842212">(Apr 05 2022 at 08:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273865733">said</a>:</p>
<blockquote>
<p>I wonder if you can panic in a <code>dbgTraceIfShared</code> message</p>
</blockquote>
<p>implemented arrays with fixed length which panic if used persistently :p</p>



<a name="277842522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277842522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277842522">(Apr 05 2022 at 08:23)</a>:</h4>
<p>(deleted)</p>



<a name="277960642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277960642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277960642">(Apr 06 2022 at 00:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273858250">said</a>:</p>
<blockquote>
<p>Apparently False.rec is UB already:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.compiler.ir.result</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="mi">10</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">100</span> <span class="k">then</span>
    <span class="n">nomatch</span> <span class="k">show</span> <span class="n">False</span> <span class="k">from</span> <span class="gr">sorry</span>
  <span class="k">else</span>
    <span class="mi">42</span>

<span class="k">#eval</span> <span class="n">foo</span> <span class="mi">3</span> <span class="c1">-- returns 42 although 10 * 3 &lt; 100</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I missed this thread. The Lean compiler interprets <code>False.rec</code> as unreachable code. I think this is a quite reasonable interpretation and enables useful optimizations. As you probably noticed, the compiler eliminates any <code>case</code> statement if all but one alternative is reachable. This is exactly what is happening here. The key problem here is that you are essentially saying "trust me this is unreachable", but this is not true. In my point of view, this is an incorrect use of <code>sorry</code>.</p>



<a name="277961983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277961983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277961983">(Apr 06 2022 at 00:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277842212">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273865733">said</a>:</p>
<blockquote>
<p>I wonder if you can panic in a <code>dbgTraceIfShared</code> message</p>
</blockquote>
<p>implemented arrays with fixed length which panic if used persistently :p</p>
</blockquote>
<p>We know that <code>dbgTraceIfShared</code> is far from ideal for debugging code that is accidentally performing nondestructive updates. We want to have better support for this in the future, but we do not want to modify the Lean kernel since this feature is only relevant to users that want to use Lean as a programming language. Our current plan is to modify the type checker in <code>Meta</code> that is outside the kernel. It would support annotations similar to the ones in Idris 2 (<a href="https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html">https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html</a>). Unfortunately, this will not happen this year unless we get help from volunteers.</p>



<a name="277966099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277966099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277966099">(Apr 06 2022 at 01:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277960642">said</a>:</p>
<blockquote>
<p>The Lean compiler interprets <code>False.rec</code> as unreachable code. I think this is a quite reasonable interpretation and enables useful optimizations. As you probably noticed, the compiler eliminates any <code>case</code> statement if all but one alternative is reachable. This is exactly what is happening here. The key problem here is that you are essentially saying "trust me this is unreachable", but this is not true. In my point of view, this is an incorrect use of <code>sorry</code>.</p>
</blockquote>
<p>By the way, in case my earlier comments didn't make it clear, I think there is no problem at all treating <code>False.rec</code> as undefined behavior to execute and optimizing in accordance with this. This is a very useful effect of having proofs in the source language. I was lamenting above that it doesn't lower to <em>C</em> undefined behavior, meaning that although you get lean-level optimizations you don't get any LLVM optimizations from the existence of a proof of false in the function (because the proofs are erased and any unoptimized unreachable branches are compiled to a runtime panic, which LLVM has to treat as having defined behavior).</p>



<a name="277966314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277966314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277966314">(Apr 06 2022 at 01:48)</a>:</h4>
<p>One way to assist with this would be to lower some <code>have</code> statements to <code>llvm.assume</code> or whatever produces that effect in C</p>



<a name="277967217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277967217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277967217">(Apr 06 2022 at 02:04)</a>:</h4>
<p>Thanks for clarifying, but I was confused by Gabriel's comment that <code>False.rec</code> is UB (undefined behavior) in Lean when its behavior is well defined (it is unreachable code). I think you two are using UB as "the compiler is free to do whatever it wants", correct?</p>



<a name="277967434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277967434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277967434">(Apr 06 2022 at 02:08)</a>:</h4>
<p>yes</p>



<a name="277967447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277967447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277967447">(Apr 06 2022 at 02:09)</a>:</h4>
<p>this is UB as in C</p>



<a name="277967560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277967560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277967560">(Apr 06 2022 at 02:11)</a>:</h4>
<p>Even though <code>False.rec</code> has a specific implementation which prints a message and so on,  it is undefined behavior to call, which means that the program might not print that message even if you call it. This is what licenses optimizations like the 1-branch match example</p>



<a name="277967864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277967864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277967864">(Apr 06 2022 at 02:17)</a>:</h4>
<p>I view it a bit differently. <code>False.rec</code> is unreachable. The message is there only for users that are using <code>sorry</code> for stuff that is not really true. In the ideal (<code>sorry</code> free) world, it would be impossible to reach a <code>False.rec</code> at runtime.</p>



<a name="277968025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968025">(Apr 06 2022 at 02:20)</a>:</h4>
<p>If "unreachable" means "the compiler knows it cannot be reached", then that's what we would normally call undefined behavior. For example, <code>if i &lt; arr.size then arr[i] else panic</code> is a bounds checked array access, but <code>if i &lt; arr.size then arr[i] else unreachable</code> is not bounds checked (because the compiler will optimize the branch away)</p>



<a name="277968112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968112">(Apr 06 2022 at 02:22)</a>:</h4>
<p>since the lean compiler will (in some cases) compile the second to the first (which is a valid lowering), it removes the undefined behavior before it gets to C, which means that LLVM won't get a chance to optimize that branch away (because it would not be legal to do so)</p>



<a name="277968301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968301">(Apr 06 2022 at 02:26)</a>:</h4>
<p>Are you referring to the <code>Array.get!</code> implementation? The <code>else</code> branch there is definitely reachable.</p>



<a name="277968384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968384">(Apr 06 2022 at 02:28)</a>:</h4>
<p>In those two examples it doesn't matter which <code>arr[i]</code> we're talking about because inside the if it's definitely in bounds</p>



<a name="277968398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968398">(Apr 06 2022 at 02:28)</a>:</h4>
<p>but if I had to make a parallel, the first one is <code>Array.get!</code> and the second one is <code>Array.get</code></p>



<a name="277968492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968492">(Apr 06 2022 at 02:30)</a>:</h4>
<p>(<code>Array.get</code> isn't written like that because the <code>else unreachable</code> is superfluous, but you could rewrite it into such a form and my point is that <em>the compiler</em> is permitted to rewrite it back to eliminate the if statement)</p>



<a name="277968494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968494">(Apr 06 2022 at 02:30)</a>:</h4>
<p>Not sure what you are suggesting anymore. Are you suggesting we change the implementation of <code>Array.get!</code>? If yes, to what?</p>



<a name="277968513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968513">(Apr 06 2022 at 02:31)</a>:</h4>
<p>No, both of the functions are fine. I'm talking about codegenning <code>unreachable</code> to something like <code>*NULL</code> which is known to C to be undefined behavior</p>



<a name="277968569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968569">(Apr 06 2022 at 02:32)</a>:</h4>
<p>and possibly also removing bounds checks from <code>lean_array_fget</code> since they shouldn't be needed</p>



<a name="277968592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968592">(Apr 06 2022 at 02:33)</a>:</h4>
<p>actually scratch that last part, looks like the bounds check is already under a debug flag</p>



<a name="277968596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968596">(Apr 06 2022 at 02:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277968569">said</a>:</p>
<blockquote>
<p>and possibly also removing bounds checks from <code>lean_array_fget</code> since they shouldn't be needed</p>
</blockquote>
<p>It does not have any.</p>



<a name="277968839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277968839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277968839">(Apr 06 2022 at 02:38)</a>:</h4>
<p>for example, I think that if you match on a three variant inductive where one of the variants is a <code>nomatch</code>, the lean compiler will still emit a three-way branch with an explicit <code>unreachable</code> in one branch, and then LLVM won't be able to reduce it to just a two-way branch even though it knows how to do so</p>



<a name="277969175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969175">(Apr 06 2022 at 02:45)</a>:</h4>
<p>Yes, this seems useful in practice. <br>
BTW, would be useful for users if we distinguish <code>False.rec</code> applications that are <code>sorry</code> (and user axioms) free from the ones that are not?</p>



<a name="277969342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969342">(Apr 06 2022 at 02:48)</a>:</h4>
<p>heh, how would we be able to demonstrate what UB looks like in that case? :)</p>



<a name="277969350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969350">(Apr 06 2022 at 02:48)</a>:</h4>
<p>Probably it would be better to just have it be a global compiler option</p>



<a name="277969383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969383">(Apr 06 2022 at 02:49)</a>:</h4>
<p>in debug, it should be a <code>panic</code> and in release it should be <code>unreachable</code>, and with a <code>set_option</code> you can pick how you want this function to compile</p>



<a name="277969388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969388">(Apr 06 2022 at 02:49)</a>:</h4>
<ul>
<li><code>False.rec</code> applications that are <code>sorry</code> free are treated as "unreachable" code in the Lean and LLVM compiler passes.</li>
<li><code>False.rec</code> applications that contain <code>sorry</code> or depend on user axioms are treated as <code>panic "unreachable"</code> in all compiler passes. Extra: allow users to reduce this case to the first one using a compiler option.</li>
</ul>



<a name="277969493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969493">(Apr 06 2022 at 02:51)</a>:</h4>
<p>it's hard to say what to do about user axioms. It wouldn't be nice to pessimize their code, they might have a good reason to, say, assume the correctness of their external register allocator or something, but it is also not nice if you actually hit UB because you will probably get a weird crash</p>



<a name="277969609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969609">(Apr 06 2022 at 02:53)</a>:</h4>
<p>BTW, we currently don't have a solution for different code generation modes (debug, release, etc). We want to support that in the future, but we are not there yet.</p>



<a name="277969646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969646">(Apr 06 2022 at 02:54)</a>:</h4>
<p>Personally I think it's fine to treat it as UB even if it uses <code>sorry</code>; you don't want <code>sorry</code> MWE-ification to cause nonlocal changes to the compilation of a function</p>



<a name="277969769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969769">(Apr 06 2022 at 02:57)</a>:</h4>
<p>How do you feel about the <code>panic</code>?</p>



<a name="277969838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969838">(Apr 06 2022 at 02:58)</a>:</h4>
<p>even if you don't have release/debug modes, you could still have a <code>set_option</code> to control this; I'm not sure what the default should be but I'm leaning toward <code>panic</code> by default</p>



<a name="277969868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/277969868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#277969868">(Apr 06 2022 at 02:59)</a>:</h4>
<p>I think people are more likely to not know what they are doing and stumble on it by accident (or on purpose) compared to folks who really want to eliminate bounds checks, and the panic message is good discoverability</p>



<a name="278056282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278056282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278056282">(Apr 06 2022 at 17:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277961983">said</a>:</p>
<blockquote>
<p>Our current plan is to modify the type checker in <code>Meta</code> that is outside the kernel. It would support annotations similar to the ones in Idris 2 (<a href="https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html">https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html</a>). Unfortunately, this will not happen this year unless we get help from volunteers.</p>
</blockquote>
<p>By this, do you mean essentially embedding a linear language in Lean via metaprogramming? Or would this be a linter that operates outside/separate from the compiler's typechecker?</p>



<a name="278057073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278057073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278057073">(Apr 06 2022 at 17:19)</a>:</h4>
<p>(In either case, I'd be quite willing to help where I can, but I'll need to learn a lot before then...)</p>



<a name="278057174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278057174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278057174">(Apr 06 2022 at 17:20)</a>:</h4>
<p>I just so happen to have been looking into linear types as well since this week so I'd definitely be in for that as well (with the same remark on learning of course^^)</p>



<a name="278108114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278108114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278108114">(Apr 07 2022 at 01:36)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> </p>
<blockquote>
<p>By this, do you mean essentially embedding a linear language in Lean via metaprogramming? Or would this be a linter that operates <br>
outside/separate from the compiler's typechecker?</p>
</blockquote>
<p>The goal was to encode the Idris2-like annotations in our <code>Expr</code> objects. It is not clear right not now what the best encoding is. We could try to use <code>Expr.mdata</code>, identity-like functions (i.e., the same approach we use for <code>optParam</code>), etc. Then, write a new <code>Meta.check</code> that also checks the new annotations. Just having this checker would be a big improvement. Then, when we move the rest of the compiler code to Lean, we make sure we don't lose the annotations in the compiler passes, and may even eventually emit code that does not need to check whether the RC = 1 or not before performing destructive updates.</p>



<a name="278132458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278132458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278132458">(Apr 07 2022 at 08:34)</a>:</h4>
<p>I have a question regarding the Idris 2 approach though. in this section <a href="https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html#erasure">https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html#erasure</a> the author details how the compiler knows what to erase and what not to erase, in particular that all not explicitly denoted variables have multiplicity 0 by default (which makes sense of of course) but right now the Lean approach is to just automatically generate a regular implicit argument already so it would be a breaking change if done like Idris 2 right? The correct  way to go in Lean would probably be to be liberal about multiplicity bindings and instead bind with unrestricted multiplicity per default correct?</p>



<a name="278152076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278152076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278152076">(Apr 07 2022 at 11:56)</a>:</h4>
<p>FYI, <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> is planning to investigate the uniqueness typing part for his master thesis under my supervision. It's not clear to me yet whether this should also entail erasure, I'll leave that for Marc to find out!</p>



<a name="278161206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278161206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278161206">(Apr 07 2022 at 13:08)</a>:</h4>
<p>Ah, we probably better leave it to Marc then^^</p>



<a name="278205338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278205338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278205338">(Apr 07 2022 at 18:17)</a>:</h4>
<p>(Personally, I'd be a big fan of some sort of inference mechanism that looks at the usage of the variable and automatically assigns the smallest possible multiplicity; so that parameters which only appear in types can be erased, etc.)</p>



<a name="278215838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Issue%20using%20a%20Type%201%20in%20forIn/near/278215838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn.html#278215838">(Apr 07 2022 at 19:38)</a>:</h4>
<p>That's just dead code/parameter elimination, which Lean already does. Multiplicity annotations are for when you cannot infer (and/or want to guarantee) this behavior, especially with higher-order functions.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
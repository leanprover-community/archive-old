---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html">Agda to Lean translation issue</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279669653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279669653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279669653">(Apr 21 2022 at 11:58)</a>:</h4>
<p>Have I not translated this correctly?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">record</span> <span class="n">func</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">Level</span><span class="o">}(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Level</span><span class="o">)(</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span> <span class="o">(</span><span class="n">k</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">sucL</span> <span class="n">ℓ</span><span class="o">))</span> <span class="n">where</span>
  <span class="n">constructor</span> <span class="n">mk</span>
  <span class="n">field</span>
    <span class="n">out</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">IDesc</span> <span class="n">ℓ</span> <span class="n">I</span>

<span class="bp">⟦</span><span class="n">_</span><span class="bp">⟧</span><span class="n">func</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">k</span> <span class="n">ℓ</span><span class="o">}{</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">k</span><span class="o">}</span> <span class="bp">→</span> <span class="n">func</span> <span class="n">ℓ</span> <span class="n">I</span> <span class="n">J</span> <span class="bp">→</span> <span class="o">(</span><span class="n">I</span> <span class="bp">→</span> <span class="n">Set</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">J</span> <span class="bp">→</span> <span class="n">Set</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="bp">⟦</span> <span class="n">D</span> <span class="bp">⟧</span><span class="n">func</span> <span class="n">X</span> <span class="n">j</span> <span class="bp">=</span> <span class="bp">⟦</span> <span class="n">func.out</span> <span class="n">D</span> <span class="n">j</span> <span class="bp">⟧</span> <span class="n">X</span>

<span class="n">data</span> <span class="n">μ</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">func</span> <span class="n">ℓ</span> <span class="n">I</span> <span class="n">I</span><span class="o">)(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span> <span class="n">ℓ</span> <span class="n">where</span>
  <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">⟦</span> <span class="n">D</span> <span class="bp">⟧</span><span class="n">func</span> <span class="o">(</span><span class="n">μ</span> <span class="n">D</span><span class="o">)</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">μ</span> <span class="n">D</span> <span class="n">i</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Fixpoint</span> <span class="o">:</span> <span class="o">(</span><span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span>
  <span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="o">(</span><span class="n">D</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">over</span> <span class="o">(</span><span class="n">Fixpoint</span> <span class="n">D</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Fixpoint</span> <span class="n">D</span> <span class="n">i</span>
</code></pre></div>
<p><code>error: (kernel) arg #4 of 'Desc.Fixpoint.step' contains a non valid occurrence of the datatypes being declared</code></p>



<a name="279669939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279669939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279669939">(Apr 21 2022 at 12:01)</a>:</h4>
<p><code>Desc.over d x</code> is <code>⟦ d ⟧ x</code></p>



<a name="279672056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279672056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279672056">(Apr 21 2022 at 12:21)</a>:</h4>
<p>I don't know about Agda, but the error is probably due to the fact that you're referring to <code>Fixpoint</code> in its own constructor in an invalid position (there's some rules as to what's a valid position). <br>
How is <code>Desc.over</code> defined?</p>



<a name="279672743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279672743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279672743">(Apr 21 2022 at 12:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> A Cosmology of Datatypes. Pierre- ́Evariste Dagand.</span>
<span class="cm">https://www.irif.fr/~dagand/stuffs/thesis-2011-phd/thesis.pdf -/</span>
<span class="kd">inductive</span> <span class="n">Desc</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u'</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u'</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="bp">|</span> <span class="n">var</span>   <span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span>
  <span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">Desc</span> <span class="n">I</span>
  <span class="bp">|</span> <span class="n">prod</span>  <span class="o">:</span> <span class="n">Desc</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span>
  <span class="bp">|</span> <span class="n">sigma</span> <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span>
  <span class="bp">|</span> <span class="n">pi</span>    <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span>

<span class="kn">namespace</span> <span class="n">Desc</span>
  <span class="c1">-- FIXME: Better name? interpret?</span>
  <span class="kd">def</span> <span class="n">over</span> <span class="o">:</span> <span class="n">Desc.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">I</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="n">i</span><span class="o">,</span>     <span class="n">X</span> <span class="bp">=&gt;</span> <span class="n">X</span> <span class="n">i</span>
    <span class="bp">|</span> <span class="n">const</span><span class="o">,</span>     <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">Lift</span> <span class="n">Unit</span>
    <span class="bp">|</span> <span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>  <span class="n">X</span> <span class="bp">=&gt;</span> <span class="n">a.over</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">b.over</span> <span class="n">X</span>
    <span class="bp">|</span> <span class="n">sigma</span> <span class="n">S</span> <span class="n">D</span><span class="o">,</span> <span class="n">X</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="bp">×</span>  <span class="o">(</span><span class="n">D</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">over</span> <span class="n">X</span>
    <span class="bp">|</span> <span class="n">pi</span>    <span class="n">S</span> <span class="n">D</span><span class="o">,</span> <span class="n">X</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">D</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">over</span> <span class="n">X</span>

  <span class="kd">inductive</span> <span class="n">Fixpoint</span> <span class="o">:</span> <span class="o">(</span><span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc</span> <span class="n">I</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="n">u</span>
    <span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="o">(</span><span class="n">D</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">over</span> <span class="o">(</span><span class="n">Fixpoint</span> <span class="n">D</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">Fixpoint</span> <span class="n">D</span> <span class="n">i</span>
<span class="kd">end</span> <span class="n">Desc</span>
</code></pre></div>



<a name="279672819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279672819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279672819">(Apr 21 2022 at 12:27)</a>:</h4>
<p>That does seem to be the error, if so either I have translated it incorrectly or this is a divergence between Agda and Lean; which typically means there is an alternative approach to encode this. I hope?</p>



<a name="279672996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279672996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279672996">(Apr 21 2022 at 12:29)</a>:</h4>
<p>Also the Agda. <a href="https://pages.lip6.fr/Pierre-Evariste.Dagand/stuffs/thesis-2011-phd/model/html/Chapter5.IDesc.html">https://pages.lip6.fr/Pierre-Evariste.Dagand/stuffs/thesis-2011-phd/model/html/Chapter5.IDesc.html</a></p>



<a name="279673802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279673802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279673802">(Apr 21 2022 at 12:37)</a>:</h4>
<p>If this is a divergence. How are my chances for the limitation being lifted if merely arbitrary and not yet known useful?</p>



<a name="279675386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279675386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279675386">(Apr 21 2022 at 12:52)</a>:</h4>
<p><a href="https://github.com/leanprover/lean4/blob/master/src/kernel/inductive.cpp#L380-L397">https://github.com/leanprover/lean4/blob/master/src/kernel/inductive.cpp#L380-L397</a></p>



<a name="279675557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279675557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279675557">(Apr 21 2022 at 12:53)</a>:</h4>
<p>Lean's positivity checker does not unfold definitions. And even if it did, it would likely be stuck at the recursor implementing <code>over</code>. And even if it handled that, nested inductives still have to be translated to mutual inductives, which the recursion would make either very difficult or perhaps impossible. So this does look like a stack of complicated extensions to me.</p>



<a name="279676148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279676148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279676148">(Apr 21 2022 at 12:58)</a>:</h4>
<p>Aww. :/</p>



<a name="279676191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279676191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279676191">(Apr 21 2022 at 12:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> <a href="#narrow/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue/near/279673802">said</a>:</p>
<blockquote>
<p>If this is a divergence. How are my chances for the limitation being lifted if merely arbitrary and not yet known useful?</p>
</blockquote>
<p>IIRC, other languages/proof assistants like Agda or Coq tend to handle more of the "non-standard" inductive declarations, but at the cost of moving this complexity into the kernel (which also increases the TCB). I think with Lean a small kernel is preferred. But there have been discussions on Zulip about how it would be nice to have certain non-standard inductives natively in Lean (but for that the underlying theory would have to be proven to work first).</p>



<a name="279676462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279676462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279676462">(Apr 21 2022 at 13:00)</a>:</h4>
<p>Usually <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> knows how to transform cases like <code>Fixpoint</code> into simpler inductives though :D</p>



<a name="279676831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279676831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279676831">(Apr 21 2022 at 13:04)</a>:</h4>
<p>For context I am trying to take a stab at an intrinsically typed implementation of the Calculus of Constructions for my own compiler, which I'm writing in Lean 4. The exact code I'm trying to translate is a description of type universes, which is first-class, can bootstrap itself and enable programming over the calculus of types within the language.</p>



<a name="279678220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279678220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279678220">(Apr 21 2022 at 13:13)</a>:</h4>
<p>In other words... I dived in the deep end. :D</p>



<a name="279708457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279708457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279708457">(Apr 21 2022 at 16:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> <a href="#narrow/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue/near/279676462">said</a>:</p>
<blockquote>
<p>Usually <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> knows how to transform cases like <code>Fixpoint</code> into simpler inductives though :D</p>
</blockquote>
<p><span class="user-mention" data-user-id="455721">@Sofia</span> Voilà:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Desc</span>
  <span class="kd">inductive</span> <span class="n">Over</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc.</span><span class="o">{</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">}</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">Desc.</span><span class="o">{</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">}</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="n">X</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="bp">.</span><span class="n">var</span> <span class="n">i</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">Over</span> <span class="n">X</span> <span class="bp">.</span><span class="n">const</span>
    <span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="n">Over</span> <span class="n">X</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">Over</span> <span class="n">X</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="bp">.</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">sigma</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="n">D</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="bp">.</span><span class="n">sigma</span> <span class="n">S</span> <span class="n">D</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">pi</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="n">D</span> <span class="n">s</span><span class="o">))</span> <span class="bp">→</span> <span class="n">Over</span> <span class="n">X</span> <span class="o">(</span><span class="bp">.</span><span class="n">pi</span> <span class="n">S</span> <span class="n">D</span><span class="o">)</span>

  <span class="kd">def</span> <span class="n">Fixpoint</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">Desc.</span><span class="o">{</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">}</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">Over</span> <span class="n">D</span> <span class="o">(</span><span class="n">D</span> <span class="n">i</span><span class="o">)</span>
<span class="kd">end</span> <span class="n">Desc</span>
</code></pre></div>



<a name="279810419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279810419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279810419">(Apr 22 2022 at 11:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="455721">Sofia</span> has marked this topic as unresolved.</p>



<a name="279814488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279814488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279814488">(Apr 22 2022 at 12:10)</a>:</h4>
<p>Hmm. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'm not sure this satisfies what I need. And I'm struggling to port any successive code to test it.</p>
<p><a href="https://www.irif.fr/~dagand/stuffs/thesis-2011-phd/thesis.pdf">https://www.irif.fr/~dagand/stuffs/thesis-2011-phd/thesis.pdf</a></p>
<p>I think it would be best for me to step back and return to the start of the thesis. I will likely return with lots more problems. Wish me luck.</p>



<a name="279940392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279940392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279940392">(Apr 23 2022 at 18:59)</a>:</h4>
<p><span class="user-mention" data-user-id="455721">@Sofia</span> out of curiosity are you too doing metatheory in lean?</p>



<a name="279950902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279950902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279950902">(Apr 23 2022 at 23:20)</a>:</h4>
<p><span class="user-mention" data-user-id="461231">@Jad Ghalayini</span> By meta-theory you mean proving properties hold on the type theory? Maybe? The objective is to implement the interpreter for the language I want, then bootstrap a complete compiler using it. I want an intrinsically typed DTLC/CoC enriched with type grades and multiple stages. Thus all type checking will be enforced in the structure. Once I have this, I will work on a parser and elaborator. Then try to reimplement all of that within the language and continue with other components.</p>



<a name="279951400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279951400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279951400">(Apr 23 2022 at 23:34)</a>:</h4>
<p>If by meta-theory you meant the type checking, then yes. Intrinsically if I can. I have an intrinsically typed implementation of STLC.</p>
<p><a href="https://gist.github.com/sofia-snow/0a85cb5ccf6cbeb6ba248813df7bbf0b">https://gist.github.com/sofia-snow/0a85cb5ccf6cbeb6ba248813df7bbf0b</a></p>
<p>The current goal is to retain this style over a DTLC, using the indexed type family descriptions as an indirection for the type in the DTLC term's types.</p>



<a name="279951532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279951532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279951532">(Apr 23 2022 at 23:38)</a>:</h4>
<p><span class="user-mention" data-user-id="455721">@Sofia</span> I was able to build a parser/elaborator for my language using Lean's <code>Syntax</code> and native parser. But the solution looks a bit hacky. When you start working on your parser, please let me know because I am interested in learning <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="279951546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279951546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279951546">(Apr 23 2022 at 23:39)</a>:</h4>
<p>Oh please share that hackery. I have considered doing exactly this for the bootstrapping.</p>



<a name="279951601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279951601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279951601">(Apr 23 2022 at 23:41)</a>:</h4>
<p>I plan to make a parser quite similar to Lean's, however it will be constrained by the profunctor/optic laws such that syntax resugaring is formally defined and accurate. <a href="https://raw.githubusercontent.com/justinpombrio/thesis/master/resugaring-thesis.pdf">https://raw.githubusercontent.com/justinpombrio/thesis/master/resugaring-thesis.pdf</a></p>



<a name="279951708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279951708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279951708">(Apr 23 2022 at 23:44)</a>:</h4>
<p>Which in turn means the compiler can produce syntax and type errors for user-defined syntax without leaking under the abstractions. Ex. A type error for a user-defined DSL should point at the DSL's terms, as written by the user. Without canonicalization and without pointing into the abstractions (code the user didn't write, but the macros expanded to).</p>



<a name="279952380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279952380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279952380">(Apr 24 2022 at 00:03)</a>:</h4>
<p>Are you interested in reading code from an arbitrary text file or from a Lean file?</p>



<a name="279952519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279952519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279952519">(Apr 24 2022 at 00:07)</a>:</h4>
<p>If you want to parse code from a Lean file, then it's not hacky. I use it to debug my interpreter: <a href="https://github.com/arthurpaulino/FxyLang/blob/master/MetaDebug.lean">https://github.com/arthurpaulino/FxyLang/blob/master/MetaDebug.lean</a></p>
<p>But if you want to read from a text file from the IO monad, then you need to lift a meta monad with an environment created from the compiled olean file (this is the hack):<br>
<a href="https://github.com/arthurpaulino/FxyLang/blob/master/FxyLang/Implementation/Parser.lean">https://github.com/arthurpaulino/FxyLang/blob/master/FxyLang/Implementation/Parser.lean</a></p>



<a name="279952854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279952854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jad Ghalayini <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279952854">(Apr 24 2022 at 00:17)</a>:</h4>
<p><span class="user-mention" data-user-id="455721">@Sofia</span> well I mean if you're proving smt about the type theory in Lean that's what I'd call metatheory haha</p>



<a name="279952982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279952982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279952982">(Apr 24 2022 at 00:20)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> That'll be both, also from stdin for a repl eventually. Thanks.</p>
<p><span class="user-mention" data-user-id="461231">@Jad Ghalayini</span> Then yes. :)</p>



<a name="279954176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279954176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279954176">(Apr 24 2022 at 00:57)</a>:</h4>
<p>Sebastian said that eventually we'll have <code>builtin syntax</code>, which is likely to eliminate the need for this hack</p>



<a name="279956021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279956021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279956021">(Apr 24 2022 at 01:46)</a>:</h4>
<p>I don't quite see where the hacky part is. :)</p>



<a name="279956848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279956848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279956848">(Apr 24 2022 at 02:10)</a>:</h4>
<p><a href="https://github.com/arthurpaulino/FxyLang/blob/b4edb87f37902bd9615838c1a013d3f2c55db760/Main.lean#L9">This</a> is the hacky part. I can't release a standalone binary for my interpreter without a companion olean file</p>



<a name="279956919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279956919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279956919">(Apr 24 2022 at 02:12)</a>:</h4>
<p>Huh.</p>



<a name="279957067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279957067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279957067">(Apr 24 2022 at 02:17)</a>:</h4>
<p>Sorry, the problematic code isn't in the file I had linked previously. It's in the <code>Main.lean</code> file</p>



<a name="279957285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279957285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279957285">(Apr 24 2022 at 02:23)</a>:</h4>
<p>Yeah I see. :)</p>



<a name="279957682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279957682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279957682">(Apr 24 2022 at 02:35)</a>:</h4>
<p>As I said, I am interested in new approaches. <span class="user-mention" data-user-id="110026">@Simon Hudon</span> might be as well</p>



<a name="279957800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279957800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279957800">(Apr 24 2022 at 02:38)</a>:</h4>
<p>Noted, though I will probably mirror your approach until I can bootstrap my language in itself, and _then_ implement its own parser in itself. Not in Lean.</p>



<a name="279960798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Agda%20to%20Lean%20translation%20issue/near/279960798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sofia <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Agda.20to.20Lean.20translation.20issue.html#279960798">(Apr 24 2022 at 04:04)</a>:</h4>
<p>Though it would probably be wise to just prototype the parser in Lean first, having all the tooling established already.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
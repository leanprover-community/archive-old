---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html">FFI for fixed-length arrays</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="277842952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277842952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277842952">(Apr 05 2022 at 08:27)</a>:</h4>
<p>Okay, I got something working:</p>
<p>Lean: <a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Array.lean">https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Array.lean</a><br>
C: <a href="https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c">https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c</a></p>
<p>Still need to implement the FFI interface for a few things, but I'm pretty happy it works at all <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>
<p>That said, not sure if what I'm doing is the right approach. If someone has a moment to take a quick look, I'd greatly appreciate it!</p>



<a name="277843437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277843437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277843437">(Apr 05 2022 at 08:31)</a>:</h4>
<p>I think it would be better to have this be a wrapper around <code>Array</code> instead of <code>List</code></p>



<a name="277843510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277843510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277843510">(Apr 05 2022 at 08:32)</a>:</h4>
<p>are there zero cost conversions to and from <code>LeanColls.Array</code>?</p>



<a name="277843760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277843760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277843760">(Apr 05 2022 at 08:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277843437">said</a>:</p>
<blockquote>
<p>I think it would be better to have this be a wrapper around <code>Array</code> instead of <code>List</code></p>
</blockquote>
<p>Part of me agrees, but part of me wants to completely replace the built-in array (see <code>ArrayBuffer</code> for UBA built on top of this <code>Array</code>), which I think means it is more reasonable to have a list representation. Unsure.</p>



<a name="277843819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277843819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277843819">(Apr 05 2022 at 08:35)</a>:</h4>
<p>That implementation seems like you would have no way to actually get the length</p>



<a name="277843913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277843913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277843913">(Apr 05 2022 at 08:36)</a>:</h4>
<p>I expect you will need the garbage collection functionalities of the original implementation even if it's basically a plain C array</p>



<a name="277843958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277843958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277843958">(Apr 05 2022 at 08:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277843510">said</a>:</p>
<blockquote>
<p>are there zero cost conversions to and from <code>LeanColls.Array</code>?</p>
</blockquote>
<p>to/from <code>LeanColls.Array</code> and <code>List</code>? No, I'm not sure that's even possible (might be wrong?)</p>



<a name="277844001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844001">(Apr 05 2022 at 08:37)</a>:</h4>
<p>but I assume that the existing Array implementation supports something that is essentially a single contiguous array, so you would just copy into a contiguous array when converting <code>Array -&gt; LeanColls.Array</code> and then both conversions become zero cost after that</p>



<a name="277844028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844028">(Apr 05 2022 at 08:37)</a>:</h4>
<p>no, zero cost between <code>Array</code> and <code>LeanColls.Array</code></p>



<a name="277844097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844097">(Apr 05 2022 at 08:38)</a>:</h4>
<p>that's why I suggested that <code>LeanColls.Array</code> wraps <code>Array</code> instead of <code>List</code></p>



<a name="277844147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844147">(Apr 05 2022 at 08:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277843819">said</a>:</p>
<blockquote>
<p>That implementation seems like you would have no way to actually get the length</p>
</blockquote>
<p>Yeah, the length (where relevant) gets passed in to functions like it does in C world (because it has to be a parameter of the function). I'm still trying to figure out how to get Lean to erase it where irrelevant, though with aggressive enough inlining by the compiler it shouldn't matter</p>



<a name="277844209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844209">(Apr 05 2022 at 08:39)</a>:</h4>
<p>wouldn't <code>LC.Array</code> need to be a dependent type for that?</p>



<a name="277844235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844235">(Apr 05 2022 at 08:39)</a>:</h4>
<p>you declared it as just <code>LC.Array A</code> and not <code>LC.Array A n</code></p>



<a name="277844327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844327">(Apr 05 2022 at 08:40)</a>:</h4>
<p>oh whoops nvm</p>



<a name="277844506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844506">(Apr 05 2022 at 08:41)</a>:</h4>
<p>you need a bounds check in <code>leancolls_array_get</code>, it can safely be called out of bounds but that yields UB in your implementation</p>



<a name="277844507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844507">(Apr 05 2022 at 08:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277844001">said</a>:</p>
<blockquote>
<p>but I assume that the existing Array implementation supports something that is essentially a single contiguous array, so you would just copy into a contiguous array when converting <code>Array -&gt; LeanColls.Array</code> and then both conversions become zero cost after that</p>
</blockquote>
<p>Ah, yeah, I could implement conversions between Array and this one. Lean's built-in seems to have specializations for small types and I'm not entirely sure how that works yet, which is what discourages me atm...</p>



<a name="277844690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844690">(Apr 05 2022 at 08:43)</a>:</h4>
<p>I think the only way to call <code>leancolls_array_get</code> from Lean is by passing a <code>Fin n</code> which should ensure it's always within bounds, no?</p>



<a name="277844957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277844957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277844957">(Apr 05 2022 at 08:45)</a>:</h4>
<p>oh I see, you have some misleadingly named functions</p>



<a name="277845024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845024">(Apr 05 2022 at 08:46)</a>:</h4>
<p>why does <code>getExternal</code> have a definition at all? It's a lie</p>



<a name="277845064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845064">(Apr 05 2022 at 08:46)</a>:</h4>
<p>those functions shouldn't be private in any case</p>



<a name="277845093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845093">(Apr 05 2022 at 08:47)</a>:</h4>
<p>you should just slap the <code>extern</code> directly on <code>get</code></p>



<a name="277845095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845095">(Apr 05 2022 at 08:47)</a>:</h4>
<p>One thing I'm particularly unsure about is <a href="https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c#L35">this function</a> for ensuring all mutations are safe to perform in place. It seems like there's kind of two cases where you aren't allowed to modify in place:<br>
1) The object is shared. Here I want the implementation to just panic, because using these Arrays persistently should be eagerly caught.<br>
2) The object is persistent. It seems like constants in a program just get compiled to always be marked as persistent even when they're only used once? Which I'm not sure how to avoid</p>



<a name="277845147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845147">(Apr 05 2022 at 08:47)</a>:</h4>
<p>persistent objects can't be modified, because they are shared with the whole program</p>



<a name="277845238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845238">(Apr 05 2022 at 08:48)</a>:</h4>
<p>it would not be sound to do so even if they are "unshared" because the next time you call the function you will get that constant again but its value is different</p>



<a name="277845420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845420">(Apr 05 2022 at 08:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845093">said</a>:</p>
<blockquote>
<p>you should just slap the <code>extern</code> directly on <code>get</code></p>
</blockquote>
<p>Okay, so that was my first thought as well -- but there's kinda two steps happening here?</p>
<p>First step is to erase index/length parameters from <code>Nat</code> to <code>USize</code> (which is safe because of memory constraints). Second step is to call the extern'd function.</p>
<p>I wanted the <code>getExternal</code> to be a <code>constant</code> rather than a definition, but it can't automatically generate an <code>Inhabited</code> instance which made everything sad.</p>



<a name="277845483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845483">(Apr 05 2022 at 08:51)</a>:</h4>
<p>you can just change the signature of the extern function to match <code>get</code></p>



<a name="277845541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845541">(Apr 05 2022 at 08:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845238">said</a>:</p>
<blockquote>
<p>it would not be sound to do so even if they are "unshared" because the next time you call the function you will get that constant again but its value is different</p>
</blockquote>
<p>What determines whether an expression is compiled to a persistent object? It seems kinda arbitrary</p>



<a name="277845664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845664">(Apr 05 2022 at 08:52)</a>:</h4>
<p>Lean will automatically lift any subexpression with no free variables to a constant</p>



<a name="277845740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845740">(Apr 05 2022 at 08:53)</a>:</h4>
<p>which basically means that <code>Array.mk</code> will probably be a copy from a global instead of a constructor</p>



<a name="277845840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845840">(Apr 05 2022 at 08:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845483">said</a>:</p>
<blockquote>
<p>you can just change the signature of the extern function to match <code>get</code></p>
</blockquote>
<p>Yeah. I'll try this out and see what it would look like.</p>



<a name="277845958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277845958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277845958">(Apr 05 2022 at 08:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845664">said</a>:</p>
<blockquote>
<p>Lean will automatically lift any subexpression with no free variables to a constant</p>
</blockquote>
<p>Huh, okay. What if I don't want it to do that..? I could see a use-case here where you don't want to have, say, an extra copy of a very large array floating around just because it's technically a closed expression...</p>



<a name="277846049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846049">(Apr 05 2022 at 08:56)</a>:</h4>
<p>there is some trick here involving <code>Unit -&gt; A</code> functions that I forget</p>



<a name="277846184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846184">(Apr 05 2022 at 08:57)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> will know if there is a way to disable constant lifting in a function</p>



<a name="277846304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846304">(Apr 05 2022 at 08:58)</a>:</h4>
<p>It just seems like not what I'd expect/want as a programmer. If I want an expression to not be recomputed every call, I'll lift it manually.</p>



<a name="277846347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846347">(Apr 05 2022 at 08:59)</a>:</h4>
<p>It's one of the advantages of pure functional programming. lots of subexpressions can be cached or precomputed</p>



<a name="277846470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846470">(Apr 05 2022 at 09:00)</a>:</h4>
<p>I don't think you would want to lift it manually considering that there are a huge number of such liftings in the average lean program</p>



<a name="277846567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846567">(Apr 05 2022 at 09:00)</a>:</h4>
<p>Most imperative languages lift constants if they can as well (C / C++ / Rust all do this)</p>



<a name="277846728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846728">(Apr 05 2022 at 09:02)</a>:</h4>
<p>Fair enough! Maybe the solution is to just be less aggressive with marking things persistent, maybe by making sure that the things which are marked are actually used twice</p>



<a name="277846802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846802">(Apr 05 2022 at 09:02)</a>:</h4>
<p>Anyways --  I'll try to get benchmarks down soon to see how the performance looks, before I even try to optimize the emitted bytecode</p>



<a name="277846928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846928">(Apr 05 2022 at 09:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277846184">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> will know if there is a way to disable constant lifting in a function</p>
</blockquote>
<p>That's <code>set_option compiler.extract_closed false</code></p>



<a name="277846961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846961">(Apr 05 2022 at 09:04)</a>:</h4>
<p>Have you considered using a variation on <code>Fin n</code> that uses <code>USize</code> instead of <code>Nat</code>?</p>



<a name="277846983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277846983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277846983">(Apr 05 2022 at 09:04)</a>:</h4>
<p>that would avoid the boxing overhead</p>



<a name="277847075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847075">(Apr 05 2022 at 09:04)</a>:</h4>
<p>and might actually be enough to get something that looks like a C loop over an array after enough inlining</p>



<a name="277847136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847136">(Apr 05 2022 at 09:05)</a>:</h4>
<p>although I guess <code>set</code> is still hard to optimize</p>



<a name="277847275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847275">(Apr 05 2022 at 09:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277803454">said</a>:</p>
<blockquote>
<p>I believe it should be possible to bind to those functions directly, but it doesn't seem to be working:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="c1">-- could not find native implementation of external declaration 'Nat.toUSize!' (symbols 'l_Nat_toUSize_x21___boxed' or 'l_Nat_toUSize_x21')</span>
</code></pre></div><br>
</p>
</blockquote>
<p>The interpreter only speaks the always-boxed subset of the Lean ABI, so <code>extern</code>s must always be compiled first before evaluation</p>



<a name="277847333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847333">(Apr 05 2022 at 09:07)</a>:</h4>
<p>I tried putting it in a separate file but it didn't make a difference</p>



<a name="277847363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847363">(Apr 05 2022 at 09:07)</a>:</h4>
<p>how does lean do it?</p>



<a name="277847460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847460">(Apr 05 2022 at 09:08)</a>:</h4>
<p>maybe the interpreter is just ignoring those extern declarations on things like <code>USize.add</code></p>



<a name="277847478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847478">(Apr 05 2022 at 09:08)</a>:</h4>
<p>By compiling it first, into a binary named <code>lean</code> :)</p>



<a name="277847535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847535">(Apr 05 2022 at 09:09)</a>:</h4>
<p>That is, you would need <a href="https://github.com/leanprover/lake/pull/47">https://github.com/leanprover/lake/pull/47</a> to make it work in a different module</p>



<a name="277847709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277847709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277847709">(Apr 05 2022 at 09:10)</a>:</h4>
<p>BTW <span class="user-mention" data-user-id="407274">@James Gallicchio</span> I'm also wondering whether these functions can instead be exposed as regular functions on <code>Array</code> instead of a new type</p>



<a name="277898525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277898525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277898525">(Apr 05 2022 at 15:41)</a>:</h4>
<p>oh definitely -- the goal here was to sidestep <code>Array</code>entirely, and reimplement dynamic arrays in Lean</p>



<a name="277898931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277898931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277898931">(Apr 05 2022 at 15:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277846961">said</a>:</p>
<blockquote>
<p>Have you considered using a variation on <code>Fin n</code> that uses <code>USize</code> instead of <code>Nat</code>?</p>
</blockquote>
<p>That's a good idea. <code>{u : USize // u &lt; n}</code>. I'll think about it.</p>



<a name="277900648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277900648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277900648">(Apr 05 2022 at 15:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845420">said</a>:</p>
<blockquote>
<p>I wanted the <code>getExternal</code> to be a <code>constant</code> rather than a definition, but it can't automatically generate an <code>Inhabited</code> instance which made everything sad.</p>
</blockquote>
<p>Bumping this -- is there a way to give Lean an inhabitant without calling that inhabitant the definition?</p>



<a name="277903889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277903889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277903889">(Apr 05 2022 at 16:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">private</span> <span class="n">unsafe</span> <span class="kd">def</span> <span class="n">getExternal</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="bp">...</span> <span class="o">:</span> <span class="n">α</span>
</code></pre></div>
<p>If you have an arbitrary type <code>α</code>, that's the only way to ensure inhabitation. But I think your primitive should rather take a proof that the index is in bounds and then you can give a reference implementation (in terms of lists) that doesn't need an <code>Inhabited</code> constraint.</p>



<a name="277905967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277905967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277905967">(Apr 05 2022 at 16:27)</a>:</h4>
<p>Yeah, that makes sense. I guess this is the tradeoff we make to avoid soundness issues :/</p>



<a name="277906146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277906146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277906146">(Apr 05 2022 at 16:29)</a>:</h4>
<p>It just feels .. slightly not ideal that, in Lean world, it "looks" super cheap to go from the list representation to the array representation, when in reality that is a very expensive operation</p>



<a name="277906184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277906184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277906184">(Apr 05 2022 at 16:29)</a>:</h4>
<p>I thought you didn't need <code>Inhabited</code> if the constant is <code>unsafe</code></p>



<a name="277906980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277906980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277906980">(Apr 05 2022 at 16:34)</a>:</h4>
<p>go figure.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[extern "foo"]</span> <span class="n">unsafe</span> <span class="kd">constant</span> <span class="n">something</span> <span class="o">:</span> <span class="n">α</span>
<span class="c1">-- failed to synthesize</span>
<span class="c1">--   Inhabited α</span>

<span class="kd">@[extern "foo"]</span> <span class="n">unsafe</span> <span class="kd">constant</span> <span class="n">loop</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">loop</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="277913016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277913016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277913016">(Apr 05 2022 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277906980">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[extern "foo"]</span> <span class="n">unsafe</span> <span class="kd">constant</span> <span class="n">something</span> <span class="o">:</span> <span class="n">α</span>
<span class="c1">-- failed to synthesize</span>
<span class="c1">--   Inhabited α</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I think that's a small bug</p>



<a name="277923723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277923723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277923723">(Apr 05 2022 at 18:29)</a>:</h4>
<p>Yes, we can clearly skip the <code>Inhabitant</code> synthesis code for <code>unsafe</code>. The current implementation always executes the synthesis code.</p>



<a name="277927918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277927918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277927918">(Apr 05 2022 at 18:57)</a>:</h4>
<p><span class="user-mention" data-user-id="407274">@James Gallicchio</span> Sorry for the delay. I had to take the day off yesterday.</p>
<blockquote>
<p>Right now the behaviors just don't match up, which seems like a recipe for issues</p>
</blockquote>
<p>The C and Lean behavior should match. Are you observing a mismatch in a particular example?</p>
<blockquote>
<p>Maybe this does actually mod?</p>
</blockquote>
<p>It should. We may have a bug in the current implementation, but our intention was to "mod" in C too.</p>



<a name="277929036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277929036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277929036">(Apr 05 2022 at 19:05)</a>:</h4>
<p>Ah, no, I was reading the wrong thing there, sorry! It looks like it has the mod behavior in both C and Lean</p>



<a name="277935357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277935357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277935357">(Apr 05 2022 at 19:58)</a>:</h4>
<p>What would be the best way to implement <code>Fin n</code> with <code>USize</code>? My main concern is: should <code>n : USize</code> or <code>n : Nat</code> or it does not matter?</p>
<p>My attempt:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">UFin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">USize</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">val</span> <span class="o">:</span> <span class="n">USize</span>
  <span class="n">property</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span>

<span class="kd">@[export ufin_add]</span>
<span class="kd">def</span> <span class="n">add</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">x.1</span> <span class="bp">+</span> <span class="n">y.1</span><span class="o">)</span> <span class="bp">%</span> <span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">@[export ufin_sub]</span>
<span class="kd">def</span> <span class="n">sub</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">x.1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">y.1</span><span class="o">))</span> <span class="bp">%</span> <span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">@[export ufin_mul]</span>
<span class="kd">def</span> <span class="n">mul</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">x.1</span> <span class="bp">*</span> <span class="n">y.1</span><span class="o">)</span> <span class="bp">%</span> <span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">@[export ufin_div]</span>
<span class="kd">def</span> <span class="n">div</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">UFin</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">x.1</span> <span class="bp">/</span> <span class="n">y.1</span><span class="o">),</span> <span class="gr">sorry</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">add</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Sub</span> <span class="o">(</span><span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">sub</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Mul</span> <span class="o">(</span><span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mul</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Div</span> <span class="o">(</span><span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">div</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">ToString</span> <span class="o">(</span><span class="n">UFin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">toString</span> <span class="n">n.1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="o">(</span><span class="n">UFin</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Nat.toUSize</span> <span class="n">n</span> <span class="bp">%</span> <span class="n">m</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">UFin</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">UFin</span> <span class="mi">5</span><span class="o">)</span>
<span class="k">#eval</span> <span class="o">(</span><span class="mi">3</span> <span class="o">:</span> <span class="n">UFin</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">UFin</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div>
<p>Example of the generated C code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">size_t</span> <span class="n">ufin_sub</span><span class="o">(</span><span class="n">size_t</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">x_2</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">x_3</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">size_t</span> <span class="n">x_4</span><span class="bp">;</span> <span class="n">size_t</span> <span class="n">x_5</span><span class="bp">;</span> <span class="n">size_t</span> <span class="n">x_6</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_usize_sub</span><span class="o">(</span><span class="n">x_1</span><span class="o">,</span> <span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_5</span> <span class="bp">=</span> <span class="n">lean_usize_add</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="n">x_4</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_6</span> <span class="bp">=</span> <span class="n">lean_usize_mod</span><span class="o">(</span><span class="n">x_5</span><span class="o">,</span> <span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_6</span><span class="bp">;</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>With <code>n : Nat</code> the generated code is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">LEAN_EXPORT</span> <span class="n">size_t</span> <span class="n">ufin_sub</span><span class="o">(</span><span class="n">lean_object</span><span class="bp">*</span> <span class="n">x_1</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">x_2</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">x_3</span><span class="o">)</span> <span class="o">{</span>
<span class="n">_start</span><span class="o">:</span>
<span class="o">{</span>
<span class="n">size_t</span> <span class="n">x_4</span><span class="bp">;</span> <span class="n">size_t</span> <span class="n">x_5</span><span class="bp">;</span> <span class="n">size_t</span> <span class="n">x_6</span><span class="bp">;</span> <span class="n">size_t</span> <span class="n">x_7</span><span class="bp">;</span>
<span class="n">x_4</span> <span class="bp">=</span> <span class="n">lean_usize_of_nat</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_5</span> <span class="bp">=</span> <span class="n">lean_usize_sub</span><span class="o">(</span><span class="n">x_4</span><span class="o">,</span> <span class="n">x_3</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_6</span> <span class="bp">=</span> <span class="n">lean_usize_add</span><span class="o">(</span><span class="n">x_2</span><span class="o">,</span> <span class="n">x_5</span><span class="o">)</span><span class="bp">;</span>
<span class="n">x_7</span> <span class="bp">=</span> <span class="n">lean_usize_modn</span><span class="o">(</span><span class="n">x_6</span><span class="o">,</span> <span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">lean_dec</span><span class="o">(</span><span class="n">x_1</span><span class="o">)</span><span class="bp">;</span>
<span class="n">return</span> <span class="n">x_7</span><span class="bp">;</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>You probably want to avoid the reference counting <code>lean_dec(x_1)</code> and <code>lean_usize_modn</code> that unboxes <code>Nat</code> inside.</p>



<a name="277935467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277935467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277935467">(Apr 05 2022 at 19:59)</a>:</h4>
<p>Also not sure if I got those operations right for <code>n &gt; sqrt(USize.size)</code>.</p>



<a name="277936241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277936241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277936241">(Apr 05 2022 at 20:04)</a>:</h4>
<p>If you care about performance, you definitely want to avoid that modulo (by directly proving <code>val &lt; n</code> for each index access, most probably)</p>



<a name="277936655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277936655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277936655">(Apr 05 2022 at 20:08)</a>:</h4>
<p>Right, so having <code>x y : UFin n</code> you would not write <code>x + y</code> but <code>⟨x.1 + y.1, ...⟩</code> where you provide a custom proof.</p>



<a name="277938027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277938027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277938027">(Apr 05 2022 at 20:19)</a>:</h4>
<p>it doesn't make much sense to add two array indexes anyway</p>



<a name="277938232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277938232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277938232">(Apr 05 2022 at 20:21)</a>:</h4>
<p>I would imagine that in user code you wouldn't have a <code>UFin n</code> in the first place if you are doing anything other than handling this index opaquely; you would just have a <code>USize</code> and combine this with the proof of <code>val &lt; n</code> at the last minute when calling <code>get</code></p>



<a name="277939534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277939534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277939534">(Apr 05 2022 at 20:33)</a>:</h4>
<p>I'm quite often writing code like <code>λ i =&gt; if (i=0) ∨ (i=(n-1)) then 0 else u[i+1] - u[i-1]</code> where the type is automatically deduced to <code>Fin n</code> where <code>n</code> is the size of array <code>u</code>.</p>



<a name="277940260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/277940260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#277940260">(Apr 05 2022 at 20:40)</a>:</h4>
<p>there are redundant bounds checks in that expression though</p>



<a name="278058026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278058026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278058026">(Apr 06 2022 at 17:27)</a>:</h4>
<p>I think that the built-in Array in Lean does the right thing here, where arrays use <code>Nat</code> for indexing (because it's way easier that way), but behind the scenes we are making (technically unsafe) assumptions that everything fits in USize because otherwise you'd have already hit an out-of-memory error</p>



<a name="278105698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278105698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278105698">(Apr 07 2022 at 00:53)</a>:</h4>
<p>the problem is that it impacts the ABI of the function if you use <code>Nat</code> - you don't get unboxed values anymore. This applies to both extern functions like <code>get</code> and also lean functions that just call each other normally: in addition to the cost of boxing and unboxing this is an optimization barrier, and you need a whole lot of things to go right for lean loops to look like C loops and trigger LLVM loop optimizations</p>



<a name="278205012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278205012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278205012">(Apr 07 2022 at 18:14)</a>:</h4>
<p>Yeah. Maybe instead I implement the interface directly on USize and then provide a separate interface for using <code>Nat</code>s with it</p>



<a name="278291079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278291079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278291079">(Apr 08 2022 at 11:35)</a>:</h4>
<p>So, I'm revamping my implementation to work around some boxing costs with ArrayBuffer as defined.</p>
<p>I need a type whose ABI representation could be any arbitrary value (not just <code>leanbox(0)</code>). Does something like <code>True</code> serve that purpose? Its value per the ABI would be <code>leanbox(0)</code>, but does it <em>have</em> to be? or can it be any arbitrary value of the right width?</p>



<a name="278291434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278291434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278291434">(Apr 08 2022 at 11:38)</a>:</h4>
<p>If not -- is there a way to mark a recursor noncomputable?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Uninit</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">uninit</span> <span class="o">:</span> <span class="n">Uninit</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">init</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Uninit</span> <span class="n">α</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">noncomputable</span><span class="o">]</span> <span class="n">Uninit.rec</span>
</code></pre></div>
<p>This doesn't work because noncomputable is not an attribute. But it would definitely suffice my use-case, since it is not possible to distinguish the two constructors in any produced program.</p>



<a name="278291686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278291686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278291686">(Apr 08 2022 at 11:40)</a>:</h4>
<p>I could also go the extern route, but if I conjecture an Uninit type by <code>constant</code> then I can't conjecture values of that type since it can't prove the type is inhabited...</p>



<a name="278292367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278292367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278292367">(Apr 08 2022 at 11:47)</a>:</h4>
<p>Having an Uninit type would be useful for other FFIs as well; it's nice to say at the type-level that some value is junk, instead of having to ensure everything is known everywhere</p>



<a name="278409511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278409511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278409511">(Apr 09 2022 at 13:09)</a>:</h4>
<p>Also, should allocations for external objects go through <code>lean_alloc</code> or directly call <code>malloc</code>? And if I do use <code>lean_alloc</code> I assume the finalize function should just call<code>lean_dealloc</code>?</p>



<a name="278410102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278410102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278410102">(Apr 09 2022 at 13:25)</a>:</h4>
<p>After poking around the codebase, I think my real question is why the small object allocator exists</p>



<a name="278410216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278410216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278410216">(Apr 09 2022 at 13:27)</a>:</h4>
<p>To make Lean go fast</p>



<a name="278410276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278410276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278410276">(Apr 09 2022 at 13:29)</a>:</h4>
<p>I kinda assumed most malloc implementations already had paging for small allocations but that must be a wrong assumption</p>



<a name="278410450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278410450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278410450">(Apr 09 2022 at 13:33)</a>:</h4>
<p>mimalloc would not have been so successful then. The Lean allocator is very similar to it.</p>



<a name="278410459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278410459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278410459">(Apr 09 2022 at 13:33)</a>:</h4>
<p>So yes, Lean objects should always allocated with <code>lean_alloc</code> so that Lean uses the correct deallocator on them.</p>



<a name="278411426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278411426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278411426">(Apr 09 2022 at 13:56)</a>:</h4>
<p>Actually, I think I am not able to use the lean allocator right now because I need a <code>realloc</code>. For now I'll just use malloc, might try my hand at implementing a realloc on Lean's allocator later</p>



<a name="278411866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278411866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278411866">(Apr 09 2022 at 14:06)</a>:</h4>
<p>I assume you are not talking about the <code>lean_external_object</code> itself then, those should have a fixed size I believe</p>



<a name="278414457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278414457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278414457">(Apr 09 2022 at 15:09)</a>:</h4>
<p>Oh, yeah -- I'm using <code>lean_alloc_external</code> for the external object itself. But I wasn't sure if I should also use lean_alloc for the array allocation</p>



<a name="278419346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278419346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278419346">(Apr 09 2022 at 16:56)</a>:</h4>
<p>It's just a <code>void *</code> to Lean, you are responsible for it</p>



<a name="278424827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/FFI%20for%20fixed-length%20arrays/near/278424827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays.html#278424827">(Apr 09 2022 at 18:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/278291079">said</a>:</p>
<blockquote>
<p>I need a type whose ABI representation could be any arbitrary value (not just <code>leanbox(0)</code>). Does something like <code>()</code> serve that purpose? Its value per the ABI would be <code>leanbox(0)</code>, but does it <em>have</em> to be?</p>
</blockquote>
<p>RE: this, I think it just depends on whether Unit.rec actually checks its value, no? I know the compiler optimizes away matches with only one live branch, so I assume that's true here as well and Unit.rec doesn't check the value?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
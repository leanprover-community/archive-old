---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html">System programming using Lean 4</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225249484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249484">(Feb 05 2021 at 01:24)</a>:</h4>
<p>For school reasons, I am looking to make a (micro|uni)-kernel in some language supporting formal verification, I know some Lean 3 and I was wondering if it was a good idea to jump into Lean 4 and try to make it into Lean 4, it looks like it might be able to fit the bill, I wonder how feasible this is?</p>
<p>e.g. how much stuff has to be reimplemented in baremetal to kickstart Lean 4 programs without any operating system on x86_64 for example? Is it easy or like insanely difficult?</p>



<a name="225249544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249544">(Feb 05 2021 at 01:25)</a>:</h4>
<p>I know the existence of stuff like <a href="https://github.com/stepcut/idrOS">https://github.com/stepcut/idrOS</a> and am ready to carry out similar stuff if required</p>



<a name="225249573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249573">(Feb 05 2021 at 01:25)</a>:</h4>
<p>There are commands that let you write bindings to C calls, so as long as C can do it I think it's possible to make lean do it</p>



<a name="225249581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249581">(Feb 05 2021 at 01:25)</a>:</h4>
<p>I'm not sure how include files work though</p>



<a name="225249688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249688">(Feb 05 2021 at 01:27)</a>:</h4>
<p>I can indeed write down the required stuff to provide primitives in C, then if I can call them from Lean world and write down a model of they should work (which would be really cool if it stops at some boundary to define)</p>
<p>Also, maybe harder question, can Lean 4 compile to non-x86_64 platforms, e.g. RISC-V or ARM?</p>



<a name="225249689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249689">(Feb 05 2021 at 01:27)</a>:</h4>
<p>If <code>lean.h</code> doesn't work because the baremetal environment doesn't have the support this might be a trickier task though. In particular I can imagine memory allocation being a sticking point</p>



<a name="225249721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249721">(Feb 05 2021 at 01:27)</a>:</h4>
<p>lean compiles to C which compiles via any C compiler. So yes, it should work on any arch</p>



<a name="225249768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225249768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225249768">(Feb 05 2021 at 01:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/System.20programming.20using.20Lean.204/near/225249721">said</a>:</p>
<blockquote>
<p>lean compiles to C which compiles via any C compiler. So yes, it should work on any arch</p>
</blockquote>
<p>Wow! That's really neat :&gt;</p>



<a name="225250230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225250230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225250230">(Feb 05 2021 at 01:34)</a>:</h4>
<p>Hm, it looks like that I would need to patch this: <a href="https://github.com/leanprover/lean4/blob/master/src/runtime/object.cpp">https://github.com/leanprover/lean4/blob/master/src/runtime/object.cpp</a> and everything else would reuse those implementations but I might be wrong?</p>



<a name="225250297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225250297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225250297">(Feb 05 2021 at 01:35)</a>:</h4>
<p>wait, that's C++ code? I thought the runtime was all C</p>



<a name="225250408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225250408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225250408">(Feb 05 2021 at 01:36)</a>:</h4>
<p>Well, it is ; but as it looks like to be wrapped in some FFI, I imagine that I can just replace the cool STL containers &amp; stuff by baremetal ol'C</p>



<a name="225250452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225250452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225250452">(Feb 05 2021 at 01:37)</a>:</h4>
<p>I wonder if I can do unikernels of Lean 4 programs :D</p>



<a name="225253852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225253852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225253852">(Feb 05 2021 at 02:31)</a>:</h4>
<p><span class="user-mention" data-user-id="262143">@Ryan Lahfa</span> I do not wish to discourage you, by all means do try to put Lean on bare metal! <em>But</em> it does seem like a Lean 4 OS would be a work-intensive project. While it is true that Lean programs compile to C which you could then compile to any architecture, they also link against the language runtime. So while you can definitely compile to RISC-V or ARM (with some obvious rough edges, but nothing should be fundamentally difficult), this is RISC-V or ARM <em>with an OS</em>. Being a reference-counted language, Lean needs the allocator in its runtime to function. So as Mario mentioned, you would need a heap, which is quite <a href="https://os.phil-opp.com/heap-allocation/">a few chapters into</a> "Writing an OS in Rust". By contrast, there is an allocation-less subset of Rust which is used in that guide to get off the ground fairly quickly with displaying some text into VGA. On top of all this, numerical Lean code uses <a href="https://gmplib.org/"><code>libgmp</code></a> providing which in real mode sounds.. challenging. It sounds like you would have to cut that out of the runtime also. While I know nothing about Idris internals, looking at the idrOS project you linked it seems its author has written about 9k lines of C and <em>9</em> lines of Idris and then given up, so make of that what you will. Having said all this, I think it should be possible, it might just require a fairly high level of determination.</p>



<a name="225260311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225260311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225260311">(Feb 05 2021 at 04:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="128280">Wojciech Nawrocki</span> <span class="user-mention" data-user-id="262143">@Ryan Lahfa</span> Very much agree, having written an OS in Rust. I've been thinking about this idea a lot too. There are many parts of a kernel where heap allocation really shouldn't happen, or where data must be placed in certain places. Doing a unikernel should be a lot easier IMO, since you could write the whole runtime/OS in C/Rust and then use it in Lean.<br>
Maybe if there were a way to make the typechecker linear so allocation wouldn't be necessary this could work.</p>



<a name="225260554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225260554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225260554">(Feb 05 2021 at 04:33)</a>:</h4>
<p>Another issue I think you'd run into here is stack space.<br>
Operating systems have notoriously tiny stacks (in some places, like the kernel stack for a process), usually just one page.<br>
I know some OSdevs who have long, recursive functions, and if they recurse too much they have to be offloaded into new threads as to not overflow the stack. Really the rule of thumb is to never have your callstack over 5 layers deep.<br>
On the other hand, I've had __huge__ issues with lean recursing too much. I've started to compile the program I'm writing with <code>LEANC_OPTS="-fsplit-stack "</code> so it can't overflow... and obviously this isn't possible in an OS context.</p>



<a name="225291037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225291037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225291037">(Feb 05 2021 at 12:14)</a>:</h4>
<p><span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> <span class="user-mention" data-user-id="382349">@Calvin Lee</span>  Well, it definitely makes sense to me ; I'm just wondering what is the shortest path to get something like a unikernel for example and what properties could I get from writing the rest in Lean 4, etc.<br>
That's more an experiment than something else, my fallback project being writing the project in Rust with some design by contracts lib.</p>



<a name="225380751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225380751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225380751">(Feb 06 2021 at 02:11)</a>:</h4>
<p><span class="user-mention" data-user-id="262143">@Ryan Lahfa</span> An OS in Lean 4 sounds awesome.  A practical consideration that Wojciech also mentioned is the Lean runtime is still pretty big.  In particular it depends on GMP, and it introduces a bunch of dependencies due to the way constants are compiled.  Essentially, you end up pulling a lot of the definitions needed for implementing Lean in the runtime dependencies. <br>
We've gotten Lean 4 programs compiling and running as a process on a Rasberry Pi, but I think a more resource constrained environment would be a lot of work.  Leo has heard about our experience at Galois, but I don't know how much of a priority it is to minimize the runtime and enable more bare-metal applications.  I'd like to be able to compile Lean 4 code to Arduino eventually.</p>



<a name="225425539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/225425539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#225425539">(Feb 06 2021 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110994">@Joe Hendrix</span> We are currently fixing bugs and writing papers, but we hope to get back to the compiler in April. This issue is a priority.</p>



<a name="226033688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/226033688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christian Pehle <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#226033688">(Feb 11 2021 at 18:10)</a>:</h4>
<p>I would distinguish between writing an OS and getting C++ to run on bare metal. The latter is relatively easy to do if you have a reasonably powerful embedded system as a target. All you need to get started is a bare metal build of gcc, an embedded C library like <a href="https://sourceware.org/newlib/">https://sourceware.org/newlib/</a>, a linker script and a small set of c++ specific assembly routines. You need surprisingly little to get C++ running, see for example <a href="https://github.com/electronicvisions/libnux/blob/master/src/crt.s">https://github.com/electronicvisions/libnux/blob/master/src/crt.s</a>. So before trying your hand at compiling lean, I would start out just setting up an environment that allows you to compile C++ to bare metal on the platform of your choice.</p>



<a name="226042186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/System%20programming%20using%20Lean%204/near/226042186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/System.20programming.20using.20Lean.204.html#226042186">(Feb 11 2021 at 19:10)</a>:</h4>
<p>We already done such things on RISC-V and FPGAs, so that's why we're interested into the next steps</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
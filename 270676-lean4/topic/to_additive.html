---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/to_additive.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html">to_additive</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221861331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221861331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221861331">(Jan 07 2021 at 06:28)</a>:</h4>
<p>One thing I would like to experiment with (but I won't have time until teaching is done ~ 4 weeks from now) is the add-vs-mul stuff.</p>
<ul>
<li>Does fully-bundled + unification hints make it easier to have only <code>Group</code>?</li>
<li>What are the 37 problems we will hit, when there are 2 paths from <code>Semiring</code> to <code>Monoid</code>?</li>
<li>Can we have notation agnostic <code>Group</code>/<code>Semiring</code>/<code>Monoid</code>, and use the new macro system to have nice and readable notation anyway?</li>
<li>...</li>
</ul>



<a name="221861485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221861485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221861485">(Jan 07 2021 at 06:32)</a>:</h4>
<p>What advantage does a notation agnostic <code>Group</code> have, if the theory is still being duplicated for add/mul? It would just mean 3 copies instead of 2, and with really awkward naming and notation for one of them</p>



<a name="221862518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221862518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221862518">(Jan 07 2021 at 06:56)</a>:</h4>
<p>No... I would want to know if it's possible to do with just 1 copy.</p>



<a name="221862530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221862530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221862530">(Jan 07 2021 at 06:56)</a>:</h4>
<p>Are there new Lean features that we can leverage to make that happen, and still have readable code?</p>



<a name="221862789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221862789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221862789">(Jan 07 2021 at 07:02)</a>:</h4>
<p>We need theorems named <code>add_assoc</code> and <code>mul_assoc</code> independent of any behind the scenes shenanigans</p>



<a name="221862807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221862807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221862807">(Jan 07 2021 at 07:02)</a>:</h4>
<p>so we are already committed to some amount of duplication, even if it's only instantiating one as the other</p>



<a name="221862886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221862886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221862886">(Jan 07 2021 at 07:04)</a>:</h4>
<p>we already have the means to create readable, non-duplicated code that generates 2 copies, via <code>@[to_additive]</code></p>



<a name="221862979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221862979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221862979">(Jan 07 2021 at 07:06)</a>:</h4>
<p>but we could invest in a tactic to allow applying e.g. <code>mul_assoc</code> even when the application does not use <code>mul</code>, both to make the proof of the additive version not require replaying the whole proof, and also to allow using it in situations that use neither notation, e.g. <code>\comp</code> or <code>++</code></p>



<a name="221863262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221863262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221863262">(Jan 07 2021 at 07:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/to_additive/near/221862789">said</a>:</p>
<blockquote>
<p>We need theorems named <code>add_assoc</code> and <code>mul_assoc</code> independent of any behind the scenes shenanigans</p>
</blockquote>
<p>Why exactly do we need this? It's not clear to me that in theory we can't get away with <code>assoc</code>.</p>



<a name="221863687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221863687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221863687">(Jan 07 2021 at 07:22)</a>:</h4>
<p>I don't know what problems we are trying to solve with bundled structures + canonical instances, but I think that typeclasses are way nicer.</p>
<p>Suppose I write everything multiplicative for now (not worrying about additive stuff). Suppose I want to rewrite with <code>mul_assoc</code>. I'm looking for <code>(_ * _) * _</code>. What does <code>*</code> mean here? <code>Group.mul</code>, i.e. one of the fields for <code>Group</code>? That of course doesn't work, since I will also have <code>CommGroup.mul</code>, <code>Ring.mul</code> etc.</p>



<a name="221863736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221863736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221863736">(Jan 07 2021 at 07:23)</a>:</h4>
<p>Isn't it going to be <code>SemiGroup.mul</code>? And then you need coercions to kick in?</p>



<a name="221863781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221863781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221863781">(Jan 07 2021 at 07:24)</a>:</h4>
<p>But the issue you're raising has certainly been solved in mathcomp</p>



<a name="221864482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221864482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221864482">(Jan 07 2021 at 07:38)</a>:</h4>
<p>While I won't discourage any experiments with any of this, I would not put your hopes too high. </p>
<p>Here is a paper that is about packed classes, used in mathcomp: <a href="https://arxiv.org/pdf/2002.00620.pdf">https://arxiv.org/pdf/2002.00620.pdf</a></p>
<p>Here is a paragraph from page 2:</p>
<blockquote>
<p>In spite of its success, the packed classes methodology is hard to master<br>
for library designers and requires a substantial amount of work to maintain as<br>
libraries evolve. For instance, the strict application of packed classes requires<br>
defining quadratically many implicit coercions and unification hints in the number of structures. <br>
To give some figures, the MathComp library 1.10.0 uses this<br>
methodology ubiquitously to define the 51 mathematical structures depicted in<br>
Fig. 1, and declares 554 implicit coercions and 746 unification hints to implement their inheritance. <br>
Moreover, defining new intermediate structures between<br>
existing ones requires fixing their subclasses and their inheritance accordingly;<br>
thus, it can be a challenging task</p>
</blockquote>



<a name="221864672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221864672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221864672">(Jan 07 2021 at 07:43)</a>:</h4>
<p>Hmm, thanks for that quote.</p>



<a name="221864851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221864851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221864851">(Jan 07 2021 at 07:46)</a>:</h4>
<p>This "quadratically many implicit coercions and unification hints" is pretty bad, but I'm not even sure if that is the worst. We can limit the number of classes we have by having multiple classes on 1 type, e.g. <code>[fintype F] [field F]</code>. If you do everything bundled you need to define a bundled structure for every combination. For example, in Figure 1 you see that there is <code>ringType</code>, <code>groupType</code> and <code>fieldType</code>, but also <code>finRingType</code>, <code>finGroupType</code>, <code>countRingType</code>, <code>decFieldType</code>, etc. <br>
I think that requires exponentially many structures, which would be already be <em>way</em> too large for the current size of mathlib.</p>



<a name="221865099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221865099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221865099">(Jan 07 2021 at 07:50)</a>:</h4>
<p>Imagine having <code>topologicalGroup</code>, <code>topologicalCommGroup</code>, <code>hausdorffTopologicalGroup</code> <code>compactSecondCountableTopologicalRing</code>, ...</p>



<a name="221866049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221866049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221866049">(Jan 07 2021 at 08:06)</a>:</h4>
<p>I don't think the "quadratically many implicit coercions and unification hints" is actually that bad. That's the amount of extra setup you have to do to set up the hierarchy itself; it is basically precomputing all shortcut instances. The benefit is that the equivalent of typeclass instance searches become way shorter. Plus I think it would be quite reasonable, if we were to implement this strategy, to have a similar "hierarchy builder" tactic to what mathcomp itself uses (now, after a long manual history)</p>



<a name="221866199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221866199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221866199">(Jan 07 2021 at 08:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/270676-lean4/topic/to_additive/near/221865099">said</a>:</p>
<blockquote>
<p>Imagine having <code>topologicalGroup</code>, <code>topologicalCommGroup</code>, <code>hausdorffTopologicalGroup</code> <code>compactSecondCountableTopologicalRing</code>, ...</p>
</blockquote>
<p>I believe the coq answer to this is mixins. They work pretty similar to the instances like <code>second_countable A</code> that we already use</p>



<a name="221866267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221866267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221866267">(Jan 07 2021 at 08:10)</a>:</h4>
<p>(None of this is to say that I advocate switching, but I can believe that lean 4 makes it possible to actually build a working mathcomp style hierarchy)</p>



<a name="221866961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221866961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221866961">(Jan 07 2021 at 08:20)</a>:</h4>
<p>My impression was that mixins were used only to define new bundled structures, but I might be wrong with that. But if I'm wrong, then I'm wondering why they duplicated all their structures with finite structures.<br>
If you use a mixin in a theorem statement, it better be a type class (right?). And now you're doing both type-class inference and unification hints.</p>



<a name="221924006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221924006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221924006">(Jan 07 2021 at 10:06)</a>:</h4>
<p>Of course we've also been floating around this idea of having <code>[[topological_group G]]</code> do something like:</p>
<ul>
<li>Observe that <code>[topological_group G]</code> needs <code>G : Type*</code>, <code>[topological_space G]</code> and <code>[group G]</code> to make sense.</li>
<li>Check if <code>G</code> exists as <code>variable</code>. If not, add it (at least locally).</li>
<li>Use typeclass resolution to check if <code>[topological_space G]</code> can be derived from the current environment. If not, add the assumption locally.</li>
<li>Idem dito for <code>[group G]</code>.</li>
</ul>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> does <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> sound like something that is in scope for a macro?</p>



<a name="221933549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221933549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221933549">(Jan 07 2021 at 12:00)</a>:</h4>
<p>This could potentially be an elaborator in the <code>binder</code> category, though none of these exist ATM. Note that your second point should be covered by <a href="https://leanprover.github.io/lean4/doc/autobound.html">https://leanprover.github.io/lean4/doc/autobound.html</a>. AFAIR, <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> and I consciously decided <em>not</em> to auto-bind typeclass instance arguments since it's hard to tell whether a user deliberately elided them or <em>thinks</em> they should be implied by the current assumptions, in which case we would unexpectedly add new ones. Perhaps a new notation for that isn't the worst idea, especially when it can be implemented and experimented with outside of core.</p>



<a name="221934478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221934478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221934478">(Jan 07 2021 at 12:11)</a>:</h4>
<p>I can read that you only autobound "a single lower case or greek letter". We tend to use upper case letters as types (or weird letters such as <code>𝕜</code>, for which I don't know how it counts). Is this something we will be able to customize in mathlib?</p>



<a name="221934702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/221934702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#221934702">(Jan 07 2021 at 12:14)</a>:</h4>
<p>Ah, that's true...</p>



<a name="222119200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222119200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222119200">(Jan 08 2021 at 20:09)</a>:</h4>
<p>Along these lines, I was wondering about having "abbreviation classes."  These would be classes that extend some number of classes and have no members themselves, and whenever they appear they should behave as if they are replaced by all the classes they extend.</p>
<p>A bit more precisely,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="kd">class</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">C1</span> <span class="n">α</span><span class="o">,</span> <span class="n">C2</span> <span class="n">α</span><span class="o">,</span> <span class="n">C3</span> <span class="n">α</span>
</code></pre></div>
<p>indicates that a <code>[Foo α]</code> should mean <code>[C1 α] [C2 α] [C3 α]</code>, and whenever a class extends <code>Foo</code>, it would actually extend these three classes.  Under the hood, there should be an actual class for <code>Foo</code> that records the instances, so the typeclass resolution can be more easily cached -- there would be an instance for <code>Foo α</code> whenever instances for the classes being extended exist, so <code>abbreviation class</code> should mean something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Foo</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">C1</span> <span class="n">α</span><span class="o">,</span> <span class="n">C2</span> <span class="n">α</span><span class="o">,</span> <span class="n">C3</span> <span class="n">α</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Foo</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{}</span>
</code></pre></div>
<p>It can't be exactly this because it would create infinite loops in typeclass resolution: <code>Foo</code> provides, for example, a <code>C1</code> instance, so if you need a <code>C1</code> instance then typeclass resolution would try to find a <code>Foo</code> instance, which needs a <code>C1</code> instance, and so on.  The automatic instance for abbreviation classes needs to be special in some way to prevent this infinite loop.</p>
<p>What this feature would support is having all algebraic structures being mixins of basic operations and axioms.  The Lean 3 mockup below illustrates how a commutative monoid would automatically be a monoid, a commutative semigroup, and a semigroup.  This is just because <code>[comm_monoid α]</code> would be roughly equivalent to saying <code>[has_mul α] [has_mul_assoc α] [has_one α] [has_mul_one α] [has_mul_comm α]</code> (though, again, you'd probably only want to pass a single <code>comm_monoid</code> instance argument in the implementation).  This setup should also make it easier to generate automatic universal algebra constructions (forgetful functors are completely trivial, and the right adjoints to these should be macro-ize-able -- I've done them by hand for a few cases).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">flat_structures</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="c">/-</span><span class="cm"> from core:</span>
<span class="cm">class has_one      (α : Type u) := (one : α)</span>
<span class="cm">class has_mul      (α : Type u) := (mul : α → α → α)</span>
<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">has_mul_assoc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>

<span class="kd">class</span> <span class="n">has_mul_one</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one_mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_one</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_mul_comm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="kd">class</span> <span class="n">semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_mul_assoc</span> <span class="n">α</span>
<span class="kd">abbreviation</span> <span class="kd">class</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">semigroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_mul_one</span> <span class="n">α</span>
<span class="kd">abbreviation</span> <span class="kd">class</span> <span class="n">comm_semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">semigroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_mul_comm</span> <span class="n">α</span>
<span class="kd">abbreviation</span> <span class="kd">class</span> <span class="n">comm_monoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_mul_comm</span> <span class="n">α</span>

<span class="kn">section</span> <span class="n">inferences</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">comm_semigroup</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">infer_instance</span>  <span class="c1">-- Cannot infer this using usual `extends`</span>
<span class="kd">end</span> <span class="n">inferences</span>

<span class="kd">end</span> <span class="n">flat_structures</span>
</code></pre></div>



<a name="222122808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222122808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222122808">(Jan 08 2021 at 20:40)</a>:</h4>
<p>Abbreviation classes make it easier to use a certain solution to the so-called "expression problem," where functions can specify exactly which properties of an object they make use of.  Furthermore, it seems it allows property classes to be refactored without changing user code.</p>



<a name="222164350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222164350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222164350">(Jan 09 2021 at 10:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/270676-lean4/topic/to_additive/near/222119200">said</a>:</p>
<blockquote>
<p>It can't be exactly this because it would create infinite loops in typeclass resolution</p>
</blockquote>
<p>Not an issue for the Lean 4 typeclass inference</p>



<a name="222227551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222227551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222227551">(Jan 10 2021 at 15:38)</a>:</h4>
<p>Wait until you also want to put loops, racks, quandles, squags, dioids, spindles and shelfs in the same library, in a backwards compatible manner.  Just because they are not yet 'mainstream' mathematics makes them no less mathematics. </p>
<p>It's also quite fun to formalize the very large set of modal logics out there. It's a fun exercise in meta-mathematics, because any mathematician that values elegance in the least bit will bridle at the amount of duplication they're forced to do in any system that does handle (6+ dimensional!) diamonds seamlessly.</p>
<p>The problem with <code>assoc</code> that <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> mentions is huge. And it of course is not specific to <code>assoc</code>, but a symptom of every law: they end up needing to be either human-duplicated, or the 'renaming' problem involved in transporting them from their origin to their use site (where there might be multiple uses) is quite large. I've implemented a couple of hacky solutions in 2 of my systems - and I would not recommend either of those 'solutions' to anyone.</p>
<p>[tiny rant: The thing with proof systems is that the effort of doing all the proofs is quite significant, so that tends to swallow all the air available, and that's not unreasonable. The problem is that it doesn't leave room left for people to notice just how much duplication there is in their tapestry of theories, definitions and lemmas.  end rant]</p>



<a name="222229978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222229978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222229978">(Jan 10 2021 at 16:41)</a>:</h4>
<p>We at least have <a href="https://leanprover-community.github.io/mathlib_docs/find/shelf">docs#shelf</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/rack">docs#rack</a>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/quandle">docs#quandle</a> (and the conjugation quandle <a href="https://leanprover-community.github.io/mathlib_docs/find/quandle.conj">docs#quandle.conj</a> of a group) -- I've heard of loops and spindles, but the other two <em>must</em> be made up! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>   (Note: shelves are only halfheartedly implemented, and they're only left shelves.)</p>
<p>Just to add some more complexity to your list, how about also having biracks and biquandles in the same library? (It would be nice to eventually have these: they are actually studied in quantum topology to describe factorizations in quantum groups.)</p>



<a name="222264294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222264294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Scheel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222264294">(Jan 11 2021 at 06:40)</a>:</h4>
<p>I’ve always thought that in DTTs, classes should take their operations as parameters, because the identities, inverses, and laws are propositionally-uniquely determined from that, and of course the type can be unification-inferred from the operation (or vice-versa: you need to fix the type to say the operation). That is, instead of <code>Group Nat</code> you would have <code>Group Nat (+)</code> (or maybe just <code>Group (+)</code>). I think it might even play nicely with <code>has_add</code> and <code>has_mul</code>, which are allowed to pick canonical operations for types, while <code>Group</code> would always be told its operation. But of course I don’t spend enough time in proof assistants these days to evaluate my proposal myself ...</p>



<a name="222265512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222265512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222265512">(Jan 11 2021 at 07:11)</a>:</h4>
<p>I have been surprised myself about how effective the lean approach to this has been. It makes code more readable and seems to have surprisingly few disadvantages.</p>



<a name="222265521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222265521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222265521">(Jan 11 2021 at 07:11)</a>:</h4>
<p><span class="user-mention" data-user-id="111651">@Nick Scheel</span> I think the problem with that approach is that it leads to exponential blow-up in term sizes. Let me try to find the blogpost that explains that.</p>



<a name="222265681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222265681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222265681">(Jan 11 2021 at 07:15)</a>:</h4>
<p><span class="user-mention" data-user-id="111651">@Nick Scheel</span> voila: <a href="https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a></p>



<a name="222265757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222265757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Scheel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222265757">(Jan 11 2021 at 07:17)</a>:</h4>
<p>Oh I was just going to ask if it was that post. My understanding is that the style discussed there is just <code>Group A</code> not <code>Group A (+)</code>, i.e. mathlib’s current style.</p>



<a name="222267495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222267495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222267495">(Jan 11 2021 at 07:51)</a>:</h4>
<p><span class="user-mention" data-user-id="111651">@Nick Scheel</span> no, it seems to be the other way round</p>



<a name="222269863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222269863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nick Scheel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222269863">(Jan 11 2021 at 08:24)</a>:</h4>
<p>Oh, I see. I misunderstood arguments vs superclasses. I was only proposing that the operation be an argument, and the rest of the hierarchy would be superclasses (or fields), so it would only be quadratic, I believe.</p>



<a name="222294241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222294241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222294241">(Jan 11 2021 at 13:06)</a>:</h4>
<p>Am I right in thinking that the blow-up is irrelevant as long we define <code>AddGroup A := Group A (+)</code> at some level in the API, and use that for higher-level things?</p>



<a name="222295009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222295009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222295009">(Jan 11 2021 at 13:14)</a>:</h4>
<p>From that blog post:</p>
<blockquote>
<p>Taking the superclasses as indices instead of embedding them as fields simplifies typeclass search and is necessary to support diamonds in the hierarchy</p>
</blockquote>
<p>This sounds like a coq problem that may not translate to lean, unless I'm missing something - my impression is only <code>Op</code>, <code>Unit</code> and <code>Inv</code> need to be arguments, which means that instead of a monster term like <code>Group A (_ : Monoid A (_ : SemiGroup A (*)) 1 inv)</code> as that blog seems to suggest, we can use a shorter <code>Group A (*) 1 inv</code> - so the blow-up does not increase with the depth of the heirarchy, it just increases by one over what we currently have</p>



<a name="222444583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/222444583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#222444583">(Jan 12 2021 at 15:15)</a>:</h4>
<p>BTW, I added an example showing how to use unification hints and type classes simultaneously. It creates a bridge between the bundled (<code>Magma</code> in the example) and unbundled (<code>Mul</code> in the example) worlds.<br>
<a href="https://github.com/leanprover/lean4/blob/master/tests/lean/unifHintAndTC.lean#L46-L53">https://github.com/leanprover/lean4/blob/master/tests/lean/unifHintAndTC.lean#L46-L53</a><br>
Disclaimer: we don't need this feature to implement Lean. So, we don't know how reliable it is.</p>



<a name="223422846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223422846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223422846">(Jan 20 2021 at 19:29)</a>:</h4>
<p>Thanks to Lean 4's typeclass resolution algorithms, it's possible to make typeclasses that represent when certain operations and axioms are available for a type -- there's no difference between a commutative monoid and a monoid with commutative multiplication.  The pattern automatically gives you the full poset of algebraic structures with the given operations and axioms.</p>
<p>Before going to that code, I should mention that I tried combining multiplication and addition into single classes with things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">HasComm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y</span> <span class="n">x</span>
<span class="kn">export</span> <span class="n">HasComm</span> <span class="o">(</span><span class="n">comm</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">HasMulComm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">HasComm</span> <span class="n">α</span> <span class="n">HMul.hMul</span>
<span class="kd">def</span> <span class="n">mulComm</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">HasMulComm</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">h.comm</span>

<span class="kd">class</span> <span class="n">HasAddComm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">HasComm</span> <span class="n">α</span> <span class="n">HAdd.hAdd</span>
<span class="kd">def</span> <span class="n">addComm</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">HasAddComm</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="n">h.comm</span>
</code></pre></div>
<p>but the issue I ran into is that you get name conflicts when you try to extend both <code>HasMulComm</code> and <code>HasAddComm</code>.</p>
<p>Anyway, here's the algebraic hierarchy I was experimenting with.  The pattern is to (1) split off all axioms as classes and (2) give the constructors for the algebraic objects the <code>instance</code> attribute so that they are automatically constructed when all the axioms are available.  If it's not too expensive, you can add instances when certain collections of axioms imply others to help "coerce" algebraic objects.  Below I made it so that a <code>Ring</code> is a <code>Semiring</code> by adding the instance that a <code>Ring</code> has <code>ZeroMul</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> from core:</span>
<span class="cm">class OfNat (α : Type u) (n : Nat) where</span>
<span class="cm">  ofNat : α</span>
<span class="cm">class Mul (α : Type u) where</span>
<span class="cm">  mul : α → α → α</span>
<span class="cm">class Add (α : Type u) where</span>
<span class="cm">  add : α → α → α</span>
<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">Inv</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">inv</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">postfix</span><span class="o">:</span><span class="n">max</span> <span class="s2">"⁻¹"</span> <span class="bp">=&gt;</span> <span class="n">Inv.inv</span>

<span class="kd">class</span> <span class="n">One</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">one</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">export</span> <span class="n">One</span> <span class="o">(</span><span class="n">one</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">natLit</span><span class="bp">!</span> <span class="mi">1</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">one</span>

<span class="kd">class</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">zero</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">export</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">zero</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">natLit</span><span class="bp">!</span> <span class="mi">0</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">ofNat</span> <span class="o">:=</span> <span class="n">zero</span>

<span class="kd">class</span> <span class="n">MulComm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">mulComm</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>
<span class="kn">export</span> <span class="n">MulComm</span> <span class="o">(</span><span class="n">mulComm</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">MulAssoc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">mulAssoc</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>
<span class="kn">export</span> <span class="n">MulAssoc</span> <span class="o">(</span><span class="n">mulAssoc</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">OneUnit</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">oneMul</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
    <span class="n">mulOne</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span>
<span class="kn">export</span> <span class="n">OneUnit</span> <span class="o">(</span><span class="n">oneMul</span> <span class="n">mulOne</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">AddComm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">addComm</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span>
<span class="kn">export</span> <span class="n">AddComm</span> <span class="o">(</span><span class="n">addComm</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">AddAssoc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">addAssoc</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
<span class="kn">export</span> <span class="n">AddAssoc</span> <span class="o">(</span><span class="n">addAssoc</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ZeroUnit</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">zeroAdd</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
    <span class="n">addZero</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
<span class="kn">export</span> <span class="n">ZeroUnit</span> <span class="o">(</span><span class="n">zeroAdd</span> <span class="n">addZero</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">InvMul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">invMul</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="kn">export</span> <span class="n">InvMul</span> <span class="o">(</span><span class="n">invMul</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">NegAdd</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Neg</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">negAdd</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="kn">export</span> <span class="n">NegAdd</span> <span class="o">(</span><span class="n">negAdd</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ZeroMul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">zeroMul</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="kn">export</span> <span class="n">ZeroMul</span> <span class="o">(</span><span class="n">zeroMul</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Distrib</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">leftDistrib</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span>
    <span class="n">rightDistrib</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span>
<span class="kn">export</span> <span class="n">Distrib</span> <span class="o">(</span><span class="n">leftDistrib</span> <span class="n">rightDistrib</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Domain</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
    <span class="n">eqZeroOrEqZeroOfMulEqZero</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="kn">export</span> <span class="n">Domain</span> <span class="o">(</span><span class="n">eqZeroOrEqZeroOfMulEqZero</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">MulAssoc</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Semigroup.mk</span>

<span class="kd">class</span> <span class="n">AddSemigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Add</span> <span class="n">α</span><span class="o">,</span> <span class="n">AddAssoc</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">AddSemigroup.mk</span>

<span class="kd">class</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Semigroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">One</span> <span class="n">α</span><span class="o">,</span> <span class="n">OneUnit</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Monoid.mk</span>

<span class="kd">class</span> <span class="n">AddMonoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddSemigroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">Zero</span> <span class="n">α</span><span class="o">,</span> <span class="n">ZeroUnit</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">AddMonoid.mk</span>

<span class="kd">class</span> <span class="n">CommSemigroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Semigroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">MulComm</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">CommSemigroup.mk</span>

<span class="kd">class</span> <span class="n">CommMonoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">MulComm</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">CommMonoid.mk</span>

<span class="kd">class</span> <span class="n">Group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">Inv</span> <span class="n">α</span><span class="o">,</span> <span class="n">InvMul</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Group.mk</span>

<span class="kd">class</span> <span class="n">AddGroup</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddMonoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">Neg</span> <span class="n">α</span><span class="o">,</span> <span class="n">NegAdd</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">AddGroup.mk</span>

<span class="kd">class</span> <span class="n">Semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddMonoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">Monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">AddComm</span> <span class="n">α</span><span class="o">,</span> <span class="n">ZeroMul</span> <span class="n">α</span><span class="o">,</span> <span class="n">Distrib</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Semiring.mk</span>

<span class="kd">class</span> <span class="n">Ring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">AddGroup</span> <span class="n">α</span><span class="o">,</span> <span class="n">Monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">AddComm</span> <span class="n">α</span><span class="o">,</span> <span class="n">Distrib</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">Ring.mk</span>

<span class="kd">class</span> <span class="n">CommRing</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Ring</span> <span class="n">α</span><span class="o">,</span> <span class="n">MulComm</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">CommRing.mk</span>

<span class="kd">class</span> <span class="n">IntegralDomain</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">CommRing</span> <span class="n">α</span><span class="o">,</span> <span class="n">Domain</span> <span class="n">α</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">IntegralDomain.mk</span>

<span class="kn">section</span> <span class="n">test1</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Semigroup</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">CommSemigroup</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">end</span> <span class="n">test1</span>

<span class="kn">section</span> <span class="n">test2</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">CommSemigroup</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">OneUnit</span> <span class="n">β</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Semigroup</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">end</span> <span class="n">test2</span>

<span class="kn">section</span> <span class="n">test3</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">MulAssoc</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">OneUnit</span> <span class="n">β</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Semigroup</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">end</span> <span class="n">test3</span>

<span class="kd">theorem</span> <span class="n">negZero</span> <span class="o">[</span><span class="n">AddGroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">addZero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:=</span> <span class="bp">-</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)),</span> <span class="n">negAdd</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">subZero</span> <span class="o">[</span><span class="n">AddGroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">addZero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:=</span> <span class="n">a</span><span class="o">),</span> <span class="n">addAssoc</span><span class="o">,</span> <span class="n">negZero</span><span class="o">,</span> <span class="n">addZero</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">negNeg</span> <span class="o">[</span><span class="n">AddGroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">addZero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:=</span> <span class="bp">-</span> <span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">negAdd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:=</span> <span class="n">a</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">addAssoc</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="n">negAdd</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="n">zeroAdd</span><span class="bp">;</span>
<span class="o">}</span>

<span class="kd">theorem</span> <span class="n">addNeg</span> <span class="o">[</span><span class="n">AddGroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">-</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">negAdd</span> <span class="o">}</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="n">negNeg</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">h</span>
<span class="o">}</span>

<span class="kd">theorem</span> <span class="n">addIdemIffZero</span> <span class="o">[</span><span class="n">AddGroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">apply</span> <span class="n">Iff.intro</span>
    <span class="n">focus</span>
        <span class="n">intro</span> <span class="n">h</span>
        <span class="k">have</span> <span class="n">h'</span> <span class="o">:=</span> <span class="n">congrArg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">h</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="n">h'</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">addAssoc</span><span class="o">,</span> <span class="n">addNeg</span><span class="o">,</span> <span class="n">addZero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h'</span>
        <span class="n">exact</span> <span class="n">h'</span>
    <span class="n">focus</span>
        <span class="n">intro</span> <span class="n">h</span>
        <span class="n">subst</span> <span class="n">a</span>
        <span class="n">rw</span> <span class="n">addZero</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ZeroMul</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">ZeroMul.mk</span><span class="bp">;</span>
    <span class="n">intro</span> <span class="n">a</span><span class="bp">;</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">rightDistrib</span><span class="o">,</span> <span class="n">addZero</span><span class="o">]</span> <span class="o">}</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="n">addIdemIffZero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">;</span>
<span class="o">}</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">Ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Semiring</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">inferInstance</span>
</code></pre></div>



<a name="223425196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223425196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223425196">(Jan 20 2021 at 19:48)</a>:</h4>
<p>This looks like exactly the design that someone complained gives exponential blow-up due to every type in the heirarchy being indexed by all the previous types. Perhaps that applies only to Coq / whatever language the blog they linked complained about</p>



<a name="223425870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223425870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223425870">(Jan 20 2021 at 19:53)</a>:</h4>
<p>I think a difference is that this is able to cache intermediate instances.  If you have a <code>Ring</code> and a <code>MulComm</code>, then the term for <code>CommRing</code> is that pair of instances -- it doesn't have to go all the way down to the basic operations and axioms every time.  There is a "fast path" for coercion depending on which objects you extend to define the new object.  (I'd only looked at a couple of terms to see whether the exponential blowup happened. By my non-expert eye it didn't <em>look</em> like it happened, but I'm really not sure.  It probably would happen when the object being coerced doesn't have a nearby common ancestor.)</p>



<a name="223426713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223426713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223426713">(Jan 20 2021 at 19:59)</a>:</h4>
<p>To be clear, the blow up I'm recalling is in term size, not typeclass search duration</p>



<a name="223426790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223426790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223426790">(Jan 20 2021 at 19:59)</a>:</h4>
<p>Yeah, that's what I was referring to.</p>



<a name="223433431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223433431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223433431">(Jan 20 2021 at 20:52)</a>:</h4>
<p>Here's a quick test of this.  I added instances for products of groups, mirroring the one in the article, and then I printed out <code>#reduce</code> of the instance with <code>set_option pp.all true</code>.  I then counted the characters in the message (excluding spaces, since the pretty printer does indenting) and got this graph:</p>
<p><a href="/user_uploads/3121/ix1yscQRBVZ_GXg9JsLSnHgJ/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/ix1yscQRBVZ_GXg9JsLSnHgJ/image.png" title="image.png"><img src="/user_uploads/3121/ix1yscQRBVZ_GXg9JsLSnHgJ/image.png"></a></div><p>Code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">prod</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Mul</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">mul</span> <span class="n">p</span> <span class="n">p'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">*</span> <span class="n">p'.1</span><span class="o">,</span> <span class="n">p.2</span> <span class="bp">*</span> <span class="n">p'.2</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Inv</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Inv</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">inv</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p.1</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">p.2</span><span class="bp">⁻¹</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">One</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">One</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">one</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">Product.ext</span> <span class="o">:</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">}</span> <span class="bp">→</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">q.1</span> <span class="bp">→</span> <span class="n">p.2</span> <span class="bp">=</span> <span class="n">q.2</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">a</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">b</span><span class="bp">;</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Semigroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Semigroup</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Semigroup</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">mulAssoc</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">apply</span> <span class="n">Product.ext</span>
        <span class="n">apply</span> <span class="n">mulAssoc</span>
        <span class="n">apply</span> <span class="n">mulAssoc</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">oneMul</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">apply</span> <span class="n">Product.ext</span>
        <span class="n">apply</span> <span class="n">oneMul</span>
        <span class="n">apply</span> <span class="n">oneMul</span>
    <span class="n">mulOne</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">apply</span> <span class="n">Product.ext</span>
        <span class="n">apply</span> <span class="n">mulOne</span>
        <span class="n">apply</span> <span class="n">mulOne</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">Group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Group</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
    <span class="n">invMul</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">apply</span> <span class="n">Product.ext</span>
        <span class="n">apply</span> <span class="n">invMul</span>
        <span class="n">apply</span> <span class="n">invMul</span>

<span class="kd">end</span> <span class="n">prod</span>

<span class="kd">def</span> <span class="n">test1</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test2</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test3</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test4</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test5</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test6</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test7</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>
<span class="kd">def</span> <span class="n">test8</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">[</span><span class="n">Group</span> <span class="n">G</span><span class="o">]:</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inferInstance</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#reduce</span> <span class="bp">@</span><span class="n">test8</span>
</code></pre></div>
<p>This is what the term for <code>test8</code> looked like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">inst</span> <span class="o">:</span> <span class="n">Group.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">G</span><span class="o">]</span> <span class="bp">=&gt;</span>
  <span class="bp">@</span><span class="n">Group.mk.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span>
    <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
      <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))))))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">instMonoidProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
      <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))))</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">Group.toMonoid.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">inst</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">Group.toMonoid.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
          <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
          <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))))</span> <span class="n">inst</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))</span>
            <span class="n">inst</span>
            <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))</span> <span class="n">inst</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))</span> <span class="n">inst</span>
                <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)</span> <span class="n">inst</span> <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span> <span class="n">inst</span> <span class="n">inst</span><span class="o">))))))))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">instInvProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
      <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))))</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">Group.toInv.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">inst</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">Group.toInv.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
          <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
          <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))))</span> <span class="n">inst</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))</span>
            <span class="n">inst</span>
            <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))</span> <span class="n">inst</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))</span> <span class="n">inst</span>
                <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)</span> <span class="n">inst</span> <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span> <span class="n">inst</span> <span class="n">inst</span><span class="o">))))))))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.proof_1.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
      <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))))</span>
      <span class="n">inst</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span>
        <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))))</span> <span class="n">inst</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))))</span>
          <span class="n">inst</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)))</span> <span class="n">inst</span>
            <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">))</span> <span class="n">inst</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="o">(</span><span class="n">Prod.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span><span class="o">)</span> <span class="n">inst</span> <span class="o">(</span><span class="bp">@</span><span class="n">instGroupProd.</span><span class="o">{</span><span class="n">u_1</span><span class="o">,</span> <span class="n">u_1</span><span class="o">}</span> <span class="n">G</span> <span class="n">G</span> <span class="n">inst</span> <span class="n">inst</span><span class="o">)))))))</span>
</code></pre></div>



<a name="223439481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223439481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223439481">(Jan 20 2021 at 21:39)</a>:</h4>
<p>Nevermind, I now see how this avoids the limitations of the versions I was thinking of - you're taking advantage of dependent types in the extends clause</p>



<a name="223552643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/223552643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#223552643">(Jan 21 2021 at 18:43)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Thanks. This is a useful experiment. I added it to the test suite. BTW, the internal expressions are much smaller since they are shared. Here is your example + code for computing the actual "number of <code>Expr</code> objects used by Lean"<br>
<a href="https://github.com/leanprover/lean4/blob/c78a06d9a5553e8ffc5ffeeb7ba75fd271bc272e/tests/lean/run/KyleAlg.lean#L262-L278">https://github.com/leanprover/lean4/blob/c78a06d9a5553e8ffc5ffeeb7ba75fd271bc272e/tests/lean/run/KyleAlg.lean#L262-L278</a></p>



<a name="236016077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/236016077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#236016077">(Apr 24 2021 at 23:09)</a>:</h4>
<p>Suppose I use this technique and fill out the appropriate instances for Bool. Is there a more efficient way of writing the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">Semiring</span> <span class="n">Bool</span> <span class="o">:=</span>
 <span class="o">{</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">Zero.zero</span><span class="o">,</span> <span class="n">one</span> <span class="o">:=</span> <span class="n">One.one</span><span class="o">,</span> <span class="n">mul</span> <span class="o">:=</span> <span class="n">Mul.mul</span><span class="o">,</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">Add.add</span><span class="o">,</span> <span class="n">addComm</span> <span class="o">:=</span> <span class="n">AddComm.addComm</span><span class="o">,</span>
   <span class="n">oneMul</span> <span class="o">:=</span> <span class="n">OneUnit.oneMul</span><span class="o">,</span> <span class="n">mulOne</span> <span class="o">:=</span> <span class="n">OneUnit.mulOne</span> <span class="o">}</span>
</code></pre></div>



<a name="236031517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/to_additive/near/236031517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/to_additive.html#236031517">(Apr 25 2021 at 02:53)</a>:</h4>
<p>nevermind thx Mario <code>instance : Semiring Bool := {}</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
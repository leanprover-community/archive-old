---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Misunderstanding.20of.20simp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html">Misunderstanding of simp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238246043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238246043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238246043">(May 11 2021 at 03:24)</a>:</h4>
<p>So if I don't use an inductive type where it automatically creates theorems that make things inconsistent and just define a type like this it would work (be sound)? (found a post from Mario suggesting this). And then I'd somehow introduce my own recursor or something</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">int</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">succ</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">eq1</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="bp">→</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="238246506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238246506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Selsam <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238246506">(May 11 2021 at 03:30)</a>:</h4>
<p>Yes, the actual integers with standard zero/succ/pred form a model.</p>



<a name="238323896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238323896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238323896">(May 11 2021 at 15:08)</a>:</h4>
<p><span class="user-mention" data-user-id="243102">@Brandon Brown</span> Lean does not directly support constructing higher inductive types, but in many cases, including this one, you can build higher inductive types by quotienting a regular inductive type by the constraints on the constructors. So in this case we would write this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">int_base</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">int_base</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">int_base</span> <span class="bp">→</span> <span class="n">int_base</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">int_base</span> <span class="bp">→</span> <span class="n">int_base</span>

<span class="kd">inductive</span> <span class="n">int_base.rel</span> <span class="o">:</span> <span class="n">int_base</span> <span class="bp">→</span> <span class="n">int_base</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">succ_congr</span> <span class="o">:</span> <span class="n">rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">rel</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pred_congr</span> <span class="o">:</span> <span class="n">rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">rel</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">pred</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ_pred</span> <span class="o">:</span> <span class="n">rel</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">pred_succ</span> <span class="o">:</span> <span class="n">rel</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">Quot</span> <span class="n">int_base.rel</span>
<span class="kd">def</span> <span class="n">int.succ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">i.lift</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">_</span> <span class="n">a.succ</span><span class="o">)</span>
  <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Quot.sound</span> <span class="o">(</span><span class="n">int_base.rel.succ_congr</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">int.pred</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">i.lift</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">_</span> <span class="n">a.pred</span><span class="o">)</span>
  <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Quot.sound</span> <span class="o">(</span><span class="n">int_base.rel.pred_congr</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">theorem</span> <span class="n">int.succ_pred</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="o">:</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">induction</span> <span class="n">a</span> <span class="n">using</span> <span class="n">Quot.ind</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">_</span> <span class="n">a</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">Quot.sound</span> <span class="n">int_base.rel.succ_pred</span>
<span class="kd">theorem</span> <span class="n">int.pred_succ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="o">:</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">induction</span> <span class="n">a</span> <span class="n">using</span> <span class="n">Quot.ind</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">_</span> <span class="n">a</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">Quot.sound</span> <span class="n">int_base.rel.pred_succ</span>
</code></pre></div>



<a name="238336480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238336480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238336480">(May 11 2021 at 16:17)</a>:</h4>
<p>Oh that's neat, I think I finally get it; I really appreciate you taking the time to write that clear example of the quotient type, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> .   I still do wonder if Lean4 could be extended to support a kind of higher inductive type since it has extensible syntax. Would it be possible to just write syntax for a custom inductive type where you do something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">int</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">int</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span>
<span class="n">and</span>
<span class="bp">|</span> <span class="n">eq1</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="bp">→</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">eq2</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="bp">→</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>
<p>And it would parse this into a set of variables in a namespace</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">int</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">succ</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">eq1</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="bp">→</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">eq2</span><span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="bp">→</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>along with a recursor and all the other ancillaries that are needed to make an inductive type? Just wondering out of curiosity. And I have no interest in HoTT I just like that higher inductive types appear to make it easier to do some "synthetic mathematics" i.e. axiomatizing something and proving from there rather than having to keep deriving from simpler types.</p>



<a name="238337073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337073">(May 11 2021 at 16:21)</a>:</h4>
<p>If you want to do "synthetic mathematics" you can do the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">my_int</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">s</span>
  <span class="n">succ</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">s</span>
  <span class="n">pred</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">s</span>
  <span class="n">eq1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">s</span><span class="o">},</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">eq2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">s</span><span class="o">},</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>



<a name="238337145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337145">(May 11 2021 at 16:22)</a>:</h4>
<p>Lean 4 syntax is intended to be easily extensible, so this should be possible. (I struggled with a similar construct some long time ago and gave up... I hope experts will chime in with a solution.) Should the "and" allow for anything other than equalities?</p>



<a name="238337205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337205">(May 11 2021 at 16:22)</a>:</h4>
<p>(If I got the lean4 syntax right)</p>



<a name="238337261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337261">(May 11 2021 at 16:22)</a>:</h4>
<p>Then you can postulate</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">my_int</span> <span class="n">s</span><span class="o">]</span>
</code></pre></div>



<a name="238337407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337407">(May 11 2021 at 16:23)</a>:</h4>
<p>Now, Mario showed above that one can actually construct an actual type that can be shown to have a <code>my_int</code> instance. But not all postulated collections are valid. So whatever higher inductive type you make, you'd have to show that it doesn't imply False</p>



<a name="238337663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François G. Dorais <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337663">(May 11 2021 at 16:25)</a>:</h4>
<p>To be clear from my last message, a "solution" would need to create an inductive and then a quotient, perhaps with some equation lemmas to hide the machinery.</p>



<a name="238337889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238337889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238337889">(May 11 2021 at 16:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Misunderstanding.20of.20simp/near/238337407">said</a>:</p>
<blockquote>
<p>Now, Mario showed above that one can actually construct an actual type that can be shown to have a <code>my_int</code> instance. But not all postulated collections are valid. So whatever higher inductive type you make, you'd have to show that it doesn't imply False</p>
</blockquote>
<p>This is the main reason that Lean doesn't support HITs. In fact the consistency and even a general schema for sound HITs was an open problem for a long time. There are some reasonable looking HITs that are inconsistent</p>



<a name="238338004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238338004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238338004">(May 11 2021 at 16:28)</a>:</h4>
<p>The "in many cases" in my earlier post is doing a lot of work there</p>



<a name="238338199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238338199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238338199">(May 11 2021 at 16:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="119741">François G. Dorais</span> <a href="#narrow/stream/270676-lean4/topic/Misunderstanding.20of.20simp/near/238337145">said</a>:</p>
<blockquote>
<p>(I struggled with a similar construct some long time ago and gave up... I hope experts will chime in with a solution.) </p>
</blockquote>
<p>Could you elaborate? What did you want to implement?</p>



<a name="238339266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238339266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238339266">(May 11 2021 at 16:36)</a>:</h4>
<p>I see. So HITs are actually more work than quotient types. I was just cursorily looking at this paper "THE INTEGERS AS A HIGHER INDUCTIVE TYPE" <a href="https://arxiv.org/pdf/2007.00167.pdf">https://arxiv.org/pdf/2007.00167.pdf</a> and was intrigued but looks like it is actually a quite involved construction. I will stick with quotients.</p>



<a name="238339526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238339526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238339526">(May 11 2021 at 16:38)</a>:</h4>
<p>Things get a lot more complicated when you need higher higher constructors like <code>coh : (z : Z) → ap_succ(sec(z)) =ret(succ(z))</code> there</p>



<a name="238340247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238340247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238340247">(May 11 2021 at 16:42)</a>:</h4>
<p>The associated talk by Thorsten is quite good iirc <a href="https://www.youtube.com/watch?v=Fov95A2bGDI">https://www.youtube.com/watch?v=Fov95A2bGDI</a></p>
<div class="youtube-video message_inline_image"><a data-id="Fov95A2bGDI" href="https://www.youtube.com/watch?v=Fov95A2bGDI"><img src="https://uploads.zulipusercontent.net/43a2bf37201e7f67167439ae74f620d9c27cb26b/68747470733a2f2f692e7974696d672e636f6d2f76692f466f7639354132624744492f64656661756c742e6a7067"></a></div>



<a name="238357289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238357289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238357289">(May 11 2021 at 18:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Misunderstanding.20of.20simp/near/238337407">said</a>:</p>
<blockquote>
<p>Now, Mario showed above that one can actually construct an actual type that can be shown to have a <code>my_int</code> instance. But not all postulated collections are valid. So whatever higher inductive type you make, you'd have to show that it doesn't imply False</p>
</blockquote>
<p>It is important to note though, that even if your axioms schema does imply <code>False</code> with "synthetic mathematics"  approach by <span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span>  i,e,</p>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Misunderstanding.20of.20simp/near/238337073">said</a>:</p>
<blockquote>
<p>If you want to do "synthetic mathematics" you can do the following:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">my_int</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">s</span>
  <span class="n">succ</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">s</span>
  <span class="n">pred</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">s</span>
  <span class="n">eq1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">s</span><span class="o">},</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">eq2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">s</span><span class="o">},</span> <span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div><br>
</p>
</blockquote>
<p>and</p>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/270676-lean4/topic/Misunderstanding.20of.20simp/near/238337261">said</a>:</p>
<blockquote>
<p>Then you can postulate</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">my_int</span> <span class="n">s</span><span class="o">]</span>
</code></pre></div><br>
</p>
</blockquote>
<p><code>False</code> will only be provable in places <code>s</code> is in scope. You will not have rendered Lean as a whole inconsistent (because you will not actually be able to construct an instance of <code>my_int</code> in a vacuum).</p>



<a name="238357767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238357767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238357767">(May 11 2021 at 18:12)</a>:</h4>
<p>That's probably not much consolation if you want to work with <code>my_int</code> though</p>



<a name="238383968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/238383968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#238383968">(May 11 2021 at 21:19)</a>:</h4>
<p>True, though luckily <code>my_int</code> does not prove <code>False</code> (at least I hope so XD).</p>



<a name="243306099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306099">(Jun 20 2021 at 14:48)</a>:</h4>
<p>So the inductive relation defined by <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  above</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">int_base.rel</span> <span class="o">:</span> <span class="n">int_base</span> <span class="bp">→</span> <span class="n">int_base</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">succ_congr</span> <span class="o">:</span> <span class="n">rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">rel</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pred_congr</span> <span class="o">:</span> <span class="n">rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">rel</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">pred</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ_pred</span> <span class="o">:</span> <span class="n">rel</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">))</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">pred_succ</span> <span class="o">:</span> <span class="n">rel</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">))</span> <span class="n">a</span>
</code></pre></div>
<p>appears not equivalent to the subtype version of the integers I defined elsewhere based on if it's in norm form, i.e. <code>{ x : base_int // is_norm (x)}</code><br>
because I want e.g. <code>a.succ.succ.pred.pred</code> to be equal to <code>zero</code> whereas with this relation that doesn't appear to be true. I've instead defined a relation using the <code>norm</code> function Mario wrote. But was hoping someone could give me some clues on how to make progress on the proof that my addition function on the base integer type respects the relation so I can lift it to the quotient type. I think this new relation can be easily made into an equivalence relation but not sure if using <code>Quotient</code> rather than <code>Quot</code> buys me anything in this particular case.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">b_int</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="n">deriving</span> <span class="n">DecidableEq</span>

<span class="kn">open</span> <span class="n">b_int</span>

<span class="kd">def</span> <span class="n">up</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">succ</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">down</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">pred</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">norm_aux</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">up</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">norm_aux</span> <span class="o">(</span><span class="n">down</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="o">:=</span> <span class="n">norm_aux</span> <span class="n">zero</span>

<span class="kn">protected</span> <span class="kd">inductive</span> <span class="n">b_int.rel</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="o">(</span><span class="n">norm</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">norm</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">succ_congr</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.rel</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pred_congr</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.rel</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">pred</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">Quot</span> <span class="n">b_int.rel</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">int.succ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">a.lift</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">a.succ</span><span class="o">)</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.sound</span> <span class="o">(</span><span class="n">b_int.rel.succ_congr</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">int.pred</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">a.lift</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">a.pred</span><span class="o">)</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.sound</span> <span class="o">(</span><span class="n">b_int.rel.pred_congr</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Coe</span> <span class="n">b_int</span> <span class="n">int</span> <span class="n">where</span>
  <span class="n">coe</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">a</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">pred</span>

<span class="kd">theorem</span> <span class="n">add_zero</span> <span class="o">:</span> <span class="n">b_int.add</span> <span class="n">zero</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">add_succ</span> <span class="o">:</span> <span class="n">b_int.add</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">theorem</span> <span class="n">add_pred</span> <span class="o">:</span> <span class="n">b_int.add</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- Not sure if this is the right direction</span>
<span class="kd">theorem</span> <span class="n">add_eq2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">),</span> <span class="o">(</span><span class="n">b_int.rel</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">b_int.add</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intros</span> <span class="n">c</span> <span class="n">b</span> <span class="n">h</span>
  <span class="n">induction</span> <span class="n">a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">int</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">int</span><span class="o">)</span>
    <span class="n">apply</span> <span class="n">Quot.sound</span>
    <span class="n">assumption</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="n">h2</span> <span class="bp">=&gt;</span>
    <span class="n">apply</span> <span class="n">add_succ</span>
    <span class="n">assumption</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="n">h3</span> <span class="bp">=&gt;</span>
    <span class="n">apply</span> <span class="n">add_pred</span>
    <span class="n">assumption</span>

<span class="c1">-- have to apply lift twice</span>
<span class="kd">def</span> <span class="n">int.add</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">Quot.lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">=&gt;</span> <span class="n">Quot.lift</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span><span class="o">)</span> <span class="n">add_eq2</span><span class="o">)</span> <span class="gr">sorry</span><span class="o">)</span>
</code></pre></div>



<a name="243306206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306206">(Jun 20 2021 at 14:51)</a>:</h4>
<p>The relation is not itself an equivalence relation, but the equivalence relation generated by that relation makes <code>a.succ.succ.pred.pred = a</code> because <code>a.succ.succ.pred.pred ~ a.succ.pred ~ a</code> where the two relations are in <code>int_base.rel</code> and they are connected by transitivity</p>



<a name="243306264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306264">(Jun 20 2021 at 14:52)</a>:</h4>
<p>That is, in <code>int := Quot int_base.rel</code>, <code>[[a.succ.succ.pred.pred]] = [[a.succ.pred]] = [[a]]</code> where we use <code>Quot.sound</code> for the individual equalities and <code>Eq.trans</code> to connect them</p>



<a name="243306280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306280">(Jun 20 2021 at 14:52)</a>:</h4>
<p>If you import mathlib's <code>data.quot</code> then you will have access to stuff like <code>quot.lift₂</code>, <code>quotient.lift₂</code>, <code>quotient.map₂</code> and so on, which might make things easier.</p>



<a name="243306380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306380">(Jun 20 2021 at 14:55)</a>:</h4>
<p>Mathlib4 has <code>quot.lift₂</code> ?</p>



<a name="243306435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306435">(Jun 20 2021 at 14:56)</a>:</h4>
<p>mathlib 3 does</p>



<a name="243306439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306439">(Jun 20 2021 at 14:56)</a>:</h4>
<p>there isn't really anything about what you are doing that needs lean 4</p>



<a name="243306454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306454">(Jun 20 2021 at 14:57)</a>:</h4>
<p>you might as well learn how to do it in lean 3 where there are more theorems available</p>



<a name="243306527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243306527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243306527">(Jun 20 2021 at 14:58)</a>:</h4>
<p>Apologies, I hadn't noticed what stream we're in. Please feel free to port data.quot to mathlib 4 :-)</p>



<a name="243470467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243470467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243470467">(Jun 22 2021 at 04:09)</a>:</h4>
<p>Thanks, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> . I get it now, it didn't occur to me that once I have the quotient my non-equivalence relation becomes an equivalence relation given the quotient sound axiom. Indeed, I can prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">zero.pred.pred.succ.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">zero.pred.succ</span> <span class="bp">=</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">pred</span> <span class="n">zero</span><span class="o">))))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">Quot.sound</span><span class="bp">;</span>
    <span class="n">apply</span> <span class="n">b_int.rel.succ_congr</span><span class="bp">;</span>
    <span class="n">apply</span> <span class="n">b_int.rel.succ_pred</span><span class="bp">;</span>
  <span class="o">}</span><span class="bp">;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">h1</span><span class="o">]</span><span class="bp">;</span>
  <span class="n">apply</span> <span class="n">int_succ_pred</span><span class="bp">;</span>
</code></pre></div>
<p>Moreover, I got around having to use Quot.lift twice by defining my add function to take as the first argument an <code>int</code> and as the second argument a <code>b_int</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">pred</span>
</code></pre></div>
<p>And I proved it respects the equivalence relation to make it into the desired <code>int.add : int → int → int</code><br>
I am now content and can move beyond my obsession defining the integers in various ways, now having defined the integers the way lean core does, as a subtype using <code>norm</code> and as a quotient type.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Full Code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">b_int</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span>
<span class="bp">|</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">blean</span>
<span class="n">deriving</span> <span class="n">DecidableEq</span>

<span class="kn">open</span> <span class="n">b_int</span>

<span class="kn">protected</span> <span class="kd">inductive</span> <span class="n">b_int.rel</span> <span class="o">:</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="n">b_int</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">succ_pred</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="bp">$</span> <span class="n">pred</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pred_succ</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="o">(</span><span class="n">pred</span> <span class="bp">$</span> <span class="n">succ</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ_congr</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.rel</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">pred_congr</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.rel</span> <span class="o">(</span><span class="n">pred</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">pred</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">Quot</span> <span class="n">b_int.rel</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">int.succ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">a.lift</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">a.succ</span><span class="o">)</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.sound</span> <span class="o">(</span><span class="n">b_int.rel.succ_congr</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">int.pred</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">a.lift</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">a.pred</span><span class="o">)</span>
  <span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.sound</span> <span class="o">(</span><span class="n">b_int.rel.pred_congr</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">int_succ_pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a.pred.succ</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">a</span>
  <span class="n">induction</span> <span class="n">a</span> <span class="n">using</span> <span class="n">Quot.ind</span>
  <span class="n">apply</span> <span class="n">Quot.sound</span>
  <span class="n">apply</span> <span class="n">b_int.rel.succ_pred</span>

<span class="kd">theorem</span> <span class="n">int_pred_succ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a.succ.pred</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">a</span> <span class="n">using</span> <span class="n">Quot.ind</span>
  <span class="n">apply</span> <span class="n">Quot.sound</span>
  <span class="n">apply</span> <span class="n">b_int.rel.pred_succ</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">zero.pred.pred.succ.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">zero.pred.succ</span> <span class="bp">=</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">pred</span> <span class="n">zero</span><span class="o">))))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">Quot.sound</span><span class="bp">;</span>
    <span class="n">apply</span> <span class="n">b_int.rel.succ_congr</span><span class="bp">;</span>
    <span class="n">apply</span> <span class="n">b_int.rel.succ_pred</span><span class="bp">;</span>
  <span class="o">}</span><span class="bp">;</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">h1</span><span class="o">]</span><span class="bp">;</span>
  <span class="n">apply</span> <span class="n">int_succ_pred</span><span class="bp">;</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">b_int.add</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">pred</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Coe</span> <span class="n">b_int</span> <span class="n">int</span> <span class="n">where</span>
  <span class="n">coe</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Quot.mk</span> <span class="n">b_int.rel</span> <span class="n">a</span>

<span class="kd">theorem</span> <span class="n">add_eq3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">b_int</span><span class="o">),</span> <span class="n">b_int.rel</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">c</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span>
  <span class="n">induction</span> <span class="n">a</span> <span class="n">generalizing</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">c</span> <span class="n">b</span><span class="bp">;</span>
    <span class="n">cases</span> <span class="n">h</span>
    <span class="k">show</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c.pred.succ</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int_succ_pred</span><span class="o">]</span>
    <span class="k">show</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c.succ.pred</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int_pred_succ</span><span class="o">]</span><span class="bp">;</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">a</span> <span class="n">h1</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">c</span> <span class="n">b</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">succ_pred</span> <span class="bp">=&gt;</span>
      <span class="k">show</span> <span class="n">int.succ</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ.pred.succ</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int_succ_pred</span><span class="o">]</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">pred_succ</span> <span class="bp">=&gt;</span>
      <span class="k">show</span> <span class="n">int.succ</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ.succ.pred</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int_pred_succ</span><span class="o">]</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">succ_congr</span> <span class="n">z1</span> <span class="bp">=&gt;</span>
      <span class="k">show</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
      <span class="n">apply</span> <span class="n">congr</span><span class="bp">;</span>
      <span class="n">rfl</span><span class="bp">;</span>
      <span class="n">apply</span> <span class="n">h1</span><span class="bp">;</span>
      <span class="n">assumption</span><span class="bp">;</span>
  <span class="bp">|</span> <span class="n">pred</span> <span class="n">a</span> <span class="n">h2</span> <span class="bp">=&gt;</span>
    <span class="k">show</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">pred</span> <span class="bp">=</span> <span class="n">b_int.add</span> <span class="n">c</span> <span class="n">b</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">succ_pred</span> <span class="bp">=&gt;</span>
      <span class="k">show</span> <span class="n">int.pred</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">pred.pred.succ</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int_succ_pred</span><span class="o">]</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">pred_succ</span> <span class="bp">=&gt;</span>
      <span class="k">show</span> <span class="n">int.pred</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">pred.succ.pred</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">int_pred_succ</span><span class="o">]</span><span class="bp">;</span>
    <span class="bp">|</span> <span class="n">pred_congr</span> <span class="n">z2</span> <span class="bp">=&gt;</span>
      <span class="k">show</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">pred</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">c</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">pred</span>
      <span class="n">apply</span> <span class="n">congr</span><span class="bp">;</span>
      <span class="n">rfl</span><span class="bp">;</span>
      <span class="n">apply</span> <span class="n">h2</span><span class="bp">;</span>
      <span class="n">assumption</span><span class="bp">;</span>

<span class="c1">-- Quot.lift b_int.add _ : int → (int → int)</span>
<span class="kd">def</span> <span class="n">int.add</span> <span class="o">:</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span> <span class="bp">→</span> <span class="n">int</span> <span class="o">:=</span>
  <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">Quot.lift</span> <span class="o">(</span><span class="n">b_int.add</span> <span class="n">a</span><span class="o">)</span> <span class="n">add_eq3</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">Quot.mk</span> <span class="n">_</span> <span class="n">zero.pred</span>
<span class="kd">def</span> <span class="n">t2</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">Quot.mk</span> <span class="n">_</span> <span class="n">zero.succ</span>
<span class="kd">def</span> <span class="n">int.zero</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="n">Quot.mk</span> <span class="n">_</span> <span class="n">b_int.zero</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="n">int.add</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span> <span class="c1">-- Quot.mk b_int.rel (succ (pred zero))</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">int.add</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">Eq.symm</span>
  <span class="n">apply</span> <span class="n">Quot.sound</span><span class="bp">;</span>
  <span class="n">apply</span> <span class="n">b_int.rel.succ_pred</span><span class="bp">;</span>
</code></pre></div>
</div></div>



<a name="243470691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Misunderstanding%20of%20simp/near/243470691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Misunderstanding.20of.20simp.html#243470691">(Jun 22 2021 at 04:15)</a>:</h4>
<p>And yes Lean 3 would be probably easier but I intend to write some tutorials on Lean 4 on my blog</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
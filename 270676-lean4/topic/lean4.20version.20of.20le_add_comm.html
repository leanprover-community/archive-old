---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html">lean4 version of le_add_comm</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="301507905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301507905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301507905">(Sep 29 2022 at 18:41)</a>:</h4>
<p>What is the lean4 version of this proof that uses cases' from mathlib:<br>
<a href="/user_uploads/3121/bo3-J-o_GynlqS3HuoOm3OSm/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/bo3-J-o_GynlqS3HuoOm3OSm/image.png" title="image.png"><img src="/user_uploads/3121/bo3-J-o_GynlqS3HuoOm3OSm/image.png"></a></div><p>I tried this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">le_add_comm</span> <span class="o">(</span><span class="n">l</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">l</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases'</span> <span class="n">Classical.em</span> <span class="o">(</span><span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span>
  <span class="n">case</span> <span class="n">inl</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">inr</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
</code></pre></div>
<p>But it has unsolved goals like this:<br>
<a href="/user_uploads/3121/7E7WzPPUvvs6zI2jHpI3KQI7/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/7E7WzPPUvvs6zI2jHpI3KQI7/image.png" title="image.png"><img src="/user_uploads/3121/7E7WzPPUvvs6zI2jHpI3KQI7/image.png"></a></div><p>I tried adding <code>simp [min, h, Nat.le_of_add_le_add_right]</code> thinking that since that proves <code>a + b ≤ c + b → a ≤ c</code> it would help me eliminate <code>l</code> in this goal and then simp could finish it using the hypothesis, but this didn't work either.  Is there a tactic that eliminates <code>l</code> by subtracting <code>l</code> from both sides of the <code>≤ </code> ?</p>



<a name="301508319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301508319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301508319">(Sep 29 2022 at 18:43)</a>:</h4>
<p>it's a simp lemma</p>



<a name="301508619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301508619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301508619">(Sep 29 2022 at 18:45)</a>:</h4>
<p>where did you find that lemma? I can't find <code>min_add_add</code> in any of {lean, mathlib, lean4, std4, mathlib4}</p>



<a name="301508689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301508689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301508689">(Sep 29 2022 at 18:45)</a>:</h4>
<p>oh, hang on, no I added it in order to port min_add_add which is in the hitchhiker's guide to logic verification.</p>



<a name="301508805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301508805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301508805">(Sep 29 2022 at 18:46)</a>:</h4>
<p>do you have a MWE that compiles in lean 3?</p>



<a name="301508924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301508924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301508924">(Sep 29 2022 at 18:47)</a>:</h4>
<p>Assuming you have a working version of the lean 3 code, you can use <code>simp?</code> to find what additional lemmas it's using</p>



<a name="301508944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301508944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301508944">(Sep 29 2022 at 18:47)</a>:</h4>
<p>This is the one I'm trying to port:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">min_add_add</span> <span class="o">(</span><span class="n">l</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">min</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">Classical.em</span> <span class="o">(</span><span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span>
  <span class="n">case</span> <span class="n">inl</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">inr</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
</code></pre></div>



<a name="301509050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301509050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301509050">(Sep 29 2022 at 18:47)</a>:</h4>
<p>the behavior of <code>simp</code> depends on all the lemmas tagged <code>@[simp]</code> in the library, and there are a ton of those and not all have been ported</p>



<a name="301509568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301509568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301509568">(Sep 29 2022 at 18:51)</a>:</h4>
<p>this works for me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.Nat.Lemmas</span> <span class="c1">-- or something in mathlib4 that implies this</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">Nat.add_le_add_iff_le_right</span>

<span class="kd">theorem</span> <span class="n">min_add_add</span> <span class="o">(</span><span class="n">l</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">min</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">Classical.em</span> <span class="o">(</span><span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span>
  <span class="n">case</span> <span class="n">inl</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">inr</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
</code></pre></div>



<a name="301510140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301510140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301510140">(Sep 29 2022 at 18:54)</a>:</h4>
<p>Thanks!</p>



<a name="301510303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301510303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301510303">(Sep 29 2022 at 18:55)</a>:</h4>
<p>Yeah, math lib provides lemma in <code>import Mathlib.Tactic.Basic</code>.</p>



<a name="301541786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301541786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301541786">(Sep 29 2022 at 22:22)</a>:</h4>
<p>Ok, now that I have min_add_add, I'm also having trouble with length_zip, do we have a lean4 version of length_zip ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">length</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">Nat.add_le_add_iff_le_right</span>

<span class="kd">theorem</span> <span class="n">min_add_add</span> <span class="o">(</span><span class="n">l</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">min</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">Classical.em</span> <span class="o">(</span><span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span>
  <span class="n">case</span> <span class="n">inl</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">inr</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">min</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>

<span class="kd">set_option</span> <span class="n">trace.Meta.Tactic.simp.rewrite</span> <span class="n">true</span>
<span class="kd">lemma</span> <span class="n">length_zip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">length</span> <span class="o">(</span><span class="n">zip</span> <span class="n">xs</span> <span class="n">ys</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction'</span> <span class="n">xs</span>
  <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length</span><span class="o">,</span> <span class="n">min</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">xs'</span> <span class="n">ih</span>  <span class="bp">=&gt;</span> <span class="c1">-- ih ⊢ length (zip (x :: xs') ys) = min (length (x :: xs')) (length ys)</span>
    <span class="n">cases</span> <span class="n">ys</span>
    <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
    <span class="n">case</span> <span class="n">cons</span> <span class="n">y</span> <span class="n">ys'</span> <span class="bp">=&gt;</span>   <span class="c1">-- ⊢ length (zip (x :: xs') (y :: ys')) = min (length (x :: xs')) (length (y :: ys'))</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">zip</span><span class="o">]</span>         <span class="c1">-- ⊢ length ((x, y) :: zip xs' ys') = min (length (x :: xs')) (length (y :: ys'))</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">length</span><span class="o">]</span>      <span class="c1">-- ⊢ length (zip xs' ys') + 1 = min (length xs' + 1) (length ys' + 1)</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">min_add_add</span><span class="o">]</span>  <span class="c1">-- ⊢ length (zip xs' ys') = min (length xs') (length ys')</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">ih</span><span class="o">]</span>           <span class="c1">-- why can't it make use of ih to solve this?</span>
</code></pre></div>
<p>Here's the lean3 proof :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">length_zip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">length</span> <span class="o">(</span><span class="n">zip</span> <span class="n">xs</span> <span class="n">ys</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction'</span> <span class="n">xs</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">nil</span> <span class="o">{</span>
    <span class="n">refl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">x</span> <span class="n">xs'</span> <span class="o">{</span>
    <span class="n">cases'</span> <span class="n">ys</span><span class="o">,</span>
    <span class="n">case</span> <span class="n">nil</span> <span class="o">{</span>
      <span class="n">refl</span> <span class="o">},</span>
    <span class="n">case</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">y</span> <span class="n">ys'</span> <span class="o">{</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">zip</span><span class="o">,</span> <span class="n">length</span><span class="o">,</span> <span class="n">ih</span> <span class="n">ys'</span><span class="o">,</span> <span class="n">min_add_add</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>and it could solve it, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">LoVe.zip.equations._eqn_3</span><span class="o">]:</span> <span class="n">zip</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">::</span> <span class="n">zip</span> <span class="n">xs'</span> <span class="n">ys'</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">LoVe.length.equations._eqn_2</span><span class="o">]:</span> <span class="n">length</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">::</span> <span class="n">zip</span> <span class="n">xs'</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="n">length</span> <span class="o">(</span><span class="n">zip</span> <span class="n">xs'</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[[</span><span class="n">anonymous</span><span class="o">]]:</span> <span class="n">length</span> <span class="o">(</span><span class="n">zip</span> <span class="n">xs'</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">LoVe.length.equations._eqn_2</span><span class="o">]:</span> <span class="n">length</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="n">length</span> <span class="n">xs'</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">LoVe.length.equations._eqn_2</span><span class="o">]:</span> <span class="n">length</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="n">length</span> <span class="n">ys'</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">LoVe.min_add_add</span><span class="o">]:</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">add_left_inj</span><span class="o">]:</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">==&gt;</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span>
<span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify.rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">eq_self_iff_true</span><span class="o">]:</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">==&gt;</span> <span class="n">true</span>
</code></pre></div>
<p>but I'm not sure how to do <code>ih ys'</code> in lean4, that part doesn't compile... saying</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">ih</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">length</span> <span class="o">(</span><span class="n">zip</span> <span class="n">xs'</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span>
</code></pre></div>
<p>I assume that is what helps it with the difference between <code>zip (x :: xs') ys</code> and <code>zip xs' ys</code> ?</p>



<a name="301541854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301541854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301541854">(Sep 29 2022 at 22:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="434989">Chris Lovett</span> has marked this topic as unresolved.</p>



<a name="301544072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301544072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301544072">(Sep 29 2022 at 22:43)</a>:</h4>
<p>How about:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">length_zip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">xs.zip</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">xs.length</span> <span class="n">ys.length</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">xs</span> <span class="n">generalizing</span> <span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">List.length</span><span class="o">,</span> <span class="n">min</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">xs'</span> <span class="n">ih</span>  <span class="bp">=&gt;</span>
    <span class="n">cases</span> <span class="n">ys</span>
    <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
    <span class="n">case</span> <span class="n">cons</span> <span class="n">y</span> <span class="n">ys'</span> <span class="bp">=&gt;</span>
      <span class="n">simp_all</span><span class="o">[</span><span class="n">List.length</span><span class="o">,</span> <span class="n">List.zip</span><span class="o">,</span> <span class="n">min_add_add</span><span class="o">]</span>
</code></pre></div>



<a name="301544595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301544595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301544595">(Sep 29 2022 at 22:48)</a>:</h4>
<p>The key here is that I am generalzing over <code>ys</code> which allows me to apply the more general IH in the induction step. If you check it out we have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">),</span> <span class="n">List.length</span> <span class="o">(</span><span class="n">List.zip</span> <span class="n">xs'</span> <span class="n">ys</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">ys</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">List.length</span> <span class="o">(</span><span class="n">List.zip</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">List.length</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span><span class="o">))</span> <span class="o">(</span><span class="n">List.length</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span>
</code></pre></div>
<p>in the generalized vs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ih</span> <span class="o">:</span> <span class="n">List.length</span> <span class="o">(</span><span class="n">List.zip</span> <span class="n">xs'</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">List.length</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span>
<span class="bp">⊢</span> <span class="n">List.length</span> <span class="o">(</span><span class="n">List.zip</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">List.length</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span><span class="o">))</span> <span class="o">(</span><span class="n">List.length</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span>
</code></pre></div>
<p>in the non generalized variant. This will after all simplification get stuck on:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ih</span> <span class="o">:</span> <span class="n">List.length</span> <span class="o">(</span><span class="n">List.zipWith</span> <span class="n">Prod.mk</span> <span class="n">xs'</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys'</span><span class="o">))</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">ys'</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">List.length</span> <span class="o">(</span><span class="n">List.zipWith</span> <span class="n">Prod.mk</span> <span class="n">xs'</span> <span class="n">ys'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">min</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">xs'</span><span class="o">)</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">ys'</span><span class="o">)</span>
</code></pre></div>
<p>because ys' does not match (y :: ys') but if we universally quantify over <code>ys</code> we can just plug it in here and everything works out nicely.</p>



<a name="301547463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301547463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301547463">(Sep 29 2022 at 23:15)</a>:</h4>
<p>Thanks works great, and makes sense, I see you also is <code>simp_all</code> so you didn't need to add <code>ih</code> to the simp list.</p>



<a name="301548204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301548204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301548204">(Sep 29 2022 at 23:22)</a>:</h4>
<p>Nice that this <code>generalizing ys</code> syntax now reads very nicely with the proof explanation:</p>
<blockquote>
<p>The presence of ∀-quantifiers is explained as follows. The <code>induction’</code> tactic<br>
automatically generalized the lemma statement so that the induction hypothesis<br>
is not restricted to same fixed <code>β</code> and <code>ys</code> as the proof goal but can be used for<br>
arbitrary values of <code>β</code> and <code>ys</code>. Such flexibility is rarely needed for types (e.g., <code>β</code>),<br>
but here we need it for <code>ys</code>, because we want to instantiate the quantifier with <code>ys</code>’s<br>
tail (called <code>ys'</code>) and not with <code>ys</code> itself.</p>
</blockquote>



<a name="301576790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301576790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301576790">(Sep 30 2022 at 06:12)</a>:</h4>
<p>Note that I'm not using simp_all just to save simp[ih] but mainly because the ih also needs some simplification with the mentioned definitions and simp_all allows that in 1 instead of 2 steps.</p>
<p>Furthermore I believe that at least mathlib doesn't usually simplify using definitions right away but instead they will build an API such as length_nil: List.length [] = 0 etc and then use these API lemmata to prove things. This allows for change of definition afterwards without breaking all the downstream proofs</p>



<a name="301730317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301730317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301730317">(Sep 30 2022 at 20:36)</a>:</h4>
<p>Thanks for the clarification, but I did notice this <code>simp</code> works too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">length_zip₂</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">xs.zip</span> <span class="n">ys</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">xs.length</span> <span class="n">ys.length</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">xs</span> <span class="n">generalizing</span> <span class="n">ys</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">List.length</span><span class="o">,</span> <span class="n">min</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">xs'</span> <span class="n">ih</span>  <span class="bp">=&gt;</span>
    <span class="n">cases</span> <span class="n">ys</span>
    <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
    <span class="n">case</span> <span class="n">cons</span> <span class="n">y</span> <span class="n">ys'</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">List.length</span><span class="o">,</span> <span class="n">List.zip</span><span class="o">,</span> <span class="n">min_add_add</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
</code></pre></div>



<a name="301731150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301731150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301731150">(Sep 30 2022 at 20:43)</a>:</h4>
<p>Hm, didnt work for me on the first try but maybe I was just being stupid /o\</p>



<a name="301732580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4%20version%20of%20le_add_comm/near/301732580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/lean4.20version.20of.20le_add_comm.html#301732580">(Sep 30 2022 at 20:55)</a>:</h4>
<p>Nice to know about <code>simp_all</code> thought, thanks :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
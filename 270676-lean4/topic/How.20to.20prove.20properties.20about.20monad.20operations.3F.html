---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html">How to prove properties about monad operations?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="318674727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/318674727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#318674727">(Dec 31 2022 at 01:03)</a>:</h4>
<p>Now that I'm more confortable composing monad operations, I would like to proove some properties of such compositions. I'm aware that this is probably jumping ahead of <span class="user-mention" data-user-id="354934">@David Thrane Christiansen</span>'s section 8 so I made an MWE to precisely illustrate the problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Data.HashMap</span>
<span class="kn">import</span> <span class="n">Lean.Data.HashSet</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">BEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Hashable</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Repr</span> <span class="n">α</span><span class="o">]:</span> <span class="n">Repr</span> <span class="o">(</span><span class="n">Lean.HashSet</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">reprPrec</span> <span class="n">h</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">h.toList.repr</span> <span class="n">n</span>

<span class="kd">instance</span> <span class="o">[</span><span class="n">BEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Hashable</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Repr</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)]:</span> <span class="n">Repr</span> <span class="o">(</span><span class="n">Lean.HashMap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">reprPrec</span> <span class="n">h</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">h.toList.repr</span> <span class="n">n</span>

<span class="kn">namespace</span> <span class="n">MWE</span>

<span class="kd">inductive</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">aspect</span>
    <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">«</span><span class="n">specializations</span><span class="bp">»</span><span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span> <span class="n">List.nil</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">concept</span>
    <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">«</span><span class="n">specializations</span><span class="bp">»</span><span class="o">:</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span> <span class="n">List.nil</span><span class="o">)</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">».</span><span class="n">name</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span><span class="o">):</span> <span class="n">String</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">aspect</span> <span class="n">n</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">concept</span> <span class="n">n</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">n</span>

<span class="kd">def</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">».«</span><span class="n">specializations</span><span class="bp">»</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span><span class="o">):</span> <span class="n">List</span> <span class="n">String</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">aspect</span> <span class="n">_</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">concept</span> <span class="n">_</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s</span>

<span class="kd">class</span> <span class="bp">«</span><span class="n">Vocabulary</span><span class="bp">»</span><span class="n">where</span>
  <span class="bp">«</span><span class="n">ownedStatements</span><span class="bp">»</span><span class="o">:</span> <span class="n">List</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="n">v</span> <span class="o">:</span> <span class="bp">«</span><span class="n">Vocabulary</span><span class="bp">»</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">ownedStatements</span> <span class="o">:=</span> <span class="o">[</span>
    <span class="bp">«</span><span class="n">Entity</span><span class="bp">».</span><span class="n">aspect</span> <span class="s2">"base:Container"</span><span class="o">,</span>
    <span class="bp">«</span><span class="n">Entity</span><span class="bp">».</span><span class="n">concept</span> <span class="s2">"mission:Component"</span> <span class="o">[</span> <span class="s2">"base:Container"</span> <span class="o">]</span>
  <span class="o">]</span>
<span class="o">}</span>

<span class="kd">inductive</span> <span class="n">RDeclarationKind</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">rAspect</span>
  <span class="bp">|</span> <span class="n">rConcept</span>
  <span class="n">deriving</span> <span class="n">BEq</span><span class="o">,</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">».</span><span class="n">toKind</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span><span class="o">):</span> <span class="n">RDeclarationKind</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">aspect</span> <span class="n">_</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">rAspect</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">concept</span> <span class="n">_</span> <span class="n">_</span>  <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">rConcept</span>

<span class="kd">inductive</span> <span class="n">Exception</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">error</span> <span class="o">(</span><span class="n">message</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="n">abbrev</span> <span class="n">Names</span> <span class="o">:=</span> <span class="n">Lean.HashSet</span> <span class="n">String</span>
<span class="n">abbrev</span> <span class="n">Name2NamesMap</span> <span class="o">:=</span> <span class="n">Lean.HashMap</span> <span class="n">String</span> <span class="n">Names</span>

<span class="kd">structure</span> <span class="n">State</span> <span class="n">where</span>
  <span class="n">declarations</span> <span class="o">:</span> <span class="n">Lean.HashMap</span> <span class="n">String</span> <span class="n">RDeclarationKind</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">empty</span>
  <span class="n">aspectSpecializations</span> <span class="o">:</span> <span class="n">Name2NamesMap</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">empty</span>
  <span class="n">conceptSpecializations</span> <span class="o">:</span> <span class="n">Name2NamesMap</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">empty</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="kd">structure</span> <span class="n">Context</span> <span class="n">where</span>
  <span class="n">vocabularies</span><span class="o">:</span> <span class="n">List</span> <span class="bp">«</span><span class="n">Vocabulary</span><span class="bp">»</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">nil</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="n">abbrev</span> <span class="n">MCore</span> <span class="o">:=</span> <span class="n">EStateM</span> <span class="n">Exception</span> <span class="n">State</span>
<span class="n">abbrev</span> <span class="n">M</span>     <span class="o">:=</span> <span class="n">ReaderT</span> <span class="n">Context</span> <span class="n">MCore</span>

<span class="kd">def</span> <span class="n">EStateM.Result.getState</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span> <span class="n">EStateM.Result</span> <span class="n">Exception</span> <span class="n">State</span> <span class="n">α</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">EStateM.Result.ok</span> <span class="n">_</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">{}</span>

<span class="kd">def</span> <span class="n">State.appendSpecializations</span>
  <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">dts</span><span class="o">:</span> <span class="n">List</span> <span class="n">RDeclarationKind</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ds</span><span class="o">:</span> <span class="n">List</span> <span class="n">String</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coll</span><span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">Name2NamesMap</span><span class="o">)</span>
  <span class="o">(</span><span class="n">update</span><span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Names</span> <span class="bp">→</span> <span class="n">State</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">get</span>
  <span class="k">match</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">k</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">dts.contains</span> <span class="n">k</span> <span class="k">then</span>
      <span class="k">let</span> <span class="n">rds</span> <span class="o">:</span> <span class="n">Names</span> <span class="o">:=</span> <span class="o">(</span><span class="n">coll</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">findD</span> <span class="n">d</span> <span class="bp">.</span><span class="n">empty</span>
      <span class="k">let</span> <span class="n">merged</span> <span class="o">:</span> <span class="n">Names</span> <span class="o">:=</span> <span class="n">ds.foldl</span> <span class="bp">.</span><span class="n">insert</span> <span class="n">rds</span>
      <span class="k">let</span> <span class="n">s'</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="n">update</span> <span class="n">s</span> <span class="n">d</span> <span class="n">merged</span>
      <span class="n">set</span> <span class="n">s'</span>
      <span class="n">pure</span> <span class="o">()</span>
    <span class="k">else</span>
      <span class="n">throw</span> <span class="o">(</span><span class="n">Exception.error</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Error: appendSpecializations: {repr d} is registered as a {repr k}, not one of {repr dts}."</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span>
    <span class="n">throw</span> <span class="o">(</span><span class="n">Exception.error</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Error: appendSpecializations: there is no registered {repr dts}: {repr d} to append specializations to."</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">State.updateAspectSpecializations</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">ds</span><span class="o">:</span> <span class="n">Names</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">aspectSpecializations</span> <span class="o">:=</span> <span class="n">s.aspectSpecializations.insert</span> <span class="n">d</span> <span class="n">ds</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">State.appendAspectSpecializations</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span><span class="o">:</span> <span class="n">List</span> <span class="n">String</span><span class="o">):</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">appendSpecializations</span> <span class="n">a</span> <span class="o">[</span> <span class="bp">.</span><span class="n">rAspect</span> <span class="o">]</span> <span class="n">as</span> <span class="n">State.aspectSpecializations</span> <span class="n">State.updateAspectSpecializations</span>

<span class="kd">def</span> <span class="n">State.updateConceptSpecializations</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">ds</span><span class="o">:</span> <span class="n">Names</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">conceptSpecializations</span> <span class="o">:=</span> <span class="n">s.conceptSpecializations.insert</span> <span class="n">d</span> <span class="n">ds</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">State.appendConceptSpecializations</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">cs</span><span class="o">:</span> <span class="n">List</span> <span class="n">String</span><span class="o">):</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">appendSpecializations</span> <span class="n">c</span> <span class="o">[</span> <span class="bp">.</span><span class="n">rAspect</span><span class="o">,</span> <span class="bp">.</span><span class="n">rConcept</span> <span class="o">]</span> <span class="n">cs</span> <span class="n">State.conceptSpecializations</span> <span class="n">State.updateConceptSpecializations</span>

<span class="kd">def</span> <span class="n">validateStatementDeclaration</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span><span class="o">):</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">get</span>
  <span class="k">match</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">e.name</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">ek</span> <span class="bp">=&gt;</span>
    <span class="n">throw</span> <span class="o">(</span><span class="n">Exception.error</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Error: declaration conflict: {repr e} is already registered as a {repr ek}."</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.insert</span> <span class="n">e.name</span> <span class="n">e.toKind</span> <span class="o">}</span>
    <span class="n">set</span> <span class="n">s</span>
    <span class="n">pure</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">validateVocabularyStatementDeclarations</span><span class="o">:</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">for</span> <span class="n">v</span> <span class="k">in</span> <span class="o">(</span><span class="bp">←</span> <span class="n">read</span><span class="o">)</span><span class="bp">.</span><span class="n">vocabularies</span> <span class="k">do</span>
    <span class="n">for</span> <span class="n">e</span> <span class="k">in</span> <span class="n">v.ownedStatements</span> <span class="k">do</span>
      <span class="n">validateStatementDeclaration</span> <span class="n">e</span>

<span class="kd">def</span> <span class="n">validateVocabularySpecialization</span> <span class="o">(</span><span class="n">e</span><span class="o">:</span> <span class="bp">«</span><span class="n">Entity</span><span class="bp">»</span><span class="o">):</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">get</span>
  <span class="k">match</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">e.name</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">ek</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">ek</span> <span class="bp">==</span> <span class="n">e.toKind</span> <span class="k">then</span>
      <span class="k">match</span> <span class="n">ek</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="bp">.</span><span class="n">rAspect</span> <span class="bp">=&gt;</span>
        <span class="n">State.appendAspectSpecializations</span> <span class="n">e.name</span> <span class="n">e.specializations</span>
      <span class="bp">|</span> <span class="bp">.</span><span class="n">rConcept</span> <span class="bp">=&gt;</span>
        <span class="n">State.appendConceptSpecializations</span> <span class="n">e.name</span> <span class="n">e.specializations</span>
    <span class="k">else</span>
      <span class="n">throw</span> <span class="o">(</span><span class="n">Exception.error</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Error: declaration inconsistency: {repr e} is registered as a {repr ek}, not a {repr e.toKind}."</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span>
    <span class="n">pure</span> <span class="o">()</span>

<span class="kd">def</span> <span class="n">validateVocabularySpecializations</span><span class="o">:</span> <span class="n">M</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">for</span> <span class="n">v</span> <span class="k">in</span> <span class="o">(</span><span class="bp">←</span> <span class="n">read</span><span class="o">)</span><span class="bp">.</span><span class="n">vocabularies</span> <span class="k">do</span>
    <span class="n">for</span> <span class="n">e</span> <span class="k">in</span> <span class="n">v.ownedStatements</span> <span class="k">do</span>
      <span class="n">validateVocabularySpecialization</span> <span class="n">e</span>

<span class="kd">def</span> <span class="n">c0</span> <span class="o">:</span> <span class="n">Context</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">vocabularies</span> <span class="o">:=</span> <span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kd">def</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="n">EStateM.Result.getState</span> <span class="o">(</span><span class="n">validateVocabularyStatementDeclarations</span> <span class="bp">|&gt;.</span><span class="n">run</span> <span class="n">c0</span> <span class="bp">|&gt;.</span><span class="n">run</span> <span class="n">s0</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">s1</span>
<span class="c1">-- { declarations := [("base:Container", MWE.RDeclarationKind.rAspect),</span>
<span class="c1">--                    ("mission:Component", MWE.RDeclarationKind.rConcept)],</span>
<span class="c1">--   aspectSpecializations := [],</span>
<span class="c1">--   conceptSpecializations := [] }</span>


<span class="kd">def</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="n">EStateM.Result.getState</span> <span class="o">(</span><span class="n">validateVocabularySpecializations</span> <span class="bp">|&gt;.</span><span class="n">run</span> <span class="n">c0</span> <span class="bp">|&gt;.</span><span class="n">run</span> <span class="n">s1</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">s2</span>
<span class="c1">-- { declarations := [("base:Container", MWE.RDeclarationKind.rAspect),</span>
<span class="c1">--                    ("mission:Component", MWE.RDeclarationKind.rConcept)],</span>
<span class="c1">--   aspectSpecializations := [("base:Container", [])],</span>
<span class="c1">--   conceptSpecializations := [("mission:Component", ["base:Container"])] }</span>

<span class="c1">-- All keys of the aspectSpecialization map must have a corresponding declaration as an rAspect</span>
<span class="kd">theorem</span> <span class="n">AllAspectsSpecializationsKeysAreDeclared</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">):</span>
  <span class="bp">∀</span> <span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="o">,</span> <span class="n">s.aspectSpecializations.contains</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">some</span> <span class="bp">.</span><span class="n">rAspect</span>
<span class="o">:=</span> <span class="kd">by</span>
    <span class="gr">sorry</span>

<span class="c1">-- All values of the aspectSpecialization map must have a corresponding declaration as an rAspect</span>
<span class="kd">theorem</span> <span class="n">AllAspectsSpecializationsValuesAreDeclared</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span> <span class="o">:</span> <span class="n">String</span><span class="o">),</span> <span class="o">(</span><span class="n">s.aspectSpecializations.findD</span> <span class="n">a</span> <span class="bp">.</span><span class="n">empty</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sup</span> <span class="bp">→</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sup</span> <span class="bp">==</span> <span class="n">some</span> <span class="bp">.</span><span class="n">rAspect</span>
<span class="o">:=</span> <span class="kd">by</span>
    <span class="gr">sorry</span>

<span class="c1">-- All keys of the conceptSpecializations map must have a corresponding declaration as an rConcept</span>
<span class="kd">theorem</span> <span class="n">AllConceptSpecializationsKeysAreDeclared</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">):</span>
  <span class="bp">∀</span> <span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="o">,</span> <span class="n">s.conceptSpecializations.contains</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">some</span> <span class="bp">.</span><span class="n">rConcept</span>
<span class="o">:=</span> <span class="kd">by</span>
    <span class="gr">sorry</span>

<span class="c1">-- All values of the conceptSpecializations map must have a corresponding declaration as an rAspect or rConcept</span>
<span class="kd">theorem</span> <span class="n">AllConceptSpecializationsValuesAreDeclared</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span> <span class="o">:</span> <span class="n">String</span><span class="o">),</span> <span class="o">(</span><span class="n">s.conceptSpecializations.findD</span> <span class="n">a</span> <span class="bp">.</span><span class="n">empty</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sup</span> <span class="bp">→</span>
    <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sup</span> <span class="bp">==</span> <span class="n">some</span> <span class="bp">.</span><span class="n">rAspect</span> <span class="bp">||</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sup</span> <span class="bp">==</span> <span class="n">some</span> <span class="bp">.</span><span class="n">rConcept</span>
<span class="o">:=</span> <span class="kd">by</span>
    <span class="gr">sorry</span>
<span class="kd">end</span> <span class="n">MWE</span>
</code></pre></div>
<p>In the above, <code>s2</code> is a simple example of the <code>State</code> for which I would like to proove 4 theorems. However, I am not sure how to exploit properties of the monad operations and of their composition to do this.</p>
<p>For example, consider the first theorem, which I hope will be easy to proove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- All keys of the aspectSpecialization map must have a corresponding declaration as an rAspect</span>
<span class="kd">theorem</span> <span class="n">AllAspectsSpecializationsKeysAreDeclared</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">):</span>
  <span class="bp">∀</span> <span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="o">,</span> <span class="n">s.aspectSpecializations.contains</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">some</span> <span class="bp">.</span><span class="n">rAspect</span>
<span class="o">:=</span> <span class="kd">by</span>
    <span class="gr">sorry</span>
</code></pre></div>
<p>Intuitively, it should follow from the composition of these two monad operations: <code>validateVocabularyStatementDeclarations</code> and <code>validateVocabularySpecializations</code>:</p>
<ul>
<li>both operations iterate over the same <code>Context</code> of <code>vocabularies</code> and their <code>ownedStatements</code>.</li>
<li>the validation of statement declarations adds an entry in the <code>State.declarations</code></li>
<li>the validation of statement specializations adds entries in the <code>State.aspectSpecializations</code> for the same keys as the previous step.</li>
</ul>
<p>I hope that I've explained sufficiently clearly the problem and I'm open to suggestions.</p>



<a name="318918496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/318918496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#318918496">(Jan 02 2023 at 00:22)</a>:</h4>
<p>The essence of the long MWE above can be reduced to this smaller MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean.Data.HashMap</span>
<span class="kn">import</span> <span class="n">Lean.Data.HashSet</span>
<span class="kn">namespace</span> <span class="n">MWE4</span>

<span class="kd">structure</span> <span class="n">State</span> <span class="n">where</span>
  <span class="n">declarations</span><span class="o">:</span> <span class="n">Lean.HashMap</span> <span class="n">String</span> <span class="o">(</span><span class="n">Lean.HashSet</span> <span class="n">String</span><span class="o">)</span>

<span class="c1">-- all declaration values must be declaration keys</span>
<span class="kd">def</span> <span class="n">State.wff</span><span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.toList.all</span> <span class="k">fun</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">xs.toList.all</span> <span class="n">s.declarations.contains</span>

<span class="kd">def</span> <span class="n">State.withDeclaration</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">s.declarations.contains</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.insert</span> <span class="n">d</span> <span class="bp">.</span><span class="n">empty</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">State.withSpecialization</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">s.withDeclaration</span> <span class="n">sup</span>
  <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.insert</span> <span class="n">sub</span> <span class="o">((</span><span class="n">s.declarations.findD</span> <span class="n">sub</span> <span class="bp">.</span><span class="n">empty</span><span class="o">)</span><span class="bp">.</span><span class="n">insert</span> <span class="n">sup</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">State.withDeclarationWff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">State.withSpecializationWff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">):</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">MWE4</span>
</code></pre></div>
<p>Looking at examples in Lean and the Std4 library, I realized that I should try to use inductive data types instead, so I reformulated the MWE using Std4, preserving the intent of the example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>

<span class="kn">namespace</span> <span class="n">MWE5</span>

<span class="n">abbrev</span> <span class="n">Sups</span> <span class="o">:=</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Unit</span>

<span class="kd">structure</span> <span class="n">State</span> <span class="n">where</span>
  <span class="n">declarations</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Sups</span>

<span class="c1">-- all declaration values must be declaration keys</span>
<span class="kd">def</span> <span class="n">State.wff</span><span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.all</span>
    <span class="k">fun</span> <span class="o">(</span><span class="n">_</span> <span class="n">sups</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">sups.all</span>
      <span class="k">fun</span> <span class="o">(</span><span class="n">sup</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.contains</span> <span class="n">sup</span>

<span class="kd">def</span> <span class="n">State.withDeclaration</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">s.declarations.contains</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.replace</span> <span class="n">d</span> <span class="bp">.</span><span class="n">nil</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">State.withSpecialization</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">s.withDeclaration</span> <span class="n">sup</span>
  <span class="k">let</span> <span class="n">sups</span> <span class="o">:</span> <span class="n">Sups</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sub</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">nil</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.replace</span> <span class="n">sup</span> <span class="o">()</span>
  <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.replace</span> <span class="n">sub</span> <span class="n">sups</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">State.withDeclarationWff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">State.withSpecializationWff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">):</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">MWE5</span>
</code></pre></div>
<p>I have several questions about this:</p>
<p>1) I noticed that there are different ways to define well-formedness predicates as <code>Bool</code> vs. <code>Prop</code>.</p>
<p><a href="https://github.com/leanprover/lean4/blob/master/tests/playground/pge.lean">https://github.com/leanprover/lean4/blob/master/tests/playground/pge.lean</a><br>
<a href="https://github.com/leanprover/lean4/blob/master/doc/examples/bintree.lean">https://github.com/leanprover/lean4/blob/master/doc/examples/bintree.lean</a><br>
<a href="https://github.com/leanprover/std4/blob/main/Std/Data/AssocList.lean">https://github.com/leanprover/std4/blob/main/Std/Data/AssocList.lean</a></p>
<p>It seems that one can use either form to define subtypes. <br>
Is this difference a matter of proof writing style, or is there something more subtle going on?</p>
<p>2) Even though <code>State</code> is defined above in terms of inductive datatypes, it is not inductively defined.</p>
<p>It seems that this approach complicates writing proofs since we cannot use the <code>cases</code> tactic.<br>
So, I suspect I must reformulate my MWE using an inductive datatype definition.</p>



<a name="318921006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/318921006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#318921006">(Jan 02 2023 at 00:59)</a>:</h4>
<blockquote>
<p>It seems that one can use either form to define subtypes.</p>
</blockquote>
<p><code>Bool</code> can be coerced to <code>Prop</code> (with <code>true</code> =&gt; <code>True</code> and <code>false</code> =&gt; <code>False</code>), so anywhere that expects a <code>Prop</code> you can also pass a <code>Bool</code> (including, e.g. the predicate for subtypes)</p>



<a name="319111579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319111579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319111579">(Jan 03 2023 at 00:38)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="407274">@James Gallicchio</span>; I see that there's indeed a conversion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">boolToProp</span> <span class="o">:</span> <span class="n">Coe</span> <span class="n">Bool</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">coe</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">Eq</span> <span class="n">b</span> <span class="n">true</span>
</code></pre></div>
<p>I managed to proove a simple theorem about the data structure above; however, I'm getting stuck for others:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>

<span class="kn">namespace</span> <span class="n">MWE5</span>

<span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>
<span class="n">abbrev</span> <span class="n">Sups</span> <span class="o">:=</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Repr</span> <span class="n">Sups</span> <span class="n">where</span> <span class="n">reprPrec</span> <span class="n">s</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">s.toList.repr</span> <span class="n">n</span>

<span class="kd">structure</span> <span class="n">State</span> <span class="n">where</span>
  <span class="n">declarations</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">nil</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="n">State.empty</span><span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="c1">-- all declaration values must be declaration keys</span>
<span class="kd">def</span> <span class="n">State.wff</span><span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.all</span>
    <span class="k">fun</span> <span class="o">(</span><span class="n">_</span> <span class="n">sups</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">sups.all</span>
      <span class="k">fun</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.contains</span> <span class="n">sup</span>

<span class="kd">def</span> <span class="n">State.withDeclaration</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">s.declarations.contains</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.cons</span> <span class="n">d</span> <span class="bp">.</span><span class="n">nil</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">State.withSpecialization</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">s.withDeclaration</span> <span class="n">sub</span> <span class="bp">|&gt;.</span><span class="n">withDeclaration</span> <span class="n">sup</span>
  <span class="k">let</span> <span class="n">sups</span> <span class="o">:</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sub</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">xs.contains</span> <span class="n">sup</span> <span class="k">then</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">xs.cons</span> <span class="n">sup</span>
  <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.replace</span> <span class="n">sub</span> <span class="n">sups</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.noChange</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s.withDeclaration</span> <span class="n">d</span>
<span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.added</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.contains</span> <span class="n">d</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">]</span>
  <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">,</span> <span class="n">List.all</span><span class="o">,</span> <span class="n">List.any</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">State.withSpecialization.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withSpecialization</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">,</span> <span class="n">List.all</span><span class="o">,</span> <span class="n">List.any</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="n">State.empty</span> <span class="bp">|&gt;.</span><span class="n">withSpecialization</span> <span class="s2">"a"</span> <span class="s2">"b"</span>
<span class="k">#eval</span> <span class="n">s0</span>

<span class="kd">end</span> <span class="n">MWE5</span>
</code></pre></div>
<p>For the 2nd one, I am wondering how to simplify a nested expression in the goal; i.e.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withDeclaration.added</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.contains</span> <span class="n">d</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">]</span>
  <span class="gr">sorry</span>
</code></pre></div>
<p>The tactic state before <code>sorry</code> shows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">s</span><span class="o">:</span> <span class="n">State</span>
<span class="n">d</span><span class="o">:</span> <span class="n">String</span>
<span class="n">h</span><span class="o">:</span> <span class="o">(</span><span class="bp">!</span><span class="n">Std.AssocList.contains</span> <span class="n">d</span> <span class="n">s.declarations</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span>
<span class="bp">⊢</span> <span class="n">Std.AssocList.contains</span> <span class="n">d</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">Std.AssocList.contains</span> <span class="n">d</span> <span class="n">s.declarations</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">true</span> <span class="bp">=&gt;</span> <span class="n">s</span>
      <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="o">{</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">Std.AssocList.cons</span> <span class="n">d</span> <span class="o">[]</span> <span class="n">s.declarations</span> <span class="o">})</span><span class="bp">.</span><span class="n">declarations</span> <span class="bp">=</span>
  <span class="n">true</span>
</code></pre></div>
<p>Is there a trick to apply <code>!h</code> inside the goal and simplify the <code>match</code> expression?</p>
<p>For the last 2 theorems, I am wondering if I am on the right path.</p>
<p>Any suggestions?</p>



<a name="319118780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319118780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319118780">(Jan 03 2023 at 02:28)</a>:</h4>
<p>I managed to make some progress, proving 3 theorems out of 7; any suggestions for the last 4?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>

<span class="kn">namespace</span> <span class="n">MWE5</span>

<span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>
<span class="n">abbrev</span> <span class="n">Sups</span> <span class="o">:=</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">Repr</span> <span class="n">Sups</span> <span class="n">where</span> <span class="n">reprPrec</span> <span class="n">s</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">s.toList.repr</span> <span class="n">n</span>

<span class="kd">structure</span> <span class="n">State</span> <span class="n">where</span>
  <span class="n">declarations</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">nil</span>
  <span class="n">deriving</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="n">State.empty</span><span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="c1">-- all declaration values must be declaration keys</span>
<span class="kd">def</span> <span class="n">State.wff</span><span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">Bool</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.all</span>
    <span class="k">fun</span> <span class="o">(</span><span class="n">_</span> <span class="n">sups</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">sups.all</span>
      <span class="k">fun</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">s.declarations.contains</span> <span class="n">sup</span>

<span class="kd">def</span> <span class="n">State.withDeclaration</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">s.declarations.contains</span> <span class="n">d</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.cons</span> <span class="n">d</span> <span class="bp">.</span><span class="n">nil</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">State.withSpecialization</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">):</span> <span class="n">State</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">s.withDeclaration</span> <span class="n">sub</span> <span class="bp">|&gt;.</span><span class="n">withDeclaration</span> <span class="n">sup</span>
  <span class="k">let</span> <span class="n">sups</span> <span class="o">:</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sub</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span>
    <span class="c1">-- this case can never happen since sub has been declared.</span>
    <span class="o">[</span><span class="n">sup</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">xs</span> <span class="bp">=&gt;</span>
    <span class="k">if</span> <span class="n">xs.contains</span> <span class="n">sup</span> <span class="k">then</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">xs.cons</span> <span class="n">sup</span>
  <span class="o">{</span> <span class="n">s</span> <span class="k">with</span> <span class="n">declarations</span> <span class="o">:=</span> <span class="n">s.declarations.replace</span> <span class="n">sub</span> <span class="n">sups</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.noChange</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s.withDeclaration</span> <span class="n">d</span>
<span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.added1</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.contains</span> <span class="n">d</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">,</span> <span class="n">List.any</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.added2</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.find</span><span class="bp">?</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">[]</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">,</span> <span class="n">List.any</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">split</span>
  <span class="bp">.</span><span class="n">apply</span> <span class="n">h</span>
  <span class="bp">.</span><span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span><span class="bp">;</span> <span class="n">done</span>


<span class="kd">theorem</span> <span class="n">State.withSpecialization.noChange</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">sub</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">(</span><span class="n">h3</span><span class="o">:</span> <span class="o">(</span><span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sub</span><span class="o">)</span><span class="bp">.</span><span class="n">all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">sups</span> <span class="bp">=&gt;</span> <span class="n">sups.contains</span> <span class="n">sup</span><span class="o">))</span>
<span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">--unfold State.withSpecialization State.withDeclaration at *</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.withSpecialization</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">done</span>

<span class="kd">theorem</span> <span class="n">State.withSpecialization.added</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">sub</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.contains</span> <span class="n">sub</span> <span class="bp">&amp;&amp;</span>
  <span class="o">(</span><span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.contains</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withSpecialization</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">,</span> <span class="n">Std.AssocList.contains</span><span class="o">,</span> <span class="n">List.any</span><span class="o">,</span> <span class="n">List.replaceF</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">apply</span> <span class="n">And.intro</span>
  <span class="n">done</span>

<span class="kd">theorem</span> <span class="n">State.withSpecialization.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withSpecialization</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">done</span>

<span class="kd">def</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">State</span> <span class="o">:=</span> <span class="n">State.empty</span> <span class="bp">|&gt;.</span><span class="n">withSpecialization</span> <span class="s2">"a"</span> <span class="s2">"b"</span>
<span class="k">#eval</span> <span class="n">s0</span>

<span class="kd">end</span> <span class="n">MWE5</span>
</code></pre></div>



<a name="319127176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319127176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319127176">(Jan 03 2023 at 04:45)</a>:</h4>
<p>Ah, sure -- check out the <code>split</code> tactic!</p>
<p>To finish <code>State.withDeclaration.added1</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">split</span>
<span class="bp">.</span> <span class="n">assumption</span>
<span class="bp">.</span> <span class="n">simp</span>
</code></pre></div>
<p>Something similar should work for the others!</p>



<a name="319129137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319129137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319129137">(Jan 03 2023 at 05:17)</a>:</h4>
<p>Oh, wait, I misunderstood your question...</p>
<p>Rewriting within a match is generally a hard to do. I'm not sure if there's a way to rewrite through it. The only way I know to do what you want is to <code>split</code> and then do the simp/rewrite in each case. Usually this isn't too bad, since you can use the <code>&lt;;&gt;</code> combinator like <code>split &lt;;&gt; simp</code> or similar</p>



<a name="319129446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319129446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319129446">(Jan 03 2023 at 05:22)</a>:</h4>
<p>Honestly, a good strategy with any goals involving <code>match</code> is to just split on it. Sometimes I find it much easier to clean up unnecessary splits after the fact, instead of thinking too deeply about whether I need to split or not...</p>



<a name="319130037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319130037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319130037">(Jan 03 2023 at 05:30)</a>:</h4>
<p>Thanks, I managed to simplify a few proofs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withDeclaration.added1</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.contains</span> <span class="n">d</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp_all</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.added2</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="bp">!</span><span class="n">s.declarations.contains</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">declarations.find</span><span class="bp">?</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">[]</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp_all</span>
</code></pre></div>
<p>For the next one, I am not sure how to split the nested Or:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withDeclaration.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp_all</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">split</span>
  <span class="bp">.</span> <span class="n">apply</span> <span class="n">h</span>
  <span class="bp">.</span> <span class="n">simp_all</span>
    <span class="gr">sorry</span>
</code></pre></div>
<p>Before <code>sorry</code>, the tactic state shows:</p>
<div class="codehilite" data-code-language="case"><pre><span></span><code>s: State
d: String
x✝: Bool
h: (List.all (Std.AssocList.toList s.declarations) fun x =&gt;
    List.all x.snd fun sup =&gt; List.any (Std.AssocList.toList s.declarations) fun x =&gt; x.fst == sup) =
  true
heq✝: (List.any (Std.AssocList.toList s.declarations) fun x =&gt; x.fst == d) = false
⊢ (List.all (Std.AssocList.toList s.declarations) fun x =&gt;
    List.all x.snd fun sup =&gt; d == sup || List.any (Std.AssocList.toList s.declarations) fun x =&gt; x.fst == sup) =
  true
</code></pre></div>
<p>What are the grayed symbols: <code>x✝</code> and <code>heq✝</code>?</p>
<p>In the above, the assumption <code>h</code> is very close to the goal.<br>
The goal has an Or with the left <code>d == sup</code> that seems ought to match with <code>heq✝</code>if I could somehow bind it to an assumption (I tried but it is not available); the right could match the assumption <code>h</code>.</p>
<p>Since the Or is nested, <code>split</code> is not readily applicable.</p>
<p>How can I tackle this situation?</p>
<p>For the next one, the problem is similar that I cannot readily apply an assumption to a nested expression:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withSpecialization.noChange</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">sub</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">(</span><span class="n">h3</span><span class="o">:</span> <span class="o">(</span><span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sub</span><span class="o">)</span><span class="bp">.</span><span class="n">all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">sups</span> <span class="bp">=&gt;</span> <span class="n">sups.contains</span> <span class="n">sup</span><span class="o">))</span>
<span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">--unfold State.withSpecialization State.withDeclaration at *</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.withSpecialization</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp_all</span>
  <span class="n">apply</span> <span class="n">h3</span>
  <span class="gr">sorry</span>
</code></pre></div>
<p>The application of <code>h3</code> fails because:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="bp">'</span><span class="n">apply'</span> <span class="n">failed</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="n">Option.all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">sups</span> <span class="bp">=&gt;</span> <span class="n">List.contains</span> <span class="n">sups</span> <span class="n">sup</span><span class="o">)</span>
      <span class="o">(</span><span class="n">Option.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.snd</span><span class="o">)</span> <span class="o">(</span><span class="n">List.find</span><span class="bp">?</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.fst</span> <span class="bp">==</span> <span class="n">sub</span><span class="o">)</span> <span class="o">(</span><span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span><span class="o">)))</span> <span class="bp">=</span>
    <span class="n">true</span>
<span class="k">with</span>
  <span class="n">s</span> <span class="bp">=</span>
    <span class="o">{</span>
      <span class="n">declarations</span> <span class="o">:=</span>
        <span class="n">Std.AssocList.replace</span> <span class="n">sub</span>
          <span class="o">(</span><span class="k">match</span>
            <span class="n">Option.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.snd</span><span class="o">)</span> <span class="o">(</span><span class="n">List.find</span><span class="bp">?</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.fst</span> <span class="bp">==</span> <span class="n">sub</span><span class="o">)</span> <span class="o">(</span><span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span><span class="o">))</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">some</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">List.contains</span> <span class="n">xs</span> <span class="n">sup</span> <span class="bp">=</span> <span class="n">true</span> <span class="k">then</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">sup</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
          <span class="n">s.declarations</span> <span class="o">}</span>
<span class="n">s</span><span class="o">:</span> <span class="n">State</span>
<span class="n">subsup</span><span class="o">:</span> <span class="n">String</span>
<span class="n">h1</span><span class="o">:</span> <span class="o">(</span><span class="n">List.any</span> <span class="o">(</span><span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span><span class="o">)</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.fst</span> <span class="bp">==</span> <span class="n">sub</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span>
<span class="n">h2</span><span class="o">:</span> <span class="o">(</span><span class="n">List.any</span> <span class="o">(</span><span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span><span class="o">)</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.fst</span> <span class="bp">==</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span>
<span class="n">h3</span><span class="o">:</span> <span class="n">Option.all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">sups</span> <span class="bp">=&gt;</span> <span class="n">List.contains</span> <span class="n">sups</span> <span class="n">sup</span><span class="o">)</span>
    <span class="o">(</span><span class="n">Option.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.snd</span><span class="o">)</span> <span class="o">(</span><span class="n">List.find</span><span class="bp">?</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.fst</span> <span class="bp">==</span> <span class="n">sub</span><span class="o">)</span> <span class="o">(</span><span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span><span class="o">)))</span> <span class="bp">=</span>
  <span class="n">true</span>
<span class="bp">⊢</span> <span class="n">s</span> <span class="bp">=</span>
  <span class="o">{</span>
    <span class="n">declarations</span> <span class="o">:=</span>
      <span class="n">Std.AssocList.replace</span> <span class="n">sub</span>
        <span class="o">(</span><span class="k">match</span>
          <span class="n">Option.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.snd</span><span class="o">)</span> <span class="o">(</span><span class="n">List.find</span><span class="bp">?</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.fst</span> <span class="bp">==</span> <span class="n">sub</span><span class="o">)</span> <span class="o">(</span><span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span><span class="o">))</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span>
        <span class="bp">|</span> <span class="n">some</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">List.contains</span> <span class="n">xs</span> <span class="n">sup</span> <span class="bp">=</span> <span class="n">true</span> <span class="k">then</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">sup</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span>
        <span class="n">s.declarations</span> <span class="o">}</span>
</code></pre></div>
<p>The last two proofs involve much more complicated expressions; I have not figured out how to tackle them.</p>



<a name="319132145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319132145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319132145">(Jan 03 2023 at 06:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="362579">Nicolas Rouquette</span> <a href="#narrow/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F/near/319130037">said</a>:</p>
<blockquote>
<p>What are the grayed symbols: <code>x✝</code> and <code>heq✝</code>?</p>
</blockquote>
<p>Those are auto-generated, inaccessible names. There's a bunch of different ways to introduce accessible names, but the easiest here is probably to use <code>next</code> instead of <code>.</code> for the second case, like <code>next x heq =&gt;</code>.</p>
<p>Almost all (all?) autogenerated names are inaccessible, I believe that's to ensure autogenerated names don't have to be stable.</p>
<blockquote>
<p>Since the Or is nested, <code>split</code> is not readily applicable.</p>
</blockquote>
<p>Yeah, you have to do quite a lot of unpacking before you can use split. My first attempt at doing so reached an unprovable goal, but maybe it's still helpful to look at:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withDeclaration.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">s.wff</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp_all</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">split</span>
  <span class="bp">.</span> <span class="n">apply</span> <span class="n">h</span>
  <span class="n">next</span> <span class="n">x</span> <span class="n">heq</span> <span class="bp">=&gt;</span>
    <span class="n">simp_all</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">h</span><span class="o">]</span>
    <span class="n">clear</span> <span class="n">h</span>
    <span class="n">congr</span>
    <span class="n">funext</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>
    <span class="n">congr</span>
    <span class="n">funext</span> <span class="n">sup</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">==</span> <span class="n">sup</span>
    <span class="n">case</span> <span class="n">true</span> <span class="bp">=&gt;</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">sup</span> <span class="o">:=</span> <span class="n">eq_of_beq</span> <span class="n">h</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">this</span><span class="o">,</span> <span class="n">heq</span><span class="o">]</span>
      <span class="n">simp</span>
      <span class="gr">sorry</span>
    <span class="n">case</span> <span class="n">false</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span>
    <span class="n">done</span>
</code></pre></div>
<p>How can I tackle this situation?</p>
<p>For the next one, the problem is similar that I cannot readily apply an assumption to a nested expression:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withSpecialization.noChange</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">sub</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span><span class="o">:</span> <span class="n">s.declarations.contains</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">(</span><span class="n">h3</span><span class="o">:</span> <span class="o">(</span><span class="n">s.declarations.find</span><span class="bp">?</span> <span class="n">sub</span><span class="o">)</span><span class="bp">.</span><span class="n">all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">sups</span> <span class="bp">=&gt;</span> <span class="n">sups.contains</span> <span class="n">sup</span><span class="o">))</span>
<span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s.withSpecialization</span> <span class="n">sub</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="c1">--unfold State.withSpecialization State.withDeclaration at *</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.withSpecialization</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">simp_all</span>
  <span class="n">apply</span> <span class="n">h3</span>
  <span class="gr">sorry</span>
</code></pre></div>



<a name="319132519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319132519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319132519">(Jan 03 2023 at 06:07)</a>:</h4>
<p>As you can probably tell, Lean currently has very little automation for proofs about even relatively small programs... I don't know if I have good advice aside from keeping your lemmas very small and focused, since that's the only way I know to parse large expressions in Lean</p>



<a name="319135674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319135674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319135674">(Jan 03 2023 at 06:45)</a>:</h4>
<p>here's my attempt at that theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.List.Lemmas</span>
<span class="bp">...</span>

<span class="kd">theorem</span> <span class="n">State.withDeclaration.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s.wff</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span>
  <span class="n">intro</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">ss</span><span class="o">)</span>
  <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">h</span>
  <span class="bp">·</span> <span class="n">rintro</span> <span class="o">(⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="bp">|</span> <span class="n">h'</span><span class="o">)</span><span class="bp">;</span> <span class="o">{</span><span class="n">intro.</span><span class="o">}</span>
    <span class="n">exact</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">hs</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span> <span class="n">h'</span> <span class="n">_</span> <span class="n">hs</span><span class="o">)</span>
</code></pre></div>



<a name="319135846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319135846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319135846">(Jan 03 2023 at 06:48)</a>:</h4>
<p>I should really learn the rintro black magic at some point....</p>



<a name="319135911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319135911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319135911">(Jan 03 2023 at 06:48)</a>:</h4>
<p>the thing that pulls the most weight in this proof is the <code>simp</code> on the first line, plus the <code>Std.Data.List.Lemmas</code> to make it actually do something</p>



<a name="319136023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319136023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319136023">(Jan 03 2023 at 06:50)</a>:</h4>
<p>The original proof had a <code>simp [List.all]</code>, that's the wrong move. You want to turn all those boolean functions into logical functions (in this case a <code>\forall</code>) ASAP since then all the other stuff like <code>intro</code> and <code>fun</code> do useful things</p>



<a name="319136198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319136198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319136198">(Jan 03 2023 at 06:53)</a>:</h4>
<p>This does seem a bit situational, since we kinda luck out that <code>List.all</code> and <code>List.any</code> are succinct to describe in proposition land</p>



<a name="319136278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319136278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319136278">(Jan 03 2023 at 06:54)</a>:</h4>
<p>A common situation, nonetheless <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="319136841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319136841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319136841">(Jan 03 2023 at 07:00)</a>:</h4>
<p>not really. If you look at <code>AssocList</code> you will notice that <em>every single function</em> has a theorem which relates it to proposition land written immediately afterward</p>



<a name="319137027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319137027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319137027">(Jan 03 2023 at 07:03)</a>:</h4>
<p>this is very much by design</p>



<a name="319233811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/319233811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#319233811">(Jan 03 2023 at 16:38)</a>:</h4>
<p>Thanks for all of your suggestions; I have plenty to think about.</p>



<a name="320007767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320007767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320007767">(Jan 07 2023 at 21:26)</a>:</h4>
<p>I want to make sure that I understand correctly <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> 's ingenious proof that I've reformatted like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">State.withDeclaration.wff</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">State</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">s.wff</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">s.withDeclaration</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">wff</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">State.wff</span><span class="o">,</span> <span class="n">State.withDeclaration</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span>
  <span class="n">intro</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">ss</span><span class="o">)</span>
  <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
  <span class="bp">.</span> <span class="n">apply</span> <span class="n">h</span>
  <span class="bp">·</span> <span class="n">rintro</span> <span class="o">(⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="bp">|</span> <span class="n">h'</span><span class="o">)</span>
    <span class="bp">.</span> <span class="n">intro.</span>
    <span class="bp">.</span> <span class="n">exact</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">hs</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span> <span class="n">h'</span> <span class="n">x</span> <span class="n">hs</span><span class="o">)</span>
</code></pre></div>
<p>Just before <code>rintro</code>, the goal is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">s1</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">ss</span> <span class="bp">=</span> <span class="o">[]</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">ss</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">String</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">ss</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">x</span>
</code></pre></div>
<p>Based on VS code feedback, I see that <code>rintro (⟨rfl, rfl⟩ | h')</code> matches the left hand side of the implication: <code>s1 = d ∧ ss = [] ∨ (s1, ss) ∈ Std.AssocList.toList s.declarations</code>.</p>
<p>Why is it matching just the LHS of the goal instead of the whole goal expression?</p>
<p>On the last line, the goal is the RHS of the above, I am really amazed by the flexibility of the equivalence between universal quantifiers and functions; it seems to me far more powerful than what is explained in section 4 here: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html">https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html</a></p>
<p>If I understand correctly, the goal at the <code>exact</code> line above is a universal quantifier expression:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">String</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">ss</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">x</span>
</code></pre></div>
<p>So it is equivalent to a function like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span><span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">ss</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">x</span>
</code></pre></div>
<p>That equivalence allows matching the <code>exact</code> pattern function: <code>exact fun x hs =&gt;</code> </p>
<p>Then on the right, the <code>.inr</code> construction involves the reverse.</p>
<p>With:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">×</span> <span class="n">Strings</span><span class="o">),</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span> <span class="bp">→</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">String</span><span class="o">),</span> <span class="n">x_1</span> <span class="bp">∈</span> <span class="n">x.snd</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">x_1</span>
<span class="n">h'</span><span class="o">:</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">ss</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">s.declarations</span>
<span class="n">x</span><span class="o">:</span> <span class="n">String</span>
<span class="n">hs</span><span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">ss</span>
</code></pre></div>
<p>The expression: <code>(h _ h' x hs)</code> effectively uses <code>h</code> as a function of 4 arguments:</p>
<ul>
<li><code>(x : String × Strings)</code> given by the placeholder <code>_</code></li>
<li><code>x ∈ Std.AssocList.toList s.declarations</code> given by the hypothesis <code>h'</code></li>
<li><code>(x_1 : String)</code> given by <code>x</code></li>
<li><code>x_1 ∈ x.snd</code> given by the hypothesis <code>hs</code></li>
</ul>
<p>Did I get this right?</p>



<a name="320070490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320070490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320070490">(Jan 08 2023 at 12:35)</a>:</h4>
<p>Are you asking about what the <code>rintro</code> tactic does? <code>rintro</code> is just <code>intro</code> then <code>cases</code>, and <code>rintro rfl</code> is just <code>intro h</code> and then <code>subst h</code>.</p>



<a name="320098324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320098324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320098324">(Jan 08 2023 at 17:00)</a>:</h4>
<p>I read this in the doc; however p, it’s application in this particular proof is unclear to me because it seems to be matching the LHS of the goal instead of the whole goal.</p>
<p>Then it took me a while to understand how the last line works; which is close to magical.</p>



<a name="320099449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320099449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320099449">(Jan 08 2023 at 17:12)</a>:</h4>
<p>The goal looks like <code>A -&gt; B</code> (here both A and B are complicated). <code>intro</code> doesn't "match on the LHS", rather it introduces <code>a : A</code> into the context and turns the goal into <code>B</code></p>
<p>In particular, <code>A</code> here looks like <code>x /\ y \/ z</code>. Normally, you could do <code>intro h</code>, which would give you <code>h : x /\ y \/ z</code> in the context. Then you can destruct the ands and ors with <code>split</code>, etc. <code>rintro</code> just makes things easier by allowing you to destruct while introducing. So you could also write <code>rintro ((hx, hy) | hz)</code>, where the <code>|</code> eliminates on <code>or</code>, and the <code>&lt;hx, hy&gt;</code> destructs the and. However, notice <code>x</code> and <code>y</code> are also equalities, and most likely your next step would have been <code>subst hx; subst hy</code> -- so <code>rintro</code> also allows the sugar <code>rfl</code> to automatically do that for you.</p>



<a name="320118159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320118159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320118159">(Jan 08 2023 at 20:52)</a>:</h4>
<p>Ah, thanks <span class="user-mention" data-user-id="355764">@Hanting Zhang</span> for the explanation.</p>



<a name="320126994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320126994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320126994">(Jan 08 2023 at 23:01)</a>:</h4>
<p>Also worth clarifying, small but important distinction:</p>
<ul>
<li><code>∀ (x : String), x ∈ ss → ...</code> is a type (specifically a dependent function type)</li>
<li><code>(x : String) → x ∈ ss → ...</code> is equivalent to that type, written in a syntax that emphasizes the function aspect</li>
</ul>
<p>These are distinct from</p>
<ul>
<li><code>fun (x : String) =&gt; fun (hs : x ∈ ss) =&gt; ...</code>, a value of the above types</li>
<li><code>fun (x : String) (hs : x ∈ ss) =&gt; ...</code> is equivalent to the above value, just with more syntax sugar</li>
</ul>
<p>So the function value inhabits the (dependent) function type, and the forall quantifier is secretly just a dependent function type. <code>exact blah</code> is a tactic that lets you provide a term whose type is <code>exact</code>ly the goal. So here we are providing a value of type <code>∀ (x : String), ...</code>, but terms of that type look like <code>fun (x : String) =&gt; ...</code></p>



<a name="320128324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320128324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320128324">(Jan 08 2023 at 23:22)</a>:</h4>
<p>Oh, thanks <span class="user-mention" data-user-id="407274">@James Gallicchio</span>, this is indeed a subtle aspect of the propositions-as-types correspondence that I misunderstood.</p>
<p>To be fair, what you wrote above is clearer to me than the cryptic doc here:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html">https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html</a></p>
<blockquote>
<p>The Calculus of Constructions therefore identifies dependent arrow types with forall-expressions in this way. If p is any expression, ∀ x : α, p is nothing more than alternative notation for (x : α) → p, with the idea that the former is more natural than the latter in cases where p is a proposition.</p>
</blockquote>
<p>I've read the above several times and I had not quite grasped the subtle distinction you're making, particularly the last paragraph.</p>



<a name="320128566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320128566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320128566">(Jan 08 2023 at 23:26)</a>:</h4>
<p>Ah, yeah, that page seems hard to parse. I'll look into cleaning it up...</p>



<a name="320149972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320149972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320149972">(Jan 09 2023 at 05:05)</a>:</h4>
<p>Following earlier advice to simplify the functions even more, I reduced my struggle to the following MWE.</p>
<p>Below, there is a single function, <code>addSup</code>, for which I want to show that the result contains the element being added.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">String</span><span class="o">),</span> <span class="o">(</span><span class="n">addSup</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I tried to proove this by induction on <code>l</code>; however, I ended up getting stuck at showing that a proof terminates.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>
<span class="kn">import</span> <span class="n">Std.Data.List.Lemmas</span>

<span class="kn">namespace</span> <span class="n">MWE5a</span>

<span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>

<span class="kd">def</span> <span class="n">addSup</span> <span class="o">:</span> <span class="n">Strings</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Strings</span>
<span class="bp">|</span> <span class="o">[],</span> <span class="n">sup</span>       <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">sup</span>  <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">sup</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">addSup</span> <span class="n">xs</span> <span class="n">sup</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">addSup.nil</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">List.elem</span> <span class="n">sup</span> <span class="o">(</span><span class="n">addSup</span> <span class="o">[]</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addSup</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">addSup.more</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">head</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span><span class="o">:</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">List.elem</span> <span class="n">sup</span> <span class="o">(</span><span class="n">addSup</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sup</span><span class="o">))</span>
<span class="o">:</span>   <span class="n">List.elem</span> <span class="n">sup</span> <span class="o">(</span><span class="n">addSup</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">head</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">xs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addSup</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
    <span class="n">split</span>
    <span class="bp">.</span> <span class="n">next</span> <span class="n">ht</span> <span class="bp">=&gt;</span>
      <span class="n">simp_all</span>
    <span class="bp">.</span> <span class="n">next</span> <span class="n">hf</span> <span class="bp">=&gt;</span>
      <span class="n">simp_all</span>
      <span class="n">split</span>
      <span class="bp">.</span> <span class="n">rfl</span>
      <span class="bp">.</span> <span class="n">split</span>
        <span class="bp">.</span> <span class="n">simp_all</span>
        <span class="bp">.</span> <span class="n">next</span> <span class="n">ht</span> <span class="bp">=&gt;</span>
          <span class="n">rw</span> <span class="o">[</span><span class="n">List.elem</span><span class="o">]</span>
          <span class="n">split</span>
          <span class="bp">.</span> <span class="n">rfl</span>
          <span class="bp">.</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">a</span> <span class="o">::</span> <span class="n">as</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">addSup.more</span><span class="o">]</span>     <span class="c1">-- lean says: failed to prove termination</span>
    <span class="n">assumption</span>
  <span class="n">termination_by</span> <span class="n">addSup.more</span> <span class="n">_</span> <span class="n">_</span> <span class="n">xs</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">xs.length</span>

<span class="kd">theorem</span> <span class="n">addSup.cons</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span><span class="o">:</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="n">List.elem</span> <span class="n">sup</span> <span class="o">(</span><span class="n">addSup</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">xs</span>
  <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp_all</span> <span class="o">[</span><span class="n">addSup</span><span class="o">]</span>
    <span class="n">split</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">inl</span> <span class="bp">=&gt;</span>
      <span class="n">simp_all</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">inr</span> <span class="bp">=&gt;</span>
      <span class="n">next</span> <span class="n">hf</span> <span class="bp">=&gt;</span>
        <span class="n">simp_all</span> <span class="o">[</span><span class="n">hf</span><span class="o">]</span>
        <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">rfl</span>
  <span class="n">case</span> <span class="n">cons</span> <span class="n">head</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">apply</span> <span class="n">addSup.more</span> <span class="n">x</span> <span class="n">head</span> <span class="n">tail</span> <span class="n">sup</span> <span class="n">tail_ih</span>

<span class="kd">end</span> <span class="n">MWE5a</span>
</code></pre></div>
<p>Above, the line <code>rw [← addSup.more] </code> shows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">termination</span><span class="o">,</span> <span class="n">possible</span> <span class="n">solutions</span><span class="o">:</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="k">have</span><span class="bp">`-</span><span class="n">expressions</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">the</span> <span class="n">remaining</span> <span class="n">goals</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">termination_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">different</span> <span class="n">well</span><span class="bp">-</span><span class="n">founded</span> <span class="n">relation</span>
  <span class="bp">-</span> <span class="n">Use</span> <span class="bp">`</span><span class="n">decreasing_by</span><span class="bp">`</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">your</span> <span class="n">own</span> <span class="n">tactic</span> <span class="n">for</span> <span class="n">discharging</span> <span class="n">this</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">goal</span>
<span class="n">a</span><span class="o">:</span> <span class="n">String</span>
<span class="n">as</span><span class="o">:</span> <span class="n">List</span> <span class="n">String</span>
<span class="n">xhead</span><span class="o">:</span> <span class="n">String</span>
<span class="n">xs</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">sup</span><span class="o">:</span> <span class="n">String</span>
<span class="n">h</span><span class="o">:</span> <span class="n">List.elem</span> <span class="n">sup</span> <span class="o">(</span><span class="n">addSup</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span>
<span class="bp">⊢</span> <span class="n">List.length</span> <span class="n">xs</span> <span class="bp">&lt;</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">as</span><span class="o">)</span>
</code></pre></div>
<p>Since I matched on <code>xs</code> and obtained a case: <code>a :: as</code>, the goal above should be true.</p>
<p>I get the feeling that this proof strategy is overly complicated but I am not sure what it is that I'm missing.</p>
<p>Any suggestions?</p>



<a name="320150514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320150514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320150514">(Jan 09 2023 at 05:15)</a>:</h4>
<p>If you just want to expose the fact that you pattern matched on <code>xs</code>, you can instead <code>match h_xs : xs with ...</code> and then use <code>subst_vars</code> to substitute <code>a::as</code> for <code>xs</code>. Not sure RE: simplifying the overall proof structure though...</p>



<a name="320150757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320150757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320150757">(Jan 09 2023 at 05:19)</a>:</h4>
<p>Here's how I would approach your original theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">addSup</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">List.contains</span><span class="o">]</span>
  <span class="n">apply</span> <span class="n">List.elem_eq_true_of_mem</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addSup</span><span class="o">]</span>
  <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span>
</code></pre></div>
<p><code>List.elem_eq_true_of_mem</code> should be a simp lemma, which would have eliminated that line</p>



<a name="320150860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/320150860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#320150860">(Jan 09 2023 at 05:21)</a>:</h4>
<p>also <code>addSup</code> is called <code>List.insert</code> in std (although it pushes the element to the front instead of the end)</p>



<a name="321284747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321284747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321284747">(Jan 14 2023 at 00:44)</a>:</h4>
<p>ok, I followed Mario's suggestion to use <code>List.insert</code> instead of my own...</p>
<p>Now, I am getting stuck at prooving an existential property:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>
<span class="kn">import</span> <span class="n">Std.Data.List.Lemmas</span>

<span class="kn">namespace</span> <span class="n">MWE7</span>

<span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>

<span class="kd">def</span> <span class="n">addBoth</span> <span class="o">:</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span>            <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sup</span> <span class="o">[]</span> <span class="o">(</span><span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span> <span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">tail</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">bif</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">sub</span> <span class="k">then</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">as.insert</span> <span class="n">sup</span><span class="o">)</span> <span class="n">tail</span> <span class="k">else</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">addBoth.nil</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="bp">.</span><span class="n">nil</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">addBoth</span> <span class="bp">.</span><span class="n">nil</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">addBoth.sub</span> <span class="o">(</span><span class="n">ss</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">ss</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">]</span>
  <span class="n">induction</span> <span class="n">ss</span>
  <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">cons</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
   <span class="c1">-- apply Exists.elim</span>
    <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">MWE7</span>
</code></pre></div>
<p>Just before the <code>sorry</code>, the tactic state is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">∈</span>
      <span class="n">Std.AssocList.toList</span>
        <span class="o">(</span><span class="n">bif</span> <span class="n">key</span> <span class="bp">==</span> <span class="n">sub</span> <span class="k">then</span> <span class="n">Std.AssocList.cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">List.insert</span> <span class="n">sup</span> <span class="n">value</span><span class="o">)</span> <span class="n">tail</span>
        <span class="k">else</span> <span class="n">Std.AssocList.cons</span> <span class="n">key</span> <span class="n">value</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">))</span> <span class="bp">∧</span>
    <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
</code></pre></div>
<p>According to <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier">https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier</a><br>
I should be able to apply the <code>Exists.elim</code> tactic; however, there are implicit variables in that theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">Exists.elim</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>
   <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">Exists</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">p</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h₁</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="n">a</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">h₂</span> <span class="n">a</span> <span class="n">h</span>
</code></pre></div>
<p>So if I apply this tactic, I get subgoals that I have no idea how to discharge:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">case</span> <span class="n">h₁</span>
<span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">?</span><span class="n">p</span> <span class="n">x</span>
<span class="n">case</span> <span class="n">h₂</span>
<span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="bp">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">α</span><span class="o">),</span>
  <span class="bp">?</span><span class="n">p</span> <span class="n">a</span> <span class="bp">→</span>
    <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">x</span> <span class="bp">∈</span>
          <span class="n">Std.AssocList.toList</span>
            <span class="o">(</span><span class="n">bif</span> <span class="n">key</span> <span class="bp">==</span> <span class="n">sub</span> <span class="k">then</span> <span class="n">Std.AssocList.cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">List.insert</span> <span class="n">sup</span> <span class="n">value</span><span class="o">)</span> <span class="n">tail</span>
            <span class="k">else</span> <span class="n">Std.AssocList.cons</span> <span class="n">key</span> <span class="n">value</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">))</span> <span class="bp">∧</span>
        <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="n">case</span> <span class="n">α</span>
<span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="bp">⊢</span> <span class="kt">Sort</span> <span class="bp">?</span><span class="n">u.3967</span>
<span class="n">case</span> <span class="n">p</span>
<span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="bp">⊢</span> <span class="bp">?</span><span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>
<p>How do I handle this kind of proof?</p>



<a name="321289364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321289364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321289364">(Jan 14 2023 at 01:39)</a>:</h4>
<p>Exists.elim lets you sort of “forward” the burden of existence to a different existential. Here, if you apply <code>Exists.elim tail_ih</code>, you’ll be left with the goal to prove that the tail_ih property implies the goal before Exists.elim</p>



<a name="321289446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321289446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321289446">(Jan 14 2023 at 01:40)</a>:</h4>
<p>And since you’re supplying h1 in Exists.elim explicitly, it will unify against that to figure out the implicit variables in the theorem :)</p>



<a name="321413043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321413043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321413043">(Jan 14 2023 at 22:07)</a>:</h4>
<p>I think I need something that deconstructs the goal, not the hypothesis and split the cases for the nested <code>bif ...</code> expression.</p>
<p>The closest I managed to get is the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">addBoth</span> <span class="o">:</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span>            <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sup</span> <span class="o">[]</span> <span class="o">(</span><span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span> <span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">tail</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">bif</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">sub</span> <span class="k">then</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">as.insert</span> <span class="n">sup</span><span class="o">)</span> <span class="n">tail</span> <span class="k">else</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">addBoth.sub</span> <span class="o">(</span><span class="n">ss</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">ss</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">]</span>
  <span class="n">induction</span> <span class="n">ss</span>
  <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="n">case</span> <span class="n">cons</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
    <span class="n">by_cases</span> <span class="n">key</span> <span class="bp">==</span> <span class="n">sup</span>
    <span class="n">case</span> <span class="n">pos</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="o">{</span>

    <span class="o">}</span>
    <span class="n">case</span> <span class="n">neg</span> <span class="n">nh</span> <span class="bp">=&gt;</span> <span class="o">{</span>

    <span class="o">}</span>
</code></pre></div>
<p>Now, in the <code>pos</code> case, the tactic state becomes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="n">h</span><span class="o">:</span> <span class="o">(</span><span class="n">key</span> <span class="bp">==</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">∈</span>
      <span class="n">Std.AssocList.toList</span>
        <span class="o">(</span><span class="n">bif</span> <span class="n">key</span> <span class="bp">==</span> <span class="n">sub</span> <span class="k">then</span> <span class="n">Std.AssocList.cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">List.insert</span> <span class="n">sup</span> <span class="n">value</span><span class="o">)</span> <span class="n">tail</span>
        <span class="k">else</span> <span class="n">Std.AssocList.cons</span> <span class="n">key</span> <span class="n">value</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">))</span> <span class="bp">∧</span>
    <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
</code></pre></div>
<p>and in the <code>neg</code>case, I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="n">nh</span><span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">key</span> <span class="bp">==</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">=</span> <span class="n">true</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">∈</span>
      <span class="n">Std.AssocList.toList</span>
        <span class="o">(</span><span class="n">bif</span> <span class="n">key</span> <span class="bp">==</span> <span class="n">sub</span> <span class="k">then</span> <span class="n">Std.AssocList.cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">List.insert</span> <span class="n">sup</span> <span class="n">value</span><span class="o">)</span> <span class="n">tail</span>
        <span class="k">else</span> <span class="n">Std.AssocList.cons</span> <span class="n">key</span> <span class="n">value</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">))</span> <span class="bp">∧</span>
    <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
</code></pre></div>
<p>Now, it seems that I need to deconstruct the existential quantifier of the goal, not the <code>tail_ih</code> hypothesis.</p>
<p>With <code>apply Elim.exists</code>, I get multiple cases for the implicit parameters of the theorem; that does not seem the right way to go.</p>
<p>With <code>apply Elim.exists tail_ih</code>, the goal transforms from just an existential quantification into an implication of a universal quantification for the existential quantification. That seems to me going backwards, not towards deconstructing the goal.</p>
<p>It seems to me that there is something missing in the guidance for dealing w/ existential quantifiers.</p>



<a name="321413269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321413269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321413269">(Jan 14 2023 at 22:11)</a>:</h4>
<p>The <code>tail_ih</code> hypothesis can be split using <code>match</code> or <code>cases</code> to put the <code>x</code> and the proof of its properties into context.</p>
<p>Then, if you can come up with some expression <code>e</code> for which the goal properties hold, you can <code>refine ⟨e, ?_⟩</code> to claim <code>e</code> satisfies those properties (you then have to prove it does satisfy those properties)</p>



<a name="321413428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321413428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321413428">(Jan 14 2023 at 22:13)</a>:</h4>
<p>I had the impression that the <code>x</code> of <code>tail_ih</code> is the same <code>x</code> that works for the goal, in which case <code>apply Exists.elim tail_ih; intro h</code> is basically the same as doing the above steps one at a time</p>



<a name="321413728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321413728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321413728">(Jan 14 2023 at 22:16)</a>:</h4>
<p>TPIL has a <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier">section</a> about existentials that will probably explain better than I can</p>



<a name="321414281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321414281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321414281">(Jan 14 2023 at 22:24)</a>:</h4>
<p>I found something helpful: <a href="#narrow/stream/270676-lean4/topic/.E2.9C.94.20Golfable.20proof.3F/near/311749494">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.9C.94.20Golfable.20proof.3F/near/311749494</a></p>
<p>Then I managed to make progress:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>

<span class="kd">def</span> <span class="n">addBoth</span> <span class="o">:</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span>            <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sup</span> <span class="o">[]</span> <span class="o">(</span><span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span> <span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">tail</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">bif</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">sub</span> <span class="k">then</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">as.insert</span> <span class="n">sup</span><span class="o">)</span> <span class="n">tail</span> <span class="k">else</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span>


<span class="kd">theorem</span> <span class="n">cond_eq_ite</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">cond</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">c</span> <span class="k">then</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">c</span> <span class="bp">&lt;;&gt;</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">addBoth.sub</span> <span class="o">(</span><span class="n">ss</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">ss</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">]</span>
  <span class="n">induction</span> <span class="n">ss</span>
  <span class="bp">.</span> <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="bp">.</span> <span class="n">case</span> <span class="n">cons</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">cond_eq_ite</span><span class="o">]</span>
    <span class="n">by_cases</span> <span class="n">key</span> <span class="bp">=</span> <span class="n">sup</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
      <span class="n">by_cases</span> <span class="n">sub</span> <span class="bp">=</span> <span class="n">sup</span>
      <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">ss</span><span class="o">]</span>
      <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
        <span class="gr">sorry</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="gr">sorry</span>
</code></pre></div>
<p>When the condition is true, I solved the goal by simply applying the condition to simplify the <code>if</code>.</p>
<p>When the condition is false, it seems that I need some other theorem to simplify the <code>if</code>, e.g.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
<span class="n">h</span><span class="o">:</span> <span class="n">key</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="n">ss</span><span class="o">:</span> <span class="bp">¬</span><span class="n">sub</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">∈</span>
      <span class="n">Std.AssocList.toList</span>
        <span class="o">(</span><span class="k">if</span> <span class="n">sup</span> <span class="bp">=</span> <span class="n">sub</span> <span class="k">then</span> <span class="n">Std.AssocList.cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">List.insert</span> <span class="n">sup</span> <span class="n">value</span><span class="o">)</span> <span class="n">tail</span>
        <span class="k">else</span> <span class="n">Std.AssocList.cons</span> <span class="n">sup</span> <span class="n">value</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">))</span> <span class="bp">∧</span>
    <span class="n">x.fst</span> <span class="bp">=</span> <span class="n">sub</span>
</code></pre></div>



<a name="321414482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321414482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321414482">(Jan 14 2023 at 22:27)</a>:</h4>
<p>Got it!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>
<span class="kn">import</span> <span class="n">Std.Data.List.Lemmas</span>

<span class="kn">namespace</span> <span class="n">MWE7</span>

<span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>

<span class="kd">def</span> <span class="n">addBoth</span> <span class="o">:</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span>            <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sup</span> <span class="o">[]</span> <span class="o">(</span><span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span> <span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">tail</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">bif</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">sub</span> <span class="k">then</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">as.insert</span> <span class="n">sup</span><span class="o">)</span> <span class="n">tail</span> <span class="k">else</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">addBoth.nil</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="bp">.</span><span class="n">nil</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">addBoth</span> <span class="bp">.</span><span class="n">nil</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">cond_eq_ite</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">cond</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">c</span> <span class="k">then</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">c</span> <span class="bp">&lt;;&gt;</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">addBoth.sub</span> <span class="o">(</span><span class="n">ss</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">ss</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">]</span>
  <span class="n">induction</span> <span class="n">ss</span>
  <span class="bp">.</span> <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="bp">.</span> <span class="n">case</span> <span class="n">cons</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">cond_eq_ite</span><span class="o">]</span>
    <span class="n">by_cases</span> <span class="n">key</span> <span class="bp">=</span> <span class="n">sup</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
      <span class="n">by_cases</span> <span class="n">sub</span> <span class="bp">=</span> <span class="n">sup</span>
      <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">ss</span><span class="o">]</span>
      <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
        <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp_all</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="bp">=&gt;</span>
      <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp_all</span>

<span class="kd">end</span> <span class="n">MWE7</span>
</code></pre></div>
<p>There is probably a way to simplify the proof; this is my first non-trivial proof about a non-trivial data structure operation that I managed to do in Lean! Yeah!</p>



<a name="321415637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321415637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321415637">(Jan 14 2023 at 22:43)</a>:</h4>
<p>If you want cool lean tricks, you can write the induction as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">induction</span> <span class="n">ss</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="n">next</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">cond_eq_ite</span><span class="o">]</span>
    <span class="bp">....</span>
</code></pre></div>
<p>It looks pretty clean overall :D</p>



<a name="321419843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How%20to%20prove%20properties%20about%20monad%20operations%3F/near/321419843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F.html#321419843">(Jan 14 2023 at 23:47)</a>:</h4>
<p>Thanks for the tip. Encouraged by this progress, I tried to prove something a bit more difficult that requires dealing w/ an existential quantifier. <br>
I think I can simplify the proof w/ an auxiliary lemma but I am not sure how to handle this pattern.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Std.Data.AssocList</span>
<span class="kn">import</span> <span class="n">Std.Data.List.Lemmas</span>

<span class="kn">namespace</span> <span class="n">MWE8</span>

<span class="n">abbrev</span> <span class="n">Strings</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">String</span>

<span class="kd">def</span> <span class="n">addBoth</span> <span class="o">:</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">nil</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span>            <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sup</span> <span class="o">[]</span> <span class="o">(</span><span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">[</span><span class="n">sup</span><span class="o">]</span> <span class="bp">.</span><span class="n">nil</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">tail</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sup</span> <span class="bp">=&gt;</span> <span class="n">bif</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">sub</span> <span class="k">then</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">sub</span> <span class="o">(</span><span class="n">as.insert</span> <span class="n">sup</span><span class="o">)</span> <span class="n">tail</span> <span class="k">else</span> <span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">addBoth.nil</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="bp">.</span><span class="n">nil</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sub</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">addBoth</span> <span class="bp">.</span><span class="n">nil</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">cond_eq_ite</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">cond</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">c</span> <span class="k">then</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">c</span> <span class="bp">&lt;;&gt;</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">addBoth.tail</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">String</span> <span class="bp">×</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">sup</span><span class="o">)</span>
<span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">tail</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">tail</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="bp">.</span> <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span>
    <span class="n">simp_all</span>
    <span class="gr">sorry</span>
  <span class="bp">.</span> <span class="n">case</span> <span class="n">cons</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">by_cases</span> <span class="n">key</span> <span class="bp">=</span> <span class="n">sup</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="n">apply</span> <span class="n">Or.inl</span> <span class="n">h</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="n">h</span> <span class="n">ht</span> <span class="bp">=&gt;</span>
      <span class="n">simp_all</span>
      <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">addBoth.sup</span> <span class="o">(</span><span class="n">ss</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span><span class="o">:</span> <span class="n">String</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">ss</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span><span class="bp">.</span><span class="n">contains</span> <span class="n">sup</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">Std.AssocList.contains</span><span class="o">]</span>
  <span class="n">induction</span> <span class="n">ss</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
  <span class="bp">.</span> <span class="n">next</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span> <span class="n">tail_ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">addBoth</span><span class="o">]</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">cond_eq_ite</span><span class="o">]</span>
    <span class="n">by_cases</span> <span class="n">key</span> <span class="bp">=</span> <span class="n">sub</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">h</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
      <span class="n">by_cases</span> <span class="n">sub</span> <span class="bp">=</span> <span class="n">sup</span>
      <span class="bp">.</span> <span class="n">case</span> <span class="n">pos</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
        <span class="n">apply</span> <span class="n">Or.inl</span> <span class="n">ss</span>
      <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">ss</span><span class="o">]</span>
        <span class="n">apply</span> <span class="n">Exists.elim</span> <span class="n">tail_ih</span>
        <span class="n">intro</span> <span class="n">a</span> <span class="n">h</span>
        <span class="n">apply</span> <span class="n">addBoth.tail</span> <span class="n">a</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span> <span class="n">h</span>
    <span class="bp">.</span> <span class="n">case</span> <span class="n">neg</span> <span class="bp">=&gt;</span>
      <span class="n">split</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp_all</span>

<span class="kd">end</span> <span class="n">MWE8</span>
</code></pre></div>
<p>For the <code>nil</code> case, the <code>sorry</code> tactic state is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span><span class="o">:</span> <span class="n">String</span> <span class="bp">×</span> <span class="n">Strings</span>
<span class="n">subsup</span><span class="o">:</span> <span class="n">String</span>
<span class="n">h</span><span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sup</span><span class="o">,</span> <span class="o">[])</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sub</span><span class="o">,</span> <span class="o">[</span><span class="n">sup</span><span class="o">]))</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="bp">⊢</span> <span class="n">False</span>
</code></pre></div>
<p>Here, <code>h</code> is "obviously" false so I should be able to proove this by contradiction, splitting over <code>h</code>.<br>
Not sure how to do this...</p>
<p>For the <code>cons.neg</code> case, the <code>sorry</code> tactic state is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span><span class="o">:</span> <span class="n">String</span> <span class="bp">×</span> <span class="n">Strings</span>
<span class="n">subsupkey</span><span class="o">:</span> <span class="n">String</span>
<span class="n">value</span><span class="o">:</span> <span class="n">Strings</span>
<span class="n">tail</span><span class="o">:</span> <span class="n">Std.AssocList</span> <span class="n">String</span> <span class="n">Strings</span>
<span class="n">tail_ih</span><span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="n">tail</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">tail</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="o">(</span><span class="n">addBoth</span> <span class="o">(</span><span class="n">Std.AssocList.cons</span> <span class="n">key</span> <span class="n">value</span> <span class="n">tail</span><span class="o">)</span> <span class="n">sub</span> <span class="n">sup</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="n">ht</span><span class="o">:</span> <span class="bp">¬</span><span class="n">key</span> <span class="bp">=</span> <span class="n">sup</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Std.AssocList.toList</span> <span class="n">tail</span> <span class="bp">∧</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">sup</span>
</code></pre></div>
<p>This seems like regressing back to the original goal. </p>
<p>I am wondering if this is the right proof strategy.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html">Checking the Goldbach conjecture</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270963940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270963940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270963940">(Feb 07 2022 at 11:23)</a>:</h4>
<p>The Goldbach conjecture is that every even number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n\geq4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> is the sum of two primes. It's still an open question. Computationally-inclined number theorists sometimes write computer programs to check it for all even <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">n\leq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> grows slowly over time as computers get better. How big can we make <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> in Lean?</p>
<p><a href="https://www.ams.org/journals/mcom/1993-61-204/S0025-5718-1993-1185250-6/S0025-5718-1993-1185250-6.pdf">Here</a> is an example of a paper from 1993 by Sinisalo about numerically verifying the Goldbach conjecture up to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup></mrow><annotation encoding="application/x-tex">4\times10^{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span></span></span></span></span></span></span></span> (using non-formal techniques, as do all the papers I cite below). It's published in Math Comp, which was at that time the top journal for computational mathematics, so one can imagine that it was state of the art at the time. It doesn't do anything fancy involving zero estimates for the Riemann zeta functions (some other papers in this area do); it just does a brute force variant of Eratosthenes' sieve. The details of the algorithm are in <a href="https://www.researchgate.net/publication/241887101_Checking_the_Goldbach_conjecture_on_a_vector_computer">this earlier paper</a> of Granville et al, where if you can HANDLE THE FORTRAN CODE they explain the very simple method (my understanding, at least, is that this is the algorithm Sinisalo used as well). It seems that in 1988 (Granville et al) they could get up to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">X=2\times10^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>, in 1993 (Sinisalo) they had got as far as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup></mrow><annotation encoding="application/x-tex">4\times 10^{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span></span></span></span></span></span></span></span>, and the most recent paper I can find is by Oliviera e Silva, Herzog and Pardi <a href="https://www.semanticscholar.org/paper/Empirical-verification-of-the-even-Goldbach-and-of-Silva-Herzog/0bcebfe7cd9889039a36c73cf0a21609cb8867e2">here</a> which push the calculations up to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">4\times10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span> and again they are using very simple algorithms (they also give a history of the computational aspect of the problem at the beginning, and they explain their simple algorithms in the paper, but it's just Eratosthenes + some extra thought to make it computationally more efficient).</p>
<p>Obviously computers are many times faster now than they were in 1993 (at the time of Sinisalo's paper), however formal proofs as opposed to Fortran proofs slow things down again. I was wondering how far one could get in Lean 4, using GMP if necessary (I would also be interested in whether GMP speeds things up or whether for numbers of this size it's of no use). It would be a pretty simple job to knock off a very naive algorithm to start verifying Goldbach, and if anyone gets the bug and wants to start setting formalisation records then these more advanced algorithms which seem to be giving state of the art results are really still extremely elementary in nature as you can see from their description in the linked papers. I have no idea what the record is for formalised computational Goldbach.</p>
<p>Why am I interested? Well,  the ternary Goldbach conjecture is the weaker statement that every odd natural &gt;= 7 is the sum of three primes, and a proof was announced a few years ago by Helfgott. Helfgott's proof is in two completely different parts; he uses abstract techniques from analytic number theory to prove the results for odd numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">\geq 8\times 10^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span> and then (with Platt -- see <a href="https://arxiv.org/abs/1305.3062">here</a> does a brute force computer search to check the cases less than this bound. The proof of the abstract analytic number theory part of the argument is 300 pages long so is unlikely to be formalised any time soon, however the basic techniques used in it by Helfgott (the circle method etc) are used a lot in this area, and are being formalised by mathematicians in <a href="https://b-mehta.github.io/unit-fractions/">this Lean project here</a>, so it led me to idly speculate about how feasible it would be to formalise the various parts of the proof of the ternary conjecture and in particular the computational part. For the computational part Helfgott uses the Oliviera e Silva, Herzog and Pardi result, which reduces the claim that ternary Goldbach is true up to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">8\times 10^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span> to the claim that there are no two consecutive primes in this range which are distance <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\geq 4\times 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span> apart, and this is what he proves using a (unformalised) computer proof. I would imagine that formalised methods right now can't get close to Helfgott's unformalised bound but it seems to me that if the state of the art is being achieved with these essentially elementary arguments then it might make a good computational project for someone interested in seeing how far Lean 4 can get; certainly no maths library will be needed, for example.</p>



<a name="270966280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270966280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270966280">(Feb 07 2022 at 11:48)</a>:</h4>
<p>This is very interesting. I guess a formal proof can simply be an enumeration, with even numbers listed as sums of pairs of primes and a proof of the equality.</p>



<a name="270966458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270966458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270966458">(Feb 07 2022 at 11:50)</a>:</h4>
<p>Exactly. But I have no feeling at all as to the complexity of doing this to a non-trivial bound in a formal setting. I know that they computed the <a href="https://arxiv.org/abs/1709.01743">first million digits of pi in Coq</a> although <a href="https://en.wikipedia.org/wiki/Chronology_of_computation_of_%CF%80#2009%E2%80%93present">the non-formal people are up to about 10^13 digits by now</a>.</p>



<a name="270967582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270967582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddhartha Gadgil <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270967582">(Feb 07 2022 at 12:00)</a>:</h4>
<p>A very nice feature of lean 4 compiled code is that proofs are eliminated at runtime after checking correctness while compiling. So there is hope the overhead is small.</p>



<a name="270970652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270970652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270970652">(Feb 07 2022 at 12:30)</a>:</h4>
<p>If Lean 4 uses GMP, then the implementation of GMP (in C, I guess) is part of the TCB, right?</p>



<a name="270970678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270970678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270970678">(Feb 07 2022 at 12:31)</a>:</h4>
<p>Or is there a verified reimplementation?</p>



<a name="270970758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270970758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270970758">(Feb 07 2022 at 12:32)</a>:</h4>
<p>there are plans for a verified (or at least homegrown and not GPL) reimplementation, but indeed that's the current state of things</p>



<a name="270971060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971060">(Feb 07 2022 at 12:35)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">4 \cdot 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span> is around <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mi mathvariant="normal">/</mi><mn>4.5</mn></mrow><annotation encoding="application/x-tex">2^{64}/4.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span><span class="mord">/4.5</span></span></span></span>; so I don't think GMP will be relevant to that part (and maybe this is why they stopped at that particular value).</p>



<a name="270971105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971105">(Feb 07 2022 at 12:35)</a>:</h4>
<p>Aha, because if you off-load the bignum computations and the primality checks to a non-verified GMP, then there is little value in doing the project in Lean, methinks.</p>



<a name="270971225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971225">(Feb 07 2022 at 12:36)</a>:</h4>
<p>the part of GMP in the lean TCB only includes <code>+ - * / %</code> on nat and int, not primality</p>



<a name="270971337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971337">(Feb 07 2022 at 12:37)</a>:</h4>
<p>of course you can use FFI + implementedBy + reduceBool to add arbitrary C code to the TCB if you want</p>



<a name="270971436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971436">(Feb 07 2022 at 12:38)</a>:</h4>
<p>so for instance you could link to those GMP primality routines and add them to lean</p>



<a name="270971468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971468">(Feb 07 2022 at 12:38)</a>:</h4>
<p>Might also be interesting to do this verified Goldbach in MM0</p>



<a name="270971543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971543">(Feb 07 2022 at 12:39)</a>:</h4>
<p>lol, it's always on my mind... I'm thinking to wait until I have verified computational reflection before tackling these kinds of problems though</p>



<a name="270971926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/270971926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#270971926">(Feb 07 2022 at 12:42)</a>:</h4>
<p>Maybe it might be better to start a little simpler, for example calculating the number of primes &lt;= 100000 in lean 4 compared to (pick your favorite other language)</p>



<a name="298437314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298437314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298437314">(Sep 12 2022 at 18:18)</a>:</h4>
<p><a href="/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png">image.png</a> Here's a proof that the number of primes less than 100000 is 9592 in Lean 3</p>
<div class="message_inline_image"><a href="/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png" title="image.png"><img src="/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png"></a></div>



<a name="298440104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298440104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298440104">(Sep 12 2022 at 18:35)</a>:</h4>
<p>And kernel typechecking time?</p>



<a name="298440371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298440371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298440371">(Sep 12 2022 at 18:36)</a>:</h4>
<p>How can I measure this?</p>



<a name="298440605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298440605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298440605">(Sep 12 2022 at 18:38)</a>:</h4>
<p><a href="/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png">image.png</a> Here's all the other things the profiler tells me (on this run it says execution was around 4.5s)</p>
<div class="message_inline_image"><a href="/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png" title="image.png"><img src="/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png"></a></div>



<a name="298492923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298492923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298492923">(Sep 12 2022 at 23:13)</a>:</h4>
<p>But you didn't do this by explicitly computing all the primes less than 10^5, right?</p>



<a name="298493015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298493015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298493015">(Sep 12 2022 at 23:14)</a>:</h4>
<p>BTW if anyone has questions for Helfgott I'm at a conference with him this week</p>



<a name="298494399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298494399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298494399">(Sep 12 2022 at 23:33)</a>:</h4>
<p>I didn't, but I did also separately compute all the primes less than 2 * 10^5</p>



<a name="298494440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/298494440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#298494440">(Sep 12 2022 at 23:33)</a>:</h4>
<p>I've also managed to check Goldbach (again in Lean 3) up to 2*10^5. In particular the statement</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">goldbach_kevin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">≤</span> <span class="mi">200000</span><span class="o">,</span> <span class="mi">4</span> <span class="bp">≤</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">even</span> <span class="n">i</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">p.prime</span> <span class="bp">∧</span> <span class="n">q.prime</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">+</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span>
</code></pre></div>
<p>is sorry-free</p>



<a name="299241049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299241049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299241049">(Sep 16 2022 at 21:02)</a>:</h4>
<p>This looks like fun learning experience.  I tried super simple Eratosthenes Sieve in Lean 4 but it runs out of stack space pretty quick:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">EratosthenesSieveSimple</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">ℕ</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">EratosthenesSieveSimple</span> <span class="o">(</span><span class="n">xs.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">))</span>
</code></pre></div>
<p>So I used a StateM monad to allow some tail recursion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">EratosthenesSieve</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">StateM</span> <span class="o">(</span><span class="n">List</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">xs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="o">()</span>
  <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs'</span> <span class="bp">=&gt;</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">r</span> <span class="bp">←</span> <span class="n">get</span>
    <span class="n">set</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">r</span><span class="o">)</span>
    <span class="n">EratosthenesSieve</span> <span class="o">(</span><span class="n">xs'.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">y</span> <span class="bp">%</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">))</span>
</code></pre></div>
<p>The compiled version of this can find the first 1 million primes in about 93 seconds on my AMD Ryzen 9 CPU. It found 78498 primes. I can then save this to a new lean source file containing <code>def primes := [2, 3, 5, 7, ...]</code> but when I try and compile this simple array the Lean compiler times out, which is odd:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">.\.\.\</span><span class="n">Primes1Million.lean</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="o">(</span><span class="n">deterministic</span><span class="o">)</span> <span class="n">timeout</span> <span class="n">at</span> <span class="bp">'</span><span class="n">isDefEq'</span><span class="o">,</span> <span class="n">maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">heartbeats</span> <span class="o">(</span><span class="mi">200000</span><span class="o">)</span> <span class="n">has</span> <span class="n">b</span>                                             <span class="n">een</span> <span class="n">reached</span> <span class="o">(</span><span class="n">use</span> <span class="bp">'</span><span class="kd">set_option</span> <span class="n">maxHeartbeats</span> <span class="bp">&lt;</span><span class="n">num</span><span class="bp">&gt;'</span> <span class="n">to</span> <span class="n">set</span> <span class="n">the</span> <span class="n">limit</span><span class="o">)</span>
</code></pre></div>
<p>I was thinking of saving this file as a cheat so we could use it to implement a more efficient <code>Nat.prime</code> function, e.g. use it to build a HashMap of all the numbers with a true false saying whether they are primes or not so <code>p.prime</code> becomes an O(1) lookup....</p>



<a name="299243023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299243023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299243023">(Sep 16 2022 at 21:20)</a>:</h4>
<p>how long is your list <code>def primes := [2, 3, 5, 7, ...]</code>?</p>



<a name="299243906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299243906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299243906">(Sep 16 2022 at 21:29)</a>:</h4>
<p>Here's a MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span> <span class="s2">"make_list"</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="bp">`</span><span class="o">([</span><span class="bp">$</span><span class="o">(</span><span class="n">mkArray</span> <span class="mi">5000</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="mi">0</span><span class="o">))),</span><span class="bp">*</span><span class="o">])</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">make_list</span>
</code></pre></div>
<p>While I expect there to be problems eventually, 5000 seems unusually low for them to show up here. I think there are some issues in the scheme used for compiling list literals using nested <code>let</code> bindings.</p>



<a name="299246244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299246244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299246244">(Sep 16 2022 at 21:49)</a>:</h4>
<p>It seems like there is some quadratic behavior here with it spending a huge amount of time in <code>elimMVarDeps</code> traversing the term to ensure no metavariables contain references to the newly introduced let bindings produced by the <code>[xs,* | tail]</code> notation</p>



<a name="299246353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299246353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299246353">(Sep 16 2022 at 21:50)</a>:</h4>
<p>This is really unnecessary, this notation should just be an <code>elab</code> and produce a term directly instead of macro expanding to a pile of lets that have to be elaborated</p>



<a name="299250681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299250681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299250681">(Sep 16 2022 at 22:30)</a>:</h4>
<p><span class="user-mention" data-user-id="434989">@Chris Lovett</span> FYI, that's not the true sieve of Eratosthenes (though it's the one you see as a functional programming example, and <a href="https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">there's a paper about this</a>).</p>
<p>Here's a simple implementation of the true one -- note that it doesn't have any modulo operators nor any checking that a given number is not divisible by <em>all</em> of the primes found so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">primes</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">res</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">buf</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="bp">.</span><span class="n">mkArray</span> <span class="n">n</span> <span class="n">True</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">2</span> <span class="o">:</span> <span class="n">n</span><span class="o">]</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">buf</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">!</span> <span class="k">then</span>
      <span class="n">res</span> <span class="o">:=</span> <span class="n">res.push</span> <span class="n">i</span>
      <span class="n">for</span> <span class="n">j</span> <span class="k">in</span> <span class="o">[</span><span class="n">i</span> <span class="bp">*</span> <span class="n">i</span> <span class="o">:</span> <span class="n">n</span> <span class="o">:</span> <span class="n">i</span><span class="o">]</span> <span class="k">do</span>
        <span class="n">buf</span> <span class="o">:=</span> <span class="n">buf.set</span><span class="bp">!</span> <span class="n">j</span> <span class="n">False</span>
  <span class="n">return</span> <span class="n">res</span>

<span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">primes</span> <span class="mi">1000000</span>
  <span class="n">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">a</span> <span class="k">do</span>
    <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"{p}"</span>
</code></pre></div>
<p>Compiled, I get</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>$ time ./build/bin/primes
...  78498 lines omitted ...
./build/bin/primes  0.11s user 0.17s system 86% cpu 0.323 total
</code></pre></div>
<p>93 seconds seemed excessive for the primes less than a million!</p>



<a name="299263849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299263849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299263849">(Sep 17 2022 at 01:50)</a>:</h4>
<p>Ok, building on your nice fast primes function we can find the sum of 2 primes for every even <code>i &gt;= 4</code> with this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">abbrev</span> <span class="n">NatMap</span> <span class="o">:=</span> <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">goldback</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">primes</span> <span class="o">:=</span> <span class="n">primes</span> <span class="n">n</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">HashMap.empty</span>
  <span class="n">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">primes</span> <span class="k">do</span>
    <span class="n">map</span> <span class="o">:=</span> <span class="n">map.insert</span> <span class="n">p</span> <span class="n">p</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">4</span> <span class="o">:</span> <span class="n">n</span> <span class="o">:</span> <span class="mi">2</span><span class="o">]</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">mut</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">false</span>
    <span class="n">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">primes</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">p</span> <span class="bp">&gt;</span> <span class="n">i</span> <span class="k">then</span>
        <span class="n">break</span>
      <span class="k">else</span>
        <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">map.contains</span> <span class="n">q</span> <span class="k">then</span>
          <span class="n">found</span> <span class="o">:=</span> <span class="n">true</span>
          <span class="n">break</span>
    <span class="k">if</span> <span class="n">not</span> <span class="n">found</span> <span class="k">then</span>
      <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"{i} disproves goldback conjecture"</span>
      <span class="n">break</span>
</code></pre></div>
<p>and the compiled version can prove a pair <code>p + q</code> exists for all 5,761,455 primes found under 100 million in 9 seconds which is not bad.</p>



<a name="299264131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299264131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299264131">(Sep 17 2022 at 01:55)</a>:</h4>
<p>The performance seems quite linear (it increases by a factor of 10 each time I increase <code>n</code> by a factor of 10) but of course this solution will not scale too far before running out of memory, we'd need a more compact collection for checking whether <code>q</code> is a prime number... or a SQLite database partitioned across a bunch of terabyte drives or something... but then of course all that will slow things down....</p>



<a name="299265513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299265513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Lovett <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299265513">(Sep 17 2022 at 02:21)</a>:</h4>
<p>I could fit 1 billion in memory which it did in 101 seconds... but I only have a piddly little 32GB RAM so 10 billion is where I run out.  I need one of those machine learning boxes with a terabyte of RAM :-)</p>



<a name="299492042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299492042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tom <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299492042">(Sep 19 2022 at 02:21)</a>:</h4>
<p>For the sieve, you could start by using a bit-vector instead of a hashmap, which will reduce your space overhead significantly.<br>
Then, you can also halve the memory used by only storing the odd numbers, since any prime must be odd. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="299492425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/299492425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tom <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#299492425">(Sep 19 2022 at 02:28)</a>:</h4>
<p>There are also some sparse bitvector data structures which would allow you to take advantage of the fact that your bitvector will be mostly empty because of <a href="https://en.wikipedia.org/wiki/Prime_number_theorem">https://en.wikipedia.org/wiki/Prime_number_theorem</a>.</p>



<a name="303348534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/303348534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#303348534">(Oct 11 2022 at 01:48)</a>:</h4>
<p>I think these approaches do a different thing to what I did - evaluating whether such a counterexample exists doesn't give you a Lean 4 <em>proof</em> that none exist. Certainly for Lean 3 it's a lot faster to evaluate/run instead of proving, and I expect similar for Lean 4</p>



<a name="305066519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/305066519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> joaogui1 (he/him) <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#305066519">(Oct 20 2022 at 01:29)</a>:</h4>
<p>What's GMP and TCB?</p>



<a name="305067134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/305067134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#305067134">(Oct 20 2022 at 01:39)</a>:</h4>
<p>GMP is the <a href="https://en.wikipedia.org/wiki/GNU_Multiple_Precision_Arithmetic_Library">GNU MultiPrecision Library</a> it's a C library for doing integer arithmetic on numbers that are too big to fit into typical computer registers. TCB stands for "trusted computing base" - it means the set of all software we use when doing formally verification that we assume is bug-free.</p>



<a name="305109481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking%20the%20Goldbach%20conjecture/near/305109481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> joaogui1 (he/him) <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture.html#305109481">(Oct 20 2022 at 09:19)</a>:</h4>
<p>Thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
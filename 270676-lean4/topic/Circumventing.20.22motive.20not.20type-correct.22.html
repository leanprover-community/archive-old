---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html">Circumventing "motive not type-correct"</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="278621975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278621975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278621975">(Apr 11 2022 at 21:51)</a>:</h4>
<p>Since this has been a continuous issue for me, asking for some guidance on how to avoid issues with rewriting terms appearing in dependent positions.</p>
<p>Here's an example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">@[simp]</span>
  <span class="kd">theorem</span> <span class="n">length_rangeAux</span> <span class="o">:</span> <span class="o">(</span><span class="n">rangeAux</span> <span class="n">n</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">L.length</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="n">generalizing</span> <span class="n">L</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">length</span><span class="o">,</span> <span class="n">rangeAux</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">Nat.add_one</span><span class="o">,</span> <span class="n">Nat.add_comm</span> <span class="n">n</span> <span class="mi">1</span><span class="o">,</span> <span class="n">Nat.add_assoc</span><span class="o">]</span>

  <span class="kd">@[simp]</span>
  <span class="kd">theorem</span> <span class="n">length_range</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">range</span><span class="o">]</span>

  <span class="kd">theorem</span> <span class="n">rangeAux_eq_append</span>
    <span class="o">:</span> <span class="n">rangeAux</span> <span class="n">n</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">=</span> <span class="n">rangeAux</span> <span class="n">n</span> <span class="o">[]</span> <span class="bp">++</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">L</span><span class="o">)</span>
    <span class="o">:=</span> <span class="kd">by</span>
    <span class="k">suffices</span> <span class="bp">∀</span> <span class="n">L</span><span class="o">,</span> <span class="n">rangeAux</span> <span class="n">n</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">rangeAux</span> <span class="n">n</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">L</span> <span class="k">from</span>
      <span class="n">this</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">L</span><span class="o">)</span>
    <span class="n">intro</span> <span class="n">L</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="n">generalizing</span> <span class="n">L</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">rangeAux</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">get</span><span class="o">,</span> <span class="n">rangeAux</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">@</span><span class="n">ih</span> <span class="o">(</span><span class="n">n</span> <span class="o">::</span> <span class="n">L</span><span class="o">),</span> <span class="bp">@</span><span class="n">ih</span> <span class="o">[</span><span class="n">n</span><span class="o">]]</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">List.append_assoc</span><span class="o">]</span>

  <span class="kd">@[simp]</span>
  <span class="kd">theorem</span> <span class="n">get_range</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="o">(</span><span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">i</span>
    <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">induction</span> <span class="n">n</span>
    <span class="n">exact</span> <span class="n">i.elim0</span>
    <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">unfold</span> <span class="n">range</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">rangeAux</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">rangeAux_eq_append</span><span class="o">]</span>
</code></pre></div>
<p>Here, I want to rewrite but the term occurs as the argument to <code>get</code>. I've tried manually generalizing the term here but failed to make progress</p>



<a name="278622144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278622144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278622144">(Apr 11 2022 at 21:53)</a>:</h4>
<p>best thing is to eliminate references to <code>get</code> asap by replacing them with <code>get?</code></p>



<a name="278622184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278622184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278622184">(Apr 11 2022 at 21:53)</a>:</h4>
<p>(that's not a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>)</p>



<a name="278622853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278622853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278622853">(Apr 11 2022 at 22:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22/near/278622184">said</a>:</p>
<blockquote>
<p>(that's not a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>)</p>
</blockquote>
<p>Thought I could get away with it cuz this is a useful lemma to have around <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="278622911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278622911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278622911">(Apr 11 2022 at 22:01)</a>:</h4>
<p>the important thing about <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is to put the right imports at the top</p>



<a name="278622919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278622919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278622919">(Apr 11 2022 at 22:01)</a>:</h4>
<p>in this case</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Mathlib.Data.List.Basic</span>

<span class="kn">namespace</span> <span class="n">List</span>
</code></pre></div>



<a name="278623030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278623030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278623030">(Apr 11 2022 at 22:02)</a>:</h4>
<p>Oh, sorry! I think it just needs <code>namespace List</code>, everything else is Prelude material I think</p>



<a name="278623102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278623102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278623102">(Apr 11 2022 at 22:03)</a>:</h4>
<p>Rewriting the get is a good idea, I can definitely give that a shot. But it doesn't apply in general, right? I was reading through an old thread in Lean3 world and I think at the time you suggested just using <code>simp_rw</code> or something which would insert <code>cast</code>s as needed</p>



<a name="278623145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278623145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278623145">(Apr 11 2022 at 22:03)</a>:</h4>
<p>(But which we don't have yet in Lean 4)</p>



<a name="278623160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278623160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278623160">(Apr 11 2022 at 22:03)</a>:</h4>
<p>it kind of applies in general, the general technique is to reduce dependent types to nondependent types + predicates</p>



<a name="278623277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278623277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278623277">(Apr 11 2022 at 22:04)</a>:</h4>
<p>Ah, which is what you showed me last time with generalizing to <code>forall o h,</code> etc</p>



<a name="278623321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278623321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278623321">(Apr 11 2022 at 22:05)</a>:</h4>
<p>Okay, I did try something like that with this example but it didn't seem to be helping, let me see if I can re-derive that...</p>



<a name="278624674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278624674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278624674">(Apr 11 2022 at 22:19)</a>:</h4>
<p>here's a proof (modulo the part I assume you know how to handle). I think that <code>get_range</code> as stated is just a really hard theorem to work with and I would suggest alternatives like <code>get_range'</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="kd">theorem</span> <span class="n">get</span><span class="bp">?</span><span class="n">_range</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span><span class="bp">?</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">cases</span> <span class="n">h</span>
    <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
      <span class="n">unfold</span> <span class="n">range</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">rangeAux</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">rangeAux_eq_append</span><span class="o">]</span>
      <span class="gr">sorry</span>

  <span class="kd">theorem</span> <span class="n">get_range'</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">Option.some_inj</span><span class="o">,</span> <span class="bp">←</span> <span class="n">get</span><span class="bp">?</span><span class="n">_eq_get</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">get</span><span class="bp">?</span><span class="n">_range</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h</span><span class="o">)</span>

  <span class="kd">@[simp]</span>
  <span class="kd">theorem</span> <span class="n">get_range</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="o">(</span><span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="n">h'</span><span class="o">,</span> <span class="o">(</span><span class="n">cast</span> <span class="o">(</span><span class="n">h</span> <span class="bp">▸</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">i</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="n">intros</span> <span class="n">m</span> <span class="n">h</span> <span class="n">h'</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">rfl</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">get_range'</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">i.2</span><span class="o">]</span>
</code></pre></div>



<a name="278625805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278625805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278625805">(Apr 11 2022 at 22:32)</a>:</h4>
<p>BTW, we should probably use the TR + csimp trick to hide <code>rangeAux</code>. We have done it for a few <code>List</code> functions, but not for <code>range</code>. <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/Basic.lean#L145">https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/Basic.lean#L145</a></p>



<a name="278627668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278627668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278627668">(Apr 11 2022 at 22:55)</a>:</h4>
<p>As in define <code>range</code> via</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">range</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">range</span> <span class="n">n</span> <span class="bp">++</span> <span class="o">[</span><span class="n">n</span><span class="o">]</span>
</code></pre></div>
<p>and then prove equivalence to the TR one?</p>



<a name="278627798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278627798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278627798">(Apr 11 2022 at 22:57)</a>:</h4>
<p>I think the best definition for proofs is one that uses <code>::</code> and does not use tail recursion</p>



<a name="278627936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278627936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278627936">(Apr 11 2022 at 22:58)</a>:</h4>
<p>It has the same problem as <code>reverse</code> in that it can't really be defined that way</p>



<a name="278627977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278627977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278627977">(Apr 11 2022 at 22:59)</a>:</h4>
<p>not quite like <code>reverse</code>, you can do it but you need an <code>aux</code> which specifies the starting point</p>



<a name="278628200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278628200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278628200">(Apr 11 2022 at 23:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">rangeAux₂</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span>   <span class="n">a</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">a</span> <span class="o">::</span> <span class="n">rangeAux₂</span> <span class="n">n</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">range₂</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">rangeAux₂</span> <span class="n">n</span> <span class="mi">0</span>
</code></pre></div>



<a name="278654248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278654248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278654248">(Apr 12 2022 at 06:51)</a>:</h4>
<p>What is the "TR + csimp trick"?</p>



<a name="278688186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278688186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278688186">(Apr 12 2022 at 12:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="372804">Marcus Rossel</span> <a href="#narrow/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22/near/278654248">said</a>:</p>
<blockquote>
<p>What is the "TR + csimp trick"?</p>
</blockquote>
<p>Here is the <code>List.map</code> instance</p>
<ul>
<li>We first define the non-tail-recursive version that is more convenient to use in proofs</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="o">[]</span>    <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">as</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">::</span> <span class="n">map</span> <span class="n">f</span> <span class="n">as</span>
</code></pre></div>
<ul>
<li>Then, we define the tail-recursive version which is better for code generation</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[specialize]</span> <span class="kd">def</span> <span class="n">mapTRAux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="o">[],</span>    <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">bs.reverse</span>
  <span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">as</span><span class="o">,</span> <span class="n">bs</span> <span class="bp">=&gt;</span> <span class="n">mapTRAux</span> <span class="n">f</span> <span class="n">as</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">::</span> <span class="n">bs</span><span class="o">)</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">mapTR</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="n">mapTRAux</span> <span class="n">f</span> <span class="n">as</span> <span class="o">[]</span>
</code></pre></div>
<ul>
<li>We prove they are equal and mark the theorem with <code>[csimp]</code>. After that, the code generator replaces any occurrence of <code>map</code> with <code>mapTR</code>.</li>
</ul>



<a name="278688218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278688218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278688218">(Apr 12 2022 at 12:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mapTRAux_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">bs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">mapTRAux</span> <span class="n">f</span> <span class="n">as</span> <span class="n">bs</span> <span class="bp">=</span>  <span class="n">bs.reverse</span> <span class="bp">++</span> <span class="n">map</span> <span class="n">f</span> <span class="n">as</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="n">generalizing</span> <span class="n">bs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mapTRAux</span><span class="o">,</span> <span class="n">map</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">mapTRAux</span><span class="o">,</span> <span class="n">map</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ih</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">::</span> <span class="n">bs</span><span class="o">),</span> <span class="n">reverse_cons</span><span class="o">,</span> <span class="n">append_assoc</span><span class="o">]</span>
    <span class="n">rfl</span>

<span class="kd">@[csimp]</span> <span class="kd">theorem</span> <span class="n">map_eq_mapTR</span> <span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">mapTR</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">α</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">funext</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">β</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">funext</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">f</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">funext</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">as</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mapTR</span><span class="o">,</span> <span class="n">mapTRAux_eq</span><span class="o">]</span>
</code></pre></div>



<a name="278721054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278721054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278721054">(Apr 12 2022 at 16:56)</a>:</h4>
<p>This is very interesting. Does this situation / trick also come up for Lean 3?</p>
<p>Also, once the two definitions are set up and the <del>second one</del> equality theorem is marked <code>[csimp]</code>, is the non-tail-recursive definition still available if we want to use it for further proofs?</p>



<a name="278722462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278722462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278722462">(Apr 12 2022 at 17:06)</a>:</h4>
<p>From looking at the implementation <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/CSimpAttr.lean">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/CSimpAttr.lean</a> the "marking" only causes the two to be added into a Name -&gt; Name map, it doesnt touch the declarations at all.  ANd the fact that <code>replaceConstants</code> is exported here: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/CSimpAttr.lean#L53">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/CSimpAttr.lean#L53</a>, makes me think that it's probably gonna be used by the C parts of the compiler after the registration process.</p>



<a name="278722475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278722475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278722475">(Apr 12 2022 at 17:06)</a>:</h4>
<p>Also both the export and csimp attributes are missing from doc-gen I'll add them right away...</p>



<a name="278723632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278723632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278723632">(Apr 12 2022 at 17:16)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> there doesn't seem to be an obvious way to gain access to the theorem that declares this type of replacement is valid right now since it's not implemented as a regular tag attribute but this custom extension based on the name map, could we maybe have a tag attribute that marks the theorem in addition to this map? Or some other way to recover it?</p>
<p>Also since it is not obvious from the declaration that it will be replaced later on I guess it would make sense to mark the declaration that is getting replaced by the compiler later on as well in the docs right? (which is possible right now)</p>



<a name="278731508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278731508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278731508">(Apr 12 2022 at 18:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="391579">Jake Levinson</span> <a href="#narrow/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22/near/278721054">said</a>:</p>
<blockquote>
<p>This is very interesting. Does this situation / trick also come up for Lean 3?</p>
<p>Also, once the two definitions are set up and the <del>second one</del> equality theorem is marked <code>[csimp]</code>, is the non-tail-recursive definition still available if we want to use it for further proofs?</p>
</blockquote>
<p>This approach makes the "official" one not tail recursive, and when you definitionally unfold it and use it in proofs that's what you see. The <code>@[csimp]</code> lemma rewrites the non-tail-recursive function into a tail recursive version (which is also available for proofs, but is not recommended outside the <code>map_eq_mapTR</code> theorem itself) which is intended primarily for compilation. This means that when you use <code>map</code> you get the <code>mapTR</code> implementation in the compiler, but when you reason about it you see only <code>map</code>. This gives us the best of both worlds, and the equality is proven so there is no expansion of the TCB either.</p>



<a name="278731644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278731644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278731644">(Apr 12 2022 at 18:14)</a>:</h4>
<p>This trick is not done in lean 3, but I think the lean 3 interpreter doesn't do TCO so there isn't much point in formulating things as tail recursive</p>



<a name="278989158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/278989158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#278989158">(Apr 14 2022 at 16:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> <a href="#narrow/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22/near/278723632">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> there doesn't seem to be an obvious way to gain access to the theorem that declares this type of replacement is valid right now since it's not implemented as a regular tag attribute but this custom extension based on the name map, could we maybe have a tag attribute that marks the theorem in addition to this map? Or some other way to recover it?</p>
<p>Also since it is not obvious from the declaration that it will be replaced later on I guess it would make sense to mark the declaration that is getting replaced by the compiler later on as well in the docs right? (which is possible right now)</p>
</blockquote>
<p>I could also try and add this myself if the compiler folks are busy doing other stuff (and its desired) of course.</p>



<a name="279081185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/279081185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#279081185">(Apr 15 2022 at 13:44)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Sorry for not responding earlier, I was a bit overwhelmed in the last few days. I will add the missing feature today.</p>



<a name="279081229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/279081229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#279081229">(Apr 15 2022 at 13:44)</a>:</h4>
<p>No worries^^ Usually you just add something the next day whenever you are asked for something, it's perfectly fine to take a bit longer of course xd</p>



<a name="279099462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/279099462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#279099462">(Apr 15 2022 at 16:56)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Added <code>hasCSimpAttribute</code></p>



<a name="279099479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Circumventing%20%22motive%20not%20type-correct%22/near/279099479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Circumventing.20.22motive.20not.20type-correct.22.html#279099479">(Apr 15 2022 at 16:56)</a>:</h4>
<p>\o/</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html">Weird Error with Custom Nat Lits</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235110541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235110541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235110541">(Apr 18 2021 at 23:37)</a>:</h4>
<p>So I was defining a <code>Sort</code>-polymorphic instead of <code>Type</code>-polymorphic nat lit and ran into the following weird error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">OfNatLit</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">ofNatLit</span> <span class="o">:</span> <span class="n">A</span>

<span class="kd">@[defaultInstance low]</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">[</span><span class="n">K</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">A</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNatLit</span> <span class="n">A</span> <span class="n">n</span>
  <span class="o">:=</span> <span class="o">{</span><span class="n">ofNatLit</span> <span class="o">:=</span> <span class="n">K.ofNat</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">[</span><span class="n">K</span> <span class="o">:</span> <span class="n">OfNatLit</span> <span class="n">A</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">A</span> <span class="n">n</span>
  <span class="o">:=</span> <span class="o">{</span><span class="n">ofNat</span> <span class="o">:=</span> <span class="n">K.ofNatLit</span><span class="o">}</span>

<span class="n">abbrev</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="n">OfNatLit</span> <span class="n">A</span> <span class="o">(</span><span class="n">natLit</span><span class="bp">!</span> <span class="mi">0</span><span class="o">)</span>

<span class="c1">-- Before Syntax ovveride: Works as expected on Type</span>
<span class="kd">def</span> <span class="n">fooT</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>

<span class="c1">-- Before Syntax ovveride: Errors as expected on Sort</span>
<span class="kd">def</span> <span class="n">fooS</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">  invalid universe level, ?u.136 is not greater than 0</span>
<span class="cm">-/</span>

<span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">sortNumLit</span><span class="o">)</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">default</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">num</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">macro_rules</span> <span class="o">[</span><span class="n">sortNumLit</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">numLit</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNatLit.ofNatLit</span> <span class="o">(</span><span class="n">natLit</span><span class="bp">!</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="c1">-- After syntax override: Errors unexpectedly w/o type scription</span>
<span class="kd">def</span> <span class="n">fooS'</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">  invalid universe level, ?u.525 is not greater than 0</span>
<span class="cm">-/</span>

<span class="c1">-- After syntax override: But works as expected w/ type ascription</span>
<span class="kd">def</span> <span class="n">fooS''</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div>
<p>Why does <code>0</code> with a type ascription work, but <code>0</code> without one error? This seems like a bug in Lean.</p>



<a name="235115702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235115702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235115702">(Apr 19 2021 at 01:11)</a>:</h4>
<p>btw <code>natLit!</code> has been renamed to <code>nat_lit</code></p>



<a name="235116473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235116473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235116473">(Apr 19 2021 at 01:27)</a>:</h4>
<p>It seems like the updated syntax macro is not triggering. I tried this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="k">show</span> <span class="n">TermElabM</span> <span class="n">Syntax</span> <span class="k">from</span> <span class="k">do</span>
  <span class="n">liftMacroM</span> <span class="bp">&lt;|</span> <span class="n">expandMacros</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="n">term</span><span class="bp">|</span> <span class="n">f</span> <span class="mi">0</span><span class="o">))</span> <span class="c1">-- unknown parser term</span>
<span class="k">#eval</span> <span class="k">show</span> <span class="n">TermElabM</span> <span class="n">Syntax</span> <span class="k">from</span> <span class="k">do</span>
  <span class="n">liftMacroM</span> <span class="bp">&lt;|</span> <span class="n">expandMacros</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">))</span> <span class="c1">-- (Term.app `f._@._hyg.1 [(numLit "0")])</span>
</code></pre></div>
<p>which seems like there isn't any macro expansion happening, but I think I'm not doing it right. <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> help!</p>



<a name="235140521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235140521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235140521">(Apr 19 2021 at 07:45)</a>:</h4>
<p>So as you see in Mario's output (or, even better in general, using <code>pp.raw</code> and <code>trace.Elab</code> options), there is no <code>sortNumLit</code> syntax node to begin with, i.e. the problem is the parser and not the macro. So why would <code>0</code> be parsed differently in <code>f 0</code> and in <code>f (0 : A)</code>? The only sensible answer is precedences: <code>syntax</code> will default to a precedence of <code>lead</code> (which is lower than the "acceptable as an argument" precedence <code>arg</code>) unless the syntax is "atomic-like", which is <a href="https://github.com/leanprover/lean4/blob/1dca9d18d4b303b4fc6c57ff1c44444d92870f5f/src/Lean/Elab/Syntax.lean#L265-L272">necessarily an incomplete heuristic</a>.</p>



<a name="235141493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235141493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235141493">(Apr 19 2021 at 07:56)</a>:</h4>
<p>We could add all <code>*Lit</code> kinds to that heuristic, sure. On the other hand, there isn't really a point in introducing a syntax that is equivalent to an existing one, instead we can add a new macro for the existing syntax. Now, not sure if you already tried that, but it does turn out that there are some limitations with <code>macro_rules</code> that currently make that harder than it should be.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- fails</span>
<span class="n">macro_rules</span> <span class="o">[</span><span class="n">numLit</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">numLit</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNatLit.ofNatLit</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="c1">-- succeeds, but registers macro for the wrong syntax kind</span>
<span class="n">macro_rules</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">numLit</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNatLit.ofNatLit</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="c1">-- the hard way, then</span>
<span class="kd">@[macro numLit]</span> <span class="kd">def</span> <span class="n">expandNumLit'</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">numLit</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNatLit.ofNatLit</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>
  <span class="bp">|</span> <span class="n">_</span>            <span class="bp">=&gt;</span> <span class="n">Lean.Macro.throwUnsupported</span>
</code></pre></div>



<a name="235143027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235143027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235143027">(Apr 19 2021 at 08:10)</a>:</h4>
<p>Do you know why the <code>`(term| ...)</code> syntax doesn't work <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> ?</p>



<a name="235143057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235143057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235143057">(Apr 19 2021 at 08:11)</a>:</h4>
<p>What syntax category is <code>f 0</code> in if not <code>term</code>?</p>



<a name="235148600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235148600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235148600">(Apr 19 2021 at 09:01)</a>:</h4>
<p>The named quotations are currently hard-coded. There isn't one for <code>term</code> since it would be redundant.</p>



<a name="235148646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235148646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235148646">(Apr 19 2021 at 09:01)</a>:</h4>
<p>Generalizing the syntax yields some "interesting" implementation issues with cyclically dependent subsystems</p>



<a name="235225771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235225771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235225771">(Apr 19 2021 at 18:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/235141493">said</a>:</p>
<blockquote>
<p>On the other hand, there isn't really a point in introducing a syntax that is equivalent to an existing one, instead we can add a new macro for the existing syntax.</p>
</blockquote>
<p>Unfortunately, I did not know you could add macros to existing syntax kinds like that. However, looking at it now, there was a reason why I made it a separate syntax. Namely, as far as I am aware, you can't scope macro rules. I really wanted the following (I just eliminated the namespaces in my original example to make a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Test</span>
<span class="n">scoped</span> <span class="n">syntax</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">sortNumLit</span><span class="o">)</span> <span class="o">(</span><span class="n">priority</span> <span class="o">:=</span> <span class="n">default</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">num</span> <span class="o">:</span> <span class="n">term</span>
<span class="n">macro_rules</span> <span class="o">[</span><span class="n">sortNumLit</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">numLit</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNatLit.ofNatLit</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>
<span class="kd">end</span> <span class="n">Test</span>

<span class="kn">open</span> <span class="n">Test</span>
</code></pre></div>
<p>However, the following does also work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Test</span>
<span class="kd">@[scoped macro numLit]</span> <span class="kd">def</span> <span class="n">expandNumLit</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">numLit</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNatLit.ofNatLit</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>
  <span class="bp">|</span> <span class="n">_</span>            <span class="bp">=&gt;</span> <span class="n">Lean.Macro.throwUnsupported</span>
<span class="kd">end</span> <span class="n">Test</span>

<span class="c1">-- Does not work as expected</span>
<span class="kd">def</span> <span class="n">fooS</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>

<span class="kn">open</span> <span class="n">Test</span>

<span class="c1">-- Works as expected</span>
<span class="kd">def</span> <span class="n">fooS'</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Zero</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
</code></pre></div>
<p>So, <strong>thanks!</strong></p>



<a name="235233244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235233244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235233244">(Apr 19 2021 at 19:13)</a>:</h4>
<p>Yes, if we want to go that way, we should add <code>local/scoped macro(_rules)</code></p>



<a name="235918682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235918682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235918682">(Apr 23 2021 at 22:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/235141493">said</a>:</p>
<blockquote>
<p>On the other hand, there isn't really a point in introducing a syntax that is equivalent to an existing one, instead we can add a new macro for the existing syntax.</p>
</blockquote>
<p>I have discovered another good reason to make it new syntax. Overriding <code>numLit</code> breaks the <code>syntax</code> command:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">syntax</span><span class="o">:</span><span class="n">max</span> <span class="o">(</span><span class="n">name</span> <span class="o">:=</span> <span class="n">newNumLit</span><span class="o">)</span> <span class="n">num</span> <span class="o">:</span> <span class="n">term</span>
<span class="kd">@[macro newNumLit]</span>
<span class="kd">def</span> <span class="n">expandNewNumLit</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="c1">-- Works fine</span>
<span class="n">syntax</span> <span class="s2">"foo"</span> <span class="o">:</span> <span class="n">term</span>

<span class="kd">@[macro numLit]</span>
<span class="kd">def</span> <span class="n">expandNumLit</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="c1">-- Now breaks</span>
<span class="n">syntax</span> <span class="s2">"bar"</span> <span class="o">:</span> <span class="n">term</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">maximum recursion depth has been reached (use `set_option maxRecDepth &lt;num&gt;` to increase limit)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="235929087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/235929087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#235929087">(Apr 24 2021 at 01:01)</a>:</h4>
<p>Though I suspect this may be a bug that needs fixing.</p>



<a name="236005014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236005014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236005014">(Apr 24 2021 at 20:55)</a>:</h4>
<p>The macro </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[macro numLit]</span>
<span class="kd">def</span> <span class="n">expandNumLit</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>
</code></pre></div>
<p>triggers nontermination in any term containing a numeral. The elaborator interrupts the "infinite loop" using the maximum recursion depth threshold.<br>
For example, suppose Lean tries to elaborate the numeral <code>2</code>. Your macro expands it to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">2</span><span class="o">))</span>
</code></pre></div>
<p>but <code>2</code> is a subterm of this term, and your macro is applied again, and so on.</p>



<a name="236009877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236009877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236009877">(Apr 24 2021 at 21:43)</a>:</h4>
<p><code>#check 2</code> works for me, which makes sense because <code>2</code> is not a <code>term</code> in <code>nat_lit 2</code>. The issue seems to be the attribute argument <code>@[termParser 1024]</code>, because we eagerly unfold attribute arguments using <code>expandMacros</code>.</p>



<a name="236010314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236010314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236010314">(Apr 24 2021 at 21:49)</a>:</h4>
<p>Thus a simple workaround would be to make the macro an elaborator... but then <code>Lean</code> has to be imported</p>



<a name="236014465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236014465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236014465">(Apr 24 2021 at 22:47)</a>:</h4>
<p>Yes, the macro only causes non-termination if another elaborator or macro invokes <code>expandMacros</code><br>
For example, the <code>match</code>-elaborator uses <code>expandMacros</code> on patterns</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[macro numLit]</span> <span class="kd">def</span> <span class="n">expandNumLit</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>   <span class="c1">-- non-termination</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">false</span>
</code></pre></div>
<p>Here is a minimal example that triggers.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">macro</span> <span class="s2">"tst"</span> <span class="n">x</span><span class="o">:</span><span class="n">num</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">=&gt;</span> <span class="n">Lean.expandMacros</span> <span class="n">x</span>

<span class="kd">@[macro numLit]</span> <span class="kd">def</span> <span class="n">expandNumLit</span> <span class="o">:</span> <span class="n">Lean.Macro</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="n">OfNat.ofNat</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="bp">$</span><span class="n">n</span><span class="o">))</span>

<span class="k">#check</span> <span class="n">tst</span> <span class="mi">2</span>  <span class="c1">-- non-termination</span>
</code></pre></div>
<p>That being said, the problem is the <code>expandNumLit</code> macro that produces a term containing the input term.</p>



<a name="236015302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236015302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236015302">(Apr 24 2021 at 22:59)</a>:</h4>
<blockquote>
<p>#check 2 works for me, which makes sense because 2 is not a term in nat_lit 2</p>
</blockquote>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>  <code>2</code> is a subterm of <code>nat_lit 2</code>. <code>#check 2</code> doesn't loop because the <code>nat_lit</code> elaborator does not invoke <code>elabTerm</code> or <code>expandMacros</code> on the subterm <code>2</code>. </p>
<p>The <code>nat_lit</code> elaborator is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[builtinTermElab rawNatLit]</span> <span class="kd">def</span> <span class="n">elabRawNatLit</span> <span class="o">:</span> <span class="n">TermElab</span> <span class="o">:=</span>  <span class="k">fun</span> <span class="n">stx</span> <span class="n">expectedType</span><span class="bp">?</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">stx</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="bp">.</span><span class="n">isNatLit</span><span class="bp">?</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">val</span> <span class="bp">=&gt;</span> <span class="n">return</span> <span class="n">mkNatLit</span> <span class="n">val</span>
  <span class="bp">|</span> <span class="n">none</span>     <span class="bp">=&gt;</span> <span class="n">throwIllFormedSyntax</span>
</code></pre></div>



<a name="236032581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236032581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236032581">(Apr 25 2021 at 03:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236010314">said</a>:</p>
<blockquote>
<p>Thus a simple workaround would be to make the macro an elaborator... but then <code>Lean</code> has to be imported</p>
</blockquote>
<p>What is the reason that <code>import Lean</code> should be avoided? Back in lean 3 days this would basically always be true, and I've just been doing that whenever it is needed. Is there some hidden performance cost of this?</p>



<a name="236047817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236047817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236047817">(Apr 25 2021 at 08:05)</a>:</h4>
<p>There is no hidden cost, but <code>Lean</code> is simply very big compared to <code>Init</code>, so we are at least concerned about importing performance (and maybe performance of other declaration search parts like completion). Right now <code>import Lean</code> increases import time from 38ms to 380ms for me, which is insignificant for a single file... though keep in mind that all downstream modules will inherit that overhead. All of that would be resolved with <a href="https://github.com/leanprover/lean4/issues/416">https://github.com/leanprover/lean4/issues/416</a>... if we can in fact pull it off.</p>



<a name="236048251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236048251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236048251">(Apr 25 2021 at 08:15)</a>:</h4>
<p>I assume that in files where you actually care about the cost to downstream file imports, you can use a more selective import like <code>import Lean.Elab</code> or what have you? Or is everything mutually dependent enough that this has little advantage?</p>



<a name="236048326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236048326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236048326">(Apr 25 2021 at 08:16)</a>:</h4>
<p>(Coming from lean 3 where import times of 5-10 seconds are not unusual, I'm not particularly put off by a 380ms import time :P )</p>



<a name="236049061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236049061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236049061">(Apr 25 2021 at 08:31)</a>:</h4>
<p>In my experience, there is significant noticeable lag when adding a <code>Lean</code> import when editing in VS Code. I also feel like the response time of the editor decreases somewhat (though not significantly). Though I suspect if most complex metaprogramming requires the whole of Lean to be imported, I imagine most libraries will end up doing so. Thus, I doubt we can really get away from it unless some form of noncumulative/selective importing is introduced (such as the aforementioned module system).</p>



<a name="236049718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236049718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236049718">(Apr 25 2021 at 08:43)</a>:</h4>
<p>If you register your complex tactics as <em>built-in</em> tactics and compile them down to shared libraries (which you might want to do anyway), you can load them as plugins without actually importing their code, or their dependencies. This is the one way we imagined for "escaping" from <code>import Lean</code> without the module system.</p>



<a name="236049808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236049808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236049808">(Apr 25 2021 at 08:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236048251">said</a>:</p>
<blockquote>
<p>I assume that in files where you actually care about the cost to downstream file imports, you can use a more selective import like <code>import Lean.Elab</code> or what have you? Or is everything mutually dependent enough that this has little advantage?</p>
</blockquote>
<p>There aren't too many mutual dependencies between subsystems, but at least with <code>Lean.Elab</code> you do get almost everything (but the language server implementation).</p>



<a name="236049885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236049885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236049885">(Apr 25 2021 at 08:46)</a>:</h4>
<p>IOW, <code>import Lean.Elab</code> is ~310ms</p>



<a name="236050400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236050400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236050400">(Apr 25 2021 at 08:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236049718">said</a>:</p>
<blockquote>
<p>If you register your complex tactics as <em>built-in</em> tactics and compile them down to shared libraries (which you might want to do anyway), you can load them as plugins without actually importing their code, or their dependencies. This is the one way we imagined for "escaping" from <code>import Lean</code> without the module system.</p>
</blockquote>
<p>I guess that mathlib will not be able to escape <code>import Lean</code> then, because even with the mathlib prelude handling the majority of tactics we will still want to write small interactive tactics (that we don't mind being interpreted) inside mathlib itself. What about some kind of "header only" way to import files? I guess you could say that lean 3 did that since most substantial tactics were written in C++ and exposed as <code>constant</code> to lean.</p>



<a name="236050809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236050809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236050809">(Apr 25 2021 at 09:04)</a>:</h4>
<p>I see now that the linked module system issue is also trying to solve this problem, although I want to point out that the requirements of improving <code>import BigDependency</code> inside the server mode, say for proof authoring, are slightly different from separate compilation, and perhaps some problems that arise in the pursuit of separate compilation aren't as big of a deal when simply making it possible to write interpreted tactics calling lean builtins.</p>



<a name="236067560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236067560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236067560">(Apr 25 2021 at 13:59)</a>:</h4>
<p><code>builtinTactic</code> <em>is</em> such a header system in absence of a true module system. It allows you to use builtin tactics in macros without importing them. If you need a procedural tactic, you have to import at least <code>Lean.Elab.Tactic.Basic</code> anyway (which currently clocks in at ~170ms), in which case you can use <code>evalTactic</code> together with a syntax quotation of the builtin tactic to call it, still without actually importing it.</p>



<a name="236068193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Weird%20Error%20with%20Custom%20Nat%20Lits/near/236068193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits.html#236068193">(Apr 25 2021 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236050809">said</a>:</p>
<blockquote>
<p>although I want to point out that the requirements of improving <code>import BigDependency</code> inside the server mode</p>
</blockquote>
<p>I should probably clarify that I don't see improving server mode as a concern for the module system, since imports are fast enough for that anyway as we said above. In fact, I could imagine that we would want to lift some import restriction in server mode so that we can still <code>#eval</code> arbitrary things and e.g. show completion items that would automatically insert necessary additional imports (though ideally in a way that code outside from <code>#eval</code> would still only be accepted if it was also accepted in batch mode; that part might be a bit tricky).  <em>If</em> libraries like mathlib want to embrace the module system, the main benefit would still be separate compilation: rebuilding as few files of it as possible on (most) changes.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/index.html">lean4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html">Use recursor within inductive def</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="248810473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248810473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248810473">(Aug 09 2021 at 06:28)</a>:</h4>
<p>Perhaps the answer to this question is very type-theoretical, but why can't I use an inductive type's recursor within its own definition?<br>
E.g., if I try:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">X</span>
  <span class="bp">|</span> <span class="n">base</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">next</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x.rec</span> <span class="o">(</span><span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">false</span><span class="o">))</span>
</code></pre></div>
<p>I get an error telling me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span> <span class="n">type</span> <span class="n">is</span> <span class="n">not</span> <span class="n">of</span> <span class="n">the</span> <span class="n">form</span> <span class="o">(</span><span class="n">C</span> <span class="bp">...</span><span class="o">)</span> <span class="n">where</span> <span class="n">C</span> <span class="n">is</span> <span class="n">a</span> <span class="kd">constant</span>
  <span class="n">x</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">X</span>
</code></pre></div>
<p>Is it because that would make the recursor recursive (<span aria-label="drum" class="emoji emoji-1f941" role="img" title="drum">:drum:</span>)? Because it would have to know about its own definition in order to be defined?</p>



<a name="248811323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811323">(Aug 09 2021 at 06:46)</a>:</h4>
<p>the boring answer is that this is not allowed by the inductive definition schema</p>



<a name="248811338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811338">(Aug 09 2021 at 06:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def/near/248811323">said</a>:</p>
<blockquote>
<p>the boring answer is that this is not allowed by the inductive definition schema</p>
</blockquote>
<p>Good enough for me ¯\_(ツ)_/¯</p>



<a name="248811364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811364">(Aug 09 2021 at 06:47)</a>:</h4>
<p>Can this be circumvented by using an inductive family somehow?</p>



<a name="248811380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811380">(Aug 09 2021 at 06:47)</a>:</h4>
<p>I don't think this is a higher inductive type - even HITs don't let you reference the recursor in the constructors because that almost certainly leads to the liar paradox somehow</p>



<a name="248811429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811429">(Aug 09 2021 at 06:48)</a>:</h4>
<p>not to mention, what does the recursor's type even look like? it has to reference itself</p>



<a name="248811446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811446">(Aug 09 2021 at 06:49)</a>:</h4>
<p>Maybe you could start with a description of what you want to do</p>



<a name="248811469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811469">(Aug 09 2021 at 06:49)</a>:</h4>
<p>in the example, you are saying you want <code>x</code> to be a <code>base</code>, but in that cause the parameter could just be a <code>Nat</code></p>



<a name="248811573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811573">(Aug 09 2021 at 06:51)</a>:</h4>
<p>We have in fact had a <a href="#narrow/stream/113489-new-members/topic/Inductive.20type.20nesting/near/246821608">discussion</a> on this before :D.</p>



<a name="248811769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811769">(Aug 09 2021 at 06:54)</a>:</h4>
<p>I want to define this cycle of mutually inductive types <code>MutationOutput</code>, <code>Mutation</code>, <code>Reaction</code>, <code>Reactor</code>, <code>Network</code>. <br>
Using Lean 4 seems to fix the issue with nested inductives. </p>
<p>Now my only problem is that (e.g.) <code>Reaction</code> takes an instance of <code>Mutation</code> in its constructor, but also should impose constraints on this instance.</p>



<a name="248811832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811832">(Aug 09 2021 at 06:55)</a>:</h4>
<p>In a more MWE-syle this would be (basically):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>

<span class="kd">inductive</span> <span class="n">A</span>
  <span class="bp">|</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">next</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">B</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a.rec</span> <span class="o">(</span><span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">true</span><span class="o">))</span>

<span class="kd">inductive</span> <span class="n">C</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">D</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="248811984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248811984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248811984">(Aug 09 2021 at 06:58)</a>:</h4>
<p>I think I might be able to work around this though by ignoring all of these kinds of constraints at first and then defining a type (e.g.)  <code>ProperReactor</code> which imposes all of these constraints on its contained instances (if that makes sense).</p>



<a name="248812101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812101">(Aug 09 2021 at 07:00)</a>:</h4>
<p>what kind of constraints?</p>



<a name="248812134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812134">(Aug 09 2021 at 07:00)</a>:</h4>
<p>The general case of this is called an inductive-recursive type, where the constraint is a recursive function defined on the other inductive</p>



<a name="248812151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812151">(Aug 09 2021 at 07:01)</a>:</h4>
<p>but if it's a simple function you might be able to write it another way</p>



<a name="248812178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812178">(Aug 09 2021 at 07:01)</a>:</h4>
<p>the examples where you say that it has to be just one variant can be rephrased so that you just take the arguments to that variant instead of the inductive argument itself</p>



<a name="248812246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812246">(Aug 09 2021 at 07:02)</a>:</h4>
<p>i.e.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>

<span class="kd">inductive</span> <span class="n">A</span>
  <span class="bp">|</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">next</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">B</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">C</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">D</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="248812294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812294">(Aug 09 2021 at 07:03)</a>:</h4>
<p>if it can be multiple variants, you can still do it with a <code>ProperA</code> type expressing the conjunction of <code>A</code> and the constraints</p>



<a name="248812470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248812470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248812470">(Aug 09 2021 at 07:06)</a>:</h4>
<p>Ok the strategy for this simple example definitely makes sense. I'll try to come up with an MWE that's a bit closer to my real-world use case.</p>



<a name="248813293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248813293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248813293">(Aug 09 2021 at 07:20)</a>:</h4>
<p>Ok, probably not a <em>working</em> example, but I hope it's sufficient.</p>
<p><code>Mutation</code> defines a function <code>body</code> that produces a <code>MutationOutput</code>.<br>
The output of this function should be constrained (<code>outPrtValsDepOnly</code>) depending the mutation's own <code>deps</code>.<br>
Note, for simplicity in this example, I've expressed <code>outPrtValsDepOnly </code> as if <code>MutationOutput</code> were a simple structure - i.e. I haven't used <code>(body i s).rec ...</code> and just wrote the <code>(body i s).prtVals</code> directly.</p>
<p>Now a <code>Reaction</code> should extend a <code>Mutation</code> by further constraining the output of its <code>body</code> (via <code>noNewCns</code>).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>

<span class="kd">inductive</span> <span class="n">MutationOutput</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">prtVals</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">state</span>   <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">newCns</span>  <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">×</span> <span class="n">ι</span><span class="o">))</span>
    <span class="o">(</span><span class="n">newRcns</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">Reaction</span><span class="o">))</span>

<span class="kd">inductive</span> <span class="n">Mutation</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">deps</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">body</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">MutationOutput</span><span class="o">)</span>
    <span class="o">(</span><span class="n">outPrtValsDepOnly</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">s</span> <span class="o">{</span><span class="n">o</span><span class="o">},</span> <span class="o">(</span><span class="n">o</span> <span class="bp">∉</span> <span class="n">deps</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">body</span> <span class="n">i</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">prtVals.nth</span> <span class="n">o</span> <span class="bp">=</span> <span class="n">none</span><span class="o">))</span>

<span class="kd">inductive</span> <span class="n">Reaction</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">core</span> <span class="o">:</span> <span class="n">Mutation</span><span class="o">)</span>
    <span class="o">(</span><span class="n">noNewCns</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">core.body</span> <span class="n">i</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">newCns</span> <span class="bp">=</span> <span class="o">[])</span>

<span class="kd">end</span>
</code></pre></div>



<a name="248813590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248813590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248813590">(Aug 09 2021 at 07:25)</a>:</h4>
<p>So basically these types should all feel like structures. But their mutual inductive nature makes it not so.</p>



<a name="248813987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248813987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248813987">(Aug 09 2021 at 07:31)</a>:</h4>
<p>you forgot to define or import <code>∉</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">notin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">infix</span><span class="o">:</span><span class="mi">50</span> <span class="s2">"∉"</span> <span class="bp">=&gt;</span> <span class="n">notin</span>
</code></pre></div>



<a name="248814072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248814072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248814072">(Aug 09 2021 at 07:32)</a>:</h4>
<p>Oh it could just as well be <code>∈</code> here - I've totally butchered the original definition anyway ^^</p>



<a name="248814523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248814523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248814523">(Aug 09 2021 at 07:40)</a>:</h4>
<p>Here's a reduction to eliminate the extra hypotheses:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">mutual</span>

<span class="kd">inductive</span> <span class="n">MutationOutput</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="n">deps</span><span class="o">}</span>
    <span class="o">(</span><span class="n">prtVals</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">state</span>   <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">newCns</span>  <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">×</span> <span class="n">ι</span><span class="o">))</span>
    <span class="o">(</span><span class="n">newRcns</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Reaction</span><span class="o">)</span>
    <span class="o">(</span><span class="n">outPrtValsDepOnly</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">s</span> <span class="o">{</span><span class="n">o</span><span class="o">},</span> <span class="o">(</span><span class="n">o</span> <span class="bp">∉</span> <span class="n">deps</span><span class="o">)</span> <span class="bp">→</span> <span class="n">prtVals.nth</span> <span class="n">o</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span>
    <span class="o">(</span><span class="n">noNewCns</span>  <span class="o">:</span> <span class="n">newCns</span> <span class="bp">=</span> <span class="o">[])</span>
    <span class="o">:</span> <span class="n">MutationOutput</span> <span class="n">deps</span>

<span class="kd">inductive</span> <span class="n">Mutation</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">mk</span>
    <span class="o">(</span><span class="n">deps</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">ι</span><span class="o">)</span>
    <span class="o">(</span><span class="n">body</span> <span class="o">:</span> <span class="n">List</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">MutationOutput</span> <span class="n">deps</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Reaction</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">core</span> <span class="o">:</span> <span class="n">Mutation</span><span class="o">)</span>

<span class="kd">end</span>
</code></pre></div>



<a name="248814562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248814562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248814562">(Aug 09 2021 at 07:41)</a>:</h4>
<p>but I think you might want to consider another approach here, which applies the well formedness conditions outside the types</p>



<a name="248816824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248816824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248816824">(Aug 09 2021 at 08:14)</a>:</h4>
<p>Yeah, that's what I was guessing.</p>



<a name="248816835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248816835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248816835">(Aug 09 2021 at 08:14)</a>:</h4>
<p>Thanks for your help!</p>



<a name="248951256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248951256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248951256">(Aug 10 2021 at 08:11)</a>:</h4>
<p>I'm still having problems with these damned mutual inductives <span aria-label="see no evil" class="emoji emoji-1f648" role="img" title="see no evil">:see_no_evil:</span><br>
In the following example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">List.isSetoid</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">Multiset.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">Quotient</span> <span class="o">(</span><span class="n">List.isSetoid</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">mutual</span>

<span class="kd">inductive</span> <span class="n">Mutation</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Reactor</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">Multiset</span> <span class="o">(</span><span class="n">Mutation</span> <span class="n">ι</span><span class="o">))</span>

<span class="kd">end</span>
</code></pre></div>
<p>I get the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">kernel</span><span class="o">)</span> <span class="n">arg</span> <span class="bp">#</span><span class="mi">2</span> <span class="n">of</span> <span class="bp">'</span><span class="n">_nested.Finmap_1.mk'</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">non</span> <span class="n">valid</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="n">the</span> <span class="n">datatypes</span> <span class="n">being</span> <span class="n">declared</span>
</code></pre></div>
<p>If I define <code>Multiset</code> using a <code>sorry</code> instead of <code>Quotient</code>, the problem disappears.<br>
Does this mean that Lean can't handle the nested inductive in <code>Reactor.mk</code> because <code>Multiset</code> is a quotient type?</p>



<a name="248951475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248951475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248951475">(Aug 10 2021 at 08:14)</a>:</h4>
<p>did you make the <code>List.isSetoid</code> instance or is that still a <code>sorry</code>? That may cause issues</p>



<a name="248951499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248951499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248951499">(Aug 10 2021 at 08:14)</a>:</h4>
<p>That's still a sorry.</p>



<a name="248951674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248951674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248951674">(Aug 10 2021 at 08:17)</a>:</h4>
<p>A fully sorry-free version has the issue too though:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">List.perm</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">nil</span>   <span class="o">:</span> <span class="n">perm</span> <span class="o">[]</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">cons</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">},</span> <span class="n">perm</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">l₂</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">swap</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span> <span class="n">perm</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">x</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">l</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">},</span> <span class="n">perm</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">perm</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="bp">→</span> <span class="n">perm</span> <span class="n">l₁</span> <span class="n">l₃</span>

<span class="kd">infix</span><span class="o">:</span><span class="mi">50</span> <span class="s2">" ~ "</span> <span class="bp">=&gt;</span> <span class="n">List.perm</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">List.perm.refl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span> <span class="n">l</span> <span class="bp">~</span> <span class="n">l</span>
  <span class="bp">|</span> <span class="o">[]</span>      <span class="bp">=&gt;</span> <span class="n">perm.nil</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">perm.refl</span> <span class="n">xs</span><span class="o">)</span><span class="bp">.</span><span class="n">cons</span> <span class="n">x</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">List.perm.symm</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₂</span> <span class="bp">~</span> <span class="n">l₁</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">p</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">nil</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">_</span> <span class="n">p</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">p</span>
  <span class="bp">|</span> <span class="n">swap</span> <span class="n">x</span> <span class="n">y</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">swap</span> <span class="n">y</span> <span class="n">x</span> <span class="n">l</span>
  <span class="bp">|</span> <span class="n">trans</span> <span class="n">_</span> <span class="n">_</span> <span class="n">p₁</span> <span class="n">p₂</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">trans</span> <span class="n">p₂</span> <span class="n">p₁</span>

<span class="kd">theorem</span> <span class="n">List.perm.eqv</span> <span class="o">:</span> <span class="n">Equivalence</span> <span class="o">(</span><span class="bp">@</span><span class="n">perm</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">refl</span> <span class="o">:=</span> <span class="n">perm.refl</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="n">perm.symm</span>
  <span class="n">trans</span> <span class="o">:=</span> <span class="n">perm.trans</span>

<span class="kd">instance</span> <span class="n">List.isSetoid</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Setoid</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Setoid.mk</span> <span class="n">_</span> <span class="n">perm.eqv</span>
</code></pre></div>



<a name="248952839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248952839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248952839">(Aug 10 2021 at 08:30)</a>:</h4>
<p>so I tried doing this defn in lean3, and it even though it has the same code for dealing with positivity issues, it actually complains about universes instead -- maybe that's the real issue that's getting obfuscated?</p>



<a name="248953260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248953260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248953260">(Aug 10 2021 at 08:36)</a>:</h4>
<p>What do you mean by "positivity issues"?</p>



<a name="248953640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248953640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248953640">(Aug 10 2021 at 08:40)</a>:</h4>
<p>the error comes from <a href="https://github.com/leanprover/lean4/blob/e20a07bd6dd030cd94d42c240dd97310fa409c4f/src/kernel/inductive.cpp#L341">this line</a>, which tries to check that all terms in an inductive type's constructor are "positive"</p>



<a name="248953660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248953660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248953660">(Aug 10 2021 at 08:40)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> covers this somewhere very briefly and links to a specific paper about it (e: <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html?highlight=positivity">here</a>)</p>



<a name="248953901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248953901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248953901">(Aug 10 2021 at 08:43)</a>:</h4>
<p>Lean implements nested inductive types by translating them to mutually inductive types, but <code>Quotient</code> is not an inductive type, so this translation is not possible</p>



<a name="248954003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248954003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248954003">(Aug 10 2021 at 08:45)</a>:</h4>
<p>Basically, all types involved in the recursion must either be unfoldable or appropriate inductive types, but <code>Quot</code> is a <code>constant</code></p>



<a name="248958560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Use%20recursor%20within%20inductive%20def/near/248958560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marcus Rossel <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Use.20recursor.20within.20inductive.20def.html#248958560">(Aug 10 2021 at 09:44)</a>:</h4>
<p>Oh no, I'll have to do some trickery then. <br>
Thanks y'all for the help!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
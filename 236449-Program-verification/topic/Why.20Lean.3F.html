---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236449-Program-verification/topic/Why.20Lean.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/index.html">Program verification</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html">Why Lean?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210527879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210527879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210527879">(Sep 18 2020 at 14:40)</a>:</h4>
<p>So as some may know I'm sort of beginning my first real research project by trying to use Lean for some assurance case verification. I'm at the point in the project where I have to decide whether I want to keep investing more time in Lean, or migrate to something like Coq, and to be able to defend my choice.</p>
<p>I'm still new to verification/FM, and my experience in Coq is limited to the first volume of SF, so I'm hoping I might be able to get some input from people with more experience in using theorem provers for verification. Does Lean have any advantages compared to Coq for this purpose? Does it have any technical disadvantages, aside from simply being a much younger system? What else would I probably want to consider in choosing between the two?</p>



<a name="210529533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210529533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210529533">(Sep 18 2020 at 14:50)</a>:</h4>
<p>If you are not planning to use an existing verification library or work with a team that already has a codebase, I think it's a pretty free choice. There is not any feature in either Coq or Lean which is specifically tuned for program verification</p>



<a name="210529652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210529652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210529652">(Sep 18 2020 at 14:51)</a>:</h4>
<p>but you can just do it like regular mathematics, with possibly a bit more inductive types than would be common in mathematics</p>



<a name="210535090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210535090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210535090">(Sep 18 2020 at 15:24)</a>:</h4>
<p>As Mario says, the libraries can be a big factor. A lot of verification work has been done in Coq so the ecosystem there is richer. On my side, I prefer the tooling and language of Lean. The language, as you say, is younger. Whereas Coq got to explore the design space more (e.g. with canonical structures vs modules vs type classes), Lean committed right away to a design with type classes. I find that libraries are easier to write and use in Lean. You might want to discover for yourself how comfortable you are with the tooling and language and try solving the SF problems in Lean for comparison. (unfortunately, there's no complete draft of SF in Lean yet, it's still in progress)</p>



<a name="210535237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210535237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210535237">(Sep 18 2020 at 15:25)</a>:</h4>
<p>where is that draft?</p>



<a name="210535895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210535895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210535895">(Sep 18 2020 at 15:30)</a>:</h4>
<p><a href="https://github.com/alashworth/sf-lean/">https://github.com/alashworth/sf-lean/</a></p>



<a name="210615373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210615373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210615373">(Sep 19 2020 at 13:31)</a>:</h4>
<p>Lean's primary advantages, in my eyes, are much less idiosyncratic metaprogramming, mathlib and this chatroom. There are a few other differences (syntax, tooling, dependent pattern matching, definitional propositional extensionality, definitional reduction for quotients, pervasive use of classical logic, the handling of universes), but none of them strike me as particularly important.</p>
<p>So unless you plan to write complicated tactics or need the mathematics in mathlib, I'd go with Coq. It has less bugs, better reference and tutorial documentation, more libraries, more tactics and is generally much more polished. Lean is still very much in the research phase; particularly Lean 3, which will hopefully be obsolete soon.</p>



<a name="210615804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210615804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210615804">(Sep 19 2020 at 13:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> <a href="#narrow/stream/236449-Program-verification/topic/Why.20Lean.3F/near/210615373">said</a>:</p>
<blockquote>
<p>Lean is still very much in the research phase; particularly Lean 3, which will hopefully be obsolete soon.</p>
</blockquote>
<p>Indeed, as soon as Lean 4 is released, we hope to continue our research phase there (-;</p>



<a name="210801965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Why%20Lean%3F/near/210801965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Why.20Lean.3F.html#210801965">(Sep 21 2020 at 21:23)</a>:</h4>
<p>The strengths of Lean for me have been easy metaprogramming, relatively easy to understand implementation, and C interop.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
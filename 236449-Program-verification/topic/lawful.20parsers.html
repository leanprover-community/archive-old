---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236449-Program-verification/topic/lawful.20parsers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/index.html">Program verification</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html">lawful parsers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219419246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219419246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219419246">(Dec 10 2020 at 00:30)</a>:</h4>
<p>Is there a parser (that is used) that violates this condition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.cast</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="kn">open</span> <span class="n">parse_result</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">err</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">string</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">valid_parser_of_fail</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">err</span><span class="o">,</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="219419387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219419387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219419387">(Dec 10 2020 at 00:32)</a>:</h4>
<p>The larger <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> is trying to prove the following somewhat-definitional lemma about the alternative definition on parsers. I have the associated one done for <code>done</code> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">orelse_eq_done</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&lt;|&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">done</span> <span class="n">n'</span> <span class="n">a</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">done</span> <span class="n">n'</span> <span class="n">a</span> <span class="bp">∨</span> <span class="o">((</span><span class="bp">∃</span> <span class="n">err</span><span class="o">,</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n</span> <span class="n">err</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">done</span> <span class="n">n'</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>but have hit a snag on the case shown below for the <code>fail</code> case. If this the validity statement above is true, the whole proof can be much simpler. But I've identified precisely where I hit a contradiction when there is no validity guarantee.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Longer proof</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.cast</span>
<span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="kn">open</span> <span class="n">parse_result</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">err</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">string</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">valid_parser_of_fail</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">err</span><span class="o">,</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">orelse_eq_orelse</span> <span class="o">:</span> <span class="n">p.orelse</span> <span class="n">q</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&lt;|&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">orelse_eq_fail_le</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&lt;|&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span><span class="o">)</span> <span class="o">:</span> <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">orelse_eq_orelse</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">,</span> <span class="n">exists_and_distrib_left</span><span class="o">],</span>
  <span class="n">set</span> <span class="n">P</span> <span class="o">:</span> <span class="n">parse_result</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="k">with</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="k">with</span> <span class="n">posp</span> <span class="n">resp</span> <span class="n">posp</span> <span class="n">errp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">,</span> <span class="n">exists_false</span><span class="o">,</span> <span class="n">or_self</span><span class="o">,</span> <span class="n">and_false</span><span class="o">,</span> <span class="n">hP</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">posp</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">parser.orelse</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">not_true</span><span class="o">,</span> <span class="n">if_false</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span>
               <span class="n">and_true</span><span class="o">,</span> <span class="n">false_or</span><span class="o">,</span> <span class="n">exists_eq'</span><span class="o">,</span> <span class="n">false_and</span><span class="o">,</span> <span class="n">hP</span><span class="o">],</span>
    <span class="n">cases</span> <span class="n">q</span> <span class="n">cb</span> <span class="n">n</span> <span class="k">with</span> <span class="n">posq</span> <span class="n">resq</span> <span class="n">posq</span> <span class="n">errq</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">],</span>
      <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">H</span> <span class="n">H'</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ne_of_lt</span> <span class="n">h</span><span class="o">],</span> <span class="o">},</span>
      <span class="o">{</span>
        <span class="k">have</span> <span class="o">:</span> <span class="n">posq</span> <span class="bp">≠</span> <span class="n">n'</span> <span class="o">:=</span> <span class="n">ne_of_lt</span> <span class="o">(</span><span class="n">lt_trans</span> <span class="n">H'</span> <span class="n">h</span><span class="o">),</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">iff_self</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">posq</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_of_not_lt</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">le_of_not_lt</span> <span class="n">H'</span><span class="o">),</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">ne_of_lt</span> <span class="n">h</span><span class="o">,</span> <span class="n">this</span><span class="o">,</span> <span class="n">false_and</span><span class="o">],</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">posp</span> <span class="n">n'</span> <span class="k">with</span> <span class="n">H</span><span class="bp">|</span><span class="n">H</span><span class="bp">|</span><span class="n">H</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">ne_of_lt</span> <span class="n">H</span><span class="o">,</span> <span class="n">hP</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="bp">←</span><span class="n">H</span><span class="o">],</span>
      <span class="c1">-- this is the case where p cb n = p posp errp, and posp = n',</span>
      <span class="c1">-- so err should equal errp, since by defn of (p cb n &lt;|&gt;) propagates</span>
      <span class="c1">-- the errp to equal err when n ≠ posp</span>
      <span class="c1">-- this case needs valid_parser_if fail to show that the `err`s MUST match</span>
      <span class="c1">-- and somehow prove this false</span>
      <span class="c1">-- by already knowing that n' ≤ n</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">apply</span> <span class="n">valid_parser_of_fail</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span><span class="o">,</span>
          <span class="n">use</span> <span class="n">errp</span><span class="o">,</span>
          <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">H</span><span class="o">,</span> <span class="bp">←</span><span class="n">hP</span><span class="o">]</span> <span class="o">},</span>
      <span class="n">exact</span> <span class="n">absurd</span> <span class="n">this</span> <span class="o">(</span><span class="n">not_le_of_lt</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">parser.orelse</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">ne_of_gt</span> <span class="n">H</span><span class="o">,</span> <span class="n">hP</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="219419541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219419541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219419541">(Dec 10 2020 at 00:35)</a>:</h4>
<p>If there is a more appropriate stream, like <a class="stream" data-stream-id="239415" href="/#narrow/stream/239415-metaprogramming-.2F-tactics">#metaprogramming / tactics</a> , please let me know.</p>



<a name="219419575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219419575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219419575">(Dec 10 2020 at 00:35)</a>:</h4>
<p>The even larger <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> is trying to parse directly into subtypes, which requires proofs that a particular parser is unable to produce certain states.</p>



<a name="219419690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219419690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219419690">(Dec 10 2020 at 00:37)</a>:</h4>
<p>Of course, the subtype problem doesn't require a clear proof about how consistently <code>orelse</code> produces <code>fail</code> states, but I'm trying to be thorough in building out the theory.</p>



<a name="219446562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219446562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219446562">(Dec 10 2020 at 09:07)</a>:</h4>
<p>Of course <code>parser</code> has no such assumption, so there are parsers that fail it</p>



<a name="219446991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219446991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219446991">(Dec 10 2020 at 09:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_valid_parser_of_fail</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">err</span><span class="o">,</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span><span class="o">),</span> <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="bp">@</span><span class="n">H</span> <span class="n">unit</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">fail</span> <span class="mi">1</span> <span class="n">dlist.empty</span><span class="o">)</span> <span class="n">buffer.nil</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>



<a name="219447362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447362">(Dec 10 2020 at 09:15)</a>:</h4>
<p>Thanks. So I have defined a separate Prop that can label a <code>parser</code> as <code>valid</code> in this way, and, for example, have that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">valid</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">⦃</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">⦄</span> <span class="o">⦃</span><span class="n">n</span> <span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">⦄</span> <span class="o">⦃</span><span class="n">err</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">string</span><span class="o">⦄,</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span> <span class="bp">→</span> <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">orelse_valid</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p.valid</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q.valid</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&lt;|&gt;</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">valid</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="219447530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447530">(Dec 10 2020 at 09:17)</a>:</h4>
<p>But are there parsers that are in use often that break this assumption? <code>failure</code> is <code>valid</code>, for example. One could write a parser that always fails, and reports the error as having had occurred at a position greater than what was queried. But are such parsers useful, or are totally pathological?</p>



<a name="219447577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447577">(Dec 10 2020 at 09:17)</a>:</h4>
<p>I was surprised to see that <code>decorate_error(s)</code> completely ignores where the error has occurred, and instead reports the error at the position of the query.</p>



<a name="219447667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447667">(Dec 10 2020 at 09:18)</a>:</h4>
<p>er, actually that condition is the wrong way around, reasonable parsers do this all the time</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_valid_parser_of_fail</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">err</span><span class="o">,</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span><span class="o">),</span> <span class="n">n'</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="bp">@</span><span class="n">H</span> <span class="n">unit</span> <span class="o">(</span><span class="n">parser.sat</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="bp">&gt;&gt;</span> <span class="n">failure</span><span class="o">)</span> <span class="o">[</span><span class="sc">' '</span><span class="o">]</span><span class="bp">.</span><span class="n">to_buffer</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>
</code></pre></div>



<a name="219447736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447736">(Dec 10 2020 at 09:19)</a>:</h4>
<p>So, for <code>decorate_error msg p cb n = fail n' err -&gt; n = n'</code></p>



<a name="219447826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447826">(Dec 10 2020 at 09:19)</a>:</h4>
<p>It seems more likely that valid parsers satisfy <code> p cb n = fail n' err -&gt; n &lt;= n'</code></p>



<a name="219447973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447973">(Dec 10 2020 at 09:21)</a>:</h4>
<p>the return value is supposed to mean "I was successful up to here" so it makes sense that you wouldn't go before the start point</p>



<a name="219447999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219447999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219447999">(Dec 10 2020 at 09:21)</a>:</h4>
<p>Yes, <code>valid</code> is not propagated across any <code>&gt;&gt;=</code> operation, because in a <code>p &gt;&gt;= f</code> situation, <code>p</code> can succeed and move the cursor forward, and then the failure is at <code>f</code>.</p>



<a name="219448003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448003">(Dec 10 2020 at 09:21)</a>:</h4>
<p>Hmm.</p>



<a name="219448065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448065">(Dec 10 2020 at 09:22)</a>:</h4>
<p>I have a proof of the following statement, so I need to think about how to modify it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">orelse_eq_fail_lt</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n'</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&lt;|&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span><span class="o">)</span> <span class="bp">∨</span>
  <span class="o">(</span><span class="n">q</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n'</span> <span class="n">err</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">errp</span><span class="o">),</span> <span class="n">p</span> <span class="n">cb</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">fail</span> <span class="n">n</span> <span class="n">errp</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="219448170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448170">(Dec 10 2020 at 09:23)</a>:</h4>
<p>a valid parser should never have the hypothesis hn</p>



<a name="219448367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448367">(Dec 10 2020 at 09:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">orelse</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">input</span> <span class="n">pos</span><span class="o">,</span> <span class="k">match</span> <span class="n">p</span> <span class="n">input</span> <span class="n">pos</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="n">expected₁</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">pos₁</span> <span class="bp">≠</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="n">expected₁</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">q</span> <span class="n">input</span> <span class="n">pos</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">parse_result.fail</span> <span class="n">pos₂</span> <span class="n">expected₂</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">pos₁</span> <span class="bp">&lt;</span> <span class="n">pos₂</span> <span class="k">then</span>
      <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="n">expected₁</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">pos₂</span> <span class="bp">&lt;</span> <span class="n">pos₁</span> <span class="k">then</span>
      <span class="n">parse_result.fail</span> <span class="n">pos₂</span> <span class="n">expected₂</span> <span class="c1">-- this is the case that you say should never be valid, correct?</span>
    <span class="k">else</span> <span class="c1">-- pos₁ = pos₂</span>
      <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="o">(</span><span class="n">expected₁</span> <span class="bp">++</span> <span class="n">expected₂</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">ok</span>
  <span class="kd">end</span>
  <span class="bp">|</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">ok</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219448557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448557">(Dec 10 2020 at 09:27)</a>:</h4>
<p>I find it easier to understand after I rewrite <code>pos1</code> as <code>pos</code> in the <code>pos1 = pos</code> branch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">orelse</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">input</span> <span class="n">pos</span><span class="o">,</span> <span class="k">match</span> <span class="n">p</span> <span class="n">input</span> <span class="n">pos</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="n">expected₁</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">pos₁</span> <span class="bp">≠</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="n">expected₁</span> <span class="k">else</span>
  <span class="k">match</span> <span class="n">q</span> <span class="n">input</span> <span class="n">pos</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">parse_result.fail</span> <span class="n">pos₂</span> <span class="n">expected₂</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="bp">&lt;</span> <span class="n">pos₂</span> <span class="k">then</span>
      <span class="n">parse_result.fail</span> <span class="n">pos₁</span> <span class="n">expected₁</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">pos₂</span> <span class="bp">&lt;</span> <span class="n">pos</span> <span class="k">then</span>
      <span class="n">parse_result.fail</span> <span class="n">pos₂</span> <span class="n">expected₂</span> <span class="c1">-- this is the case that you say should never be valid, correct?</span>
    <span class="k">else</span> <span class="c1">-- pos = pos₂</span>
      <span class="n">parse_result.fail</span> <span class="n">pos</span> <span class="o">(</span><span class="n">expected₁</span> <span class="bp">++</span> <span class="n">expected₂</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">ok</span>
  <span class="kd">end</span>
  <span class="bp">|</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">ok</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219448570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448570">(Dec 10 2020 at 09:27)</a>:</h4>
<p>I suggest</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">parse_result.pos</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">parse_result</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">parse_result.done</span> <span class="n">pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pos</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">parse_result.fail</span> <span class="n">pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pos</span>

<span class="kd">def</span> <span class="n">parser.valid</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">⦄</span> <span class="o">⦃</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">⦄,</span>
<span class="k">let</span> <span class="n">res</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span> <span class="k">in</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">res</span> <span class="bp">∧</span> <span class="n">res</span> <span class="bp">≤</span> <span class="n">cb.size</span>
</code></pre></div>



<a name="219448774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448774">(Dec 10 2020 at 09:29)</a>:</h4>
<p>yes, that branch looks like it should not happen</p>



<a name="219448872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448872">(Dec 10 2020 at 09:30)</a>:</h4>
<p>But that's the core Lean definition, so in trying to write a simplifying iff lemma for <code>(p &lt;|&gt; q) cb n = fail n' err</code> I need to figure out how to represent that branch.</p>



<a name="219448928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448928">(Dec 10 2020 at 09:30)</a>:</h4>
<p>Oh, another property you can claim is that the parser is extensional wrt values of the char_buffer before <code>n</code></p>



<a name="219448968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219448968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219448968">(Dec 10 2020 at 09:31)</a>:</h4>
<p>Your simplification lemma should assume <code>p</code> and <code>q</code> are valid</p>



<a name="219449029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449029">(Dec 10 2020 at 09:31)</a>:</h4>
<p>as long as every core parser satisfies the validity predicate you are licensed to assume it even if it's not in the type</p>



<a name="219449046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449046">(Dec 10 2020 at 09:31)</a>:</h4>
<p>Thanks, this is very helpful.</p>



<a name="219449104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449104">(Dec 10 2020 at 09:32)</a>:</h4>
<p>Worth PRing in some part of mathlib, or too program verification-y?</p>



<a name="219449123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449123">(Dec 10 2020 at 09:32)</a>:</h4>
<p>I don't see why those are mutually exclusive</p>



<a name="219449157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449157">(Dec 10 2020 at 09:32)</a>:</h4>
<p>I think it would certainly be useful</p>



<a name="219449160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449160">(Dec 10 2020 at 09:33)</a>:</h4>
<p>Good to know</p>



<a name="219449188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449188">(Dec 10 2020 at 09:33)</a>:</h4>
<p>I was surprised I couldn't find this anywhere:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">asum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">alternative</span> <span class="n">m</span><span class="o">]</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">m</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">m</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">xs.foldl</span> <span class="o">(</span><span class="bp">&lt;|&gt;</span><span class="o">)</span> <span class="n">failure</span>
</code></pre></div>



<a name="219449192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449192">(Dec 10 2020 at 09:33)</a>:</h4>
<p>have you seen <code>data.hash_map</code>?</p>



<a name="219449220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449220">(Dec 10 2020 at 09:33)</a>:</h4>
<p>I think that's called <code>mfirst</code></p>



<a name="219449289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449289">(Dec 10 2020 at 09:34)</a>:</h4>
<p>Ah, so it is</p>



<a name="219449336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449336">(Dec 10 2020 at 09:34)</a>:</h4>
<p>I'll take a look at <code>hash_map</code>.</p>



<a name="219449374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449374">(Dec 10 2020 at 09:35)</a>:</h4>
<p>I would like to see more formalized data structures like that one in mathlib</p>



<a name="219449472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449472">(Dec 10 2020 at 09:36)</a>:</h4>
<p>there is a long-abandoned mathlib branch called <code>ordmap</code> which formalizes balanced 2-3 trees as an alternative to the broken <code>rbmap</code></p>



<a name="219449475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449475">(Dec 10 2020 at 09:36)</a>:</h4>
<p><code>asum = mfirst id</code></p>



<a name="219449546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449546">(Dec 10 2020 at 09:37)</a>:</h4>
<p>But I guess it simplifies things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">asum</span> <span class="o">(</span><span class="n">ch</span> <span class="bp">&lt;$&gt;</span> <span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">])</span> <span class="bp">=</span> <span class="n">mfirst</span> <span class="n">ch</span> <span class="o">[</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">]</span>
</code></pre></div>



<a name="219449647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449647">(Dec 10 2020 at 09:38)</a>:</h4>
<p>it's also more efficient since you don't actually need to build up all the thunks</p>



<a name="219449680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449680">(Dec 10 2020 at 09:38)</a>:</h4>
<p>the list can just be the data itself instead of some monad things</p>



<a name="219449894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219449894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219449894">(Dec 10 2020 at 09:40)</a>:</h4>
<p>While we're on this topic, do we have monads in mathlib where <code>&gt;&gt;</code> behaves more efficiently than <code>&gt;&gt;= (λ _, ...)</code>?</p>



<a name="219452343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219452343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219452343">(Dec 10 2020 at 10:05)</a>:</h4>
<p>Ah..., <code>pure</code> isn't <code>valid</code> by the definition that uses <code>cb.size</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">pure</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">input</span> <span class="n">pos</span><span class="o">,</span> <span class="n">parse_result.done</span> <span class="n">pos</span> <span class="n">a</span>
</code></pre></div>



<a name="219456770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219456770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219456770">(Dec 10 2020 at 10:51)</a>:</h4>
<p>Oh, you have to assume <code>pos &lt;= cb.size</code></p>



<a name="219456892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219456892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219456892">(Dec 10 2020 at 10:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">parser.valid</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">⦄</span> <span class="o">⦃</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">⦄,</span>
<span class="n">n</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">n</span> <span class="bp">≤</span> <span class="n">cb.size</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span> <span class="bp">≤</span> <span class="n">cb.size</span><span class="o">)</span>
</code></pre></div>



<a name="219735736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/lawful%20parsers/near/219735736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/lawful.20parsers.html#219735736">(Dec 13 2020 at 00:28)</a>:</h4>
<p>I think it has to be the other way around in the implication:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">valid</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">cb</span> <span class="o">:</span> <span class="n">char_buffer</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">p</span> <span class="n">cb</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span> <span class="bp">≤</span> <span class="n">cb.size</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">cb.size</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
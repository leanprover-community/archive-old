---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236449-Program-verification/topic/Turing.20machines.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/index.html">Program verification</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html">Turing machines</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198579514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198579514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198579514">(May 24 2020 at 11:45)</a>:</h4>
<p>This is an advertisement for <a href="https://github.com/leanprover-community/mathlib/issues/2792">#2792</a>, which constructs a (TM2 model) turing machine for partial recursive functions, thus proving that every <code>partrec</code> function is TM-computable. (I haven't done anything about the other direction, proving that turing machines compute partial recursive functions, but I don't think it will be nearly as difficult.)</p>
<p>I'm curious to see where people would like to see the computability library go in the future. My eye has been on defining computational complexity classes for a while, and I haven't done much with oracle turing machines but if there are interesting things to say there then it might be worthwhile. The TM construction in <a href="https://github.com/leanprover-community/mathlib/issues/2792">#2792</a> is careful to be polynomial time, using binary rather than unary representations of numbers, although there is probably around O(n^2) simulation overhead between the most basic TM model and the simulated partial recursive function.</p>



<a name="198580316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580316">(May 24 2020 at 12:07)</a>:</h4>
<p>I'd really like to have something like <code>pcodable</code> and <code>ptime</code> for implementing polynomial-time reductions, for cryptography applications.</p>



<a name="198580390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580390">(May 24 2020 at 12:09)</a>:</h4>
<p>I think <code>pcodable</code> is pretty trivial, since it is only a constraint on the encode/decode composition, which is the identity on most infinite sets of interest</p>



<a name="198580392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580392">(May 24 2020 at 12:09)</a>:</h4>
<p>I guess a benchmark here would be to pick some problem that isn't 3-SAT and reduce 3-SAT to it. Of course it would be good to have Cook's theorem too, but it's not actually as relevant for my purposes.</p>



<a name="198580437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580437">(May 24 2020 at 12:10)</a>:</h4>
<p>is <code>ptime</code> the complexity class P?</p>



<a name="198580438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580438">(May 24 2020 at 12:10)</a>:</h4>
<p>Can we already write down that constraint?</p>



<a name="198580441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580441">(May 24 2020 at 12:10)</a>:</h4>
<p>Yeah</p>



<a name="198580467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580467">(May 24 2020 at 12:11)</a>:</h4>
<p>By the way, I was wondering whether it would ever make sense, rather than working with a fixed primcodable/pcodable encoding, to instead work with an equivalence class or quotient under "can be converted between, by a primrec/polynomial-time function"</p>



<a name="198580509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580509">(May 24 2020 at 12:12)</a>:</h4>
<p>We have turing machines so we can write down P, but without the TM -&gt; partrec construction we couldn't do too much with the notion. Now we should be able to prove that lots of interesting functions are in P</p>



<a name="198580517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580517">(May 24 2020 at 12:12)</a>:</h4>
<p>Right, that was my next question.</p>



<a name="198580589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580589">(May 24 2020 at 12:14)</a>:</h4>
<p>that still requires some more work beyond what's currently done since all the reductions that have been proven thus far are polynomial time but not proven to be such (as I am still not sure how best to express the clocks inside proofs)</p>



<a name="198580590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580590">(May 24 2020 at 12:14)</a>:</h4>
<p>e.g. I see we have <code>primrec.nat_div_mod</code>--how hard is it to make a P version</p>



<a name="198580600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580600">(May 24 2020 at 12:15)</a>:</h4>
<p>I'm guessing that one would be pretty much the hardest of what there is already for <code>primrec</code></p>



<a name="198580610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580610">(May 24 2020 at 12:15)</a>:</h4>
<p>once the groundwork is laid it should not be much worse than <code>primrec</code> stuff, because there is a way to express P compositionally</p>



<a name="198580662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580662">(May 24 2020 at 12:16)</a>:</h4>
<p>I'm not sure I understand your encoding quotient suggestion</p>



<a name="198580678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580678">(May 24 2020 at 12:17)</a>:</h4>
<p>The base encoding is there as a meter stick for all other encodings</p>



<a name="198580745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580745">(May 24 2020 at 12:19)</a>:</h4>
<p>given two types A and B you can't a priori say whether a function A -&gt; B is computable, but if there are canonical maps A &lt;-&gt; nat and B &lt;-&gt; nat then f : A -&gt; B maps to f' : nat -&gt; nat and this has unambiguous meaning</p>



<a name="198580806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580806">(May 24 2020 at 12:20)</a>:</h4>
<p>Right, but you don't actually need specific maps A &lt;-&gt; nat and B &lt;-&gt; nat--you can identify two encodings A &lt;-&gt; nat if both composites nat -&gt; nat are computable/primrec/polytime, and the same for B, and still have a notion of computable/primrec/polytime for maps A -&gt; B</p>



<a name="198580824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580824">(May 24 2020 at 12:21)</a>:</h4>
<p>Or alternatively, work with a set of encodings A &lt;-&gt; nat, maybe one which contains all the encodings which are computable/...-ly equivalent to any of its members</p>



<a name="198580871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580871">(May 24 2020 at 12:22)</a>:</h4>
<p>The advantage is supposed to be that one makes a bunch of irrelevant choices when picking an encoding for something like <code>list (nat \x bool)</code>, but everyone would agree on the equivalence class of the resulting encoding</p>



<a name="198580885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580885">(May 24 2020 at 12:22)</a>:</h4>
<p>Or rather, for polytime purposes, <code>nat</code> has two natural structures, the b-ary one for b &gt;= 2 and the unary one</p>



<a name="198580896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580896">(May 24 2020 at 12:23)</a>:</h4>
<p>It's sort of like defining a manifold by an atlas, rather than by a fixed embedding in some R^N</p>



<a name="198580972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580972">(May 24 2020 at 12:24)</a>:</h4>
<p>In the context of lean though, with typeclass inference, it's not clear to me that this is really any different from the canonical bijection approach</p>



<a name="198580975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580975">(May 24 2020 at 12:25)</a>:</h4>
<p>because you still want a "canonical equivalence class"</p>



<a name="198580997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580997">(May 24 2020 at 12:25)</a>:</h4>
<p>Yeah, I'm not sure whether it would have other than conceptual value</p>



<a name="198580999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198580999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198580999">(May 24 2020 at 12:25)</a>:</h4>
<p>and it's not like this helps to make the class a subsingleton</p>



<a name="198581051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198581051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198581051">(May 24 2020 at 12:26)</a>:</h4>
<p>You'd still put an equivalence class on each type via the type class system, it would just be actually canonical in the sense that two people would usually pick the same one, rather than merely chosen in the sense that it's the one that instance search generates</p>



<a name="198581062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198581062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198581062">(May 24 2020 at 12:27)</a>:</h4>
<p>I think we can instead invest in making it easy to prove a function is computable relative to any encoding one wishes to use</p>



<a name="198581075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198581075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198581075">(May 24 2020 at 12:27)</a>:</h4>
<p>right, and I think it's probably easy already actually</p>



<a name="198581115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198581115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198581115">(May 24 2020 at 12:28)</a>:</h4>
<p>by proving that all reasonable encodings are P-equivalent to whatever the canonical one is</p>



<a name="198581122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Turing%20machines/near/198581122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Turing.20machines.html#198581122">(May 24 2020 at 12:28)</a>:</h4>
<p>I think some encodings might need to change though; the encoding of lists is something like double exponential right now</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
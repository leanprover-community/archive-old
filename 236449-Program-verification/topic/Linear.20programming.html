---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236449-Program-verification/topic/Linear.20programming.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/index.html">Program verification</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html">Linear programming</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265820080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265820080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265820080">(Dec 22 2021 at 15:56)</a>:</h4>
<p>Is there any formally-verified LP solver? In Lean would be best, but I am interested in a formally-verified LP solver in any language. In particular, I'd like to have one of those that are proven to run in polynomial time (worst case), that is not the simplex method. Even if the time complexity hasn't been formally verified.</p>



<a name="265820638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265820638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265820638">(Dec 22 2021 at 16:00)</a>:</h4>
<p><a href="https://github.com/coq-polyhedra/coq-polyhedra">https://github.com/coq-polyhedra/coq-polyhedra</a> and <a href="https://www.isa-afp.org/entries/Linear_Programming.html">https://www.isa-afp.org/entries/Linear_Programming.html</a></p>



<a name="265822362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265822362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265822362">(Dec 22 2021 at 16:14)</a>:</h4>
<p>How much work do you think it would be if I wanted to formally verify the ellipsoid method? Let me leave the time complexity aside for a while.</p>
<p>Let's say I want to formalize the ellipsoid method and prove its correctness (for LP as a decision problem over rational numbers). In terms of being a Ph.D. student, could it be, for example, half of the dissertation thesis? Any estimate?</p>



<a name="265822748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265822748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265822748">(Dec 22 2021 at 16:18)</a>:</h4>
<p>effort probably varies a lot with what prover you use (existing libraries vs building new). A verified LP solver usable in practice would probably amount to about one paper in ITP or CPP or IJCAR. In some places, PhD students are expected to co-author maybe 3-4 such papers</p>



<a name="265823235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265823235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265823235">(Dec 22 2021 at 16:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="198375">Karl Palmskog</span> <a href="#narrow/stream/236449-Program-verification/topic/Linear.20programming/near/265822748">said</a>:</p>
<blockquote>
<p>effort probably varies a lot with what prover you use (existing libraries vs building new). A verified LP solver usable in practice would probably amount to about one paper in ITP or CPP or IJCAR. In some places, PhD students are expected to co-author maybe 3-4 such papers</p>
</blockquote>
<p>By co-author, you mean a Ph.D. student working on it together with their supervisor? Or in a larger team?</p>



<a name="265823606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265823606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265823606">(Dec 22 2021 at 16:27)</a>:</h4>
<p>going from "verified LP solver" to person month estimation is going to yield false precision anyway. I'm not going to guess any more than that it's about one paper in ITP/CPP</p>



<a name="265825190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265825190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265825190">(Dec 22 2021 at 16:41)</a>:</h4>
<p>Thank you. I know it is impossible to tell beforehand how long a certain project will take, especially in this area. However, my motivation for asking these questions is the following.</p>
<p>My supervisor suggested that I should work on formal verification that LP is solvable in polynomial time. However, it would not be the whole dissertation project; it would be just one major step towards proving other complexity-theoretic results. And to me, it sounds like an overkill. Nevertheless, I wanted to ask someone else — I have no experience but someone else might have some.</p>



<a name="265825505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265825505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265825505">(Dec 22 2021 at 16:44)</a>:</h4>
<p>verifying complexity is a whole topic of its own. If you want to verify complexity, you probably want to look at libraries for that, such as: <a href="https://github.com/uds-psl/coq-library-complexity">https://github.com/uds-psl/coq-library-complexity</a></p>
<p>Example paper proving functional correctness + complexity for a practical executable algorithm implementation (ITP '19): <a href="http://gallium.inria.fr/~fpottier/publis/gueneau-jourdan-chargueraud-pottier-2019.pdf">http://gallium.inria.fr/~fpottier/publis/gueneau-jourdan-chargueraud-pottier-2019.pdf</a></p>



<a name="265828261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265828261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265828261">(Dec 22 2021 at 17:09)</a>:</h4>
<p>I have been looking into Fabian Funze's projects. I am aware that no similar library is available in Lean right now.</p>
<p>Nevertheless, even if I worked in a language that has great libraries for complexity theory ready, I would still have to implement the algorithm and verify its correctness before I could establish the time complexity of LP as a decision problem. And, if this part is going to take half of my Ph.D. working timespan, I won't choose a dissertation project that has it [LP \in P] as a prerequisite.</p>



<a name="265843159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265843159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265843159">(Dec 22 2021 at 19:30)</a>:</h4>
<p>the approach by Chargueraud et al. for complexity is different from Kunze et al's work: <a href="https://gitlab.inria.fr/charguer/cfml2/-/tree/master/theories#model-of-separation-logic-with-time-credits">https://gitlab.inria.fr/charguer/cfml2/-/tree/master/theories#model-of-separation-logic-with-time-credits</a></p>



<a name="265853150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265853150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265853150">(Dec 22 2021 at 21:09)</a>:</h4>
<p>LP solution verification is easy, because it can be expressed as a feasible point of the dual. If I were creating an LP solver in lean that is certainly what I would do. This does not address the complexity bounds but it's not clear to me whether you are actually trying to do this (and there is a huge amount of work to be done to get to the point where we can prove this, although you can shortcut some things if you want to skip to the good part)</p>



<a name="265859414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265859414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265859414">(Dec 22 2021 at 22:11)</a>:</h4>
<p>"solution verification", you mean translation validation? Unverified solution generation?</p>



<a name="265859775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265859775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265859775">(Dec 22 2021 at 22:13)</a>:</h4>
<p>if the goal is just a verified LP solution, then sure, but I don't think PC of ITP or CPP would be impressed</p>



<a name="265861512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265861512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265861512">(Dec 22 2021 at 22:29)</a>:</h4>
<p>Coq's <code>lia</code> tactic uses simplex by default and its proposed solution gets verified at <code>Qed</code>, so I guess it would qualify then (<a href="https://coq.inria.fr/refman/addendum/micromega.html">https://coq.inria.fr/refman/addendum/micromega.html</a>)</p>



<a name="265868016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265868016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265868016">(Dec 22 2021 at 23:53)</a>:</h4>
<p>I think proving complexity theoretic results of decision procedures is a pretty niche topic.<br>
On the one hand, if you are really excited about the topic, then a PhD would be a good opportunity to work on it.  However, you are likely going to have to formalize a large amount of basics, and then formalize the algorithm itself (rather than just functional code that implements the decision procedure).<br>
On the other hand, there is  a lot of interest in actually having unverified efficient decision procedures in the FM academic community and industry (for specific decision problems).  Very few people care about the complexity theory though (producing proofs of unsat has a bit more interest as you can leverage the proofs).</p>



<a name="265893513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265893513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265893513">(Dec 23 2021 at 08:24)</a>:</h4>
<p>my impression is that the "We verified algorithm X" papers are getting harder to sell without bells and whistles (unless the properties are exceptionally challenging to state and verify). People like code with machine-checked functional correctness, but it now is expected to come with performance evals and optimizations. One opportunity when code is verified might be to try crazy optimization techniques that real implementations won't try due to worry about bugs.</p>



<a name="265894000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265894000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265894000">(Dec 23 2021 at 08:32)</a>:</h4>
<p>Seminal example from the Coq community: <a href="https://github.com/mit-plv/fiat-crypto">https://github.com/mit-plv/fiat-crypto</a></p>



<a name="265910726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265910726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265910726">(Dec 23 2021 at 12:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236449-Program-verification/topic/Linear.20programming/near/265853150">said</a>:</p>
<blockquote>
<p>LP solution verification is easy, because it can be expressed as a feasible point of the dual. If I were creating an LP solver in lean that is certainly what I would do. This does not address the complexity bounds but it's not clear to me whether you are actually trying to do this (and there is a huge amount of work to be done to get to the point where we can prove this, although you can shortcut some things if you want to skip to the good part)</p>
</blockquote>
<p>It is what I would need to do in order to work on my supervisor's project. And it makes me nervous.</p>



<a name="265910992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265910992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265910992">(Dec 23 2021 at 12:13)</a>:</h4>
<p>The "skip to the good part" way to formalize computational complexity is to define a step-counting monad and write the algorithm in the monad, and prove bounds on how many steps are executed</p>



<a name="265912252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265912252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265912252">(Dec 23 2021 at 12:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kd">structure</span> <span class="n">with_steps</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">steps</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">step</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_steps</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">delay</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_steps</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_steps</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">with_steps</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pure</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">⟩,</span>
  <span class="n">bind</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">α</span> <span class="n">β</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span> <span class="n">f</span><span class="o">,</span> <span class="n">delay</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">pure_def</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">pure</span> <span class="n">a</span> <span class="o">:</span> <span class="n">with_steps</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">map_def</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&lt;$&gt;</span> <span class="n">with_steps.mk</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">bind_def</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">with_steps</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">with_steps.mk</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">&gt;&gt;=</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">delay</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">list.map_is_linear_time</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">step</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">l.length</span><span class="o">,</span> <span class="n">l.map</span> <span class="n">f</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">step</span><span class="o">]</span><span class="bp">;</span> <span class="n">induction</span> <span class="n">l</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mmap</span><span class="o">,</span> <span class="n">return</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span>
</code></pre></div>



<a name="265912743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265912743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265912743">(Dec 23 2021 at 12:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236449-Program-verification/topic/Linear.20programming/near/265910992">said</a>:</p>
<blockquote>
<p>The "skip to the good part" way to formalize computational complexity is to define a step-counting monad and write the algorithm in the monad, and prove bounds on how many steps are executed</p>
</blockquote>
<p>What "features" would be "lost" if we used this approach?</p>



<a name="265913242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265913242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265913242">(Dec 23 2021 at 12:47)</a>:</h4>
<p>You are taking the computational model on faith here. That is, you get to say what is constant time, and you have to be careful to apply <code>step</code> everywhere it is needed, because if you don't you can prove bad things:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">list.map_is_constant_time</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">pure</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">with_steps</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">l.map</span> <span class="n">f</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">step</span><span class="o">]</span><span class="bp">;</span> <span class="n">induction</span> <span class="n">l</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mmap</span><span class="o">,</span> <span class="n">return</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span>
</code></pre></div>



<a name="265913344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265913344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265913344">(Dec 23 2021 at 12:49)</a>:</h4>
<p>Some other things you might want to take as axiomatic are, for example, the cost of performing addition or multiplication of elements of the base field</p>



<a name="265913355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265913355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265913355">(Dec 23 2021 at 12:49)</a>:</h4>
<p>True. Thanks.</p>



<a name="265913807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265913807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265913807">(Dec 23 2021 at 12:56)</a>:</h4>
<p>One recent paper I read that demonstrates this approach well is Hing Lun Chan's thesis <a href="https://openresearch-repository.anu.edu.au/bitstream/1885/177195/1/thesis.pdf">Primality Testing is Polynomial-time: A Mechanised Verification of the AKS Algorithm</a>, which proves the "PRIMES is in P" algorithm (both correctness and complexity bounds) in HOL4. See chapter 6 for the step counting stuff</p>



<a name="265915284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265915284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265915284">(Dec 23 2021 at 13:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236449-Program-verification/topic/Linear.20programming/near/265853150">said</a>:</p>
<blockquote>
<p>LP solution verification is easy, because it can be expressed as a feasible point of the dual. If I were creating an LP solver in lean that is certainly what I would do.</p>
</blockquote>
<p>Has the weak duality of LP been proved in Lean/mathlib already?</p>



<a name="265915457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265915457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265915457">(Dec 23 2021 at 13:17)</a>:</h4>
<p>There isn't a general theory of LPs in mathlib, so I think the answer is no unless it is a simple application of a theorem about matrices</p>



<a name="265915997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265915997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265915997">(Dec 23 2021 at 13:25)</a>:</h4>
<p>Actually, it is a simple application of the arithmetic of matrices.</p>



<a name="265916090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265916090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265916090">(Dec 23 2021 at 13:26)</a>:</h4>
<p>Actually, I don't know why the authors of <a href="https://www.isa-afp.org/entries/Linear_Programming.html">https://www.isa-afp.org/entries/Linear_Programming.html</a> emphasized in the abstract that they proved the weak duality of LP themselves.</p>



<a name="265916578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265916578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265916578">(Dec 23 2021 at 13:32)</a>:</h4>
<p>I think they are just pointing out the important theorems in the article, so that you know where to look to find the weak duality theorem. By reading the abstract you can see that the weak duality theorem is there but the simplex algorithm is not, even though you might guess it is the other way around.</p>



<a name="265919706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265919706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265919706">(Dec 23 2021 at 14:09)</a>:</h4>
<p>BTW, is there any kind of RAM model with step counting formalized in any language?</p>



<a name="265922004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/265922004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#265922004">(Dec 23 2021 at 14:37)</a>:</h4>
<p>Strong duality for linear programming over the reals should follow from <a href="https://github.com/leanprover-community/mathlib/pull/7288">#7288</a></p>



<a name="318988343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/318988343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#318988343">(Jan 02 2023 at 13:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/236449-Program-verification/topic/Linear.20programming/near/265922004">said</a>:</p>
<blockquote>
<p>Strong duality for linear programming over the reals should follow from <a href="https://github.com/leanprover-community/mathlib/pull/7288">#7288</a></p>
</blockquote>
<p>I can intuit why weak duality would follow from hahn banach separation. How does strong duality follow?</p>



<a name="318988991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/318988991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#318988991">(Jan 02 2023 at 13:07)</a>:</h4>
<p>My intuition : Farkas Lemma is a version of Hahn Banach separation.</p>



<a name="318989517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/318989517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#318989517">(Jan 02 2023 at 13:10)</a>:</h4>
<p>Correction: I can't see why weak duality follows</p>



<a name="318990482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/318990482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#318990482">(Jan 02 2023 at 13:16)</a>:</h4>
<p>Update: I see what was meant now. But it still seems some translation is needed to bring about the LP formulation.</p>



<a name="319034441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/319034441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#319034441">(Jan 02 2023 at 18:01)</a>:</h4>
<p>LP duality is definitely on my wish list.</p>



<a name="319368910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/319368910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#319368910">(Jan 04 2023 at 11:26)</a>:</h4>
<p>I did some work on this three years ago. <a href="https://github.com/ChrisHughes24/LP/blob/e3ed64c2d1f642696104584e74ae7226d8e916de/src/simplex2.lean#L646">https://github.com/ChrisHughes24/LP/blob/e3ed64c2d1f642696104584e74ae7226d8e916de/src/simplex2.lean#L646</a> If you're interested I can talk to you about it, but it might take some time for me to remember how to navigate this repository.</p>



<a name="319404721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/319404721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#319404721">(Jan 04 2023 at 14:49)</a>:</h4>
<p>Woah! Is it (both implementation and verification) finished?</p>



<a name="319422081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/319422081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#319422081">(Jan 04 2023 at 16:15)</a>:</h4>
<p>Yes, and there's a more efficient version using array matrices which is also verified. I don't think I did Farka's lemma and to be honest I have trouble remembering what all the theorems are. I think the duality stuff is fairly straightforward once you have a verified terminating simplex algorithm. Termination was a tricky to prove I remember.</p>



<a name="319583724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/319583724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#319583724">(Jan 05 2023 at 13:20)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span>  Did you have any plans to go further with this? I'm considering revisiting this work.</p>



<a name="319637803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Linear%20programming/near/319637803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Linear.20programming.html#319637803">(Jan 05 2023 at 17:44)</a>:</h4>
<p>Imma be busy until 2023-03-10 with my current stuff. In mid-March, I will be deciding what to do next. The decision will mostly depend on how this community about doing complexity theory for mathlib4. Therefore, I cannot tell you right now whether I will use your code in my work.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/index.html">Program verification</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html">Need a way to unfold a definition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202878232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202878232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202878232">(Jul 04 2020 at 15:23)</a>:</h4>
<p>Sorry for bringing up the stupid example again. I'm just annoyingly stuck and it seems to be really lean-specific. The moral equivalent goes  through in Coq no problem because we can unfold a fixpoint definition. Here goes:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">variables</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>

<span class="kn">inductive</span> <span class="n">color</span>
<span class="bp">|</span> <span class="n">red</span>
<span class="bp">|</span> <span class="n">black</span>

<span class="kn">inductive</span> <span class="n">node</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">node</span>
<span class="bp">|</span> <span class="n">tree</span> <span class="o">{}</span> <span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">color</span><span class="o">)</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span><span class="o">)</span> <span class="o">:</span> <span class="n">node</span>

<span class="n">def</span> <span class="n">balance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="o">:=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span><span class="o">))</span> <span class="n">z</span> <span class="n">d</span> <span class="o">:=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">b</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
     <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">color</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">balance</span><span class="bp">.</span><span class="n">equations</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">,</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">-- intros, refl, -- should work</span>
    <span class="n">rintros</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="n">y</span> <span class="o">(</span><span class="n">c</span><span class="bp">|⟨</span><span class="n">cc</span><span class="bp">|</span><span class="n">cc</span><span class="o">,</span> <span class="n">cl</span><span class="o">,</span> <span class="n">cv</span><span class="o">,</span> <span class="n">cr</span><span class="bp">⟩</span><span class="o">)</span> <span class="n">z</span> <span class="o">(</span><span class="n">d</span><span class="bp">|⟨</span><span class="n">dc</span><span class="bp">|</span><span class="n">dc</span><span class="o">,</span> <span class="n">dl</span><span class="bp">|⟨</span><span class="n">dlc</span><span class="bp">|</span><span class="n">dlc</span><span class="o">,</span> <span class="n">dll</span><span class="o">,</span> <span class="n">dlv</span><span class="o">,</span> <span class="n">dlr</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">dv</span><span class="o">,</span> <span class="n">dr</span><span class="bp">|⟨</span><span class="n">drc</span><span class="bp">|</span><span class="n">drc</span><span class="o">,</span> <span class="n">drl</span><span class="o">,</span> <span class="n">drv</span><span class="o">,</span> <span class="n">drr</span><span class="bp">⟩⟩</span><span class="o">),</span>
    <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>I've found a very concise proof, but it's deeply unsatisfying. First notice, that the statement of the lemma is literally the pattern match, so it really should just go through with <code>refl</code>. In fact nothing in the context or anywhere else gives us a hint at all what to do next.</p>
<p>I haven't found any tactic to make any progress, unfold doesn't say anything. And the fact, that I have to destruct <code>dl</code> and <code>dr</code> is because of lines 3 and 4 of the pattern match. If we erase them, we don't have to do that much distinction by cases. In total the equation compiler creates 122 equations.</p>
<p>The root cause seems to be that the equation compiler is introducing cases which are meaningless in the context.</p>
<p>What it conceptually should do, is go over the first case in the pattern match,  see, that the first pattern is <code>color.black</code>, so we do have to destruct the first argument. Keep that fact around, go to the next argument, see that it needs a pattern on node because we encountered <code>node.tree</code>. Next we see that color needs to be split again, etc. </p>
<p>If the compiler did a backtracking search during the generation of cases, we'd end up with quite a bit fewer cases and the lemmas would be more useful, because they'd quantify over all <code>c</code> and <code>d</code> in this particular case, fixing <code>refl</code>.</p>
<p>Now if the compiler can't do that / be told to do that / can't be fixed, the next best thing would be a tactic, that lets us destruct based on the concrete lambda.</p>
<p>If <code>unfold</code> worked in this case, we should get something like <code>[a lot of the body is gone, because we're in a deeply nested case...] (fun x, x.cases_on ...)</code>. At that point, we could make a tactic (I'm going to call it <code>unfold_cases</code>), that takes the type of <code>x</code>, and destructs it. As a consequence we'd get a few new goals.</p>
<p>With this tactic, we could write the proof as this, I think: <code>intros, repeat { refl &lt;|&gt; unfold_cases }</code>.</p>
<p>If we want to avoid exploding the whole body, we could always do the distinction by cases and then elide the body.</p>
<p>I'd be happy to have a go at writing such a tactic, but I don't even know how to unfold the definition. I can't find what to pass as the config to <code>unfold</code>; <code>delta</code>, <code>dsimp</code> and <code>simp</code> all do nothing. </p>
<p>Any help would be very, very welcome. I've been struggling with this example for a year now on and off and I'm determined to make it work is some nice way.</p>
<p>And I'm pretty sure this is not a fluke, but rather something that's quite deeply linked to the distinction between Coq and lean so it'll come in handy in pretty much all cases of non-trivial pattern match expressions. It may not come up in maths that much but comes up tons in reasoning about programs.</p>



<a name="202878914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202878914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202878914">(Jul 04 2020 at 15:39)</a>:</h4>
<p>Yeah, I see it's pretty hairy. Writing a good equation compiler is quite a difficult task. I think a tactic like you describe that can use details of the specification of the function would be very useful indeed</p>



<a name="202879020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202879020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202879020">(Jul 04 2020 at 15:41)</a>:</h4>
<p>It's now possible to roll our own syntax for functions and call the built-in equation compiler. I could imagine a way of defining equations so that, we can at least prove the branches used in the specification of the function as lemmas / additional equations, even if it doesn't match the definition exactly</p>



<a name="202879103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202879103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202879103">(Jul 04 2020 at 15:43)</a>:</h4>
<p>ya, adding the lemmas for the cases would be fine. They should be easy to construct proofs for too, as they are really just distinction by cases, refl (by definition).</p>



<a name="202879234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202879234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202879234">(Jul 04 2020 at 15:46)</a>:</h4>
<p>is there any kind of docu / examples where I could learn something about the API? I struggle to find docu.</p>



<a name="202879978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202879978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202879978">(Jul 04 2020 at 16:04)</a>:</h4>
<p>Here is a good tutorial on the writing of automation <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md</a>. Looking at the code of <code>tactic.core</code> in mathlib should provide you with a lot of good examples</p>



<a name="202880220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202880220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202880220">(Jul 04 2020 at 16:09)</a>:</h4>
<p>Oh and here is a guide for the available tactics <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html">https://leanprover-community.github.io/mathlib_docs/tactics.html</a></p>



<a name="202880397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202880397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202880397">(Jul 04 2020 at 16:13)</a>:</h4>
<p>Ya, I've studied both before writing here. At this point, I think my next step would be getting the AST of the goal that I need. So I could inspect it and figure out what to <code>cases</code> on.</p>



<a name="202880564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202880564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202880564">(Jul 04 2020 at 16:17)</a>:</h4>
<p>That sounds like a good exercise. Please keep me posted, maybe I can give you a couple of nudges</p>



<a name="202880623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202880623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202880623">(Jul 04 2020 at 16:18)</a>:</h4>
<p>k will do</p>



<a name="202885891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202885891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202885891">(Jul 04 2020 at 18:30)</a>:</h4>
<p>alright, this is not very useful. When I unfold the application a few times, I get to a "constant" named "balance".</p>



<a name="202885893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202885893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202885893">(Jul 04 2020 at 18:30)</a>:</h4>
<p>I don't get its body.</p>



<a name="202887430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887430">(Jul 04 2020 at 19:12)</a>:</h4>
<p>Don't try to do too much in one definition. For one thing, it's easier to have separate <code>balance_l</code> and <code>balance_r</code> functions rather than doing both at once. Plus, it's impossible for all of these case splits to be true by <code>refl</code>, even if the equation compiler didn't do some superfluous case splits, because they overlap</p>



<a name="202887464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887464">(Jul 04 2020 at 19:13)</a>:</h4>
<p>Additionally, there will be far fewer cases if you consider only well formed red black trees</p>



<a name="202887527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887527">(Jul 04 2020 at 19:15)</a>:</h4>
<p>With valid RB trees, you mean having a type family that does things like enforcing the balance or red-black invariant by construction, right? Then it's becomes a GADT and we can prove much more about it during construction.</p>



<a name="202887577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887577">(Jul 04 2020 at 19:16)</a>:</h4>
<p>doing that ends up with a more painful insertion algorithm, though. In particular it becomes a mutually recursive insertion.</p>



<a name="202887641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887641">(Jul 04 2020 at 19:18)</a>:</h4>
<p>I wrote this once a long long time ago. Here's how I did it:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">rb_node</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">ff</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">red</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="n">r</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">ff</span> <span class="n">n</span><span class="o">),</span> <span class="n">rb_node</span> <span class="n">tt</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">black</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span> <span class="n">a</span><span class="o">},</span> <span class="n">rb_node</span> <span class="n">a</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">rb_node</span> <span class="n">ff</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">rb_node</span> <span class="n">ff</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">rb_node</span>
  <span class="n">def</span> <span class="n">blackR</span> <span class="o">{</span><span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="n">a</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">ff</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">a</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">ff</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ff</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">black</span> <span class="n">d</span> <span class="n">l</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="n">tt</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">red</span> <span class="n">d&#39;</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">black</span> <span class="n">d&#39;</span> <span class="o">(</span><span class="n">red</span> <span class="n">d</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span>
  <span class="kn">end</span>

  <span class="kn">section</span>
  <span class="c1">-- An rb_node whose invariant has been broken. The bool,nat type parameters refer to the</span>
  <span class="c1">-- original type of the node before being broken.</span>
  <span class="kn">inductive</span> <span class="n">ins_broken</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">fixed</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ins_broken</span> <span class="n">b</span>
  <span class="bp">|</span> <span class="n">redden</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">tt</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ins_broken</span> <span class="n">ff</span>
  <span class="bp">|</span> <span class="n">redL</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="bp">Π</span><span class="n">b</span><span class="o">,</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">tt</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ins_broken</span> <span class="n">tt</span>
  <span class="bp">|</span> <span class="n">redR</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="bp">Π</span><span class="n">b</span><span class="o">,</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">b</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">tt</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ins_broken</span> <span class="n">tt</span>

  <span class="kn">open</span> <span class="n">ins_broken</span>
  <span class="n">def</span> <span class="n">insert2</span> <span class="o">{</span><span class="n">D</span><span class="o">}</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">((</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)]</span> <span class="o">(</span><span class="n">dat</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">replace</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">rb_node</span> <span class="n">D</span> <span class="n">a</span> <span class="n">n</span><span class="o">),</span> <span class="n">ins_broken</span> <span class="n">D</span> <span class="n">n</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">ff</span> <span class="mi">0</span> <span class="o">(</span><span class="n">nil</span> <span class="bp">._</span><span class="o">)</span> <span class="o">:=</span> <span class="n">redden</span> <span class="o">(</span><span class="n">red</span> <span class="n">dat</span> <span class="o">(</span><span class="n">nil</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">nil</span> <span class="n">D</span><span class="o">))</span>
  <span class="bp">|</span> <span class="n">tt</span> <span class="n">n</span> <span class="o">(</span><span class="n">red</span> <span class="n">d</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">cmp</span> <span class="n">dat</span> <span class="n">d</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">lt</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">insert2</span> <span class="n">l</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">fixed</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">red</span> <span class="n">d</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>
      <span class="bp">|</span> <span class="n">redden</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">redL</span> <span class="n">d</span> <span class="bp">_</span> <span class="n">c</span> <span class="n">r</span>
      <span class="kn">end</span>
    <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">eq</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">red</span> <span class="o">(</span><span class="n">cond</span> <span class="n">replace</span> <span class="n">dat</span> <span class="n">d</span><span class="o">)</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">gt</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">insert2</span> <span class="n">r</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">fixed</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">red</span> <span class="n">d</span> <span class="n">l</span> <span class="n">c</span><span class="o">)</span>
      <span class="bp">|</span> <span class="n">redden</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">redR</span> <span class="n">d</span> <span class="bp">_</span> <span class="n">l</span> <span class="n">c</span>
      <span class="kn">end</span>
    <span class="kn">end</span>
  <span class="bp">|</span> <span class="n">ff</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">black</span> <span class="bp">._</span> <span class="n">d</span> <span class="bp">._</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">cmp</span> <span class="n">dat</span> <span class="n">d</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">lt</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">insert2</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">fixed</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">black</span> <span class="n">d</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span>
      <span class="bp">|</span> <span class="n">ff</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">redden</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">black</span> <span class="n">d</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span>
      <span class="bp">|</span> <span class="n">tt</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">redL</span> <span class="n">d₂</span> <span class="n">b</span> <span class="o">(</span><span class="n">red</span> <span class="n">d₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">redden</span> <span class="o">(</span><span class="n">red</span> <span class="n">d₂</span> <span class="o">(</span><span class="n">black</span> <span class="n">d₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">black</span> <span class="n">d</span> <span class="n">z</span> <span class="n">w</span><span class="o">))</span>
      <span class="bp">|</span> <span class="n">tt</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">redR</span> <span class="n">d₁</span> <span class="n">b</span> <span class="n">x</span> <span class="o">(</span><span class="n">red</span> <span class="n">d₂</span> <span class="n">y</span> <span class="n">z</span><span class="o">),</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">redden</span> <span class="o">(</span><span class="n">red</span> <span class="n">d₂</span> <span class="o">(</span><span class="n">black</span> <span class="n">d₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">black</span> <span class="n">d</span> <span class="n">z</span> <span class="n">w</span><span class="o">))</span>
      <span class="kn">end</span>
    <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">eq</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">black</span> <span class="o">(</span><span class="n">cond</span> <span class="n">replace</span> <span class="n">dat</span> <span class="n">d</span><span class="o">)</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">ordering</span><span class="bp">.</span><span class="n">gt</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">insert2</span> <span class="n">r</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">fixed</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">black</span> <span class="n">d</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span>
      <span class="bp">|</span> <span class="n">ff</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">redden</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">fixed</span> <span class="o">(</span><span class="n">blackR</span> <span class="n">d</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span>
      <span class="bp">|</span> <span class="n">tt</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">red</span> <span class="n">d₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">redden</span> <span class="o">(</span><span class="n">red</span> <span class="n">d₂</span> <span class="n">z</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span> <span class="n">redden</span> <span class="o">(</span><span class="n">red</span> <span class="n">d</span> <span class="o">(</span><span class="n">black</span> <span class="n">d₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">black</span> <span class="n">d₂</span> <span class="n">z</span> <span class="n">w</span><span class="o">))</span>
      <span class="kn">end</span>
    <span class="kn">end</span>
  <span class="kn">end</span>

<span class="kn">end</span> <span class="n">rb_node</span>
</code></pre></div>



<a name="202887667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887667">(Jul 04 2020 at 19:19)</a>:</h4>
<p>And what do you mean by overlapping, btw? Pattern matches are disjoint by definition, no? The second case only applies, if the first one didn't, I.e. we could even have a new information in the local context, saying that it is not compatible with the any of the previous cases.</p>



<a name="202887723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887723">(Jul 04 2020 at 19:20)</a>:</h4>
<p>Maybe that's the way you write the branches of the definition, but in the equations they all have to stand alone. That's why there are so many case splits</p>



<a name="202887750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887750">(Jul 04 2020 at 19:21)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">2</span>
</code></pre></div>


<p>Obviously we can't have the equation <code>foo.equations_1 : foo m 0 = 1</code> here</p>



<a name="202887764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887764">(Jul 04 2020 at 19:21)</a>:</h4>
<p>so lean has to case split it and you get <code>foo (m+1) 0 = 1</code> instead</p>



<a name="202887823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887823">(Jul 04 2020 at 19:23)</a>:</h4>
<p>Unlike Coq's <code>Program Definition</code>, lean does not have definitions where the later branches come with preconditions saying that the earlier branches don't match</p>



<a name="202887895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887895">(Jul 04 2020 at 19:25)</a>:</h4>
<p>Ah... that's different from my mental model coming from F#. I always think of them as the next branch having a proof of the previous not having matched.</p>



<a name="202887904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887904">(Jul 04 2020 at 19:25)</a>:</h4>
<p>the only way lean can express that property is by case splitting until it's true by disjointness of constructors</p>



<a name="202887950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887950">(Jul 04 2020 at 19:26)</a>:</h4>
<p>something like <code>forall m, (forall n, (0, n) &lt;&gt; (m, 0)) -&gt; rest</code> wouldn't work?</p>



<a name="202887962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887962">(Jul 04 2020 at 19:27)</a>:</h4>
<p>Which means that when you have a definition like </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">node</span> <span class="bp">-&gt;</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>


<p>it generates a ton of case splits. If you do it twice it generates a square ton</p>



<a name="202887967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887967">(Jul 04 2020 at 19:27)</a>:</h4>
<p>I'm just saying that this isn't how the equation compiler works</p>



<a name="202887972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887972">(Jul 04 2020 at 19:27)</a>:</h4>
<p>ok fair enough.</p>



<a name="202887993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202887993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202887993">(Jul 04 2020 at 19:28)</a>:</h4>
<p>I can imagine a variation on the equation compiler that generates those, although it might be difficult to work with</p>



<a name="202888018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888018">(Jul 04 2020 at 19:28)</a>:</h4>
<p>does that mean I'm just simply restricted how I have to write the definition, or could that in general be solved using tactics?</p>



<a name="202888019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888019">(Jul 04 2020 at 19:28)</a>:</h4>
<p>One thing you can do is to split the definition into smaller parts</p>



<a name="202888020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888020">(Jul 04 2020 at 19:28)</a>:</h4>
<p>it's a bit like <code>ite</code> vs. <code>dite</code>, isn't it?</p>



<a name="202888028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888028">(Jul 04 2020 at 19:29)</a>:</h4>
<p>Done properly, it can eliminate the superfluous case splits (so you can get the proofs by <code>refl</code> back when possible)</p>



<a name="202888076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888076">(Jul 04 2020 at 19:30)</a>:</h4>
<p>You can also very precisely specify the case split tree using by using <code>induction</code> and <code>cases</code> to write the definition</p>



<a name="202888095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888095">(Jul 04 2020 at 19:30)</a>:</h4>
<p>right, sure, but then I do it by hand, right?</p>



<a name="202888105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888105">(Jul 04 2020 at 19:31)</a>:</h4>
<p>as in during the proof, right?</p>



<a name="202888110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888110">(Jul 04 2020 at 19:31)</a>:</h4>
<p>you do the same case splits in the proof</p>



<a name="202888113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888113">(Jul 04 2020 at 19:31)</a>:</h4>
<p>you have to do that anyway</p>



<a name="202888171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888171">(Jul 04 2020 at 19:33)</a>:</h4>
<p>I wonder if it could be written almost like a relation, with 5 separate constructors.</p>



<a name="202888173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888173">(Jul 04 2020 at 19:33)</a>:</h4>
<p>then you'd only have 5 cases</p>



<a name="202888175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888175">(Jul 04 2020 at 19:33)</a>:</h4>
<p>Indeed, I recommend it</p>



<a name="202888179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888179">(Jul 04 2020 at 19:33)</a>:</h4>
<p>That's what <code>ins_broken</code> is accomplishing in my code snippet</p>



<a name="202888246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888246">(Jul 04 2020 at 19:35)</a>:</h4>
<p>Do we have any control about how the equation compiler does its work? perhaps some attributes or something?</p>



<a name="202888250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888250">(Jul 04 2020 at 19:35)</a>:</h4>
<p>maybe help it out a little?</p>



<a name="202888251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888251">(Jul 04 2020 at 19:35)</a>:</h4>
<p>not really</p>



<a name="202888255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888255">(Jul 04 2020 at 19:35)</a>:</h4>
<p>You can help it out by writing the equations in a particular way</p>



<a name="202888306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888306">(Jul 04 2020 at 19:36)</a>:</h4>
<p>is there a white paper that describes the algo, so I could know what is and what isn't good?</p>



<a name="202888314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888314">(Jul 04 2020 at 19:37)</a>:</h4>
<p>I don't think so, but equation compilation has a literature from systems like Agda already</p>



<a name="202888358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888358">(Jul 04 2020 at 19:38)</a>:</h4>
<p>ah, ok, so I'll have to look it up there.</p>



<a name="202888377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888377">(Jul 04 2020 at 19:39)</a>:</h4>
<p>Generally speaking, superfluous case splits happen in examples like <code>foo : ℕ → ℕ → ℕ</code> above, which will probably have 4 cases instead of 3 because it decides which things need splitting at the top level and then splits all of them</p>



<a name="202888378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888378">(Jul 04 2020 at 19:39)</a>:</h4>
<p>I do have to say, I was really hoping to write down the definition as naturally as possible and use tactics to prove the cases. Having to change the definition so the compiler is happier, is a bit disappointing.</p>



<a name="202888397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888397">(Jul 04 2020 at 19:40)</a>:</h4>
<p>You can still do that, if you don't care about the 100 cases thing</p>



<a name="202888422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888422">(Jul 04 2020 at 19:40)</a>:</h4>
<p>you should prove the equations you want regardless</p>



<a name="202888424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888424">(Jul 04 2020 at 19:40)</a>:</h4>
<p>I really don't care too much about the cases, but unfortunately unfold doesn't help.</p>



<a name="202888426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888426">(Jul 04 2020 at 19:40)</a>:</h4>
<p>so I literally don't see what cases need to be considered.</p>



<a name="202888444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888444">(Jul 04 2020 at 19:41)</a>:</h4>
<p>even a tactic that would do something like "here's a definition, you introduce all the cases as per definition and create goals, please" would pretty much fix the problem.</p>



<a name="202888483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888483">(Jul 04 2020 at 19:42)</a>:</h4>
<p>it's that I can't see what cases are missing that makes is to hard to work with.</p>



<a name="202888489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888489">(Jul 04 2020 at 19:42)</a>:</h4>
<p>I think we could have a <code>split_unfold foo</code> tactic that attempts to unfold <code>foo</code> and do case splits on any variables that block unfolding</p>



<a name="202888503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888503">(Jul 04 2020 at 19:43)</a>:</h4>
<p>that would be amazing, I tried doing something like that, but so far not too much luck.</p>



<a name="202888509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888509">(Jul 04 2020 at 19:43)</a>:</h4>
<p>I can unfold the goal a bit, but then I just get a constant "balance".</p>



<a name="202888516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888516">(Jul 04 2020 at 19:43)</a>:</h4>
<p>not the lambda that it corresponds to.</p>



<a name="202888568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888568">(Jul 04 2020 at 19:44)</a>:</h4>
<p>It doesn't correspond to a lambda that would be helpful for you anyway</p>



<a name="202888579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888579">(Jul 04 2020 at 19:45)</a>:</h4>
<p>I guess in Coq matches get compiled to primitive matches so this kind of display makes sense?</p>



<a name="202888644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888644">(Jul 04 2020 at 19:47)</a>:</h4>
<p>it does this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">to_set</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">\/</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">\/</span> <span class="n">to_set</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">&lt;-&gt;</span>
<span class="n">to_set</span>
  <span class="k">match</span> <span class="n">c</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">red</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
  <span class="bp">|</span> <span class="n">black</span> <span class="bp">=&gt;</span>
      <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">leaf</span> <span class="bp">=&gt;</span>
          <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">leaf</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
          <span class="bp">|</span> <span class="n">tree</span> <span class="n">color0</span> <span class="n">b</span> <span class="n">y</span> <span class="n">d</span> <span class="bp">=&gt;</span>
              <span class="k">match</span> <span class="n">color0</span> <span class="k">with</span>
              <span class="bp">|</span> <span class="n">red</span> <span class="bp">=&gt;</span>
                  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
                  <span class="bp">|</span> <span class="n">leaf</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
                            <span class="bp">|</span> <span class="n">leaf</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
                            <span class="bp">|</span> <span class="n">tree</span> <span class="n">color1</span> <span class="n">c0</span> <span class="n">z</span> <span class="n">d0</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">color1</span> <span class="k">with</span>
                                                     <span class="bp">|</span> <span class="n">red</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">red</span> <span class="o">(</span><span class="n">tree</span> <span class="n">black</span> <span class="n">l</span> <span class="n">v</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">tree</span> <span class="n">black</span> <span class="n">c0</span> <span class="n">z</span> <span class="n">d0</span><span class="o">)</span>
                                                     <span class="bp">|</span> <span class="n">black</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
                                                     <span class="kn">end</span>
                            <span class="kn">end</span>
                  <span class="bp">|</span> <span class="n">tree</span> <span class="n">color1</span> <span class="n">b0</span> <span class="n">y0</span> <span class="n">c0</span> <span class="bp">=&gt;</span>
                      <span class="k">match</span> <span class="n">color1</span> <span class="k">with</span>
                      <span class="bp">|</span> <span class="n">red</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">red</span> <span class="o">(</span><span class="n">tree</span> <span class="n">black</span> <span class="n">l</span> <span class="n">v</span> <span class="n">b0</span><span class="o">)</span> <span class="n">y0</span> <span class="o">(</span><span class="n">tree</span> <span class="n">black</span> <span class="n">c0</span> <span class="n">y</span> <span class="n">d</span><span class="o">)</span>
                      <span class="bp">|</span> <span class="n">black</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
                                 <span class="bp">|</span> <span class="n">leaf</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
                                 <span class="bp">|</span> <span class="n">tree</span> <span class="n">color2</span> <span class="n">c1</span> <span class="n">z</span> <span class="n">d0</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">color2</span> <span class="k">with</span>
                                                          <span class="bp">|</span> <span class="n">red</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">red</span> <span class="o">(</span><span class="n">tree</span> <span class="n">black</span> <span class="n">l</span> <span class="n">v</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">tree</span> <span class="n">black</span> <span class="n">c1</span> <span class="n">z</span> <span class="n">d0</span><span class="o">)</span>
                                                          <span class="bp">|</span> <span class="n">black</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
                                                          <span class="kn">end</span>
                                 <span class="kn">end</span>
                      <span class="kn">end</span>
                  <span class="kn">end</span>
              <span class="bp">|</span> <span class="n">black</span> <span class="bp">=&gt;</span> <span class="n">tree</span> <span class="n">c</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span>
              <span class="kn">end</span>
          <span class="kn">end</span>
      <span class="bp">|</span> <span class="n">tree</span> <span class="n">color0</span> <span class="n">a</span> <span class="n">x0</span> <span class="n">c0</span> <span class="bp">=&gt;</span>
          <span class="k">match</span> <span class="n">color0</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">red</span> <span class="bp">=&gt;</span>
      <span class="o">(</span><span class="n">and</span> <span class="n">more</span><span class="o">)</span>
              <span class="bp">```</span>
</code></pre></div>



<a name="202888651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888651">(Jul 04 2020 at 19:47)</a>:</h4>
<p>so you immediately see what do and you can make a tactic destructing the top match expr.</p>



<a name="202888711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888711">(Jul 04 2020 at 19:48)</a>:</h4>
<p>my attempt so far was this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">find_matching</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">failed</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">H</span><span class="bp">::</span><span class="n">Hs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">t</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">resolve_name</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">t</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">to_expr</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">t</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">infer_type</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">unify</span> <span class="n">e</span> <span class="n">t</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">transparency</span><span class="bp">.</span><span class="n">all</span> <span class="bp">&gt;&gt;</span> <span class="n">return</span> <span class="n">t</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">trace_goal</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span>  <span class="n">goal</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">target</span><span class="o">,</span>
    <span class="n">names</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_eqn_lemmas_for</span> <span class="n">ff</span> <span class="bp">`</span><span class="n">balance</span><span class="o">,</span>
    <span class="n">find_matching</span> <span class="n">goal</span> <span class="n">names</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span>
</code></pre></div>



<a name="202888722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888722">(Jul 04 2020 at 19:49)</a>:</h4>
<p>It finds the lemmas. And I was hoping to instantiate each one of them like <code>apply</code> and if it doesn't unify with the current context, kill off the lemma for the current path.</p>



<a name="202888724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888724">(Jul 04 2020 at 19:49)</a>:</h4>
<p>If you <code>delta balance balance._main</code> you can see something pretty similar</p>



<a name="202888726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888726">(Jul 04 2020 at 19:49)</a>:</h4>
<p>so you'd get fewer and fewer lemmas work.</p>



<a name="202888777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888777">(Jul 04 2020 at 19:50)</a>:</h4>
<p>ya, looking good, now we'd need to make the root thing go away.</p>



<a name="202888782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888782">(Jul 04 2020 at 19:51)</a>:</h4>
<p>root thing?</p>



<a name="202888784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888784">(Jul 04 2020 at 19:51)</a>:</h4>
<p>because <code>color.black.cases_on</code> should become just one branch, right?</p>



<a name="202888785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888785">(Jul 04 2020 at 19:51)</a>:</h4>
<p><code>dsimp</code></p>



<a name="202888842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888842">(Jul 04 2020 at 19:53)</a>:</h4>
<p>I see. so now after <code>dsimp</code> it I think looks like this: <code>node.rec (blablabla) c</code>. so the tactic would now have to go and split <code>c</code>, correct?</p>



<a name="202888915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888915">(Jul 04 2020 at 19:55)</a>:</h4>
<p>yea</p>



<a name="202888971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202888971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202888971">(Jul 04 2020 at 19:57)</a>:</h4>
<p>that's probably the best way to do it: first <code>delta</code> then <code>dsimp</code> until you get stuck, then call <code>cases</code> to split on all stuck recursors; this generates the split tree, and then you can restart from the beginning with the split tree and then use regular <code>rw</code> to apply the equation lemmas</p>



<a name="202889011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889011">(Jul 04 2020 at 19:58)</a>:</h4>
<p>it would be nice if the equation compiler reported the split tree though, that would save a lot of trouble</p>



<a name="202889106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889106">(Jul 04 2020 at 20:01)</a>:</h4>
<p>I've got this beautiful pattern:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">,</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">-- intros, refl, -- should work</span>
    <span class="c1">-- rintros a x b y (c|⟨cc|cc, cl, cv, cr⟩) z (d|⟨dc|dc, dl|⟨dlc|dlc, dll, dlv, dlr⟩, dv, dr|⟨drc|drc, drl, drv, drr⟩⟩),</span>
    <span class="c1">-- all_goals {refl}</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">delta</span> <span class="n">balance</span> <span class="n">balance</span><span class="bp">._</span><span class="n">main</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">c</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_left</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_right</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_right_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_left_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_right</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_right_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_right</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_right_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">c_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">d_color</span><span class="bp">;</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202889108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889108">(Jul 04 2020 at 20:01)</a>:</h4>
<p>very repetitive, but it's entirely obvious what to do next.</p>



<a name="202889158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889158">(Jul 04 2020 at 20:02)</a>:</h4>
<p>and it's directly driven by the goal, no guessing.</p>



<a name="202889174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889174">(Jul 04 2020 at 20:03)</a>:</h4>
<p>so I think, we could pattern match <code>%%x.cases_on _ c</code> and then <code>cases c</code> or something like that.</p>



<a name="202889225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889225">(Jul 04 2020 at 20:04)</a>:</h4>
<p>You can also try <code>casesm</code>. First you try refl, then <code>casesm color</code>, try refl again then try <code>casesm</code> on trees but without repetition</p>



<a name="202889241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889241">(Jul 04 2020 at 20:05)</a>:</h4>
<p>the problem with that is that the type here is recursive, so you can end up splitting forever if you don't consult the definition</p>



<a name="202889308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889308">(Jul 04 2020 at 20:06)</a>:</h4>
<p>I kind of like the idea of finding occurrences of <code>rec_on</code> or <code>cases_on</code> and unfold them.</p>



<a name="202889313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889313">(Jul 04 2020 at 20:07)</a>:</h4>
<p>that should be fairly safe and make progress, because it shrinks the lambda.</p>



<a name="202889371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889371">(Jul 04 2020 at 20:08)</a>:</h4>
<p>I would like the <code>split_unfold</code> tactic to not split <code>rec</code> terms that were manually written (not part of the equation compiler splitting) though</p>



<a name="202889377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889377">(Jul 04 2020 at 20:09)</a>:</h4>
<p>no problem</p>



<a name="202889391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889391">(Jul 04 2020 at 20:09)</a>:</h4>
<p><code>id_rhs</code> is a special term added by the compiler.</p>



<a name="202889393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889393">(Jul 04 2020 at 20:09)</a>:</h4>
<p>so we should only split on them.</p>



<a name="202889405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889405">(Jul 04 2020 at 20:09)</a>:</h4>
<p>just an identity function for this very purpose; to drive case splits.</p>



<a name="202889454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889454">(Jul 04 2020 at 20:10)</a>:</h4>
<p>Looking at the term, it looks like <code>id_rhs</code> protects individual branches of the definition</p>



<a name="202889457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889457">(Jul 04 2020 at 20:10)</a>:</h4>
<p>I don't know if <code>dsimp</code> simplifies it</p>



<a name="202889464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889464">(Jul 04 2020 at 20:11)</a>:</h4>
<p>so that really means, to find the tree, we could probably do a tree walk over the expr, collecting <code>id_rhs</code></p>



<a name="202889483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889483">(Jul 04 2020 at 20:11)</a>:</h4>
<p>we don't need to dsimp at all, I don't think.</p>



<a name="202889522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889522">(Jul 04 2020 at 20:12)</a>:</h4>
<p>the <code>._main</code> is normalized after all.</p>



<a name="202889525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889525">(Jul 04 2020 at 20:12)</a>:</h4>
<p>so we could walk that definition directly to get the tree.</p>



<a name="202889530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889530">(Jul 04 2020 at 20:13)</a>:</h4>
<p>and <code>dsimp</code> seems to keep it in place btw.</p>



<a name="202889546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889546">(Jul 04 2020 at 20:13)</a>:</h4>
<p>I run <code>dsimp</code> at every step and still see it. It goes away once the <code>rec</code> and <code>cases_on</code> are invoked.</p>



<a name="202889609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889609">(Jul 04 2020 at 20:14)</a>:</h4>
<p>oh, that sounds more like it's not being touched because it is in a dependent position</p>



<a name="202889754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202889754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202889754">(Jul 04 2020 at 20:18)</a>:</h4>
<p>so I finished the proof using this weird script above, it's very mechanical and super fast it checks in like 200ms.</p>



<a name="202890003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890003">(Jul 04 2020 at 20:26)</a>:</h4>
<p>Cool! Do you want to PR it?</p>



<a name="202890018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890018">(Jul 04 2020 at 20:27)</a>:</h4>
<p>Well, I don't have a tactic for it. Just verified that this mechanical thing works.</p>



<a name="202890021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890021">(Jul 04 2020 at 20:27)</a>:</h4>
<p>At the moment, though each line still has a different identifier.</p>



<a name="202890022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890022">(Jul 04 2020 at 20:27)</a>:</h4>
<p>I wouldn't mind a bit of help with the tactic, but then, yes sure, I'll make a PR.</p>



<a name="202890082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890082">(Jul 04 2020 at 20:28)</a>:</h4>
<p>see if you can derive the name from the goal, so that your tactic is repeated verbatim n times</p>



<a name="202890092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890092">(Jul 04 2020 at 20:28)</a>:</h4>
<p>even if it's something hacky like ~ <code>last (get_app_args target)</code></p>



<a name="202890100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890100">(Jul 04 2020 at 20:29)</a>:</h4>
<p>yep, I think it's a lambda application each time.</p>



<a name="202890105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890105">(Jul 04 2020 at 20:29)</a>:</h4>
<p>so if I pattern match the expr, that should work.</p>



<a name="202890179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890179">(Jul 04 2020 at 20:30)</a>:</h4>
<p>Indeed</p>



<a name="202890278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890278">(Jul 04 2020 at 20:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> consider using <code>app_arg</code> instead of <code>last (get_app_args _)</code>, it's faster and simpler</p>



<a name="202890325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890325">(Jul 04 2020 at 20:34)</a>:</h4>
<p>The ~ is because that's totally made up</p>



<a name="202890335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890335">(Jul 04 2020 at 20:35)</a>:</h4>
<p>where's a handwavy emoji when you need one</p>



<a name="202890710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890710">(Jul 04 2020 at 20:47)</a>:</h4>
<p>hehe</p>



<a name="202890842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202890842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202890842">(Jul 04 2020 at 20:51)</a>:</h4>
<p>horrible, unelegant, not pretty and all, but effective:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">get_arg</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">app</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">y</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">failed</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">split_unfold</span> <span class="o">:=</span>
<span class="n">do</span>  <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">l</span> <span class="bp">=</span> <span class="err">%%</span><span class="n">r</span><span class="o">)</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">target</span><span class="o">,</span>
    <span class="n">head</span> <span class="err">←</span> <span class="n">get_arg</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">cases</span> <span class="n">head</span>



<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">,</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">-- intros, refl, -- should work</span>
    <span class="c1">-- rintros a x b y (c|⟨cc|cc, cl, cv, cr⟩) z (d|⟨dc|dc, dl|⟨dlc|dlc, dll, dlv, dlr⟩, dv, dr|⟨drc|drc, drl, drv, drr⟩⟩),</span>
    <span class="c1">-- all_goals {refl}</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">delta</span> <span class="n">balance</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">split_unfold</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="n">dsimp</span> <span class="bp">&lt;|&gt;</span> <span class="n">skip</span><span class="o">}},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202891025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891025">(Jul 04 2020 at 20:57)</a>:</h4>
<p><code>get_arg</code> should already exist</p>



<a name="202891027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891027">(Jul 04 2020 at 20:57)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/expr.app_arg/src">src#expr.app_arg</a></p>



<a name="202891071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891071">(Jul 04 2020 at 20:58)</a>:</h4>
<p>the kind of experience, I'd want would be something like you have the normal local context, where balance is kept as a constant, nothing fancy.  Then you'd call <code>unfold_split balance with  lc ll lv lr</code>. It would do the <code>delta balance, dsimp</code> internally to find the next arg. Then throw away the state, and simply do the <code>split</code> on said identifier.</p>



<a name="202891098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891098">(Jul 04 2020 at 20:59)</a>:</h4>
<p>I was thinking that <code>split_unfold</code> would split as many times as necessary to apply <code>unfold balance</code> once in every subgoal</p>



<a name="202891107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891107">(Jul 04 2020 at 20:59)</a>:</h4>
<p>ya, could do that too.</p>



<a name="202891151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891151">(Jul 04 2020 at 21:00)</a>:</h4>
<p>then we need the full tree.</p>



<a name="202891157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891157">(Jul 04 2020 at 21:00)</a>:</h4>
<p>either way, it'd be nice, if we don't do the <code>delta</code> in the user-visible state.</p>



<a name="202891169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891169">(Jul 04 2020 at 21:00)</a>:</h4>
<p>yeah, it would do your <code>repeat {split_unfold, all_goals ...}</code> loop internally</p>



<a name="202891174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891174">(Jul 04 2020 at 21:00)</a>:</h4>
<p>yep.</p>



<a name="202891909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891909">(Jul 04 2020 at 21:22)</a>:</h4>
<p>actually, I don't think we should be unfolding the apps like this... The equational lemmas tell us exactly what cases are possible.</p>



<a name="202891918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891918">(Jul 04 2020 at 21:23)</a>:</h4>
<p>If we go and unfold apps wildly, we may end up unfolding inside of user code which is a bad idea.</p>



<a name="202891927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891927">(Jul 04 2020 at 21:23)</a>:</h4>
<p>so we should really use the definitional lemmas to infer the split tree. and then use the local context to decide which ones are missing</p>



<a name="202891966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202891966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202891966">(Jul 04 2020 at 21:24)</a>:</h4>
<p>I'm pretty sure that's safer, don't you think?</p>



<a name="202892037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892037">(Jul 04 2020 at 21:26)</a>:</h4>
<p>I don't think using the equational lemmas is going to be easy. In comparison, doing case for the calls to rec in the user code should be a small enough issue. If you use <code>match</code> in your code, the tactic won't see the <code>rec</code> calls so you really have to invoke them directly. And when you do, you can have an option to say "do one less than you otherwise would"</p>



<a name="202892091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892091">(Jul 04 2020 at 21:28)</a>:</h4>
<p>One thing you can use the equation tree for is check if you have done enough <code>cases</code>. If you can find an equation that matches your current state, you should stop going into more case analysis.</p>



<a name="202892105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892105">(Jul 04 2020 at 21:29)</a>:</h4>
<p>ah, the argument being, that we FIRST unfold the arguments and only then things in the body.</p>



<a name="202892112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892112">(Jul 04 2020 at 21:29)</a>:</h4>
<p>so by noticing, we've done enough cases, we can use that as the exit criterion.</p>



<a name="202892121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892121">(Jul 04 2020 at 21:29)</a>:</h4>
<p>exactly</p>



<a name="202892185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892185">(Jul 04 2020 at 21:30)</a>:</h4>
<p>in that case the raw delta unfolding is not really a problem, because we will consume the whole definition.</p>



<a name="202892205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892205">(Jul 04 2020 at 21:31)</a>:</h4>
<p>exactly</p>



<a name="202892298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892298">(Jul 04 2020 at 21:34)</a>:</h4>
<p>I could see using <code>split_unfold balance</code> as one would use <code>cases</code>. We can tag the resulting goals and do a proof by case or do <code>split_unfold balance; finish</code> (with <code>finish</code> or other tactic)</p>



<a name="202892388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892388">(Jul 04 2020 at 21:37)</a>:</h4>
<p>I don't think so.</p>



<a name="202892393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892393">(Jul 04 2020 at 21:37)</a>:</h4>
<p>In case you DO want to tag, <code>rcases</code> does the trick.</p>



<a name="202892396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892396">(Jul 04 2020 at 21:37)</a>:</h4>
<p><code>split_unfold</code> is specifically about not having to do that.</p>



<a name="202892436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892436">(Jul 04 2020 at 21:38)</a>:</h4>
<p><code>rcases</code> already does the cartesian explosion for you.</p>



<a name="202892464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892464">(Jul 04 2020 at 21:39)</a>:</h4>
<p>but I really can't see how you can use inference and have to provide explicit identifiers at the same time.</p>



<a name="202892513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892513">(Jul 04 2020 at 21:40)</a>:</h4>
<p>Right but it does it with a pattern that you provide it. <code>split_unfold</code> detects that pattern. If you don't want to do the proof by case you don't have to. If you do, it's easy to enable</p>



<a name="202892528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892528">(Jul 04 2020 at 21:41)</a>:</h4>
<p>But what would be the identifiers you provide?</p>



<a name="202892532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892532">(Jul 04 2020 at 21:41)</a>:</h4>
<p>There's a pattern that you can follow:</p>
<div class="codehilite"><pre><span></span><code><span class="n">cases</span> <span class="n">xs</span><span class="o">,</span>
<span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="o">:</span>
<span class="o">{</span> <span class="c">/-</span><span class="cm"> proof when xs is nil -/</span> <span class="o">},</span>
<span class="n">case</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">:</span> <span class="n">x</span> <span class="n">xs</span>
<span class="o">{</span> <span class="c">/-</span><span class="cm"> proof when xs is cons -/</span> <span class="o">},</span>
</code></pre></div>


<p>That's actually what I refer to as "tagging the goals"</p>



<a name="202892535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892535">(Jul 04 2020 at 21:41)</a>:</h4>
<p>AH, that you mean.</p>



<a name="202892540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892540">(Jul 04 2020 at 21:41)</a>:</h4>
<p>i thought you meant naming the locals.</p>



<a name="202892588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892588">(Jul 04 2020 at 21:42)</a>:</h4>
<p>No, like you say, for that <code>rcases</code> does a good job already.</p>



<a name="202892605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892605">(Jul 04 2020 at 21:43)</a>:</h4>
<p>I'm really excited now, once we have this as a tactic, proving large cases will be much nicer :D</p>



<a name="202892659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202892659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202892659">(Jul 04 2020 at 21:44)</a>:</h4>
<p>:) me too</p>



<a name="202895895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202895895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202895895">(Jul 04 2020 at 23:32)</a>:</h4>
<p>Have you considered what you want to do if <code>balance</code> occurs more than once in the goal?</p>



<a name="202896026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896026">(Jul 04 2020 at 23:35)</a>:</h4>
<p>Ya, I'm just walking around the house thinking about it.</p>



<a name="202896068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896068">(Jul 04 2020 at 23:36)</a>:</h4>
<p>Let alone under quantifiers.</p>



<a name="202896073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896073">(Jul 04 2020 at 23:36)</a>:</h4>
<p>I'm tempted to change the interface a bit</p>



<a name="202896089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896089">(Jul 04 2020 at 23:37)</a>:</h4>
<p>how about you'd <code>unfold_split balance color.black (node.tree col left v right)</code>...</p>



<a name="202896096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896096">(Jul 04 2020 at 23:37)</a>:</h4>
<p>I.e. rather than trying to do the cartesian explosion that'd be needed for fully solving the problem for multiple occurrences, we'd ask the user to give us an expression</p>



<a name="202896139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896139">(Jul 04 2020 at 23:38)</a>:</h4>
<p>and we'd unfold to the point where the definition goes away in that case.</p>



<a name="202896337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896337">(Jul 04 2020 at 23:45)</a>:</h4>
<p>That's one way. You could also make up an attribute to tag <code>balance</code> with and generate an inductive relation for it, to encode the graph of the function. If I simplify, for definition <code>f</code>, you'd have the property that <code>f x = y &lt;-&gt; r x y</code></p>



<a name="202896400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896400">(Jul 04 2020 at 23:47)</a>:</h4>
<p>Then, if you try to prove <code>P (f x)</code>, you can replace it with <code>∀ y, r x y -&gt; P y</code> and then doing <code>cases</code> on the <code>r x y</code> gives you all the cases that you care about</p>



<a name="202896441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896441">(Jul 04 2020 at 23:48)</a>:</h4>
<p>Ah, so rather than doing induction on <code>x</code>, we'd do induction over <code>r</code>, yes?</p>



<a name="202896445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896445">(Jul 04 2020 at 23:48)</a>:</h4>
<p>that's right</p>



<a name="202896452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896452">(Jul 04 2020 at 23:48)</a>:</h4>
<p>ya, that looks really neat, actually.</p>



<a name="202896460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896460">(Jul 04 2020 at 23:49)</a>:</h4>
<p>So how could I have the compiler spit out the definitions?</p>



<a name="202896513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896513">(Jul 04 2020 at 23:51)</a>:</h4>
<p>Go in <code>tactic.ext</code>, you'll see that, when you apply <code>ext</code> to a structure definition, it generates theorems. In your case, instead, you'd generate an inductive type</p>



<a name="202896522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896522">(Jul 04 2020 at 23:51)</a>:</h4>
<p>Ok, I'll look, thx</p>



<a name="202896738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896738">(Jul 04 2020 at 23:59)</a>:</h4>
<p>do I understand correctly that the <code>ext</code> attribute is only used inside of a call to the <code>ext</code> tactic and gets created on the fly? Or is there somehow a separate code-gen phase (didn't read the code in detail yet)</p>



<a name="202896842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896842">(Jul 05 2020 at 00:02)</a>:</h4>
<p>oh, I see. It's the <code>after_set</code> of the <code>user_attribute</code> that generates the code.</p>



<a name="202896937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896937">(Jul 05 2020 at 00:05)</a>:</h4>
<p>That's right. You tag your structures and lemmas with <code>ext</code>. For structures, it creates an extensionality lemma and puts the <code>ext</code> attribute on it. For lemmas, it just puts them in a table of extensionality lemmas indexed by the type they apply to</p>



<a name="202896978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202896978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202896978">(Jul 05 2020 at 00:06)</a>:</h4>
<p>The <code>ext</code> tactic reads that table and selects the right lemmas when needed</p>



<a name="202897769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202897769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202897769">(Jul 05 2020 at 00:35)</a>:</h4>
<p>wahoo, I can now generate a relation :). It's a dumb one, just added the identity function, but my attribute works :D</p>



<a name="202903589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202903589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202903589">(Jul 05 2020 at 03:51)</a>:</h4>
<p>I think the idea of generating additional lemma or the graph run into the same kind of problem. By the time we get access to the expr that corresponds to the definition of the function, the pattern match is lost. So we again have to reconstruct the decision procedure from the lambda. And the decision procedure is NOT what is written in the matter match, in fact that's the reason why <code>refl</code> doesn't work.</p>



<a name="202904197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904197">(Jul 05 2020 at 04:11)</a>:</h4>
<p>The usefulness of that lemma is not to do away with the machinery that we discussed but to separate two parts of the problem. When generating the lemmas, you have a simple, controlled proof state. That makes the case distinction logic less susceptible to breaking. When we use them, the proof state maybe be less clean but the lemmas should present a nice interface</p>



<a name="202904249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904249">(Jul 05 2020 at 04:13)</a>:</h4>
<p>yes, that makes a lot of sense</p>



<a name="202904252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904252">(Jul 05 2020 at 04:13)</a>:</h4>
<p>and I think I might a way how to reconstruct the "pattern match" cases from the lemmas.</p>



<a name="202904292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904292">(Jul 05 2020 at 04:14)</a>:</h4>
<p>In one of my projects I designed a data structure that creates a set based on cartesian products, as in it detects when a particular subset is a cartesian product.</p>



<a name="202904300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904300">(Jul 05 2020 at 04:15)</a>:</h4>
<p>this mechanism could be used to figure out what combinations of equations form a subset, that is a cartesian product</p>



<a name="202904342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904342">(Jul 05 2020 at 04:16)</a>:</h4>
<p>and then when it is a cartesian product, you can universally quantify instead of the distinction by cases.</p>



<a name="202904344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904344">(Jul 05 2020 at 04:16)</a>:</h4>
<p>From the lemmas, I think that should be more straightforward than that.</p>



<a name="202904350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904350">(Jul 05 2020 at 04:16)</a>:</h4>
<blockquote>
<p>Then, if you try to prove P (f x), you can replace it with ∀ y, r x y -&gt; P y and then doing cases on the r x y gives you all the cases that you care about</p>
</blockquote>



<a name="202904353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904353">(Jul 05 2020 at 04:17)</a>:</h4>
<p>when you have <code>h : r x y</code>, doing <code>cases h</code> should give you the perfect case distinction</p>



<a name="202904394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904394">(Jul 05 2020 at 04:18)</a>:</h4>
<p>right, but what's the structure of <code>r</code>? just a single inductive with 122 cases?</p>



<a name="202904400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904400">(Jul 05 2020 at 04:19)</a>:</h4>
<p>I thought we would want it to be compactified.</p>



<a name="202904401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904401">(Jul 05 2020 at 04:19)</a>:</h4>
<p>You can put that in a derived lemma of the shape:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">balance_rec</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">P</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="202904424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904424">(Jul 05 2020 at 04:19)</a>:</h4>
<p>No, <code>r</code> would just have the few equations that you care about</p>



<a name="202904465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904465">(Jul 05 2020 at 04:20)</a>:</h4>
<p>exactly, but the difficulty is to generate <code>r</code> from the definition.</p>



<a name="202904466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904466">(Jul 05 2020 at 04:20)</a>:</h4>
<p>Or were you thinking to hand-write <code>r</code>?</p>



<a name="202904470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904470">(Jul 05 2020 at 04:20)</a>:</h4>
<p>No, I see that I overlooked a difficulty, you're right</p>



<a name="202904478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904478">(Jul 05 2020 at 04:21)</a>:</h4>
<p>it boils down to finding a way how to compress the number of cases.</p>



<a name="202904479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904479">(Jul 05 2020 at 04:21)</a>:</h4>
<p>You'd still need to filter the cases.</p>



<a name="202904481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904481">(Jul 05 2020 at 04:21)</a>:</h4>
<p>once we have that, the equation lemmas are fine</p>



<a name="202904484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904484">(Jul 05 2020 at 04:21)</a>:</h4>
<p>in fact <code>=</code> is just such a relation after all</p>



<a name="202904522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904522">(Jul 05 2020 at 04:22)</a>:</h4>
<p>That's true (on both accounts)</p>



<a name="202904524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904524">(Jul 05 2020 at 04:22)</a>:</h4>
<p>When generating the relation, we can take care of the case filtering there</p>



<a name="202904530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904530">(Jul 05 2020 at 04:23)</a>:</h4>
<p>right. Or we can generate some augmented helper cases for the equation lemmas.</p>



<a name="202904532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904532">(Jul 05 2020 at 04:23)</a>:</h4>
<p>something like <code>case_1</code>.</p>



<a name="202904533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904533">(Jul 05 2020 at 04:23)</a>:</h4>
<p>then you'd <code>apply case_1</code>.</p>



<a name="202904539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904539">(Jul 05 2020 at 04:23)</a>:</h4>
<p>and it's pretty much exactly your <code>forall y, r x y -&gt; P y</code></p>



<a name="202904541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904541">(Jul 05 2020 at 04:23)</a>:</h4>
<p>I'd have to see it to judge</p>



<a name="202904582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904582">(Jul 05 2020 at 04:24)</a>:</h4>
<p>first I'd need this mechanism of finding what case splits were unnecessary.</p>



<a name="202904588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904588">(Jul 05 2020 at 04:25)</a>:</h4>
<p>If you had access to the specification, that would be easier. Maybe we can add that to Lean's API</p>



<a name="202904590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904590">(Jul 05 2020 at 04:25)</a>:</h4>
<p>ya, having the spec would be a lot better, indeed.</p>



<a name="202904628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904628">(Jul 05 2020 at 04:26)</a>:</h4>
<p>plus it'd give a canonical way for building <code>r</code>.</p>



<a name="202904630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904630">(Jul 05 2020 at 04:26)</a>:</h4>
<p>And we could make <code>r</code> even better like this:</p>



<a name="202904645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904645">(Jul 05 2020 at 04:27)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">case_1</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">case_2</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">U</span> <span class="bp">-&gt;</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">case_3</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">T</span> <span class="bp">-&gt;</span> <span class="bp">¬</span><span class="n">U</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">r</span>
</code></pre></div>



<a name="202904683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904683">(Jul 05 2020 at 04:28)</a>:</h4>
<p>this kind of thing could make proofs potentially easier in some cases.</p>



<a name="202904693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904693">(Jul 05 2020 at 04:29)</a>:</h4>
<p>who parses the spec, btw? Is that written in c++ or lean?</p>



<a name="202904800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904800">(Jul 05 2020 at 04:33)</a>:</h4>
<p>That's written in C++. That part of the code is fresh in my mind. I've been playing with the equation compiler in the last couple of months. It might be good to see if we can make the feature without this addition though</p>



<a name="202904980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202904980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202904980">(Jul 05 2020 at 04:39)</a>:</h4>
<p>I could port my product set, potentially.</p>



<a name="202905030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905030">(Jul 05 2020 at 04:40)</a>:</h4>
<p>That thing would at least figure out what pairs of variables form cartesian products.</p>



<a name="202905034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905034">(Jul 05 2020 at 04:40)</a>:</h4>
<p>or maybe at least the core of that inference.</p>



<a name="202905048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905048">(Jul 05 2020 at 04:41)</a>:</h4>
<p>The rule is, that a union of two cartesian products is a cartesian product iff all but one dimensions agree.</p>



<a name="202905096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905096">(Jul 05 2020 at 04:42)</a>:</h4>
<p>so if each variable is a dimension, and each constructor a point, then you can think of each case as a bunch of points in an n-dimensional space.</p>



<a name="202905107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905107">(Jul 05 2020 at 04:43)</a>:</h4>
<p>and this inference allows you to merge things into bigger and bigger "blocks" which translates into more and more coarse patterns.</p>



<a name="202905259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905259">(Jul 05 2020 at 04:48)</a>:</h4>
<p>That could be useful. You might want to start with more basic stuff and build up to it</p>



<a name="202905363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905363">(Jul 05 2020 at 04:50)</a>:</h4>
<p>Well, the product set is really just that. A representation of a set. But unlike a hash set or a binary search tree, is has a notion of dense and sparse and uses this to compress the representation.</p>



<a name="202905369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905369">(Jul 05 2020 at 04:51)</a>:</h4>
<p>you could think of it a bit like n-dimensional run-length encoding.</p>



<a name="202905382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905382">(Jul 05 2020 at 04:51)</a>:</h4>
<p>but it can be used for this kind of task where you need to figure out if you are "dense" over a region. In fact that was the very purpose we built it in the other project.</p>



<a name="202905435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905435">(Jul 05 2020 at 04:52)</a>:</h4>
<p>As for making a simpler cases, I really know what, to be honest.</p>



<a name="202905438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905438">(Jul 05 2020 at 04:52)</a>:</h4>
<p>My experience with lean is overall really, really nice.</p>



<a name="202905443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905443">(Jul 05 2020 at 04:53)</a>:</h4>
<p>It's just that it completely falls apart in case of these large-number case-splits.</p>



<a name="202905455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905455">(Jul 05 2020 at 04:53)</a>:</h4>
<p>So working on fixing that is extremely enticing, tbh.</p>



<a name="202905503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905503">(Jul 05 2020 at 04:54)</a>:</h4>
<p>Excellent :) It sounds like we'll get some nice automation to work with</p>



<a name="202905518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905518">(Jul 05 2020 at 04:55)</a>:</h4>
<p>let me port the product set then. It's gonna take me a few days, but it's a purely functional persistent datastructure.</p>



<a name="202905525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905525">(Jul 05 2020 at 04:55)</a>:</h4>
<p>so it shouldn't be too bad.</p>



<a name="202905526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905526">(Jul 05 2020 at 04:55)</a>:</h4>
<p>For a more verification condition style of verification (a la F*), I built something that could be considered a further extension. It creates lemma stubs for you</p>



<a name="202905532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905532">(Jul 05 2020 at 04:55)</a>:</h4>
<p>My original version is in typescript. So lean should have no trouble representing it.</p>



<a name="202905575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905575">(Jul 05 2020 at 04:56)</a>:</h4>
<p>and I was actually making a point to design it very flexibly. Thinking as inductive branches as exactly the kind of thing we might want.</p>



<a name="202905587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905587">(Jul 05 2020 at 04:57)</a>:</h4>
<p>Cool</p>



<a name="202905594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905594">(Jul 05 2020 at 04:57)</a>:</h4>
<p>I'll be in touch ;-)</p>



<a name="202905641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905641">(Jul 05 2020 at 04:58)</a>:</h4>
<p>Please do</p>



<a name="202905642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202905642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202905642">(Jul 05 2020 at 04:58)</a>:</h4>
<p>I actually have a formal proof of the cartesian product properties in lean (was an exercise when I was learning)</p>



<a name="202945851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202945851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202945851">(Jul 06 2020 at 01:05)</a>:</h4>
<p>I've got the first layer coded up. This is the bsp set. The idea is, that you provide a way of breaking the space into disjoint regions (however you want, e.g. one constructor at a time, or something like that). And then the bsp set lets you do efficient set operations like union, intersection, set difference and complement.</p>



<a name="202945852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202945852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202945852">(Jul 06 2020 at 01:05)</a>:</h4>
<p><a href="https://gist.github.com/DanielFabian/9e1013582f7ce6e5563f204708a82e5d">https://gist.github.com/DanielFabian/9e1013582f7ce6e5563f204708a82e5d</a></p>



<a name="202945900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202945900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202945900">(Jul 06 2020 at 01:06)</a>:</h4>
<p>the next layer would be the product set. That's a multidimensional thing that lets us find these regions that form cartesian products. and they'd allow us to find an efficient handling of all the cases.</p>



<a name="202945908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202945908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202945908">(Jul 06 2020 at 01:07)</a>:</h4>
<p>One challenge I see, though, is that even once we have these regions, unification of types is not really straightforward...</p>



<a name="202946096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946096">(Jul 06 2020 at 01:12)</a>:</h4>
<p>consider a case like this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">sparse_node</span><span class="o">),</span> <span class="n">combine_children</span> <span class="o">(</span><span class="n">sparse</span> <span class="n">left</span><span class="o">)</span> <span class="n">empty</span> <span class="bp">=</span> <span class="n">sparse</span> <span class="o">(</span><span class="n">left</span><span class="bp">.</span><span class="n">left_sparse</span> <span class="n">empty</span><span class="o">)</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">sparse_node</span><span class="o">),</span> <span class="n">combine_children</span> <span class="o">(</span><span class="n">sparse</span> <span class="n">left</span><span class="o">)</span> <span class="n">dense</span> <span class="bp">=</span> <span class="n">sparse</span> <span class="o">(</span><span class="n">left</span><span class="bp">.</span><span class="n">left_sparse</span> <span class="n">dense</span><span class="o">)</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">left</span> <span class="n">root</span> <span class="o">:</span> <span class="n">sparse_node</span><span class="o">),</span> <span class="n">combine_children</span> <span class="o">(</span><span class="n">sparse</span> <span class="n">left</span><span class="o">)</span> <span class="o">(</span><span class="n">sparse</span> <span class="n">root</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sparse</span> <span class="o">(</span><span class="n">left</span><span class="bp">.</span><span class="n">left_sparse</span> <span class="o">(</span><span class="n">sparse</span> <span class="n">root</span><span class="o">))</span>
</code></pre></div>


<p>these three right-hand sides are supposed to be the same, modulo the case split <code>empty | dense | sparse root</code>. And we have to somehow reconstruct that based solely on the right-hand sides. But the problem is that the right-hand sides have all cases mixed together, so if there were multiple occurrences of <code>empty</code>, say, how would we know which one to turn into the forall case?</p>



<a name="202946116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946116">(Jul 06 2020 at 01:13)</a>:</h4>
<p>this here, again suggests that we might be better off having access to the spec, somehow.</p>



<a name="202946651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946651">(Jul 06 2020 at 01:30)</a>:</h4>
<p>I think this should not be your first focus. Using a more naive data structure first should help you understand the API better . It might even be that a naive data structure could provide sufficient performances. The size of the data structures is often not very big.</p>



<a name="202946722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946722">(Jul 06 2020 at 01:32)</a>:</h4>
<p>One problem I see, is that the API I saw (expressions, declarations, theorems, etc.) are all essentially just lambda expressions.</p>



<a name="202946728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946728">(Jul 06 2020 at 01:32)</a>:</h4>
<p>but the high-level intent is lost.</p>



<a name="202946736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946736">(Jul 06 2020 at 01:33)</a>:</h4>
<p>It's almost like trying to reconstruct the meaning of a program from assembly</p>



<a name="202946847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946847">(Jul 06 2020 at 01:36)</a>:</h4>
<p>You'd be surprised how much can be done with nothing but terms. That's because you can restrict the shape of the terms that you consider</p>



<a name="202946920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946920">(Jul 06 2020 at 01:39)</a>:</h4>
<p>I do see that <code>cases_on</code> could be potentially used to reconstruct pattern matches.</p>



<a name="202946985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202946985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202946985">(Jul 06 2020 at 01:41)</a>:</h4>
<p>With <code>cases_on</code> or <code>rec_on</code>, you can verify that it's a recursor, you can check how many parameters and indices the type has and then select which argument is the subject</p>



<a name="202947037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947037">(Jul 06 2020 at 01:42)</a>:</h4>
<p>sure, we get the arity from <code>cases_on</code></p>



<a name="202947040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947040">(Jul 06 2020 at 01:42)</a>:</h4>
<p>so that's the destructed things in the pattern match.</p>



<a name="202947046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947046">(Jul 06 2020 at 01:42)</a>:</h4>
<p>but how do you unify the resulting terms?</p>



<a name="202947049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947049">(Jul 06 2020 at 01:42)</a>:</h4>
<p>when they are clearly not the same.</p>



<a name="202947119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947119">(Jul 06 2020 at 01:44)</a>:</h4>
<p>even the most trivial case is not quite straight-forward: <code>fun x, x</code> for natural numbers could be something like <code>nat.cases_on zero (fun x, succ x)</code></p>



<a name="202947139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947139">(Jul 06 2020 at 01:45)</a>:</h4>
<p>Consider this type of <code>sum.cases_on : Π α β (C : sum α β → Sort u), sum α β → (Π x, C (sum.inl x)) → (Π x, C (sum.inr x)) : Π x : sum α β, C x</code>, you see that the first three arguments are not the branches and not the subject. That's why you need to use the API to get more meta information</p>



<a name="202947144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947144">(Jul 06 2020 at 01:45)</a>:</h4>
<p>Do you have a concrete example of where the problem shows up?</p>



<a name="202947205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947205">(Jul 06 2020 at 01:47)</a>:</h4>
<p>ya, sure. e.g. the generated functions for my own pattern match functions I wrote for the bsp set.</p>



<a name="202947209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947209">(Jul 06 2020 at 01:47)</a>:</h4>
<p>the three quoted lines above.</p>



<a name="202947217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947217">(Jul 06 2020 at 01:47)</a>:</h4>
<p>they all correspond to <code>sparse x</code></p>



<a name="202947297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947297">(Jul 06 2020 at 01:49)</a>:</h4>
<p>or were you talking about the fact, that not all arguments show up?</p>



<a name="202947306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947306">(Jul 06 2020 at 01:49)</a>:</h4>
<p>That's what I was referring to.</p>



<a name="202947358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947358">(Jul 06 2020 at 01:50)</a>:</h4>
<p>For sparse node, is it supposed to be an example or is it a data structure for the tactic?</p>



<a name="202947379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947379">(Jul 06 2020 at 01:51)</a>:</h4>
<p>Well, I ported the data structure, but the example is really showing the kind of thing, I don't really know how to address.</p>



<a name="202947382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947382">(Jul 06 2020 at 01:51)</a>:</h4>
<p>Pretty much all pattern-match defined functions have these equation lemmas.</p>



<a name="202947423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947423">(Jul 06 2020 at 01:52)</a>:</h4>
<p>and their rhs would very often be the same, module case split.</p>



<a name="202947426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947426">(Jul 06 2020 at 01:52)</a>:</h4>
<p>and the tactic we want is meant to somehow unify the cases that are same.</p>



<a name="202947432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947432">(Jul 06 2020 at 01:52)</a>:</h4>
<p>because that's how you get the number of cases down to the number of lines in the pattern match.</p>



<a name="202947438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947438">(Jul 06 2020 at 01:53)</a>:</h4>
<p>after all the RB-tree example has something like 5 cases in the source code, but 122 equations.</p>



<a name="202947444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947444">(Jul 06 2020 at 01:53)</a>:</h4>
<p>that means you have somthing like 30 equations each all coming from the same exact term in the source code.</p>



<a name="202947449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947449">(Jul 06 2020 at 01:53)</a>:</h4>
<p>I.e. they are identical modulo the case split.</p>



<a name="202947499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947499">(Jul 06 2020 at 01:54)</a>:</h4>
<p>but the substitution of terms is not an injective operation.</p>



<a name="202947562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947562">(Jul 06 2020 at 01:56)</a>:</h4>
<p>for now I haven't even tried doing more complicated cases like dependent pattern matching or recursion, just the simplest possible cases of straight, non-recursive, non-dependent pattern matching.</p>



<a name="202947791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947791">(Jul 06 2020 at 02:02)</a>:</h4>
<p>Ok so the plan so far is:</p>
<ol>
<li>generate an inductive relation</li>
<li>generate the equivalence lemma</li>
<li>automate the application of the lemma.</li>
</ol>
<p>Where would your issue become relevant?</p>



<a name="202947892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947892">(Jul 06 2020 at 02:05)</a>:</h4>
<p>before step one. In order to create a relation that's somehow better than the 122 cases, we need a way to find out what cases are the same modulo the case split. And it is on those far fewer cases that we would want to create the inductive definition.</p>



<a name="202947908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947908">(Jul 06 2020 at 02:05)</a>:</h4>
<p>but since I don't know the spec, the best I can do is try and reconstruct the spec from the already existing equation lemmas.</p>



<a name="202947957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947957">(Jul 06 2020 at 02:06)</a>:</h4>
<p>on the bright side, the equation lemmas have a standard from: <code>forall x, f x = y</code>.</p>



<a name="202947964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947964">(Jul 06 2020 at 02:07)</a>:</h4>
<p>but then they get split into the various cases that the compiler happened to have generated.</p>



<a name="202947973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202947973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202947973">(Jul 06 2020 at 02:08)</a>:</h4>
<p>so when there's a case split on <code>x</code>, then in <code>y</code> there'd be the substition from <code>x</code> to just the one constructor of the inductive type.</p>



<a name="202948015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948015">(Jul 06 2020 at 02:08)</a>:</h4>
<p>so now you get something like this:</p>



<a name="202948016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948016">(Jul 06 2020 at 02:08)</a>:</h4>
<p>Ok, yes now I see</p>



<a name="202948022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948022">(Jul 06 2020 at 02:08)</a>:</h4>
<p><code>def id x := x</code> for nat turns into <code>id zero = zero</code> and <code>forall n, id (succ n) = succ n</code>.</p>



<a name="202948027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948027">(Jul 06 2020 at 02:09)</a>:</h4>
<p>and it's really not straight-forward how to unify this.</p>



<a name="202948174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948174">(Jul 06 2020 at 02:13)</a>:</h4>
<p>Let's say you have two branches:</p>
<div class="codehilite"><pre><span></span><code><span class="n">foo</span> <span class="o">(</span><span class="n">C</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">E0</span>
<span class="n">foo</span> <span class="n">x</span> <span class="o">(</span><span class="n">D</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">E1</span>
</code></pre></div>


<p>You start by comparing the patterns. The first argument is not broken up then same so you abstract it. You get:</p>
<div class="codehilite"><pre><span></span><code><span class="n">foo</span> <span class="n">x</span> <span class="o">(</span><span class="n">E</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">E0</span> <span class="o">[</span><span class="n">C</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">x</span><span class="o">]</span>
<span class="n">foo</span> <span class="n">x</span> <span class="o">(</span><span class="n">D</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">E1</span>
</code></pre></div>


<p>And you continue until all the patterns are the same, introducing fresh variables when necessary. </p>
<div class="codehilite"><pre><span></span><code><span class="n">foo</span> <span class="n">x</span> <span class="n">v</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">E0</span> <span class="o">[</span><span class="n">C</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">x</span><span class="o">][</span><span class="n">E</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">v</span><span class="o">]</span>
<span class="n">foo</span> <span class="n">x</span> <span class="n">v</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">E1</span><span class="o">[</span><span class="n">D</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">v</span><span class="o">]</span>
</code></pre></div>


<p>Then you can compare the rhs. They should be syntactically equal. Definitionally equal should suffice though.</p>



<a name="202948318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948318">(Jul 06 2020 at 02:16)</a>:</h4>
<p>what if <code>C a b</code> occurs multiple times?</p>



<a name="202948476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948476">(Jul 06 2020 at 02:20)</a>:</h4>
<p>I think if we have multiple occurrences we may end up with a term that's syntactically different from the original one, but at least it probably would be def equal.</p>



<a name="202948510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948510">(Jul 06 2020 at 02:22)</a>:</h4>
<p>The variables <code>a</code> and <code>b</code> will be distinct because they all can occur only once</p>



<a name="202948541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948541">(Jul 06 2020 at 02:22)</a>:</h4>
<p>(in the syntax of a pattern)</p>



<a name="202948628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948628">(Jul 06 2020 at 02:25)</a>:</h4>
<p>I mean something like this: <code>def two_times_plus_one x := 1 + x + x</code>. so we get <code>two_times_plus_one zero = succ zero + succ zero + succ zero</code> and <code>forall n, two_times_plus_one (succ n) = succ zero + succ n + succ n</code></p>



<a name="202948631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948631">(Jul 06 2020 at 02:25)</a>:</h4>
<p>how do we tell it's actually the same case?</p>



<a name="202948684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948684">(Jul 06 2020 at 02:26)</a>:</h4>
<p>I totally can see your procedure work nicely left to right.</p>



<a name="202948904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202948904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202948904">(Jul 06 2020 at 02:33)</a>:</h4>
<p>I think it would work. If you find an occurrence of <code>succ n</code>, you know you must substitute it because <code>n</code> is a bound variable issue from the pattern <code>succ n</code>. That's the only way it can be introduced. We should even go further and, once <code>succ n</code> has been replaced, we should check that <code>n</code> is not still free in the right hand side</p>



<a name="202949180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202949180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202949180">(Jul 06 2020 at 02:41)</a>:</h4>
<p>in the second case, we'd introduce <code>1 + u + u</code> (u being fresh). In the first case, we'd do <code>v + v + v</code>. Then we need to use show that <code>forall n, u = succ n -&gt; 1 + u + u</code> and <code>v = zero, v + v + v </code> implies <code>forall k, 1 + k + k</code>.</p>



<a name="202949285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202949285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202949285">(Jul 06 2020 at 02:44)</a>:</h4>
<p>You traverse the pattern two at a time so when you introduce a fresh variable in one, it gets introduced in the second as well. But if we didn't traverse them two by two, we could use de Bruijn variables to encode fresh variables. That way, we they are syntactically equal if they have to match</p>



<a name="202949375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202949375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202949375">(Jul 06 2020 at 02:46)</a>:</h4>
<p>ok, I'll give it a go.  I think I understand the idea now.</p>



<a name="202949642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/202949642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#202949642">(Jul 06 2020 at 02:55)</a>:</h4>
<p>Cool. Looking forward to seeing how it turns out</p>



<a name="203033036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203033036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203033036">(Jul 06 2020 at 19:53)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="bp">_</span><span class="n">eqn_1</span>
<span class="n">term</span>
  <span class="n">α</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">Sort</span> <span class="n">u_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">,</span>
<span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">c</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">,</span>
<span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">d</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_6</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span><span class="bp">._</span><span class="n">main</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
      <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_5</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right_1</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span><span class="bp">._</span><span class="n">main</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">val_1</span> <span class="n">right_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
      <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">val_1</span> <span class="n">right_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_4</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span><span class="bp">._</span><span class="n">main</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
      <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">),</span>
<span class="bp">_</span><span class="n">eqn_3</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span><span class="bp">._</span><span class="n">main</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
      <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_2</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span><span class="bp">._</span><span class="n">main</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">x</span> <span class="n">b</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_1</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span> <span class="n">balance</span><span class="bp">._</span><span class="n">main</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span>
<span class="err">⊢</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
</code></pre></div>



<a name="203033105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203033105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203033105">(Jul 06 2020 at 19:54)</a>:</h4>
<p>I've got a first thing, that just pulls in the lemmas into the current context, but I can't really manipulate it.</p>



<a name="203033149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203033149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203033149">(Jul 06 2020 at 19:54)</a>:</h4>
<p>Apprently I've got a mess with the universe levels, in particular I can not <code>specialize</code> by <code>alpha</code>.</p>



<a name="203033345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203033345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203033345">(Jul 06 2020 at 19:56)</a>:</h4>
<p>And because they are implicit args in the declaration, I don't know how to apply it in the tactic, I tried</p>
<div class="codehilite"><pre><span></span><code><span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="err">%%</span><span class="n">body</span> <span class="n">alpha</span><span class="o">)</span>
<span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="o">(</span><span class="err">%%</span><span class="n">body</span><span class="o">)</span> <span class="n">alpha</span><span class="o">)</span>
</code></pre></div>



<a name="203033493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203033493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203033493">(Jul 06 2020 at 19:58)</a>:</h4>
<p>alternatively, if I skip the implicits and instead try to pass a <code>node alpha</code>, then it doesn't see meta vars. Presumably, because it expects the quantified type to live in a lower universe?</p>



<a name="203035929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203035929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203035929">(Jul 06 2020 at 20:19)</a>:</h4>
<p>Ok, I've managed to apply the type argument, but looks like it still isn't working. It just moved the universe level problem one level in. I think the root cause is, that the term <code>alpha</code> is a value in the next universe. But I need the sort, how do you do that?</p>



<a name="203045364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203045364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203045364">(Jul 06 2020 at 21:55)</a>:</h4>
<p>Ok, <code>Type u</code> is the same as <code>Sort (u+1)</code>. When you add <code>_eqn_n</code>, you can specify which universe you want to put them in. How do you create them?</p>



<a name="203045639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203045639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203045639">(Jul 06 2020 at 21:58)</a>:</h4>
<p>I do this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">my_tac</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">ident</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span>  <span class="n">lemmas</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_eqn_lemmas_for</span> <span class="n">ff</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">lemmas</span> <span class="err">←</span> <span class="n">mmap</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_decl</span> <span class="n">lemmas</span><span class="o">,</span>
    <span class="n">h</span> <span class="err">←</span> <span class="n">get_local</span> <span class="bp">``</span><span class="n">α</span><span class="o">,</span>
    <span class="n">lemmas</span><span class="bp">.</span><span class="n">for_each</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">lem</span><span class="o">,</span> <span class="n">do</span>
        <span class="n">body</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">instantiate_mvars</span> <span class="n">lem</span><span class="bp">.</span><span class="n">value</span><span class="o">,</span>
        <span class="n">body</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">head_beta</span> <span class="err">$</span> <span class="n">body</span><span class="bp">.</span><span class="n">app</span> <span class="n">h</span><span class="o">,</span>
        <span class="err">«</span><span class="k">have</span><span class="err">»</span> <span class="o">(</span><span class="n">some</span> <span class="n">lem</span><span class="bp">.</span><span class="n">to_name</span><span class="bp">.</span><span class="n">components</span><span class="bp">.</span><span class="n">ilast</span><span class="o">)</span> <span class="n">none</span> <span class="bp">``</span><span class="o">(</span><span class="err">%%</span><span class="n">body</span><span class="o">))</span>
</code></pre></div>



<a name="203045707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203045707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203045707">(Jul 06 2020 at 21:58)</a>:</h4>
<p>using the beta reduction in the second but last line, it does specialize the <code>alpha</code> away, but I still can't use it, because the theorem lives presumably in a level too low.</p>



<a name="203045778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203045778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203045778">(Jul 06 2020 at 21:59)</a>:</h4>
<p>ideally, I'd add the theorems to the local context in a way, though, that I can just apply the local <code>alpha</code>.</p>



<a name="203045859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203045859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203045859">(Jul 06 2020 at 22:00)</a>:</h4>
<p>Instead of <code>have</code>, you can use <code>note</code>. It takes elaborated terms</p>



<a name="203045986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203045986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203045986">(Jul 06 2020 at 22:01)</a>:</h4>
<p>Also, instead of using <code>lem.value</code> (which gives you the proof term for the lemmas) use <code>const n ls</code> where <code>n</code> is the name of the lemma and <code>ls</code> is the list of universe parameters that you want to use</p>



<a name="203046306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203046306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203046306">(Jul 06 2020 at 22:05)</a>:</h4>
<p>is there a way to figure out what universe the current proof lives in? my type <code>alpha</code> gets a variable <code>u_1</code> and I need to tie the lemmas to that.</p>



<a name="203046773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203046773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203046773">(Jul 06 2020 at 22:10)</a>:</h4>
<p>The way universes work, you have universe literals (0, 1, 2, 3), universe parameters (<code>u1</code>, <code>u2</code>, <code>u3</code>) and <br>
universe expressions (e.g. <code>max u (v+1)</code>)</p>



<a name="203046829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203046829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203046829">(Jul 06 2020 at 22:11)</a>:</h4>
<p>right, that's the <code>level</code> inductive, right?</p>



<a name="203046847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203046847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203046847">(Jul 06 2020 at 22:11)</a>:</h4>
<p>If <code>alpha : Sort u</code>, the type of alpha is an expression <code>sort l</code> where <code>l</code> is a universe level. You can use it to instantiate the universe parameters of a constant</p>



<a name="203046855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203046855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203046855">(Jul 06 2020 at 22:11)</a>:</h4>
<p>That's right</p>



<a name="203046967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203046967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203046967">(Jul 06 2020 at 22:12)</a>:</h4>
<p>so basically if I get the constant <code>alpha</code>, I know this is meant to be a type, so I'd go ahead and put the theorem one level above or below.</p>



<a name="203047370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203047370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203047370">(Jul 06 2020 at 22:17)</a>:</h4>
<p>so hang on, this whole replacing bound variables business, would we do that by just building up more and more complex lambdas  that eventually just solve the question by just simple reduction to normal form or are we meant to do reasoning outside and rewriting the terms by hand?</p>



<a name="203047740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203047740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203047740">(Jul 06 2020 at 22:22)</a>:</h4>
<p>A lot of reasoning can be automated. You should read up on <code>tactic.mk_mapp</code></p>



<a name="203047949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203047949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203047949">(Jul 06 2020 at 22:25)</a>:</h4>
<p>yes, sorry. I'm going through the code base learning the API and all.</p>



<a name="203047996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203047996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203047996">(Jul 06 2020 at 22:26)</a>:</h4>
<p>it's a non-trivial amount of API to take in :P</p>



<a name="203048028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203048028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203048028">(Jul 06 2020 at 22:26)</a>:</h4>
<p>and I think the automation I'm trying to implement is also fairly sophisticated.</p>



<a name="203048557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203048557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203048557">(Jul 06 2020 at 22:33)</a>:</h4>
<p>For sure! One step at a time and don't be afraid to take on a much smaller problem first to get acquainted with the whole system</p>



<a name="203049044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049044">(Jul 06 2020 at 22:39)</a>:</h4>
<p>this is a bit confusing... my <code>local_const</code> <code>alpha : Type u</code> shows up as <code>const 1 []</code>.</p>



<a name="203049093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049093">(Jul 06 2020 at 22:40)</a>:</h4>
<p>i.e. it says it has not universe params.</p>



<a name="203049366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049366">(Jul 06 2020 at 22:43)</a>:</h4>
<p>What did you do to get there?</p>



<a name="203049482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049482">(Jul 06 2020 at 22:44)</a>:</h4>
<p>it's this block:</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">h</span> <span class="err">←</span> <span class="n">get_local</span> <span class="bp">``</span><span class="n">α</span><span class="o">,</span>

    <span class="n">lemmas</span><span class="bp">.</span><span class="n">for_each</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">lem</span><span class="o">,</span> <span class="n">do</span>
        <span class="k">let</span> <span class="n">bla</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">local_type</span><span class="o">,</span>
        <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">bla</span><span class="bp">.</span><span class="n">to_raw_fmt</span><span class="o">,</span>
        <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_raw_fmt</span>
</code></pre></div>



<a name="203049532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049532">(Jul 06 2020 at 22:45)</a>:</h4>
<p>so <code>h.local_type</code> is <code>const 1 []</code></p>



<a name="203049628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049628">(Jul 06 2020 at 22:46)</a>:</h4>
<p>so presumably <code>const 1 []</code> refers to <code>Type u_1</code></p>



<a name="203049729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049729">(Jul 06 2020 at 22:47)</a>:</h4>
<p>I'm trying to extract <code>u_1</code> so that I can instantiate the theorem at <code>u_1</code>.</p>



<a name="203049739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049739">(Jul 06 2020 at 22:47)</a>:</h4>
<p>but don't know how to get it from the local context.</p>



<a name="203049861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049861">(Jul 06 2020 at 22:48)</a>:</h4>
<p><code>const 1 []</code> is a sign to run. It's the internals leaking through the interface</p>



<a name="203049890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049890">(Jul 06 2020 at 22:49)</a>:</h4>
<p>Instead of <code>local_type</code>, use <code>infer_type</code></p>



<a name="203049907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049907">(Jul 06 2020 at 22:49)</a>:</h4>
<p>ok.</p>



<a name="203049994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203049994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203049994">(Jul 06 2020 at 22:50)</a>:</h4>
<p>woot, now I see "sort u+1"</p>



<a name="203050022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203050022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203050022">(Jul 06 2020 at 22:50)</a>:</h4>
<p>thx</p>



<a name="203050586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203050586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203050586">(Jul 06 2020 at 22:56)</a>:</h4>
<p><span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="203050715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203050715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203050715">(Jul 06 2020 at 22:58)</a>:</h4>
<p>yay, it worked, now I can use the lemmas in the local context.</p>



<a name="203050754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203050754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203050754">(Jul 06 2020 at 22:58)</a>:</h4>
<p>Nice!</p>



<a name="203062289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062289">(Jul 07 2020 at 02:40)</a>:</h4>
<p>Ok, so now I've managed to build up a large conjunction of all the cases, so we can go and try unifying things. Here's an example:</p>
<div class="codehilite"><pre><span></span><code><span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="n">new_lemma</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
         <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span>
      <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
           <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
             <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span>
        <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
             <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
               <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">))</span> <span class="bp">∧</span>
          <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right_1</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
             <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
               <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">val_1</span> <span class="n">right_1</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
                 <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">val_1</span> <span class="n">right_1</span><span class="o">)</span> <span class="n">x</span>
                   <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span>
            <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
                 <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
                   <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∧</span>
              <span class="n">true</span>
<span class="err">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="203062410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062410">(Jul 07 2020 at 02:45)</a>:</h4>
<p>I still don't see how to unify the cases, though. </p>
<ul>
<li>The universal quantifiers are quite different between the cases</li>
<li>And even if we manage to get the rhs to be syntactically (or at least definitionally) the same, it doesn't give us much, yet, because we still don't get the universal quantification.</li>
</ul>



<a name="203062567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062567">(Jul 07 2020 at 02:49)</a>:</h4>
<p>in order to prove something like</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">id</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">zero</span>
</code></pre></div>


<p>we get lemmas <code>id zero = zero + zero</code> and <code>forall n, id (succ n) = succ n + zero</code>. So in order to get the <code>forall n, id n = n</code>, we have to go ahead and apply the induction lemmas. All the whilst making sure that the rhs be the same <code>P n</code>.</p>



<a name="203062636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062636">(Jul 07 2020 at 02:50)</a>:</h4>
<p>Try and work with two equations at a time. No need for such a big conjunction. If you have two equations, remove the universals so that theirs bound variables become free variables. You should get something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">RHS0</span>
<span class="n">f</span> <span class="n">d</span> <span class="n">e</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">RHS1</span>
</code></pre></div>


<p>that is an equality whose lhs is a function applied to multiple arguments</p>



<a name="203062643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062643">(Jul 07 2020 at 02:50)</a>:</h4>
<p>the idea of introducing fresh variables, however doesn't create the same <code>P</code>. The inferred <code>P n</code> from the case for zero is <code>P n = n + n</code>. (Because <code>n</code> is known to be <code>zero</code>, whereas the <code>succ</code> case comes up with <code>P n = n + zero</code>.</p>



<a name="203062724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062724">(Jul 07 2020 at 02:53)</a>:</h4>
<p>That's ok. I think you may have to accept that results may sometimes be imperfect. That can be improved over time but let's go with something simple first</p>



<a name="203062727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062727">(Jul 07 2020 at 02:53)</a>:</h4>
<p>(I did the conjunction mostly so I can look at the term) Can you even add a term with free variables into the context?</p>



<a name="203062784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062784">(Jul 07 2020 at 02:55)</a>:</h4>
<p>Yes but don't always need to add your terms to the context. Oh and by free variables, I mean <code>local_const</code> not <code>var</code></p>



<a name="203062833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062833">(Jul 07 2020 at 02:56)</a>:</h4>
<p>ok sure, that makes sense as the final form of how it's supposed to run. For now, I use the context as a debugging tool.</p>



<a name="203062841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062841">(Jul 07 2020 at 02:56)</a>:</h4>
<p>it does pretty-printing and I can use tactics to massage terms as needed to try things out.</p>



<a name="203062849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062849">(Jul 07 2020 at 02:57)</a>:</h4>
<p>That's reasonable</p>



<a name="203062905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062905">(Jul 07 2020 at 02:58)</a>:</h4>
<p>but we do need to apply the induction principle, right?</p>



<a name="203062910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203062910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203062910">(Jul 07 2020 at 02:58)</a>:</h4>
<p>or am I missing something?</p>



<a name="203063003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063003">(Jul 07 2020 at 03:01)</a>:</h4>
<p>The induction principle is not the next thing though</p>



<a name="203063045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063045">(Jul 07 2020 at 03:02)</a>:</h4>
<p>sure, now we need to go and turn subterms into def_eq pairs.</p>



<a name="203063052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063052">(Jul 07 2020 at 03:02)</a>:</h4>
<p>(one nice things about doing all of them at once, btw, was that it means fewer substitutions overall)</p>



<a name="203063608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063608">(Jul 07 2020 at 03:18)</a>:</h4>
<p>That’s right. </p>
<p>(Yes, but sometimes it’s easy to over-constrain your solution and make hard problems harder. And the additional constraints may not address the important bottleneck)</p>



<a name="203063769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063769">(Jul 07 2020 at 03:23)</a>:</h4>
<p>I see. My intermediate strategy was basically to quantify over the conjunction. Creating an <code>forall [fresh_var], rest</code> at the root level, and specializing each quantifier away at the inner level. That way all the bound variables become free (under the global quantifiers).</p>



<a name="203063811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063811">(Jul 07 2020 at 03:24)</a>:</h4>
<p>Not quite sure how to do it without that whilst maintaining well-formed terms.</p>



<a name="203063843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063843">(Jul 07 2020 at 03:25)</a>:</h4>
<p>after that, I can star replacing the sub-expressions as you suggested.</p>



<a name="203063850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063850">(Jul 07 2020 at 03:26)</a>:</h4>
<p>and that'll unify the right-hand sides that should be unified.</p>



<a name="203063953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063953">(Jul 07 2020 at 03:28)</a>:</h4>
<p>I wonder if I could even just prove a lemma and use it as a simplifier rule... something like <code>(forall x, P x) /\ Q &lt;-&gt; forall y, P y /\ Q</code>.</p>



<a name="203063959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203063959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203063959">(Jul 07 2020 at 03:29)</a>:</h4>
<p>If I use this as a lemma for the simplifier, that should help.</p>



<a name="203064146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064146">(Jul 07 2020 at 03:35)</a>:</h4>
<p>I wouldn’t go that route. The terms will be easier to manipulate and traverse without the forall (you can keep a list of variables on the side) and when you’re ready to generate definitions, lemmas and proofs, you add the forall and lambdas back in</p>



<a name="203064152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064152">(Jul 07 2020 at 03:36)</a>:</h4>
<p>i see.</p>



<a name="203064202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064202">(Jul 07 2020 at 03:37)</a>:</h4>
<p>I’ll have to let you experiment with the idea now. My bed calls to me (and won’t leave a voicemail)</p>



<a name="203064203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064203">(Jul 07 2020 at 03:37)</a>:</h4>
<p>same start, though, right? we just arbitrarily introduce fresh variables and quantify away each quantifier, right?</p>



<a name="203064206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064206">(Jul 07 2020 at 03:37)</a>:</h4>
<p>Of course, have a goodnight.</p>



<a name="203064208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064208">(Jul 07 2020 at 03:37)</a>:</h4>
<p>I'll go to bed soon too.</p>



<a name="203064265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203064265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203064265">(Jul 07 2020 at 03:39)</a>:</h4>
<p>That’s right. When the constructors around arguments match you leave them in otherwise you replace them with a fresh variable</p>



<a name="203140939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203140939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203140939">(Jul 07 2020 at 18:29)</a>:</h4>
<p>not quite sure how much time I'll have tonight, but the next step I want to work on is introducing the new variables, so that we can show the RHS is equal. When looking at the equations, though I noticed, that the thing we're trying to prove is false. In the following sense:</p>



<a name="203141216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203141216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203141216">(Jul 07 2020 at 18:31)</a>:</h4>
<p>given a definition like this</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">balance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="o">:=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">color</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span>
</code></pre></div>


<p>we would like to prove <code>forall a x b y c z d, balance color.black (node.tree color.red (node.tree color.red a x b) y c) z d = node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</code>, which is true.</p>
<p>but also <code>forall color a x b, balance color a x b = node.tree color a x b</code>, which is false.</p>



<a name="203141346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203141346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203141346">(Jul 07 2020 at 18:32)</a>:</h4>
<p>The second case only becomes simple when considered in a context. We must know that the first case didn't hold.</p>



<a name="203141546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203141546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203141546">(Jul 07 2020 at 18:34)</a>:</h4>
<p>So it turns out we need a proof like this: <code>forall x, first_case x</code>, <code>¬(forall x, first_case) -&gt; (forall x, second_case x)</code></p>



<a name="203141691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203141691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203141691">(Jul 07 2020 at 18:35)</a>:</h4>
<p>So the idea of building a proposition is really nice, but we need to detect the order of the RHS, too.</p>



<a name="203142054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203142054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203142054">(Jul 07 2020 at 18:38)</a>:</h4>
<p>That's right. The other thing that we can do is have predicates that correspond to constructors. We can have <code>is_cons</code> and <code>is_nil</code> for a list so that, when you unify two cases, you have to update an assumption:</p>
<div class="codehilite"><pre><span></span><code><span class="n">foo</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">A</span>
<span class="n">foo</span> <span class="n">nil</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">A</span>
</code></pre></div>


<p>would then be encoded as:</p>
<div class="codehilite"><pre><span></span><code><span class="o">(</span><span class="n">is_cons</span> <span class="n">y</span> <span class="bp">\/</span> <span class="n">is_nil</span> <span class="n">y</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">foo</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">A</span>
</code></pre></div>



<a name="203142091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203142091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203142091">(Jul 07 2020 at 18:39)</a>:</h4>
<p>And here, we can see that the disjunction is exhaustive and leave it out</p>



<a name="203147278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203147278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203147278">(Jul 07 2020 at 19:15)</a>:</h4>
<p>is there a convenient way of working with free variables? So far having things in the proof state was quite nice, because I could see the terms.</p>



<a name="203147703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203147703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203147703">(Jul 07 2020 at 19:19)</a>:</h4>
<p>You'd have to keep printing your term but otherwise, it's straightforward. Anything specific you're unclear about?</p>



<a name="203147911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203147911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203147911">(Jul 07 2020 at 19:21)</a>:</h4>
<p>Not exactly, I just presume I can't add them to the local context, because I could potentially construct bogus info, so I'd have to work by just printing. Having them in the local context is really  just a convenience thing.</p>



<a name="203147983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203147983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203147983">(Jul 07 2020 at 19:22)</a>:</h4>
<p>i suppose I could create fresh variables and prove them using sorry in the tactic.</p>



<a name="203148019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203148019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203148019">(Jul 07 2020 at 19:22)</a>:</h4>
<p>that way the terms would at least be well-formed</p>



<a name="203148346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203148346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203148346">(Jul 07 2020 at 19:25)</a>:</h4>
<p>I see what you mean. The proof state and the terms are not strictly controlled. You can do a whole lot of operations on them that could create an invalid proof. That's not really a problem because when you add a declaration, Lean makes sure that it type checks and that it has no meta variable. How you get there is your own business. It's good to stay close to something that constitutes a valid proof but if you need to take liberties, Lean won't keep you until you add a declaration</p>



<a name="203148619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203148619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203148619">(Jul 07 2020 at 19:26)</a>:</h4>
<p>ah, ok, thanks. I'll work on that.</p>



<a name="203151271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203151271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203151271">(Jul 07 2020 at 19:49)</a>:</h4>
<p>random only semi-related question. Do we have a union-find data structure?</p>



<a name="203194453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203194453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203194453">(Jul 07 2020 at 19:50)</a>:</h4>
<p>There is a specialized version of it for the <code>tfae</code> tactic (the following are equivalent, finds strongly connected components in a graph of implications)</p>



<a name="203195000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203195000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203195000">(Jul 07 2020 at 19:55)</a>:</h4>
<p>cool</p>



<a name="203209100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209100">(Jul 07 2020 at 22:03)</a>:</h4>
<p>hmm, having trouble doing a beta reduction. I've got the meta var, but it can't infer a type.</p>



<a name="203209202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209202">(Jul 07 2020 at 22:04)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">infer</span> <span class="n">type</span> <span class="n">failed</span><span class="o">,</span> <span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
     <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
       <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span>
    <span class="err">?</span><span class="n">m_1</span>
<span class="n">term</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span>
      <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">left</span> <span class="n">val</span> <span class="n">right</span><span class="o">)</span> <span class="n">x</span> <span class="n">b</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span>
</code></pre></div>



<a name="203209280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209280">(Jul 07 2020 at 22:05)</a>:</h4>
<p>I shouldn't have to manually unfold the <code>Pi</code>, should I?</p>



<a name="203209454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209454">(Jul 07 2020 at 22:07)</a>:</h4>
<p>I think you're making a mistake here. You have a term which is <code>∀ {α : Type ?}, ...</code>, whose type is <code>Prop</code> and you're trying to use function application on it but you'd need a term of the form <code>λ {a}, ...</code>, whose type is <code>∀ {a}, ...</code>. Do you see the difference?</p>



<a name="203209490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209490">(Jul 07 2020 at 22:07)</a>:</h4>
<p>sure I do, but I don't getit , because the lemma is a constant.</p>



<a name="203209541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209541">(Jul 07 2020 at 22:08)</a>:</h4>
<p>Is there a way for me to get the proof?</p>



<a name="203209615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209615">(Jul 07 2020 at 22:09)</a>:</h4>
<p>nevermind, I'm being silly, the constant of course does have that type...</p>



<a name="203209624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203209624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203209624">(Jul 07 2020 at 22:09)</a>:</h4>
<p>so will the beta reduction then unfold the const?</p>



<a name="203210062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210062">(Jul 07 2020 at 22:14)</a>:</h4>
<p>omg, now it starts to dawn on me... I'm manipulating terms, but am trying to change the shape of the type... Why didn't I notice earlier, sorry about the confusion.</p>



<a name="203210347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210347">(Jul 07 2020 at 22:18)</a>:</h4>
<p>No worries, one lesson at a time :)</p>



<a name="203210436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210436">(Jul 07 2020 at 22:19)</a>:</h4>
<p>it's one thing to prove things and a whole another level to write meta programs &gt;&lt;</p>



<a name="203210451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210451">(Jul 07 2020 at 22:19)</a>:</h4>
<p>but I am fully intent on making this work, anyway :)</p>



<a name="203210726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210726">(Jul 07 2020 at 22:22)</a>:</h4>
<p>I think that's a worthwhile exercise to go through</p>



<a name="203210812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210812">(Jul 07 2020 at 22:23)</a>:</h4>
<p>yes. And also the knowledge will be quite useful for Lean 4, as there's more in lean code there and we can continue to make the lean story better.</p>



<a name="203210879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210879">(Jul 07 2020 at 22:24)</a>:</h4>
<p>For math I already really like it, for program verification this cases thing is still quite annoying.</p>



<a name="203210928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203210928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203210928">(Jul 07 2020 at 22:24)</a>:</h4>
<p>Once we make a bit more automation, though... it'll be just awesome :D</p>



<a name="203211220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203211220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203211220">(Jul 07 2020 at 22:28)</a>:</h4>
<p>That's my feeling too. There are too few people who care about software verification in Lean so it all falls on the few who do care about. Maybe, little by little, we can make it more appealing to computer scientists</p>



<a name="203215950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203215950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203215950">(Jul 07 2020 at 23:31)</a>:</h4>
<p>heh:</p>
<div class="codehilite"><pre><span></span><code><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_6</span> <span class="o">:</span>
  <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="err">?</span><span class="n">m_2</span> <span class="err">?</span><span class="n">m_3</span> <span class="err">?</span><span class="n">m_4</span><span class="o">)</span> <span class="err">?</span><span class="n">m_5</span> <span class="err">?</span><span class="n">m_6</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="err">?</span><span class="n">m_2</span> <span class="err">?</span><span class="n">m_3</span> <span class="err">?</span><span class="n">m_4</span><span class="o">)</span> <span class="err">?</span><span class="n">m_5</span> <span class="err">?</span><span class="n">m_6</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_5</span> <span class="o">:</span>
  <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="err">?</span><span class="n">m_8</span> <span class="err">?</span><span class="n">m_9</span> <span class="err">?</span><span class="n">m_10</span><span class="o">)</span> <span class="err">?</span><span class="n">m_11</span> <span class="err">?</span><span class="n">m_12</span><span class="o">)</span> <span class="err">?</span><span class="n">m_13</span> <span class="err">?</span><span class="n">m_14</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="err">?</span><span class="n">m_8</span> <span class="err">?</span><span class="n">m_9</span> <span class="err">?</span><span class="n">m_10</span><span class="o">)</span> <span class="err">?</span><span class="n">m_11</span> <span class="err">?</span><span class="n">m_12</span><span class="o">)</span> <span class="err">?</span><span class="n">m_13</span> <span class="err">?</span><span class="n">m_14</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_4</span> <span class="o">:</span>
  <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="err">?</span><span class="n">m_16</span> <span class="err">?</span><span class="n">m_17</span> <span class="err">?</span><span class="n">m_18</span><span class="o">)</span> <span class="err">?</span><span class="n">m_19</span> <span class="err">?</span><span class="n">m_20</span><span class="o">)</span> <span class="err">?</span><span class="n">m_21</span> <span class="err">?</span><span class="n">m_22</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="err">?</span><span class="n">m_16</span> <span class="err">?</span><span class="n">m_17</span> <span class="err">?</span><span class="n">m_18</span><span class="o">)</span> <span class="err">?</span><span class="n">m_19</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="err">?</span><span class="n">m_20</span> <span class="err">?</span><span class="n">m_21</span> <span class="err">?</span><span class="n">m_22</span><span class="o">),</span>
<span class="bp">_</span><span class="n">eqn_3</span> <span class="o">:</span>
  <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="err">?</span><span class="n">m_24</span> <span class="err">?</span><span class="n">m_25</span><span class="o">)</span> <span class="err">?</span><span class="n">m_26</span> <span class="err">?</span><span class="n">m_27</span> <span class="bp">=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="err">?</span><span class="n">m_24</span> <span class="err">?</span><span class="n">m_25</span><span class="o">)</span> <span class="err">?</span><span class="n">m_26</span> <span class="err">?</span><span class="n">m_27</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_2</span> <span class="o">:</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="err">?</span><span class="n">m_29</span> <span class="err">?</span><span class="n">m_30</span> <span class="bp">=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">node</span><span class="bp">.</span><span class="n">leaf</span> <span class="err">?</span><span class="n">m_29</span> <span class="err">?</span><span class="n">m_30</span><span class="o">,</span>
<span class="bp">_</span><span class="n">eqn_1</span> <span class="o">:</span> <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="err">?</span><span class="n">m_32</span> <span class="err">?</span><span class="n">m_33</span> <span class="err">?</span><span class="n">m_34</span> <span class="bp">=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="err">?</span><span class="n">m_32</span> <span class="err">?</span><span class="n">m_33</span> <span class="err">?</span><span class="n">m_34</span>
</code></pre></div>



<a name="203216061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216061">(Jul 07 2020 at 23:32)</a>:</h4>
<p>so next, I can go call-site by call-site introducing new variables, but this time round, we need to also replace sub-exprs in other equations.</p>



<a name="203216754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216754">(Jul 07 2020 at 23:42)</a>:</h4>
<p>I'm not sure if we have the same understanding. What I was suggesting was to take the equations, two by two, zip the argument list of their lhs and find a conservative generalization, i.e. if both are <code>cons ? ?</code> then you keep them as <code>cons ? ?</code>. If they are different constructors or that one is a constructor and the other is not, you introduce a new variable</p>



<a name="203216801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216801">(Jul 07 2020 at 23:43)</a>:</h4>
<p>oh I do understand, but I can't do that under quantifiers.</p>



<a name="203216812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216812">(Jul 07 2020 at 23:43)</a>:</h4>
<p>so I first just replaced all quantifiers with free variables.</p>



<a name="203216827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216827">(Jul 07 2020 at 23:43)</a>:</h4>
<p>That's right, that's the right thing to do</p>



<a name="203216887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216887">(Jul 07 2020 at 23:44)</a>:</h4>
<p>here now, e.g. m_6 and m_14 can be unified.</p>



<a name="203216897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203216897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203216897">(Jul 07 2020 at 23:44)</a>:</h4>
<p>or m_14 and m_22</p>



<a name="203217075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217075">(Jul 07 2020 at 23:47)</a>:</h4>
<p>From which equations?</p>



<a name="203217200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217200">(Jul 07 2020 at 23:49)</a>:</h4>
<p>eqn_6 and eqn_5 have m_6 and m_14, respectively at the same place.</p>



<a name="203217209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217209">(Jul 07 2020 at 23:49)</a>:</h4>
<p>but they do have different prefixes, though.</p>



<a name="203217267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217267">(Jul 07 2020 at 23:50)</a>:</h4>
<p>are the dependent types strictly left-to-right?</p>



<a name="203217360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217360">(Jul 07 2020 at 23:51)</a>:</h4>
<p>They are strictly left to right. I have not considered dependent types so far.</p>



<a name="203217432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217432">(Jul 07 2020 at 23:52)</a>:</h4>
<p><code>eqn_1</code> and <code>eqn_2</code> are an interesting bunch, for instance.</p>



<a name="203217445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217445">(Jul 07 2020 at 23:53)</a>:</h4>
<p>How so?</p>



<a name="203217458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217458">(Jul 07 2020 at 23:53)</a>:</h4>
<p>their rhs would become <code>node.tree u x y z</code>.</p>



<a name="203217469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217469">(Jul 07 2020 at 23:53)</a>:</h4>
<p>but that is in fact too general, we can't prove it.</p>



<a name="203217555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217555">(Jul 07 2020 at 23:55)</a>:</h4>
<p>they both are the same case in the code, but the equation only holds, because we have considered the other cases first in the pattern matching.</p>



<a name="203217563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217563">(Jul 07 2020 at 23:55)</a>:</h4>
<p>so this is an instance of the dependent case, really.</p>



<a name="203217634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217634">(Jul 07 2020 at 23:56)</a>:</h4>
<p>Is it because  <code>tree</code> is an inductive family? Can you show me the definition again?</p>



<a name="203217651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217651">(Jul 07 2020 at 23:57)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">balance</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">node</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="o">:=</span>
    <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
<span class="c1">-- | color.black (node.tree color.red a x (node.tree color.red b y c)) z d :=</span>
<span class="c1">--     node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</span>
<span class="c1">-- | color.black a x (node.tree color.red (node.tree color.red b y c) z d) :=</span>
<span class="c1">--     node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</span>
<span class="c1">-- | color.black a x (node.tree color.red b y (node.tree color.red c z d)) :=</span>
<span class="c1">--      node.tree color.red (node.tree color.black a x b) y (node.tree color.black c z d)</span>
<span class="bp">|</span> <span class="n">color</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span>
</code></pre></div>



<a name="203217680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217680">(Jul 07 2020 at 23:57)</a>:</h4>
<p>the problem is, that the second pattern match is <code>color</code> for arbitrary <code>color</code>.</p>



<a name="203217740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217740">(Jul 07 2020 at 23:58)</a>:</h4>
<p>But we know from the context, that it's either <code>red</code> and anything, or <code>black</code>, but not the previous case.</p>



<a name="203217749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217749">(Jul 07 2020 at 23:58)</a>:</h4>
<p>that's why the rhs becomes simple.</p>



<a name="203217755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217755">(Jul 07 2020 at 23:58)</a>:</h4>
<p>It's the fall-through between cases that simplifies it.</p>



<a name="203217937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203217937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203217937">(Jul 08 2020 at 00:01)</a>:</h4>
<p>Yes I see</p>



<a name="203218040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203218040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203218040">(Jul 08 2020 at 00:03)</a>:</h4>
<p>I would do the unification from left to right and I would just give up (reject the unification) if generalizing one argument makes later arguments type incorrect</p>



<a name="203218067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203218067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203218067">(Jul 08 2020 at 00:03)</a>:</h4>
<p>i see</p>



<a name="203218184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203218184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203218184">(Jul 08 2020 at 00:05)</a>:</h4>
<p>There might be a more aggressive solution but I think a simpler first solution will make it easier to get a testable prototype</p>



<a name="203218391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203218391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203218391">(Jul 08 2020 at 00:09)</a>:</h4>
<p>Ya, I'll work on it. At this point I have at least the general API down, so I more or less know how to construct terms. So soon I can think about the algorithm. The more we have coded up, the easier it is to criticize ;-)</p>



<a name="203218414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203218414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203218414">(Jul 08 2020 at 00:09)</a>:</h4>
<p>Indeed :)</p>



<a name="203222957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203222957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203222957">(Jul 08 2020 at 01:41)</a>:</h4>
<p>Actually I don't think we can unify left to right. When I'm doing the transformation we want to code up by hand, It keeps smearing the wrong cases and thus make the theorem false. I think have to unify inside-out, keeping careful track of what's around in the context.</p>



<a name="203227420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203227420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203227420">(Jul 08 2020 at 03:20)</a>:</h4>
<p>(deleted)</p>



<a name="203227507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203227507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203227507">(Jul 08 2020 at 03:22)</a>:</h4>
<p>(deleted)</p>



<a name="203228003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203228003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203228003">(Jul 08 2020 at 03:33)</a>:</h4>
<p>(deleted)</p>



<a name="203228066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203228066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203228066">(Jul 08 2020 at 03:34)</a>:</h4>
<p>(deleted)</p>



<a name="203228072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203228072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203228072">(Jul 08 2020 at 03:34)</a>:</h4>
<p>(deleted)</p>



<a name="203229439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203229439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203229439">(Jul 08 2020 at 04:07)</a>:</h4>
<p>At the end of the day, I think it may well be easiest to use the lambda in the definition itself and analyse its structure.</p>



<a name="203229465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203229465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203229465">(Jul 08 2020 at 04:07)</a>:</h4>
<p>All the cases are already handled correctly. So the main question that remains, is if can have a better decision procedure by ordering the cases in the type better.</p>



<a name="203229578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203229578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203229578">(Jul 08 2020 at 04:10)</a>:</h4>
<p>It's worth exploring when you have something that works. Feel free to put it up on a git repo. It will be easier to discuss</p>



<a name="203229640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203229640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203229640">(Jul 08 2020 at 04:12)</a>:</h4>
<p>yup will do.</p>



<a name="203340954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203340954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203340954">(Jul 09 2020 at 00:50)</a>:</h4>
<p>I've made a good deal of progress on this, though not quite working yet.</p>



<a name="203340992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203340992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203340992">(Jul 09 2020 at 00:51)</a>:</h4>
<p>I also changed the strategy a bit. instead of trying to infer the spec, I instead as the user for an equality to prove.</p>



<a name="203341047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341047">(Jul 09 2020 at 00:52)</a>:</h4>
<p>I can then use normal reduction until the reduction gets stuck, at which point I can then introduce the case split as need to construct a proof.</p>



<a name="203341076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341076">(Jul 09 2020 at 00:53)</a>:</h4>
<p>That sounds like a good plan. Do you have examples that show off what you've done so far?</p>



<a name="203341166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341166">(Jul 09 2020 at 00:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">inline_body</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inline_body</span> <span class="n">l</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">pure</span> <span class="err">$</span> <span class="n">app</span> <span class="n">l</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span> <span class="n">ls</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">decl</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">get_decl</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">return</span> <span class="n">decl</span><span class="bp">.</span><span class="n">value</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span> <span class="bp">&gt;&gt;</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">failed</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">specialize_mvar</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">mv&#39;</span> <span class="n">mv</span><span class="bp">@</span><span class="o">(</span><span class="n">mvar</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">some</span> <span class="err">$</span> <span class="n">mv</span><span class="bp">.</span><span class="n">app</span> <span class="n">mv&#39;</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="n">meta</span> <span class="n">mutual</span> <span class="n">def</span> <span class="n">break_case</span><span class="o">,</span> <span class="n">eq_proof</span>
<span class="k">with</span> <span class="n">break_case</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">app</span> <span class="n">x</span> <span class="n">mv</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">ty_next</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">infer_type</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">ty_next</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">y</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span> <span class="n">y</span><span class="bp">⟩</span> <span class="err">←</span>
        <span class="k">match</span> <span class="n">ty_next</span><span class="bp">.</span><span class="n">is_pi</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">do</span>
            <span class="n">mv&#39;</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">mk_mvar</span><span class="o">,</span>
            <span class="n">return</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">replace</span> <span class="o">(</span><span class="n">specialize_mvar</span> <span class="n">mv&#39;</span><span class="o">),</span> <span class="n">mv&#39;</span><span class="o">,</span> <span class="n">y</span><span class="bp">.</span><span class="n">replace</span> <span class="o">(</span><span class="n">specialize_mvar</span> <span class="n">mv&#39;</span><span class="o">))</span>
        <span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
        <span class="kn">end</span><span class="o">,</span>
    <span class="n">return</span> <span class="n">e</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="n">e</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">fail</span> <span class="s2">&quot;failed to break cases&quot;</span>
<span class="k">with</span> <span class="n">eq_proof</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">is_eq</span> <span class="err">←</span> <span class="n">succeeds</span> <span class="err">$</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">is_def_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">is_eq</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">pure</span> <span class="err">$</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">app</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">app</span> <span class="n">y</span>
    <span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">do</span>
        <span class="n">x</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">whnf</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">break_case</span> <span class="n">eq</span> <span class="n">x</span> <span class="n">y</span>
    <span class="kn">end</span>
    <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">pure</span> <span class="err">$</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">app</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">app</span> <span class="n">y</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">pattern_match_proof</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">pi</span> <span class="n">name</span> <span class="n">bi</span> <span class="n">ty</span> <span class="n">body</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">body</span> <span class="err">←</span> <span class="n">pattern_match_proof</span> <span class="n">body</span><span class="o">,</span>
    <span class="n">return</span> <span class="err">$</span> <span class="n">lam</span> <span class="n">name</span> <span class="n">bi</span> <span class="n">ty</span> <span class="n">body</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="n">eq</span> <span class="n">l</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">mvars</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">mk_mvar_list</span> <span class="n">e</span><span class="bp">.</span><span class="n">get_free_var_range</span><span class="o">,</span>
    <span class="n">l</span> <span class="err">←</span> <span class="n">inline_body</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">instantiate_vars</span> <span class="n">mvars</span><span class="o">),</span>
    <span class="n">eq_proof</span> <span class="n">eq</span> <span class="n">l</span> <span class="o">(</span><span class="n">r</span><span class="bp">.</span><span class="n">instantiate_vars</span> <span class="n">mvars</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">do</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">tactic</span><span class="bp">.</span><span class="n">fail</span> <span class="s2">&quot;cannot synthesize equality proof.&quot;</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">my_tac2</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span>  <span class="n">tactic</span><span class="bp">.</span><span class="n">target</span>
    <span class="bp">&gt;&gt;=</span> <span class="n">pattern_match_proof</span>
    <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">instantiate_mvars</span>
    <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact</span>
</code></pre></div>



<a name="203341182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341182">(Jul 09 2020 at 00:55)</a>:</h4>
<p>here's what I have so far. It takes care of quantifiers, can use whatever was already available in the context, so it doesn't have to match the spec exactly.</p>



<a name="203341231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341231">(Jul 09 2020 at 00:56)</a>:</h4>
<p>i'm at a point, where it doesn't  go further somewhere deeply nested.</p>



<a name="203341244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341244">(Jul 09 2020 at 00:56)</a>:</h4>
<p>I think, I need to pass the types along with meta vars.</p>



<a name="203341256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341256">(Jul 09 2020 at 00:57)</a>:</h4>
<p>because bound quantifiers turn to de Bruijn vars and I can't reduce using them.</p>



<a name="203341260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341260">(Jul 09 2020 at 00:57)</a>:</h4>
<p>Right but is there an example where you can use that, no matter how simple, that shows what it does?</p>



<a name="203341331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341331">(Jul 09 2020 at 00:58)</a>:</h4>
<p>e.g this. Given the goal: </p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">node</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">balance</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="n">c</span><span class="o">)</span> <span class="n">z</span> <span class="n">d</span> <span class="bp">=</span>
      <span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">red</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">node</span><span class="bp">.</span><span class="n">tree</span> <span class="n">color</span><span class="bp">.</span><span class="n">black</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="o">)</span>
</code></pre></div>



<a name="203341364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341364">(Jul 09 2020 at 00:59)</a>:</h4>
<p>it infers the source code of balance, gets rid of quantifiers.</p>



<a name="203341387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341387">(Jul 09 2020 at 01:00)</a>:</h4>
<p>but it doesn't finish and so I dont get a proof, i.e. it doesn't type check.</p>



<a name="203341449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341449">(Jul 09 2020 at 01:00)</a>:</h4>
<p>lemme construct an example that should go through.</p>



<a name="203341803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341803">(Jul 09 2020 at 01:06)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">4</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">3</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:=</span> <span class="mi">1</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">foo</span> <span class="n">x</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">my_tac2</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203341813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341813">(Jul 09 2020 at 01:06)</a>:</h4>
<p>this example, it does some work and gets stuck where I need to call rec</p>



<a name="203341823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341823">(Jul 09 2020 at 01:07)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)),</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">n</span>
<span class="n">decidable</span><span class="bp">.</span><span class="n">rec</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hnc</span> <span class="o">:</span> <span class="bp">¬</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
     <span class="n">ite</span> <span class="o">(</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
       <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">))))</span>
       <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">))))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
     <span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="bp">ℕ</span> <span class="mi">1</span><span class="o">))))</span>
<span class="mi">1</span>
</code></pre></div>



<a name="203341857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341857">(Jul 09 2020 at 01:07)</a>:</h4>
<p>so it does the unfolding, the quantifiers and introduces meta vars.</p>



<a name="203341912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203341912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203341912">(Jul 09 2020 at 01:08)</a>:</h4>
<p>oh and btw all that from the prop.</p>



<a name="203342102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342102">(Jul 09 2020 at 01:11)</a>:</h4>
<p>what I'm not quite sure is a great idea is building the lambda terms directly by hand.</p>



<a name="203342111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342111">(Jul 09 2020 at 01:11)</a>:</h4>
<p>in a sense, it might be easier to use the local context.</p>



<a name="203342426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342426">(Jul 09 2020 at 01:18)</a>:</h4>
<p>What do you mean by "building the lambda term by hand" vs "using the local context"?</p>



<a name="203342495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342495">(Jul 09 2020 at 01:19)</a>:</h4>
<p>the way how this works is done by a recursive descent through the lambda. The effect being, that I have to do all term manipulation myself. Whereas many other tactics define local constants, goals, etc.</p>



<a name="203342574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342574">(Jul 09 2020 at 01:21)</a>:</h4>
<p>Right so that's the difference between a stateful versus functional approach. Stateful is especially useful when you want to use pieces of the API like <code>induction</code>. Even that part of the API should become more functional in Lean 4</p>



<a name="203342666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342666">(Jul 09 2020 at 01:23)</a>:</h4>
<p>In a sense, we've gone full circle at this point, lol. The whole discussion started with wanting to have a tactic that can solve these pattern match cases. Then we found that using some combinators you can script it and solve the problem, but it's somewhat unsatisfying.</p>



<a name="203342677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342677">(Jul 09 2020 at 01:23)</a>:</h4>
<p>Then we had the idea of an iductively defined prop which pretty much needs the low-level api</p>



<a name="203342728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Need%20a%20way%20to%20unfold%20a%20definition/near/203342728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Fabian <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Need.20a.20way.20to.20unfold.20a.20definition.html#203342728">(Jul 09 2020 at 01:24)</a>:</h4>
<p>and now this approach is back to more like just a tactic script.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/index.html">Program verification</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html">Lists Without Duplicates</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221243614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221243614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221243614">(Dec 30 2020 at 20:24)</a>:</h4>
<p>I want to state that <code>(f x) ++ (g x): List α</code> has no duplicates and that <code>((f x) ++ (g x).to_finset = h x</code> (maybe there is some notion of a disjoint_finset?).<br>
Later, I would like to argue that if <code>g x = y::ys</code>, then <code>y \not \in ys ++ f x</code>.<br>
What is the best way to formalize that? I thought about stating <code>(f x ++ g x).length = (h x).card</code>. Is there a better way?</p>



<a name="221243825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221243825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221243825">(Dec 30 2020 at 20:27)</a>:</h4>
<p>This is a question about lists, right? Nothing to do with finsets. The way you prove the theorem will depend on how you are saying that L++M has no dupes.</p>



<a name="221244035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244035">(Dec 30 2020 at 20:30)</a>:</h4>
<p>Then you just need theorems like nodupes(L++M) iff nodupes(M++L) and nodupes(a::L) -&gt; a not in L.</p>



<a name="221244038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244038">(Dec 30 2020 at 20:30)</a>:</h4>
<p>I would like to optimize the formalization for later arguments, not for provability of the theorem itself (I guess it will be easy to prove, but I have to use this argument many times). Well, it is about lists, but there is a connection to finsets. <code>h x</code> is a finset, but I need the order in <code>f x</code>.</p>



<a name="221244100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244100">(Dec 30 2020 at 20:31)</a>:</h4>
<p>Sure but <code>h x</code> never occurred in your question</p>



<a name="221244103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244103">(Dec 30 2020 at 20:31)</a>:</h4>
<p>Use can use <code>nodup</code> for the first constraint.</p>



<a name="221244175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244175">(Dec 30 2020 at 20:32)</a>:</h4>
<p>And there a lot of lemmas about how <code>nodup</code> interfaces with append, concatenate, and mem.</p>



<a name="221244179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244179">(Dec 30 2020 at 20:32)</a>:</h4>
<p>Great, if there's a <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nodup">docs#list.nodup</a> that would be perfect</p>



<a name="221244287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244287">(Dec 30 2020 at 20:33)</a>:</h4>
<p>oh, nice thanks! Sorry that I missed that.</p>



<a name="221244421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244421">(Dec 30 2020 at 20:35)</a>:</h4>
<p>You could look for the lemmas I'm suggesting with <code>library_search</code> and then prove <code>nodup (L++(m::M))</code> implies m isn't in M++L, although I guess I'm a bit surprised that you have swapped L and M.</p>



<a name="221244620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221244620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221244620">(Dec 30 2020 at 20:38)</a>:</h4>
<p>I haven't had good luck finding the right <code>mem</code> lemmas via <code>library_search</code>, but have found them via <code>suggest</code>.</p>



<a name="221245156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221245156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221245156">(Dec 30 2020 at 20:46)</a>:</h4>
<p>In my case, library_searched worked great!</p>



<a name="221245308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221245308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221245308">(Dec 30 2020 at 20:48)</a>:</h4>
<p>I guess this is the difference between math and program verification:<br>
<a href="/user_uploads/3121/c2tjU9YiGAaoXCyOCWHSj3Fr/image.png">image.png</a>  :D</p>
<div class="message_inline_image"><a href="/user_uploads/3121/c2tjU9YiGAaoXCyOCWHSj3Fr/image.png" title="image.png"><img src="/user_uploads/3121/c2tjU9YiGAaoXCyOCWHSj3Fr/image.png"></a></div>



<a name="221245623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221245623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221245623">(Dec 30 2020 at 20:53)</a>:</h4>
<p>We get really long goals like that, it's just that we don't notice they're long because everything is folded up into typeclasses.</p>



<a name="221245895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221245895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221245895">(Dec 30 2020 at 20:57)</a>:</h4>
<p>How do you stay concentrated when looking at such goals? I tend to get lost in the sheer amount of identifiers. If I'm not very careful, I lose the idea of the proof and it gets very ugly.</p>



<a name="221248368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221248368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221248368">(Dec 30 2020 at 21:33)</a>:</h4>
<p><span class="user-mention" data-user-id="234196">@Henning Dieterichs</span> i ran into a similar problem during my bsc thesis (which was also cs-oriented), also struggling to keep up with the goals.<br>
i found that two things help:</p>
<ul>
<li>when defining some inductive/definition, start by proving "obvious" facts about the inductive/definition, regardless of whether you think you will need it down the line.</li>
<li>work through longer proofs with pen and paper and denote intuitive subgoals in your paper proof as lemmas, proving them separately. then, write out the big proof in dependence of all these sorry'd lemmas.</li>
</ul>
<p>your pen and paper proofs should be precise so that you don't need to do so much work for the formalized proof. <br>
in my experience, without such a pen and paper proof, you can get lost very easily, especially when you start applying theorems and simplification like a human pattern matcher without looking at the bigger picture.<br>
meanwhile, the first bullet point means that you won't have to unfold as many layers, leading to more concise goals.</p>



<a name="221248489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221248489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221248489">(Dec 30 2020 at 21:34)</a>:</h4>
<p>in the end, i didn't follow those tips nearly well enough myself, which is part of the reason why i couldn't conclude the proof in its entirety.</p>



<a name="221249055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221249055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221249055">(Dec 30 2020 at 21:43)</a>:</h4>
<p>thanks for your advice! Except for the pen&amp;paper proof, I'm already trying to do that. I'm very optimistic to be able to close all my goals, but I'm sure many of my proofs are very bloated and look like brute force.</p>



<a name="221249067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221249067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221249067">(Dec 30 2020 at 21:43)</a>:</h4>
<p>Also, let ... in ... don't simplify cleanly often, so I just avoid using them in definitions often</p>



<a name="221249141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221249141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221249141">(Dec 30 2020 at 21:45)</a>:</h4>
<p>Here, you have a big goal because it's not simplifying the defeq structure record accession</p>



<a name="221253842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221253842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221253842">(Dec 30 2020 at 23:00)</a>:</h4>
<p>This screenshot looks like either not enough abstraction (e.g. some append operation on whatever the structures are) or too much unfolding rather than applying lemmas</p>



<a name="221280384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221280384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221280384">(Dec 31 2020 at 09:56)</a>:</h4>
<p>You have a lot of subexpressions there of the form <code>{field1 := f, ...}.field1</code>, which simplify to <code>f</code> (perhaps via <code>dsimp only</code>)</p>



<a name="221296209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221296209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221296209">(Dec 31 2020 at 15:21)</a>:</h4>
<p>I struggled to solve this goal with the definition of nodup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">disjoint</span><span class="o">:</span> <span class="n">disjoint</span> <span class="n">ant_tr1.leaves</span> <span class="n">ant_tr2.leaves</span><span class="o">,</span>
<span class="n">ant_ih_tr1</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">ant_tr1.leaves</span> <span class="bp">∧</span>
    <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span><span class="o">,</span>
<span class="n">ant_ih_tr2</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">ant_tr2.leaves</span> <span class="bp">∧</span>
    <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span>
<span class="bp">⊢</span> <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span><span class="o">)</span> <span class="bp">++</span>
     <span class="o">((</span><span class="n">R</span> <span class="n">ant_tr1</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">ant_tr2</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span><span class="o">))</span><span class="bp">.</span><span class="n">nodup</span>
</code></pre></div>
<p>There is <code>list.nodup_append_comm</code>, but the simplifier couldn't make use of it. Manually applying the lemmas to rearrange the terms was too hard for me.</p>
<p>This custom theorem helped a lot: <code>theorem nodup_iff_card { α: Type } [decidable_eq α] (a: list α): a.nodup ↔ a.length = a.to_finset.card</code>. Maybe it's a good candidate for mathlib? There is <a href="https://leanprover-community.github.io/mathlib_docs/data/finset/basic.html#list.to_finset_card_of_nodup">list.to_finset_card_of_nodup</a>, but it is one direction only.<br>
It was much easier to show <code>(a ++ b ++ c ++ ...).length = (a ++ b ++ c ++ ...).to_finset.card</code>, since <code>nat.add</code> and <code>finset.union</code> are commutative and the simplifier can solve goals where only assoc and comm rules are needed.</p>



<a name="221296211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221296211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221296211">(Dec 31 2020 at 15:21)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> <code>dsimp only</code> helps! I just used unfold before.</p>



<a name="221296601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221296601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221296601">(Dec 31 2020 at 15:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221253842">said</a>:</p>
<blockquote>
<p>This screenshot looks like either not enough abstraction (e.g. some append operation on whatever the structures are) or too much unfolding rather than applying lemmas</p>
</blockquote>
<p>I felt the same (not only here but for many of my proofs). However, I have no clue how to improve that. At that point, I didn't unfold much and I don't know what new lemmas could help me to get more insight.</p>
<p>This is an except of what I'm working on:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">LeafPartition</span> <span class="o">:=</span> <span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">acc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">(</span><span class="n">inacc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">(</span><span class="n">red</span> <span class="o">:</span> <span class="n">list</span> <span class="n">Leaf</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">Ant</span> <span class="o">(</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">leaf</span><span class="o">:</span> <span class="n">Leaf</span><span class="o">):</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">branch</span> <span class="o">(</span><span class="n">tr1</span><span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">(</span><span class="n">tr2</span><span class="o">:</span> <span class="n">Ant</span><span class="o">):</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">diverge</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tr</span><span class="o">:</span> <span class="n">Ant</span><span class="o">):</span> <span class="n">Ant</span>

<span class="kd">def</span> <span class="n">R</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">LeafPartition</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Ant.leaf</span> <span class="n">can_prove_empty</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">can_prove_empty</span> <span class="k">then</span> <span class="o">⟨</span> <span class="o">[],</span> <span class="o">[],</span> <span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">⟩</span> <span class="k">else</span> <span class="o">⟨</span> <span class="o">[</span><span class="n">n</span><span class="o">],</span> <span class="o">[],</span> <span class="o">[]</span> <span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Ant.diverge</span> <span class="n">can_prove_empty</span> <span class="n">tr</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">R</span> <span class="n">tr</span><span class="o">,</span> <span class="n">can_prove_empty</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">⟨</span> <span class="o">[],</span> <span class="o">[],</span> <span class="n">m</span> <span class="o">::</span> <span class="n">ms</span> <span class="o">⟩,</span> <span class="n">ff</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="o">[],</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span> <span class="n">ms</span> <span class="o">⟩</span>
    <span class="bp">|</span> <span class="n">r</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">r</span>
    <span class="kd">end</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Ant.branch</span> <span class="n">tr1</span> <span class="n">tr2</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">r1</span> <span class="o">:=</span> <span class="n">R</span> <span class="n">tr1</span><span class="o">,</span> <span class="n">r2</span> <span class="o">:=</span> <span class="n">R</span> <span class="n">tr2</span> <span class="k">in</span>
        <span class="o">⟨</span> <span class="n">r1.acc</span> <span class="bp">++</span> <span class="n">r2.acc</span><span class="o">,</span> <span class="n">r1.inacc</span> <span class="bp">++</span> <span class="n">r2.inacc</span><span class="o">,</span> <span class="n">r1.red</span> <span class="bp">++</span> <span class="n">r2.red</span> <span class="o">⟩</span>
</code></pre></div>
<p>I want to prove that the result is indeed a partition of all leaves, if the leaves of every branch in <code>ant</code> are disjoint.<br>
The goal above is for the branch case.</p>



<a name="221296675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221296675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221296675">(Dec 31 2020 at 15:30)</a>:</h4>
<p>What does using <code>finset</code> give you? That two lists are the same if you remove duplicates and forget about order?</p>



<a name="221297085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297085">(Dec 31 2020 at 15:38)</a>:</h4>
<p>What's <code>Leaf</code> defined as?</p>



<a name="221297143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297143">(Dec 31 2020 at 15:38)</a>:</h4>
<p>Leaf is an arbitrary Type</p>



<a name="221297236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297236">(Dec 31 2020 at 15:40)</a>:</h4>
<p>The code above currently gives me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">don't</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="n">context</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="bp">→</span> <span class="kt">Type</span>
</code></pre></div>
<p>in the definition of <code>R</code></p>



<a name="221297259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297259">(Dec 31 2020 at 15:41)</a>:</h4>
<p>Sorry, it is not a MWE... Creating a MWE would be hard. The code was just to give context.<br>
Maybe adding <code>[decidable_eq Leaf]</code> to R fixes this, I have this globally.</p>



<a name="221297271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297271">(Dec 31 2020 at 15:41)</a>:</h4>
<blockquote>
<p>What does using finset give you? That two lists are the same if you remove duplicates and forget about order?</p>
</blockquote>
<p>I know that <code>as ++ bs ++ cs ++ ds</code> has no duplicates. I want to show that <code>ds ++ bs ++ cs ++ as</code> has no duplicates (it's just a permutation - that should be trivial to show).<br>
However, this is difficult, as I cannot automatically rearrange the terms - after all, permutating the lists changes them. (This is a step of my proof in the branch case)</p>
<p>BUT, it is easy to prove with lean that <code>(ds ++ bs ++ cs ++ as).length = (as ++ bs ++ cs ++ ds).length</code> and that <code>(ds ++ bs ++ cs ++ as).to_finset = (as ++ bs ++ cs ++ ds).to_finset</code>! (Since length and to_finset is some kind of homomorphism into a commutative monoid)</p>



<a name="221297488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297488">(Dec 31 2020 at 15:45)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.perm.nodup_iff">docs#list.perm.nodup_iff</a></p>



<a name="221297585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297585">(Dec 31 2020 at 15:47)</a>:</h4>
<p>How difficult would it be to convince lean that <code>as ++ bs ++ cs ++ ds</code> is a permutation of <code>ds ++ bs ++ cs ++ as</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span> <span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="n">ds</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">):</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span> <span class="bp">~</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221297679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297679">(Dec 31 2020 at 15:48)</a>:</h4>
<p>One min, checking that</p>



<a name="221297788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221297788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221297788">(Dec 31 2020 at 15:50)</a>:</h4>
<p>I think lean's automation really likes equalities. In my limited experience, definitions that are made out of equalities are much easier to reason about than definitions that involve recursively defined predicates</p>



<a name="221298844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221298844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221298844">(Dec 31 2020 at 16:06)</a>:</h4>
<p>I assume you've already found <a href="https://leanprover-community.github.io/mathlib_docs/find/list.perm_append_comm">docs#list.perm_append_comm</a></p>



<a name="221298871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221298871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221298871">(Dec 31 2020 at 16:07)</a>:</h4>
<p>there is also comm for nodup directly, but is hard to apply manually</p>



<a name="221299366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299366">(Dec 31 2020 at 16:12)</a>:</h4>
<p>I think the key to this kind of problem is that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span><span class="bp">~</span><span class="n">a'</span> <span class="bp">-&gt;</span> <span class="n">b</span> <span class="bp">~</span> <span class="n">b'</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">)</span> <span class="bp">~</span> <span class="o">(</span><span class="n">a'</span> <span class="bp">++</span> <span class="n">b'</span><span class="o">)</span>
</code></pre></div>
<p>(otherwise you could not really apply perm_append_comm recursively)<br>
...which states that <code>++</code> is well-defined on the equivalence class of permutations. But this just yields union on multisets.<br>
And if you remove duplicates, you get finsets, so maybe it might be easier to work with finsets directly?</p>



<a name="221299391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299391">(Dec 31 2020 at 16:12)</a>:</h4>
<p>Working with finsets directly is definitely the way to go here</p>



<a name="221299427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299427">(Dec 31 2020 at 16:13)</a>:</h4>
<p>That lemma is <a href="https://leanprover-community.github.io/mathlib_docs/find/list.perm.append">docs#list.perm.append</a></p>



<a name="221299513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299513">(Dec 31 2020 at 16:15)</a>:</h4>
<p>Yeah but that lemma won't work because of how the terms are associated.</p>



<a name="221299524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299524">(Dec 31 2020 at 16:15)</a>:</h4>
<p>and there's a missing <code>@[trans]</code> lemma for perms.</p>



<a name="221299731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299731">(Dec 31 2020 at 16:18)</a>:</h4>
<p>I would just use the comm and assoc lemmas and swap stuff by hand. You could even train the simplifier to do this</p>



<a name="221299802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299802">(Dec 31 2020 at 16:19)</a>:</h4>
<p>Here's a full proof using those:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span> <span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="n">ds</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span> <span class="bp">~</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span> <span class="bp">~</span> <span class="n">as</span> <span class="bp">++</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">]</span>
                        <span class="bp">...</span> <span class="bp">~</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span> <span class="bp">++</span> <span class="n">as</span> <span class="o">:</span> <span class="n">list.perm_append_comm</span>
                        <span class="bp">...</span> <span class="bp">~</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="o">(</span><span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">))</span> <span class="bp">++</span> <span class="n">as</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">]</span>
                        <span class="bp">...</span> <span class="bp">~</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">cs</span><span class="o">))</span> <span class="bp">++</span> <span class="n">as</span> <span class="o">:</span> <span class="n">list.perm.append_right</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">list.perm.append_left</span> <span class="n">_</span> <span class="n">list.perm_append_comm</span>
                        <span class="bp">...</span> <span class="bp">~</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">ds</span> <span class="bp">++</span> <span class="n">cs</span><span class="o">)</span> <span class="bp">++</span> <span class="n">as</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.append_assoc</span><span class="o">]</span>
                        <span class="bp">...</span> <span class="bp">~</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span> <span class="o">:</span> <span class="n">list.perm.append_right</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">list.perm.append_right</span> <span class="n">_</span> <span class="n">list.perm_append_comm</span>
</code></pre></div>



<a name="221299826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299826">(Dec 31 2020 at 16:19)</a>:</h4>
<p>Now get the simplifier to do it!</p>



<a name="221299891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299891">(Dec 31 2020 at 16:20)</a>:</h4>
<p>But the simplifier can't solve associativity / commutativity goals?</p>



<a name="221299896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299896">(Dec 31 2020 at 16:20)</a>:</h4>
<p>In my case though, I have 6 variables (<code>⟨ r1.acc ++ r2.acc, r1.inacc ++ r2.inacc, r1.red ++ r2.red ⟩</code>) :D So without automation it gets really hard</p>



<a name="221299899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299899">(Dec 31 2020 at 16:20)</a>:</h4>
<p>That's what <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#ac_refl">tactic#ac_refl</a> is for, right?</p>



<a name="221299914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299914">(Dec 31 2020 at 16:20)</a>:</h4>
<p>Except that only works for equality</p>



<a name="221299918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299918">(Dec 31 2020 at 16:20)</a>:</h4>
<p>I would definitely try the simplifier.</p>



<a name="221299927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299927">(Dec 31 2020 at 16:20)</a>:</h4>
<p>It's just key to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">perm_foldl_append_iff</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)}</span> <span class="o">:</span>
  <span class="n">foldl</span> <span class="n">append</span> <span class="n">b</span> <span class="n">l</span> <span class="bp">~</span> <span class="n">foldl</span> <span class="n">append</span> <span class="n">b</span> <span class="n">l'</span> <span class="bp">↔</span> <span class="n">l</span> <span class="bp">~</span> <span class="n">l'</span> <span class="o">:=</span>
</code></pre></div>



<a name="221299930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299930">(Dec 31 2020 at 16:20)</a>:</h4>
<p>You can take the quotients of lists under permutations to turn your <code>~</code> into an <code>=</code></p>



<a name="221299938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299938">(Dec 31 2020 at 16:20)</a>:</h4>
<p>But then you have multisets</p>



<a name="221299977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221299977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221299977">(Dec 31 2020 at 16:21)</a>:</h4>
<p>You tell it comm and assoc and left_comm and it will then just put things into its favourite order. I don't know if it'll work but it's worth a try.</p>



<a name="221300076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300076">(Dec 31 2020 at 16:23)</a>:</h4>
<p>Failing that, <code>abel</code> should be generalised to all operations, not just addition, and perhaps it should do this too</p>



<a name="221300193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300193">(Dec 31 2020 at 16:25)</a>:</h4>
<p>not sure if relevant, but i've found <a href="https://leanprover-community.github.io/mathlib_docs/find/list.perm_iff_count">docs#list.perm_iff_count</a> very useful for working with <code>perm</code></p>



<a name="221300330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300330">(Dec 31 2020 at 16:27)</a>:</h4>
<p>Here's how to use <code>abel</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span> <span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="n">ds</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span> <span class="bp">~</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">multiset.coe_eq_coe</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">multiset.coe_add</span><span class="o">],</span>
  <span class="n">abel</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221300512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300512">(Dec 31 2020 at 16:30)</a>:</h4>
<p>I wonder if <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.coe_add">docs#multiset.coe_add</a> simplifies in the wrong direction</p>



<a name="221300525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300525">(Dec 31 2020 at 16:30)</a>:</h4>
<p>It seems like it's much easier to work with multisets than permutations of lists</p>



<a name="221300929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300929">(Dec 31 2020 at 16:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="n">ds</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">list.perm.nodup_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">multiset.coe_eq_coe</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221300951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221300951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221300951">(Dec 31 2020 at 16:36)</a>:</h4>
<p>oops, too late</p>



<a name="221301152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301152">(Dec 31 2020 at 16:39)</a>:</h4>
<p>I don't think <code>coe_add</code> is the wrong direction. Usually you would use the simplifier on a multiset goal after <code>rcases</code> to make it about lists and it will turn everything into lists</p>



<a name="221301220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301220">(Dec 31 2020 at 16:40)</a>:</h4>
<p>this problem is a little unusual in that you want to add an additional wrapping layer rather than remove one</p>



<a name="221301300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301300">(Dec 31 2020 at 16:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221300929">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="n">ds</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">list.perm.nodup_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">multiset.coe_eq_coe</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Which is almost the same as this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">nodup_iff_card</span> <span class="o">{</span> <span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">):</span> <span class="n">a.nodup</span> <span class="bp">↔</span> <span class="n">a.length</span> <span class="bp">=</span> <span class="n">a.to_finset.card</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="n">ds</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">ds</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">ds</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">++</span> <span class="n">as</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">nodup_iff_card</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nodup_iff_card</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">finset.union_comm</span><span class="o">,</span> <span class="n">finset.union_left_comm</span><span class="o">,</span> <span class="n">nat.add_comm</span><span class="o">,</span> <span class="n">nat.add_left_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221301388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301388">(Dec 31 2020 at 16:43)</a>:</h4>
<p>except it has one fewer sorry :)</p>



<a name="221301514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301514">(Dec 31 2020 at 16:45)</a>:</h4>
<p>I'm calling it a day now. Thank you for all your help in 2020 and see you in 2021! I wish you a happy new year ;)</p>



<a name="221301806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301806">(Dec 31 2020 at 16:50)</a>:</h4>
<p>You won't be doing Lean to summon in the new year??</p>



<a name="221301849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221301849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221301849">(Dec 31 2020 at 16:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>



<a name="221304453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221304453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221304453">(Dec 31 2020 at 17:28)</a>:</h4>
<p><span class="user-mention" data-user-id="234196">@Henning Dieterichs</span> <br>
These are the sorts of definitional lemmas I would make:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Leaf</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">Leaf</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">LeafPartition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">acc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[])</span>
<span class="o">(</span><span class="n">inacc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[])</span>
<span class="o">(</span><span class="n">red</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[])</span>

<span class="kd">inductive</span> <span class="n">Ant</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">branch</span> <span class="o">(</span><span class="n">tr1</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">(</span><span class="n">tr2</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">diverge</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tr</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>

<span class="kn">open</span> <span class="n">Ant</span>

<span class="kd">def</span> <span class="n">R</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span> <span class="bp">→</span> <span class="n">LeafPartition</span> <span class="n">Leaf</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">leaf</span> <span class="n">bb</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="n">bb</span> <span class="o">{</span><span class="n">red</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span> <span class="bp">..</span><span class="o">}</span> <span class="o">{</span><span class="n">acc</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span> <span class="bp">..</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">diverge</span> <span class="n">bb</span> <span class="n">tr</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="n">bb</span> <span class="o">(</span><span class="n">R</span> <span class="n">tr</span><span class="o">)</span> <span class="o">(</span>
    <span class="k">match</span> <span class="n">R</span> <span class="n">tr</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="o">⟨[],</span> <span class="o">[],</span> <span class="n">m</span> <span class="o">::</span> <span class="n">ms</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">{</span><span class="n">inacc</span> <span class="o">:=</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span> <span class="n">red</span> <span class="o">:=</span> <span class="n">ms</span><span class="o">,</span> <span class="bp">..</span><span class="o">}</span>
      <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">R</span> <span class="n">tr</span>
    <span class="kd">end</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">branch</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">acc</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span><span class="o">,</span>
    <span class="n">inacc</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span><span class="o">,</span>
    <span class="n">red</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span>
  <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">R_leaf_true</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">(</span><span class="n">leaf</span> <span class="n">tt</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">red</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span> <span class="bp">..</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">R_leaf_false</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">(</span><span class="n">leaf</span> <span class="n">ff</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">acc</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span> <span class="bp">..</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">R_branch</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">(</span><span class="n">branch</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">{</span> <span class="n">acc</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span><span class="o">,</span> <span class="n">inacc</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span><span class="o">,</span>
    <span class="n">red</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">R_diverge_true</span> <span class="o">(</span><span class="n">tr</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">(</span><span class="n">diverge</span> <span class="n">tt</span> <span class="n">tr</span><span class="o">)</span> <span class="bp">=</span> <span class="n">R</span> <span class="n">tr</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">R_diverge_false_cons</span> <span class="o">{</span><span class="n">tr</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">Leaf</span><span class="o">}</span> <span class="o">{</span><span class="n">ms</span> <span class="o">:</span> <span class="n">list</span> <span class="n">Leaf</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">R</span> <span class="n">tr</span> <span class="bp">=</span> <span class="o">{</span><span class="n">red</span> <span class="o">:=</span> <span class="n">m</span> <span class="o">::</span> <span class="n">ms</span><span class="o">,</span> <span class="bp">..</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">R</span> <span class="o">(</span><span class="n">diverge</span> <span class="n">ff</span> <span class="n">tr</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">inacc</span> <span class="o">:=</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span> <span class="n">red</span> <span class="o">:=</span> <span class="n">ms</span><span class="o">,</span> <span class="bp">..</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">R</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
<span class="kd">lemma</span> <span class="n">R_diverge_false_not</span> <span class="o">{</span><span class="n">tr</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">Leaf</span><span class="o">}</span> <span class="o">{</span><span class="n">ms</span> <span class="o">:</span> <span class="n">list</span> <span class="n">Leaf</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">R</span> <span class="n">tr</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="bp">=</span> <span class="o">[]</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">R</span> <span class="n">tr</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">R</span> <span class="n">tr</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">≠</span> <span class="o">[])</span> <span class="o">:</span>
  <span class="n">R</span> <span class="o">(</span><span class="n">diverge</span> <span class="n">ff</span>  <span class="n">tr</span><span class="o">)</span> <span class="bp">=</span> <span class="n">R</span> <span class="n">tr</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">hr</span> <span class="o">:</span> <span class="o">(</span><span class="n">R</span> <span class="n">tr</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hac</span><span class="o">,</span> <span class="n">tlac</span><span class="o">⟩,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hin</span><span class="o">,</span> <span class="n">tlin</span><span class="o">⟩,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hre</span><span class="o">,</span> <span class="n">tlre</span><span class="o">⟩⟩</span><span class="bp">;</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">hr</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="bp">&lt;|&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">R</span><span class="o">,</span> <span class="n">hr</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221305646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221305646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221305646">(Dec 31 2020 at 17:49)</a>:</h4>
<p>you should use <code>tt</code> and <code>ff</code> instead of <code>true</code> and <code>false</code></p>



<a name="221305827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221305827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221305827">(Dec 31 2020 at 17:52)</a>:</h4>
<p>Fixed. In general, there'd likely be some way to have it be over Prop and not bool, right?</p>



<a name="221305864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221305864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221305864">(Dec 31 2020 at 17:53)</a>:</h4>
<p>Well <code>R</code> itself is over <code>bool</code> so the lemmas should be too</p>



<a name="221305871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221305871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221305871">(Dec 31 2020 at 17:53)</a>:</h4>
<p>if it used <code>Prop</code> though your cases should use <code>p -&gt; ...</code> and <code>\neg p -&gt; ...</code> instead of <code>true</code> and <code>false</code></p>



<a name="221306183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221306183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221306183">(Dec 31 2020 at 17:59)</a>:</h4>
<p>Right, I meant that <code>R</code> itself might be over Prop. Since the original example had the bools named as <code>can_prove_empty</code></p>



<a name="221306206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221306206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221306206">(Dec 31 2020 at 18:00)</a>:</h4>
<p><code>Ant</code> has three type arguments btw, that seems odd</p>



<a name="221306265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221306265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221306265">(Dec 31 2020 at 18:00)</a>:</h4>
<p>the beta argument is unused</p>



<a name="221306985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221306985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221306985">(Dec 31 2020 at 18:11)</a>:</h4>
<p>Ah, I meant</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">Ant</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">branch</span> <span class="o">(</span><span class="n">tr1</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">(</span><span class="n">tr2</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">diverge</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tr</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
</code></pre></div>



<a name="221307046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221307046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221307046">(Dec 31 2020 at 18:12)</a>:</h4>
<p>Anyway,  it was an attempt to make the example shared by the other poster above compile, just to show examples of the structure default values and the definitional lemmas.</p>



<a name="221307059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221307059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221307059">(Dec 31 2020 at 18:12)</a>:</h4>
<p>Here's a proof of something that I think roughly approximates the goal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.multiset.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Leaf</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">LeafPartition</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">acc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[])</span>
<span class="o">(</span><span class="n">inacc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[])</span>
<span class="o">(</span><span class="n">red</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">[])</span>

<span class="kd">inductive</span> <span class="n">Ant</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">branch</span> <span class="o">(</span><span class="n">tr1</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">(</span><span class="n">tr2</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>
<span class="bp">|</span> <span class="n">diverge</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">tr</span> <span class="o">:</span> <span class="n">Ant</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ant</span>

<span class="kn">open</span> <span class="n">Ant</span>

<span class="kd">def</span> <span class="n">R</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span> <span class="bp">→</span> <span class="n">LeafPartition</span> <span class="n">Leaf</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">leaf</span> <span class="n">bb</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="n">bb</span> <span class="o">{</span><span class="n">red</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span> <span class="bp">..</span><span class="o">}</span> <span class="o">{</span><span class="n">acc</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span> <span class="bp">..</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">diverge</span> <span class="n">bb</span> <span class="n">tr</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ite</span> <span class="n">bb</span> <span class="o">(</span><span class="n">R</span> <span class="n">tr</span><span class="o">)</span> <span class="o">(</span>
    <span class="k">match</span> <span class="n">R</span> <span class="n">tr</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="o">⟨[],</span> <span class="o">[],</span> <span class="n">m</span> <span class="o">::</span> <span class="n">ms</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">{</span><span class="n">inacc</span> <span class="o">:=</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span> <span class="n">red</span> <span class="o">:=</span> <span class="n">ms</span><span class="o">,</span> <span class="bp">..</span><span class="o">}</span>
      <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">R</span> <span class="n">tr</span>
    <span class="kd">end</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">branch</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">acc</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span><span class="o">,</span>
    <span class="n">inacc</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span><span class="o">,</span>
    <span class="n">red</span> <span class="o">:=</span> <span class="o">(</span><span class="n">R</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span>
  <span class="o">}</span>

<span class="kd">def</span> <span class="n">leaves</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">Leaf</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">leaf</span> <span class="n">bb</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">l</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">diverge</span> <span class="n">bb</span> <span class="n">tr</span><span class="o">)</span> <span class="o">:=</span> <span class="n">leaves</span> <span class="n">tr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">branch</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">leaves</span> <span class="n">x</span> <span class="bp">++</span> <span class="n">leaves</span> <span class="n">y</span>

<span class="kn">section</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">leaves</span> <span class="n">R</span> <span class="n">add_left_comm</span> <span class="n">add_comm</span>
<span class="kd">theorem</span> <span class="n">R_perm</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">leaves</span> <span class="n">a</span> <span class="bp">~</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">multiset.coe_eq_coe</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">],</span>
  <span class="n">induction</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">-</span><span class="n">multiset.coe_eq_coe</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">,</span> <span class="bp">*</span><span class="o">],</span>
    <span class="n">rcases</span> <span class="n">hr</span> <span class="o">:</span> <span class="o">(</span><span class="n">R</span> <span class="n">a_tr</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hac</span><span class="o">,</span> <span class="n">tlac</span><span class="o">⟩,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hin</span><span class="o">,</span> <span class="n">tlin</span><span class="o">⟩,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hre</span><span class="o">,</span> <span class="n">tlre</span><span class="o">⟩⟩</span><span class="bp">;</span>
    <span class="n">refl</span> <span class="o">}</span>
<span class="kd">end</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221307091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221307091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221307091">(Dec 31 2020 at 18:13)</a>:</h4>
<p>the proof is a bit bombastic, it just cases on everything</p>



<a name="221347839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221347839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221347839">(Jan 01 2021 at 11:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221307059">said</a>:</p>
<blockquote>
<p>Here's a proof of something that I think roughly approximates the goal:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="kd">theorem</span> <span class="n">R_perm</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Ant</span> <span class="n">bool</span> <span class="n">Leaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">leaves</span> <span class="n">a</span> <span class="bp">~</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">acc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">inacc</span> <span class="bp">++</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">red</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">multiset.coe_eq_coe</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">],</span>
  <span class="n">induction</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">-</span><span class="n">multiset.coe_eq_coe</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_add</span><span class="o">,</span> <span class="bp">*</span><span class="o">],</span>
    <span class="n">rcases</span> <span class="n">hr</span> <span class="o">:</span> <span class="o">(</span><span class="n">R</span> <span class="n">a_tr</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hac</span><span class="o">,</span> <span class="n">tlac</span><span class="o">⟩,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hin</span><span class="o">,</span> <span class="n">tlin</span><span class="o">⟩,</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hre</span><span class="o">,</span> <span class="n">tlre</span><span class="o">⟩⟩</span><span class="bp">;</span>
    <span class="n">refl</span> <span class="o">}</span>
<span class="kd">end</span>
<span class="bp">...</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Nice <span aria-label="flushed" class="emoji emoji-1f633" role="img" title="flushed">:flushed:</span>  I didn't think such a short proof could do it.<br>
I wonder though, I thought <code>simp</code> should, in general, be only used for closing goals?</p>



<a name="221353088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221353088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221353088">(Jan 01 2021 at 14:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="234196">Henning Dieterichs</span> <a href="#narrow/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates/near/221347839">said</a>:</p>
<blockquote>
<p>I wonder though, I thought <code>simp</code> should, in general, be only used for closing goals?</p>
</blockquote>
<p>if you want to use simp in the middle of a proof (e.g. because the subgoal is extremely verbose), one way to make simp less brittle is to run <code>squeeze_simp</code> instead and then paste the output for a <code>simp only</code> call. this can also greatly boost performance (or at least it used to).</p>



<a name="221362924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221362924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henning Dieterichs <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221362924">(Jan 01 2021 at 18:33)</a>:</h4>
<p>Thanks for pointing that out. I often wondered which lemmas simp used.</p>



<a name="221363615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236449-Program%20verification/topic/Lists%20Without%20Duplicates/near/221363615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/236449-Program-verification/topic/Lists.20Without.20Duplicates.html#221363615">(Jan 01 2021 at 18:50)</a>:</h4>
<p>For more low-level output you can also turn on <code>set_option trace.simplify true</code>, see the start of <a href="https://leanprover-community.github.io/extras/simp.html">the community page on the simplifier</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
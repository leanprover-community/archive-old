---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/classicalize.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html">classicalize</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224547255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224547255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224547255">(Jan 29 2021 at 22:55)</a>:</h4>
<p>It seems the best practice is to write lemmas to be as permissive as possible with which decidable instances they accept.  But within proofs this can cause issues when you use <code>classical</code> since it makes things harder to rewrite, etc., from there being multiple non-defeq instances around.  I was wondering if there were something like a "<code>classicalize</code>" tactic that could replace all decidable instances in the goal or a hypothesis with their <code>classical.prop_decidable</code> counterparts.</p>
<p>(More generally, there could be a "<code>canonicalize</code>" tactic to take every term of a singleton type and replace it with a canonical term, perhaps as defined by <code>inhabited</code>.)</p>



<a name="224548544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224548544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224548544">(Jan 29 2021 at 23:09)</a>:</h4>
<p>this doesn't really work, because classical.prop_decidable et al is the <em>least</em> canonical kind of typeclass, it almost never agrees with other instances</p>



<a name="224548639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224548639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224548639">(Jan 29 2021 at 23:10)</a>:</h4>
<p>The general approach used by simp is to "canonicalize" typeclass instances, meaning that you replace whatever instance is there with the one that typeclass inference would find in the current context. This has a higher chance of being coherent with other choices</p>



<a name="224549985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224549985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224549985">(Jan 29 2021 at 23:26)</a>:</h4>
<p>Ok, so as a followup, would it be possible to have a macro that could take a definition or lemma and classicalize it?  An example use would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="o">(</span><span class="n">classicalize</span><span class="bp">!</span> <span class="n">foo</span><span class="o">)</span>
</code></pre></div>
<p>to make a version of <code>foo</code> that would be compatible with a purely classical context.</p>



<a name="224550170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550170">(Jan 29 2021 at 23:29)</a>:</h4>
<p>The case I ran into recently was resolved by changing <code>[decidable p]</code> arguments in the lemma with <code>{_ : decidable p}</code> - the latter unified with the instance in the goal, while the former found a different instance. A tactic to generate modified lemmas like this on the fly might also help</p>



<a name="224550172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550172">(Jan 29 2021 at 23:29)</a>:</h4>
<p>lemmas should be written in a context which is strictly more general than all uses, so I don't understand what you mean</p>



<a name="224550295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550295">(Jan 29 2021 at 23:30)</a>:</h4>
<p>Ah, right that's a fault of the elaborator. The error it gives when unification and typeclass inference don't match isn't particularly useful for users</p>



<a name="224550320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550320">(Jan 29 2021 at 23:31)</a>:</h4>
<p>I don't think generating lemmas on the fly is ever a good idea though</p>



<a name="224550364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550364">(Jan 29 2021 at 23:31)</a>:</h4>
<p>Does the elaborator use typeclass resolution to fill <code>[]</code> args in lambdas?</p>



<a name="224550405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550405">(Jan 29 2021 at 23:32)</a>:</h4>
<p>in lambdas?</p>



<a name="224550446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550446">(Jan 29 2021 at 23:32)</a>:</h4>
<p>it uses typeclass resolution to fill in <code>[]</code> args in lemmas</p>



<a name="224550506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550506">(Jan 29 2021 at 23:33)</a>:</h4>
<p>this can later cause a unification error, but it doesn't know how to back this out so it just causes an error</p>



<a name="224550508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550508">(Jan 29 2021 at 23:33)</a>:</h4>
<p>I mean something like <code>(\lam x [decidable (p x)], sorry) y</code></p>



<a name="224550532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550532">(Jan 29 2021 at 23:33)</a>:</h4>
<p>There are many cases where some of the decidable instances are computed from the others. I ran into a case with <code>fintype.subtype</code> recently -- this is almost always the correct instance, but in the <code>classical</code> context it was not correct and I had to use <code>convert</code> instead of a more straightforward rewrite.</p>



<a name="224550547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550547">(Jan 29 2021 at 23:33)</a>:</h4>
<p>Does the second argument I didn't pass get inferred?</p>



<a name="224550550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550550">(Jan 29 2021 at 23:33)</a>:</h4>
<p>Yes it does</p>



<a name="224550640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550640">(Jan 29 2021 at 23:34)</a>:</h4>
<p>So a tactic could generate a wrapper lambda for a lemma with different argument binding rules?</p>



<a name="224550641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550641">(Jan 29 2021 at 23:34)</a>:</h4>
<p>what's the example?</p>



<a name="224550650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550650">(Jan 29 2021 at 23:34)</a>:</h4>
<p>I think Eric is thinking about something I had in mind with <code>classicalize!</code>, which would be that it doesn't generate modified lemmas, but instead creates a lambda wrapper whose type is classicalized.  (Edit: I hit enter right as Eric mentioned wrappers.)</p>



<a name="224550685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550685">(Jan 29 2021 at 23:35)</a>:</h4>
<p>You can also insert <code>(id _)</code> for typeclass instance arguments to suppress inference</p>



<a name="224550696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550696">(Jan 29 2021 at 23:35)</a>:</h4>
<p>but you have to know that they are going to be problematic</p>



<a name="224550765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550765">(Jan 29 2021 at 23:36)</a>:</h4>
<p>I was envisaging a weaker version of what Kyle suggests that just disables typeclass lookup for decidable args, without entering <code>@</code>/<code>_</code> hell</p>



<a name="224550799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550799">(Jan 29 2021 at 23:36)</a>:</h4>
<p>I mean literally <code>(id _)</code>, you don't actually have to specify anything</p>



<a name="224550820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550820">(Jan 29 2021 at 23:37)</a>:</h4>
<p>But I'd like to see kyle's example</p>



<a name="224550911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550911">(Jan 29 2021 at 23:38)</a>:</h4>
<p><code>rw (fixelab! bad_lemma x)</code> instead of <code>rw @bad_lemma _ _ _ (id _) _ x</code></p>



<a name="224550921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550921">(Jan 29 2021 at 23:38)</a>:</h4>
<p>also it's not clear to me how this is better than <code>convert</code></p>



<a name="224550927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550927">(Jan 29 2021 at 23:38)</a>:</h4>
<p>you still have to use a tactic to fix things up</p>



<a name="224550952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224550952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224550952">(Jan 29 2021 at 23:38)</a>:</h4>
<p>It's basic, but I just wanted to rewrite with <code>common_neighbors_symm</code> first, and it got me thinking:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/master/src/combinatorics/simple_graph/basic.lean#L384">https://github.com/leanprover-community/mathlib/blob/master/src/combinatorics/simple_graph/basic.lean#L384</a></p>



<a name="224551231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551231">(Jan 29 2021 at 23:42)</a>:</h4>
<p>I think the cause there is maybe lemmas with <code>[decidable foo]</code> which actually need <code>[decidable bar]</code> and derive the connection implicitly</p>



<a name="224551294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551294">(Jan 29 2021 at 23:43)</a>:</h4>
<p>Then you end up trying to apply the lemma to a case with a direct <code>decidable bar</code> instance not derived from a <code>decidable foo</code> (eg <code> classical.dec</code>), and it doesn't match</p>



<a name="224551370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551370">(Jan 29 2021 at 23:44)</a>:</h4>
<p>(<span class="user-mention silent" data-user-id="306601">Kyle Miller</span>)  I don't think that's a very good example. You have to prove <code>s = t -&gt; fintype.card s = fintype.card t</code> and that's a job for <code>congr</code>/<code>convert</code></p>



<a name="224551406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551406">(Jan 29 2021 at 23:44)</a>:</h4>
<p><code>rw</code> just can't handle that because of the dependent argument</p>



<a name="224551437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551437">(Jan 29 2021 at 23:45)</a>:</h4>
<p>In your code that comes up all over the place where the lemmas assume G.adj is decidable but the statement requires neighbourset is decidable.</p>



<a name="224551448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551448">(Jan 29 2021 at 23:45)</a>:</h4>
<p>Maybe what I'm describing doesn't matter though</p>



<a name="224551548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551548">(Jan 29 2021 at 23:46)</a>:</h4>
<p>Yeah, it was a choice to focus only on <code>G.adj</code> being decidable, since we don't have any applications where it the decidability of <code>G.neighbor_set</code> would be any different.  This is certainly the proximal issue, and I agree this isn't the best example.</p>



<a name="224551557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551557">(Jan 29 2021 at 23:47)</a>:</h4>
<p>In your example the default instance should still go through the "indirect" route though, i.e. deriving decidability of G.neighbor_set from G.adj which is classical</p>



<a name="224551684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551684">(Jan 29 2021 at 23:49)</a>:</h4>
<p>I think there is some value in a <code>convert_rw</code> which tries to rewrite given a lemma that only kind of matches the goal, with the difference being proved by <code>convert</code> / given as a subgoal, although I don't know how the interface would work there</p>



<a name="224551694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551694">(Jan 29 2021 at 23:49)</a>:</h4>
<p>If I write my own lemma about <code>card (G.neighbor_set v w)</code> with classical open, won't I get the direct instance and find myself unable to rewrite with Kyle's indirect lemma?</p>



<a name="224551763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551763">(Jan 29 2021 at 23:50)</a>:</h4>
<p>I still think it would be nice if there were some way to have a strong form of <code>classical</code> where decidability can be made to matter an epsilon amount.  Maybe <code>crw</code> (for <code>classical_rw</code>) would be more manageable than a <code>convert_rw</code>.</p>



<a name="224551777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551777">(Jan 29 2021 at 23:50)</a>:</h4>
<p>I don't think so; you have a lemma saying <code>G.neighbor_set</code> is decidable if <code>G.adj</code> is and that should take priority because the classical instance is the lowest priority</p>



<a name="224551801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551801">(Jan 29 2021 at 23:51)</a>:</h4>
<p>Thanks, I'd forgotten about priority</p>



<a name="224551830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224551830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224551830">(Jan 29 2021 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> the easiest way to achieve that is to take these decidability arguments out of the statements</p>



<a name="224552066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224552066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224552066">(Jan 29 2021 at 23:55)</a>:</h4>
<p>I tried using simp on your lemma and it applied <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.filter_congr_decidable">docs#finset.filter_congr_decidable</a> , which appears to be addressing your issue</p>



<a name="224553010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553010">(Jan 30 2021 at 00:08)</a>:</h4>
<p>This lemma isn't really my issue -- that lemma only reminded me how conflicting decidable instances occasionally show up and how it ideally is something you shouldn't have to think about in a <code>classical</code> context.  What I'm hoping by starting this discussion is to maybe find low-cost ways that might reduce this friction in general.  (With the Lean-is-a-videogame metaphor, matching up decidable instances inside proofs where it's pretty much irrelevant isn't good game design and isn't very satisfying.  Can we improve the game loop here?)</p>



<a name="224553067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553067">(Jan 30 2021 at 00:09)</a>:</h4>
<p>I mean <code>convert</code> does this already</p>



<a name="224553074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553074">(Jan 30 2021 at 00:09)</a>:</h4>
<p>I really don't see what you're looking for</p>



<a name="224553137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553137">(Jan 30 2021 at 00:10)</a>:</h4>
<p>It's not <em>nothing</em>, because the terms exist, there is some stuff happening</p>



<a name="224553148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553148">(Jan 30 2021 at 00:10)</a>:</h4>
<p>if you want the terms to not exist you have to change the statements</p>



<a name="224553168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553168">(Jan 30 2021 at 00:11)</a>:</h4>
<p>and then anyone who uses decidability or <code>dec_trivial</code> will not be able to use it</p>



<a name="224553183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553183">(Jan 30 2021 at 00:11)</a>:</h4>
<p>maybe you don't, but finite graph theory does seem like the place where it would come up</p>



<a name="224553245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553245">(Jan 30 2021 at 00:12)</a>:</h4>
<p>certainly when you are proving that the konigsberg graph has more than two vertices with odd degree it's nice to just <code>dec_trivial</code> that</p>



<a name="224553290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553290">(Jan 30 2021 at 00:13)</a>:</h4>
<p>With convert you have to set things up differently with how you write the tactic proof.  It takes some restructuring in a way that makes you think about how there are decidable instances.  If you are somehow able to make every decidable instance the <code>classical.prop_decidable</code> one automatically, then you wouldn't have to think about it.</p>
<p>I know you can do this all with convert, and I use convert.  It's just worth thinking about how the user experience could be improved.</p>



<a name="224553492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553492">(Jan 30 2021 at 00:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/classicalize/near/224553148">said</a>:</p>
<blockquote>
<p>if you want the terms to not exist <strong>you</strong> have to change the statements</p>
</blockquote>
<p>You might say this word is where I disagree, since the system might be able to change them for you when you're in a proof.  I'm willing to accept such a system might be too onerous to use in practice given the way Lean works.</p>



<a name="224553515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553515">(Jan 30 2021 at 00:16)</a>:</h4>
<p>I mean the lemma has to be a different lemma about a different object</p>



<a name="224553813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224553813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224553813">(Jan 30 2021 at 00:21)</a>:</h4>
<p>But again, this is what <code>convert</code> does. In order for this to work you have to know the crazy instance you have and the other crazy instance you want, and <code>rw</code> only knows one side of the picture</p>



<a name="224554245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554245">(Jan 30 2021 at 00:27)</a>:</h4>
<p>by the way, this proof works for your example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_common_neighbors_le_degree_right</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="o">(</span><span class="n">G.common_neighbors</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">G.degree</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">common_neighbors_symm</span> <span class="n">G</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">G.card_common_neighbors_le_degree_left</span> <span class="n">w</span> <span class="n">v</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224554406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554406">(Jan 30 2021 at 00:29)</a>:</h4>
<p>I'm not sure what you're objecting to here.  Here is what I'm thinking again just to put it in one place: it's convenient having lemmas that accept general decidable instances, but inside a proof you don't care what they are, so you could have a mechanism to transform the goal into the the classical form, and have another mechanism to wrap terms in a classical form.  Now supposing that this can be made to work, <code>rw</code> and friends work fine, more or less.</p>



<a name="224554466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554466">(Jan 30 2021 at 00:30)</a>:</h4>
<p>And I could have sworn I had tried <code>simp_rw</code> and it didn't work...</p>



<a name="224554519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554519">(Jan 30 2021 at 00:31)</a>:</h4>
<p>Ah, it needs all three arguments.  Hadn't considered that.</p>



<a name="224554545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554545">(Jan 30 2021 at 00:31)</a>:</h4>
<p>I'm not sure if there is an option to stop <code>simp_rw</code> from applying its argument repeatedly</p>



<a name="224554636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554636">(Jan 30 2021 at 00:32)</a>:</h4>
<p>This also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">G.card_common_neighbors_le_degree_left</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">common_neighbors_symm</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span> <span class="bp">⊢</span><span class="o">,</span> <span class="n">convert</span> <span class="n">this</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224554651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554651">(Jan 30 2021 at 00:33)</a>:</h4>
<p><code>simpa</code> doesn't quite work because it needs the convert at the end</p>



<a name="224554707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554707">(Jan 30 2021 at 00:33)</a>:</h4>
<p>What's the mechanism that makes <code>simp</code> handle <code>add_comm</code>? Does it not apply to other commutativity lemmas?</p>



<a name="224554775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554775">(Jan 30 2021 at 00:34)</a>:</h4>
<p>it puts a total order on terms and doesn't use commutativity-looking lemmas if they make the term go up in the order</p>



<a name="224554817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554817">(Jan 30 2021 at 00:35)</a>:</h4>
<p>I think the definition of "commutativity-looking" is that the rhs is a substitution instance of the lhs</p>



<a name="224554920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224554920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224554920">(Jan 30 2021 at 00:36)</a>:</h4>
<p><code>simp</code> can handle it just fine, I think <code>simp_rw</code> is just in a loop, which defeats simp's handling</p>



<a name="224555108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224555108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224555108">(Jan 30 2021 at 00:39)</a>:</h4>
<p>I need to do <code>simp only [G.common_neighbors_symm v]</code> to get it to work, rather than <code>simp only [G.common_neighbors_symm]</code></p>



<a name="224567602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224567602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224567602">(Jan 30 2021 at 05:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/classicalize/near/224554920">said</a>:</p>
<blockquote>
<p><code>simp</code> can handle it just fine, I think <code>simp_rw</code> is just in a loop, which defeats simp's handling</p>
</blockquote>
<p>If the term order were global, then this loops wouldn't be a problem either, right?</p>



<a name="224871069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224871069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224871069">(Feb 02 2021 at 13:34)</a>:</h4>
<p>Properly written lemmas should work with <code>classical</code> out of the box.</p>



<a name="224871122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224871122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224871122">(Feb 02 2021 at 13:35)</a>:</h4>
<p>My rule of thumb: require all the <code>decidable</code> instances that are used in the type (not in the proof) of a lemma/def.</p>



<a name="224871338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224871338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224871338">(Feb 02 2021 at 13:37)</a>:</h4>
<p>I mean, even if I have <code>[decidable_eq α] [decidable_eq β]</code> but the definition/lemma uses <code>[decidable_eq (α × β)]</code>, then it's better to add this as an argument.</p>



<a name="224871403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224871403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224871403">(Feb 02 2021 at 13:37)</a>:</h4>
<p>This way lemma works both in classical and non-classical contexts.</p>



<a name="224872509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224872509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224872509">(Feb 02 2021 at 13:46)</a>:</h4>
<p>Would a linter rule saying "every decidable term in a lemma statement must be a bound variable" work?</p>



<a name="224873296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224873296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224873296">(Feb 02 2021 at 13:52)</a>:</h4>
<p>Don't we already have that linter?</p>



<a name="224885972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224885972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224885972">(Feb 02 2021 at 15:25)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/linter.decidable_classical">docs#linter.decidable_classical</a> only checks for unecessary decidable assumptions, not missing ones</p>



<a name="224912303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224912303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224912303">(Feb 02 2021 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/classicalize/near/224872509">said</a>:</p>
<blockquote>
<p>Would a linter rule saying "every decidable term in a lemma statement must be a bound variable" work?</p>
</blockquote>
<p>Would that include always being explicit about decidability even for types like <code>nat</code>?  I remember there being a post where the <code>nat</code> decidable instances caused a conflict in a classical setting.</p>
<p>Previously I suggested a tactic/macro to classicalize instances in a term, but perhaps it would be more useful having a tactic called <code>exactD</code>, where what <code>exactD t</code> would do is generalize all the decidable instances in the type of <code>t</code> and then do <code>exact</code>.  But I think it would be nice if there were some way when writing a lemma to indicate that you want the decidable instances to be generalized -- it's bookkeeping I can do, but it's nice leaving what's purely mechanical to computers.</p>



<a name="224914004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224914004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224914004">(Feb 02 2021 at 18:25)</a>:</h4>
<p>I think maybe even for nat that would be a good idea</p>



<a name="224914107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224914107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224914107">(Feb 02 2021 at 18:26)</a>:</h4>
<p>Although the only way to really find out is write the linter and see which of its suggestions look harmful</p>



<a name="224914147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/224914147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#224914147">(Feb 02 2021 at 18:26)</a>:</h4>
<p>(Regarding the point I can hear Mario already saying that <code>exactD</code> is basically <code>convert</code>: the idea would be that this would let you work with terms without a goal or needing to specify the desired generalized type.  Not arguing that it's definitely useful, but it seems better at least than the original ideas I was proposing.)</p>



<a name="228204806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/classicalize/near/228204806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/classicalize.html#228204806">(Mar 01 2021 at 10:04)</a>:</h4>
<p>I had a go at making this linter in <a href="https://github.com/leanprover-community/mathlib/issues/6485">#6485</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
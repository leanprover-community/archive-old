---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html">use tactic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279301435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279301435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Chanin (he) (S2'21) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279301435">(Apr 18 2022 at 16:03)</a>:</h4>
<p>I'm following along this <a href="https://youtu.be/EXpmbAfBNnw?t=1195">gpt-f video</a>, and at one point it has the proof:</p>
<div class="youtube-video message_inline_image"><a data-id="EXpmbAfBNnw" href="https://youtu.be/EXpmbAfBNnw?t=1195"><img src="https://uploads.zulipusercontent.net/bd2a9c6a819c867efb19ea439f4a113b891f5dae/68747470733a2f2f692e7974696d672e636f6d2f76692f4558706d624166424e6e772f64656661756c742e6a7067"></a></div><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">n.lt_succ_self</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>However, when I try to write this in lean3, I get the error <code>unknown identifier 'use'</code>. What am I missing? Is there something I need to import?</p>



<a name="279302173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279302173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279302173">(Apr 18 2022 at 16:11)</a>:</h4>
<p>If you have mathlib as a dependency to your project, <code>import tactic</code> at the beginning of the file should do the trick.</p>



<a name="279302561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279302561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Chanin (he) (S2'21) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279302561">(Apr 18 2022 at 16:15)</a>:</h4>
<p>You're a genius! That did it</p>



<a name="279302759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279302759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Chanin (he) (S2'21) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279302759">(Apr 18 2022 at 16:17)</a>:</h4>
<p>Is there a way to import just what I'm using? It makes me nervous to write things like <code>import tactic</code> since then I don't know where the labels I'm using in the code is from</p>



<a name="279302846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279302846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Chanin (he) (S2'21) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279302846">(Apr 18 2022 at 16:17)</a>:</h4>
<p>Or is there a way to see what's being imported when I write something like <code>import tactic</code>? I assume lots of stuff gets pulled in, but I can't tell how to see what it all is</p>



<a name="279302953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279302953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279302953">(Apr 18 2022 at 16:18)</a>:</h4>
<p><code>import tactic</code> imports a huge amount of stuff yes; it's what I encourage mathematicians to do because it gives them most basic math stuff and most tactics.</p>



<a name="279303156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279303156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279303156">(Apr 18 2022 at 16:20)</a>:</h4>
<p>I think you can <code>import tactic.interactive</code> to get <code>use</code> working; this is an extremely minimal import which just gives you a bunch of really useful tactics which happen to be in <code>mathlib</code> rather than core Lean because they weren't needed in core Lean.</p>



<a name="279305193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279305193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Chanin (he) (S2'21) <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279305193">(Apr 18 2022 at 16:40)</a>:</h4>
<p>interesting, so there's no equivalent to, ex, in python saying something like <code>from tactic.interactive import use</code>?</p>



<a name="279306047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279306047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279306047">(Apr 18 2022 at 16:48)</a>:</h4>
<p>The docs will tell you what import works as well -- <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#use">https://leanprover-community.github.io/mathlib_docs/tactics.html#use</a> (here it says indeed <code>tactic.interactive</code>, but also <code>import tactic.basic</code>)</p>



<a name="279306122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279306122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279306122">(Apr 18 2022 at 16:49)</a>:</h4>
<p>As for the Pythonism -- my perception is the Lean community, or at least mathlib, is less ... "cognizant" maybe? of such things. Or the style indeed is "import stuff and deal with it later if needed" seemingly.</p>



<a name="279306198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279306198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279306198">(Apr 18 2022 at 16:49)</a>:</h4>
<p>There's <code>open foo (bar)</code> which is sort of similar, it just pulls <code>bar</code> out of <code>foo</code>, but I don't know if there's similar syntax which works for <code>import</code> where a bunch of stuff may get plopped into your namespace immediately</p>



<a name="279306928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279306928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279306928">(Apr 18 2022 at 16:56)</a>:</h4>
<p>I believe such targeted imports wouldn't quite work in mathlib because maths is so underconnected. Further, there is a bunch of instance stuff that would unexpectedly break if we were not taking all transitive imports by default.</p>



<a name="279307640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279307640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279307640">(Apr 18 2022 at 17:02)</a>:</h4>
<p>So the Python import there still "imports" everything, it's just a question of what things you can refer to unqualified after it has run. So if importing something (in Lean) is like "have a bunch of side effects like registering some instances with the typeclass search system" then they'd still hypothetically run.  I just mean that folks don't tend to like qualified imports, or minimizing plopping things in the global namespace, as much as in Python (which seems safe for a language like Lean but requires active energy coming from Python I think to not care about as much. To a Python programmer I'd say "use <code>from</code> imports as little as possible, and never import lots of stuff into the global namespace", and in Lean I just get the perspective that the reverse is generally preferred, folks will sometimes comment "why do you keep writing <code>foo.something</code>, get rid of the <code>foo.</code> with an open.)</p>



<a name="279324531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279324531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279324531">(Apr 18 2022 at 19:32)</a>:</h4>
<p>I rarely use <code>open</code>, the namespacing is pretty light in most parts of mathlib so it isn't needed, and certain namespaces like <code>nat</code> cause a lot of overloading if you open them</p>



<a name="279324767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279324767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279324767">(Apr 18 2022 at 19:34)</a>:</h4>
<p>I think the point is that python's <code>from foo import bar</code> is closest to lean's <code>import foo  open bar</code>, and you can just leave off the last bit if you don't want to use it unqualified. In any case, for interactive tactics like <code>use</code> there is no namespacing at all: all tactics must be in the <code>tactic.interactive</code> namespace and they are all available unqualified in begin-end blocks if imported</p>



<a name="279328243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279328243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279328243">(Apr 18 2022 at 20:08)</a>:</h4>
<p>A big difference between Python and Lean is how they handle the "linkage" problem, which is how do global variables end up actually referring to values?</p>
<p>The Python system: there are <code>module</code> objects, and a module contains a name-&gt;value mapping. When a module file is loaded it creates a <code>module</code> and (1) each module it imports gets added to this module's mapping (where <code>from foo import x</code> goes and copies the value for <code>x</code> in <code>foo</code> to this module), and (2) each function that gets defined gets a reference to the current module, since that way when that function is evaluated, it's able to evaluate global variables in the context of the module it was defined in. Modules double as a sort of hierarchical namespacing system, since when you import a module the module itself gets added to the current module's mapping, so <code>foo.x</code> turns into "look up <code>foo</code> in the current module, then ask <code>foo</code> for <code>x</code>."</p>
<p>The Lean system: there are two orthogonal systems, environments and modules. The environment is a name-&gt;value mapping, and each module you import extends the environment (and the name of the module may have no relation to the names it adds to the environment). There is a namespacing system from having hierarchical names. Then the <code>open foo</code> command just adds aliases to the environment for everything with the <code>foo</code> prefix, but any references to aliases get resolved into fully qualified names during elaboration time. There's an expectation that names will never be reused between different modules. This means that when a definition is evaluated, it can evaluate global variables by looking up a declaration by its fully qualified name alone, in any environment that contains that definition. This is useful when it comes to proving things because definitions can be unfolded, and any names you see are ones you can refer to yourself. I imagine this also makes passing things to the Lean kernel for final verification simpler.</p>
<p>The Lean system is sort of like Common Lisp's, where there are symbol packages (a complicated form of hierarchical names) and each symbol package contains some name-&gt;symbol mapping. Unlike Lean, each symbol directly contains the value it refers to, and the way the <code>open</code> equivalent works is that a reference to the symbol is added to another symbol package. Linkage happens at parse time, so when a function is evaluated it's able to evaluate global variables by just asking the symbol itself for its value.</p>
<p>In principle, Lean could allow you to do "tree shaking" and add only those declarations to the environment that are transitively necessary to work with a given declaration. But, in practice, since you're not supposed to reuse fully qualified names between different modules, I guess you don't need this sort of surgical namespace management.</p>



<a name="279328910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279328910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279328910">(Apr 18 2022 at 20:15)</a>:</h4>
<blockquote>
<p>In principle, Lean could allow you to do "tree shaking" and add only those declarations to the environment that are transitively necessary to work with a given declaration. But, in practice, since you're not supposed to reuse fully qualified names between different modules, I guess you don't need this sort of surgical namespace management.</p>
</blockquote>
<p>This would also be bad for stability, since it means that any change to the body of a definition would affect what definitions are available in downstream modules</p>



<a name="279334490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279334490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279334490">(Apr 18 2022 at 21:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/use.20tactic/near/279324767">said</a>:</p>
<blockquote>
<p>all tactics must be in the <code>tactic.interactive</code> namespace and they are all available unqualified in begin-end blocks if imported</p>
</blockquote>
<p>I wanted to see if there might have been an edge case to this, but tactic blocks do seem to require the names of tactics to be in the <code>tactic.interactive</code> namespace -- aliases don't count.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">mytactics.foo</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">tactic.interactive.simp</span>

<span class="c1">-- Create alias `tactic.interactive.foo` for `mytactics.foo`</span>
<span class="kn">open</span> <span class="n">mytactics</span> <span class="n">as</span> <span class="n">tactic.interactive</span>

<span class="c1">-- This is ok</span>
<span class="k">#print</span> <span class="n">tactic.interactive.foo</span>
<span class="c1">-- meta def mytactics.foo  ...</span>

<span class="c1">-- Yet,</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">foo</span><span class="o">,</span>
  <span class="c1">-- unknown identifier 'foo'</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279339230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279339230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279339230">(Apr 18 2022 at 21:55)</a>:</h4>
<p>I'm confused, this works fine, and the tactic isn't in the interactive namespace</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">oof</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">ayy</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">tactic.exact</span> <span class="bp">`</span><span class="o">(</span><span class="n">trivial</span><span class="o">)</span>
<span class="kd">end</span> <span class="n">oof</span>
<span class="kn">open</span> <span class="n">oof</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ayy</span><span class="o">,</span>
  <span class="n">tactic.trace_state</span>
<span class="kd">end</span>
</code></pre></div>
<p>I thought there were some differences with tactics that took arguments, but not in general</p>



<a name="279341813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279341813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279341813">(Apr 18 2022 at 22:22)</a>:</h4>
<p>you need to put tactics in the interactive namespace if you want them to be parsed as interactive tactics, which means you get to use <code>parse my_parser</code> to parse arguments with custom syntax. You can also use <em>any</em> term in a begin end block as if it was a tactic, but in this case it is just treated as an expression so you have to conform to expression syntax and name resolution works as normal</p>



<a name="279341937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/use%20tactic/near/279341937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/use.20tactic.html#279341937">(Apr 18 2022 at 22:24)</a>:</h4>
<p>This affects even simple tactics with no arguments:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">trivial</span><span class="bp">;</span> <span class="n">skip</span><span class="o">,</span> <span class="c1">-- ok</span>
  <span class="n">ayy</span><span class="bp">;</span> <span class="n">skip</span><span class="o">,</span> <span class="c1">-- unknown identifier 'skip'</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
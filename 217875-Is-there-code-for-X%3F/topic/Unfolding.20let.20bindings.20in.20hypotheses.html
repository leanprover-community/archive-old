---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html">Unfolding let bindings in hypotheses</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226456384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456384">(Feb 15 2021 at 23:44)</a>:</h4>
<p>It seems that <code>intro</code> (but not <code>rintro</code>) is able to unfold let bindings in goals:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group</span>
<span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kd">def</span> <span class="n">some_def</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="bp">$</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="bp">$</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">add_comm</span> <span class="n">j</span> <span class="n">i</span><span class="o">,</span> <span class="n">h2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">fin</span> <span class="n">h1</span><span class="o">)</span> <span class="k">in</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">h2.mp</span> <span class="n">y</span>

<span class="kd">lemma</span> <span class="n">as_goal</span> <span class="o">:</span> <span class="n">some_def</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">some_def</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">eq_mp_rfl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>However, the same does not seem to be true of hypotheses:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">as_hyp</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">some_def</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">some_def</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">,,</span> <span class="n">rest</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hs</span><span class="o">,</span>
  <span class="c1">-- `hs`, `h1`, and `h2` are gone?</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is there a tactic that can do this?</p>



<a name="226456632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456632">(Feb 15 2021 at 23:48)</a>:</h4>
<p>I don't think any such tactic exists; most tactics just unfold lets or don't know what to do with them</p>



<a name="226456661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456661">(Feb 15 2021 at 23:49)</a>:</h4>
<p>Presumably since <code>intro</code> can do it on goals, it should be possible to do it on hypotheses somehow too?</p>



<a name="226456662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456662">(Feb 15 2021 at 23:49)</a>:</h4>
<p>this needs a tactic that can "hoist" lets out of an expression</p>



<a name="226456670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456670">(Feb 15 2021 at 23:49)</a>:</h4>
<p>no, there's a missing piece</p>



<a name="226456739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456739">(Feb 15 2021 at 23:50)</a>:</h4>
<p>(although you used a really annoying example because of all the <code>_</code> in the goal)</p>



<a name="226456766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456766">(Feb 15 2021 at 23:51)</a>:</h4>
<p>(Pretend I used <code>let h1 := add_comm j i, h2 := (congr_arg fin h1) in x = h2.mp y</code>)</p>



<a name="226456787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456787">(Feb 15 2021 at 23:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">as_hyp</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">some_def</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">some_def</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">hs</span><span class="o">,</span>
  <span class="c1">-- before</span>
  <span class="k">show</span> <span class="o">(</span><span class="k">let</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">add_comm</span> <span class="mi">3</span> <span class="mi">2</span> <span class="k">in</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">some_def._proof_1</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span>
  <span class="c1">-- after</span>
  <span class="k">show</span> <span class="k">let</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">add_comm</span> <span class="mi">3</span> <span class="mi">2</span> <span class="k">in</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">some_def._proof_1</span> <span class="mi">2</span> <span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="mi">1</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span>
  <span class="c1">-- now intro</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- put hs back</span>
  <span class="n">intro</span> <span class="n">hs</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226456841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456841">(Feb 15 2021 at 23:52)</a>:</h4>
<p>you need a tactic that will do the equivalent of the show lines</p>



<a name="226456854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456854">(Feb 15 2021 at 23:52)</a>:</h4>
<p>It's a little unrealistic to be using <code>let</code> with proofs anyway</p>



<a name="226456860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456860">(Feb 15 2021 at 23:52)</a>:</h4>
<p>these should be <code>have</code></p>



<a name="226456943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456943">(Feb 15 2021 at 23:54)</a>:</h4>
<p>My original idea behind the <code>let</code> was that <code>as_goal</code> could start <code>assume h1 h2</code>, <code>substs h1 h2</code> to eliminate <code>eq.mp</code> from the goal, but for reasons I don't understand that doesn't work</p>



<a name="226456956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456956">(Feb 15 2021 at 23:55)</a>:</h4>
<p>And <code>exact eq_mp_rfl</code> doesn't actually work for my real case</p>



<a name="226456967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456967">(Feb 15 2021 at 23:55)</a>:</h4>
<p>This kind of looks like an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem though</p>



<a name="226456987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226456987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226456987">(Feb 15 2021 at 23:55)</a>:</h4>
<p><code>as_goal</code> can be proved by <code>rfl</code> straight off</p>



<a name="226457136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457136">(Feb 15 2021 at 23:58)</a>:</h4>
<p>The original problem is just exploring ways to express equalities between indexed types. I'm currently using something like <code>(a : A i) (b : A (i + 0)) : (⟨_, a⟩: Σ i, A i) = ⟨_, b⟩)</code>, but its ugly to work with, as both the caller and the prover need to supply the <code>zero_add</code> proof</p>



<a name="226457151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457151">(Feb 15 2021 at 23:58)</a>:</h4>
<p>Evidently my mwe was enough for the original question but too reduced for the follow-up</p>



<a name="226457168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457168">(Feb 15 2021 at 23:59)</a>:</h4>
<p>But a let-bindings introducing tactic would still be sane for data, right?</p>



<a name="226457201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457201">(Feb 15 2021 at 23:59)</a>:</h4>
<p>well like I said there is a missing operation here, a let hoisting operation that can be performed by <code>change</code> if it is constructed appropriately</p>



<a name="226457276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457276">(Feb 16 2021 at 00:00)</a>:</h4>
<p>the only thing lean knows to do with lets is unfold them or put them in the context with <code>intro</code> when the goal happens to be a let (because this is a no-op internally)</p>



<a name="226457313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457313">(Feb 16 2021 at 00:01)</a>:</h4>
<p>it is a bit reminiscent of <code>generalize_proofs</code>, which does the same hoisting operation but for proofs instead of lets</p>



<a name="226457435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457435">(Feb 16 2021 at 00:03)</a>:</h4>
<p><code>generalize_proofs</code> gives me the proof that <code>fin (i + j) = fin (j + i)</code>, but not the proof that <code>i + j = j + i</code> - and for a general indexed type, the former does not imply the latter.</p>



<a name="226457563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457563">(Feb 16 2021 at 00:04)</a>:</h4>
<p>True, but once the hypothesis is named it's easier to replace it by defeq with <code>congr_arg fin h'</code></p>



<a name="226457616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457616">(Feb 16 2021 at 00:06)</a>:</h4>
<p>In this particular case you should probably be using the <code>eq.mp</code> lemma specific to <code>fin</code></p>



<a name="226457674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457674">(Feb 16 2021 at 00:06)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast">docs#fin.cast</a></p>



<a name="226457676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457676">(Feb 16 2021 at 00:06)</a>:</h4>
<p><code>fin</code> was solely for the case of this mwe</p>



<a name="226457686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457686">(Feb 16 2021 at 00:06)</a>:</h4>
<p>then you should be using the <code>eq.mp</code> lemma specific to that type</p>



<a name="226457703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457703">(Feb 16 2021 at 00:07)</a>:</h4>
<p>It doesn't have a specific <code>eq.mp</code> lemma because the type is <code>A : ι → Type*</code> and <code>A i</code></p>



<a name="226457778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457778">(Feb 16 2021 at 00:08)</a>:</h4>
<p>I think <code>eq.rec A (h : i = j)</code> will work in that case</p>



<a name="226457789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457789">(Feb 16 2021 at 00:08)</a>:</h4>
<p>Yes, it does - I had in my head that <code>mp</code> was "simpler" and therefore might be easier to prove things about</p>



<a name="226457802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457802">(Feb 16 2021 at 00:09)</a>:</h4>
<p>No, it uses type equalities which are to be avoided</p>



<a name="226457815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457815">(Feb 16 2021 at 00:09)</a>:</h4>
<p>eq.rec makes the motive explicit and puts the equality in the type you actually want</p>



<a name="226457817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457817">(Feb 16 2021 at 00:09)</a>:</h4>
<p>Ultimately my thought was that if I had a goal of the form <code>h.rec a = b</code>, then I could use <code>subst h</code> in tactic mode to reduce it to <code>a = b</code></p>



<a name="226457824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457824">(Feb 16 2021 at 00:09)</a>:</h4>
<p>you should</p>



<a name="226457887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457887">(Feb 16 2021 at 00:10)</a>:</h4>
<p>that doesn't work if <code>h</code> is a composite term though</p>



<a name="226457895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457895">(Feb 16 2021 at 00:10)</a>:</h4>
<p>in particular one side has to be a variable</p>



<a name="226457906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457906">(Feb 16 2021 at 00:11)</a>:</h4>
<p>Right, therein lies the problem, <code>0 + i = i</code> is apparently not a legal form for <code>h</code> in my case</p>



<a name="226457913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457913">(Feb 16 2021 at 00:11)</a>:</h4>
<p>you have to generalize everything about <code>0 + i</code> to <code>j</code> first</p>



<a name="226457921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457921">(Feb 16 2021 at 00:11)</a>:</h4>
<p>once you can make your theorem typecheck with <code>j</code> in place of <code>0+i</code> you are done</p>



<a name="226457990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226457990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226457990">(Feb 16 2021 at 00:12)</a>:</h4>
<p>I can't say more specifically without an MWE that has these features</p>



<a name="226458123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226458123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226458123">(Feb 16 2021 at 00:15)</a>:</h4>
<p>I don't have a super minimal example, but the head commit of <a href="https://github.com/leanprover-community/mathlib/tree/direct_sum_graded-mwe">branch#direct_sum_graded-mwe</a> shows the tiny change that I was exploring (the previous commit has everything working, but is ugly)</p>



<a name="226458222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226458222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226458222">(Feb 16 2021 at 00:16)</a>:</h4>
<p>(the branch only adds a single new file, so you should be able to just copy that file locally to try it out, if it's not too big to make that undesirable)</p>



<a name="226460125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226460125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226460125">(Feb 16 2021 at 00:52)</a>:</h4>
<p>Not a complete fix, but this cleans up the statements using the sigma type approach a lot</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm">! ### Typeclasses -/</span>
<span class="kn">section</span> <span class="n">defs</span>

<span class="sd">/-- A graded version of `has_one`, which must be of grade 0. -/</span>
<span class="kd">class</span> <span class="n">ghas_one</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">ι</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">A</span> <span class="mi">0</span><span class="o">)</span>

<span class="sd">/-- A graded version of `has_one` that also subsumes `distrib` and `mul_zero_class` by requiring</span>
<span class="sd">the multiplication be an `add_monoid_hom`. Multiplication combines grades additively, like</span>
<span class="sd">`add_monoid_algebra`. -/</span>
<span class="kd">class</span> <span class="n">ghas_mul</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="n">i</span> <span class="bp">→+</span> <span class="n">A</span> <span class="n">j</span> <span class="bp">→+</span> <span class="n">A</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">j</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">g_one</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">ghas_one</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">ghas_one.one</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">g_mul</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)]</span> <span class="o">[</span><span class="n">ghas_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">),</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">x</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">y</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">i</span> <span class="bp">+</span> <span class="n">j</span><span class="o">,</span> <span class="n">ghas_mul.mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">defs</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`ᵍ</span><span class="mi">1</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">g_one</span> <span class="n">_</span>
<span class="kn">local</span> <span class="kd">infix</span> <span class="bp">`</span> <span class="bp">ᵍ*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">g_mul</span> <span class="n">_</span>
<span class="kn">local</span> <span class="kd">prefix</span> <span class="bp">`ᵍ↑`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sigma.mk</span> <span class="n">_</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">→</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">defs</span>

<span class="sd">/-- A graded version of `monoid`. -/</span>
<span class="kd">class</span> <span class="n">gmonoid</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)]</span> <span class="kd">extends</span> <span class="n">ghas_mul</span> <span class="n">A</span><span class="o">,</span> <span class="n">ghas_one</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one_mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ᵍ</span><span class="mi">1</span> <span class="bp">ᵍ*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">ᵍ*</span> <span class="bp">ᵍ</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">ᵍ*</span> <span class="n">b</span> <span class="bp">ᵍ*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">ᵍ*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">ᵍ*</span> <span class="n">c</span><span class="o">))</span>

<span class="sd">/-- A graded version of `comm_monoid`. -/</span>
<span class="kd">class</span> <span class="n">gcomm_monoid</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">A</span> <span class="n">i</span><span class="o">)]</span> <span class="kd">extends</span> <span class="n">gmonoid</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">ᵍ*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">ᵍ*</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">defs</span>
</code></pre></div>



<a name="226460136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226460136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226460136">(Feb 16 2021 at 00:53)</a>:</h4>
<p>I think the axioms are basically just the monoid axioms this way</p>



<a name="226460595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226460595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226460595">(Feb 16 2021 at 01:02)</a>:</h4>
<p>Thanks, I'll see how the proofs further down the file deal with those changes tomorrow</p>



<a name="226460860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226460860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226460860">(Feb 16 2021 at 01:08)</a>:</h4>
<p>This proof isn't perfect but it works</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Build a `gmonoid` instance for a collection of `add_submonoids`. -/</span>
<span class="kd">def</span> <span class="n">gmonoid.of_submonoids</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">(</span><span class="n">carriers</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">add_submonoid</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one_mem</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">carriers</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mul_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">i</span> <span class="n">j</span><span class="o">⦄</span> <span class="o">(</span><span class="n">gi</span> <span class="o">:</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">gj</span> <span class="o">:</span> <span class="n">carriers</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">gi</span> <span class="bp">*</span> <span class="n">gj</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">carriers</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">gmonoid</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="kd">begin</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">j</span> <span class="n">h'</span><span class="o">,</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">→</span> <span class="o">(⟨</span><span class="n">j</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">zero_add</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="kd">begin</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">j</span> <span class="n">h'</span><span class="o">,</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">→</span> <span class="o">(⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">add_zero</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩,</span> <span class="kd">begin</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">h</span> <span class="n">h'</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">i</span><span class="bp">+</span><span class="o">(</span><span class="n">j</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">i</span><span class="bp">+</span><span class="o">(</span><span class="n">j</span><span class="bp">+</span><span class="n">k</span><span class="o">),</span> <span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">),</span> <span class="n">h'</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">add_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">ghas_one.of_submonoids</span> <span class="n">carriers</span> <span class="n">one_mem</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">ghas_mul.of_submonoids</span> <span class="n">carriers</span> <span class="n">mul_mem</span> <span class="o">}</span>

<span class="sd">/-- Build a `gcomm_monoid` instance for a collection of `add_submonoid`s. -/</span>
<span class="kd">def</span> <span class="n">gcomm_monoid.of_submonoids</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">(</span><span class="n">carriers</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">add_submonoid</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">one_mem</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">carriers</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mul_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">i</span> <span class="n">j</span><span class="o">⦄</span> <span class="o">(</span><span class="n">gi</span> <span class="o">:</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">gj</span> <span class="o">:</span> <span class="n">carriers</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">gi</span> <span class="bp">*</span> <span class="n">gj</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">carriers</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">gcomm_monoid</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span> <span class="kd">begin</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">h</span> <span class="n">h'</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">j</span><span class="bp">+</span><span class="n">i</span> <span class="bp">→</span> <span class="o">(⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">carriers</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">j</span><span class="bp">+</span><span class="n">i</span><span class="o">,</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">add_comm</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">gmonoid.of_submonoids</span> <span class="n">carriers</span> <span class="n">one_mem</span> <span class="n">mul_mem</span><span class="o">}</span>
</code></pre></div>



<a name="226461468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226461468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226461468">(Feb 16 2021 at 01:21)</a>:</h4>
<p>The suffices step is probably not one I would have thought of, but I can see how it solves the problem nicely</p>



<a name="226461999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226461999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226461999">(Feb 16 2021 at 01:31)</a>:</h4>
<p>It's implementing what you said here<br>
<span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226457817">said</a>:</p>
<blockquote>
<p>Ultimately my thought was that if I had a goal of the form <code>h.rec a = b</code>, then I could use <code>subst h</code> in tactic mode to reduce it to <code>a = b</code></p>
</blockquote>



<a name="226462006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226462006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226462006">(Feb 16 2021 at 01:31)</a>:</h4>
<p>except without getting to the point of having a <code>rec</code> in the goal</p>



<a name="226462094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226462094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226462094">(Feb 16 2021 at 01:32)</a>:</h4>
<p>It would be maybe better in this case to have a (simp) lemma that reduces equalities on <code>\Sigma i, {x // p i x}</code>  to equalities of the first two components</p>



<a name="226462140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226462140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226462140">(Feb 16 2021 at 01:33)</a>:</h4>
<p>and then simp lemmas saying how the <code>.1</code> and <code>.2.1</code> components of your definitions unfold</p>



<a name="226462144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226462144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226462144">(Feb 16 2021 at 01:33)</a>:</h4>
<p>that way you never have to see a dependent type</p>



<a name="226495124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226495124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226495124">(Feb 16 2021 at 10:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226462094">said</a>:</p>
<blockquote>
<p>It would be maybe better in this case to have a (simp) lemma that reduces equalities on <code>\Sigma i, {x // p i x}</code>  to equalities of the first two components</p>
</blockquote>
<p>How about an <code>ext</code> lemma?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sigma.subtype_ext</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)},</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">b.fst</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a.snd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b.snd</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">ai</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">bi</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="n">ai</span> <span class="bp">=</span> <span class="n">bi</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₂</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226495300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226495300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226495300">(Feb 16 2021 at 10:18)</a>:</h4>
<p>Does that lemma not yet exist? <span aria-label="shock" class="emoji emoji-1f628" role="img" title="shock">:shock:</span></p>



<a name="226495439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226495439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226495439">(Feb 16 2021 at 10:20)</a>:</h4>
<p>It probably follows from <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.heq_iff_coe_eq">docs#subtype.heq_iff_coe_eq</a> somehow, which was my previous attempt at solving this problem</p>



<a name="226495830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226495830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226495830">(Feb 16 2021 at 10:24)</a>:</h4>
<p>Yeah, here's the <code>heq_iff_coe_eq</code> proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">sigma.subtype_ext'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">b.fst</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">a.snd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b.snd</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">heq_iff_coe_eq</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₁.symm</span> <span class="bp">▸</span> <span class="n">iff.rfl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>But I think the other one is nicer</p>



<a name="226497383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226497383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226497383">(Feb 16 2021 at 10:39)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6257">#6257</a> for <code>sigma.subtype_ext</code> and three variants.</p>



<a name="226557388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226557388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226557388">(Feb 16 2021 at 18:45)</a>:</h4>
<p>I don't think this can be a <code>@[ext]</code> lemma, it doesn't have a single key</p>



<a name="226557603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226557603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226557603">(Feb 16 2021 at 18:47)</a>:</h4>
<p>the proof is also simpler than that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sigma.subtype_ext</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span>
  <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">(</span><span class="n">p</span> <span class="n">i</span><span class="o">)},</span> <span class="n">a.fst</span> <span class="bp">=</span> <span class="n">b.fst</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a.snd</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b.snd</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">ai</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">bi</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="226557930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226557930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226557930">(Feb 16 2021 at 18:49)</a>:</h4>
<p>What do you mean by a single key?</p>



<a name="226558020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226558020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226558020">(Feb 16 2021 at 18:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226557388">said</a>:</p>
<blockquote>
<p>I don't think this can be a <code>@[ext]</code> lemma, it doesn't have a single key</p>
</blockquote>
<p>What does this mean? It's a criterion for deciding when two terms of a type are equal. Isn't that exactly an <code>ext</code> lemma?</p>



<a name="226558049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226558049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226558049">(Feb 16 2021 at 18:50)</a>:</h4>
<p>snap</p>



<a name="226558286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226558286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226558286">(Feb 16 2021 at 18:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, I tried to iterate towards that short proof, but the equation compiler would give an error while I still had a sorry</p>



<a name="226560269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560269">(Feb 16 2021 at 19:07)</a>:</h4>
<p>An <code>ext</code> lemma needs to actually be found when you use <code>ext</code>, it's not just an arbitrary collection of lemmas, it's a lookup table</p>



<a name="226560319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560319">(Feb 16 2021 at 19:08)</a>:</h4>
<p>the key of that lookup table is the constant name of the type, and the constant here is <code>Sigma</code> which already has an ext lemma</p>



<a name="226560477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560477">(Feb 16 2021 at 19:09)</a>:</h4>
<p>Why does the PR not break anything then?</p>



<a name="226560553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560553">(Feb 16 2021 at 19:09)</a>:</h4>
<p>When you put multiple ext lemmas it will just try a random one, maybe you got lucky</p>



<a name="226560567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560567">(Feb 16 2021 at 19:09)</a>:</h4>
<p>And then why are lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.prod_ext">docs#linear_map.prod_ext</a> fine, as they overlay another ext lemma on <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.ext">docs#linear_map.ext</a></p>



<a name="226560598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560598">(Feb 16 2021 at 19:09)</a>:</h4>
<p>there isn't any priority system so I expect this will not work robustly</p>



<a name="226560600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560600">(Feb 16 2021 at 19:09)</a>:</h4>
<p>Doesn't it try all of them until it finds one that applies?</p>



<a name="226560688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560688">(Feb 16 2021 at 19:10)</a>:</h4>
<p>yes, if it fails</p>



<a name="226560730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560730">(Feb 16 2021 at 19:10)</a>:</h4>
<p>but <code>Sigma.ext</code> would succeed on goals that your new ext lemma work on</p>



<a name="226560747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560747">(Feb 16 2021 at 19:10)</a>:</h4>
<p>Also, I remember a PR where <span class="user-mention" data-user-id="112680">@Johan Commelin</span> put <code>@[priority]</code> on a bunch of ext lemmas, and we concluded that the default priority was declaration order (and thus removed all the <code>priority</code> attributes again)</p>



<a name="226560821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560821">(Feb 16 2021 at 19:11)</a>:</h4>
<p>in that case you can get different behavior depending on the order of imports, which is bad</p>



<a name="226560932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560932">(Feb 16 2021 at 19:12)</a>:</h4>
<p>Not if file B imports file A anyway</p>



<a name="226560950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560950">(Feb 16 2021 at 19:12)</a>:</h4>
<p>Which in all the cases that came up, it does</p>



<a name="226560963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226560963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226560963">(Feb 16 2021 at 19:12)</a>:</h4>
<p>Yes. Now do we want to rely on this or not?</p>



<a name="226561030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226561030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226561030">(Feb 16 2021 at 19:13)</a>:</h4>
<p>Any bug can be considered a feature if you look at it in the right way</p>



<a name="226561139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226561139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226561139">(Feb 16 2021 at 19:13)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/5200">#5200</a> is the PR I'm referring to</p>



<a name="226561439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/226561439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#226561439">(Feb 16 2021 at 19:15)</a>:</h4>
<p>And I think we declared it a feature when writing <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#partially-applied%20ext%20lemmas">https://leanprover-community.github.io/mathlib_docs/notes.html#partially-applied%20ext%20lemmas</a></p>



<a name="227312592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Unfolding%20let%20bindings%20in%20hypotheses/near/227312592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Unfolding.20let.20bindings.20in.20hypotheses.html#227312592">(Feb 22 2021 at 18:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226462094">said</a>:</p>
<blockquote>
<p>It would be maybe better in this case to have a (simp) lemma that reduces equalities on <code>\Sigma i, {x // p i x}</code>  to equalities of the first two components</p>
</blockquote>
<p>I've finally updated <a href="https://github.com/leanprover-community/mathlib/issues/6053">#6053</a> to use this approach, thanks for the suggestions <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, that definitely ended up cleaner</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
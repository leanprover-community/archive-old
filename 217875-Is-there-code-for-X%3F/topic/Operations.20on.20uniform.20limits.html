---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html">Operations on uniform limits</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="305701726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305701726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305701726">(Oct 23 2022 at 19:52)</a>:</h4>
<p>Do we have this somewhere where I didn't find it? <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on.mul">docs#tendsto_uniformly_on.mul</a> is for uniform groups.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span> <span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_field</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">K</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">mf</span> <span class="n">mg</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">tendsto_uniformly_on.inv_of_le</span> <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x</span><span class="bp">∥</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto_uniformly_on</span> <span class="n">F</span><span class="bp">⁻¹</span> <span class="n">f</span><span class="bp">⁻¹</span> <span class="n">p</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">tendsto_uniformly_on.mul_of_le</span>
  <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">G</span> <span class="n">g</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀ᶠ</span> <span class="n">i</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∥</span><span class="n">F</span> <span class="n">i</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="n">mf</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="bp">∀ᶠ</span> <span class="n">i</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∥</span><span class="n">G</span> <span class="n">i</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="n">mg</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto_uniformly_on</span> <span class="o">(</span><span class="n">F</span> <span class="bp">*</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="n">p</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">tendsto_uniformly_on.mul_of_bound</span>
  <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">G</span> <span class="n">g</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="n">mf</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∥</span><span class="n">g</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="n">mg</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto_uniformly_on</span> <span class="o">(</span><span class="n">F</span> <span class="bp">*</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="n">p</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I have proofs but they are too ugly to be displayed in public <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="305706457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305706457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305706457">(Oct 23 2022 at 20:38)</a>:</h4>
<p>I'm not surprised this isn't there yet.  I'm not even sure we have the statement that inversion in a topological field is uniformly continuous on a set whose closure doesn't contain zero.</p>



<a name="305707204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305707204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305707204">(Oct 23 2022 at 20:46)</a>:</h4>
<p>Probably you would even need something like: if <code>p</code> and <code>q</code> are filters on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝕜</mi></mrow><annotation encoding="application/x-tex">𝕜</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">k</span></span></span></span> such that <code>p  ⊓ 𝓝 0 = ⊥</code> and <code>q  ⊓ 𝓝 0 = ⊥</code> then <code>map (λ x : 𝕜 × 𝕜, (x.1⁻¹, x.2 ⁻¹)) (𝓤 𝕜 ⊓ (p ×ᶠ q)) ≤ 𝓤 𝕜</code>.</p>



<a name="305707324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305707324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305707324">(Oct 23 2022 at 20:48)</a>:</h4>
<p>Note this is totally untested and I didn't think very hard. It simply looks good and the kind of thing that would help in writing a nice proof of your first lemma.</p>



<a name="305707586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305707586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305707586">(Oct 23 2022 at 20:51)</a>:</h4>
<p>This inequality would be meant to be used with the one appearing in <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on_iff_tendsto">docs#tendsto_uniformly_on_iff_tendsto</a></p>



<a name="305707634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305707634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305707634">(Oct 23 2022 at 20:51)</a>:</h4>
<p><code>p  ⊓ 𝓝 0 = ⊥</code> as in "eventually bounded below" ?</p>



<a name="305707974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305707974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305707974">(Oct 23 2022 at 20:55)</a>:</h4>
<p>I was thinking of <code>p</code> and <code>q</code> as <code>𝓟 (f '' s)</code> and <code>𝓝ˢ (f '' s)</code> (or the other way around)</p>



<a name="305820706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305820706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305820706">(Oct 24 2022 at 13:36)</a>:</h4>
<p>Here is what I have for step 1:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span> <span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_field</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">K</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="n">mf</span> <span class="n">mg</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span>
  <span class="o">{</span><span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">{</span><span class="n">η</span> <span class="n">η'</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">toto</span> <span class="o">(</span><span class="n">hη</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">η</span><span class="o">)</span> <span class="o">(</span><span class="n">hη'</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">η'</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">ball</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="bp">𝕜</span><span class="o">)</span> <span class="n">η</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∉</span> <span class="n">ball</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="bp">𝕜</span><span class="o">)</span> <span class="n">η'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dist</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="n">y</span><span class="bp">⁻¹</span> <span class="bp">≤</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">/</span> <span class="o">(</span><span class="n">η</span> <span class="bp">*</span> <span class="n">η'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">hη</span><span class="o">]</span> <span class="n">using</span> <span class="n">hx</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">hη'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">dist_eq_norm</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">dist_eq_norm</span><span class="o">,</span> <span class="n">inv_sub_inv</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">norm_div</span><span class="o">,</span> <span class="n">norm_mul</span><span class="o">,</span> <span class="n">dist_comm</span><span class="o">,</span> <span class="n">dist_eq_norm</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">div_le_div</span> <span class="o">(</span><span class="n">norm_nonneg</span> <span class="n">_</span><span class="o">)</span> <span class="n">le_rfl</span> <span class="o">(</span><span class="n">mul_pos</span> <span class="n">hη</span> <span class="n">hη'</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_le_mul</span> <span class="n">hx</span> <span class="n">hy</span> <span class="n">hη'.le</span> <span class="o">(</span><span class="n">norm_nonneg</span> <span class="n">_</span><span class="o">))</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">titi</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">filter</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">𝕜</span> <span class="bp">×</span> <span class="bp">𝕜</span><span class="o">,</span> <span class="o">(</span><span class="n">x.1</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">x.2</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="o">(</span><span class="bp">𝓤</span> <span class="bp">𝕜</span> <span class="bp">⊓</span> <span class="o">(</span><span class="n">p</span> <span class="bp">×ᶠ</span> <span class="n">q</span><span class="o">))</span> <span class="bp">≤</span> <span class="bp">𝓤</span> <span class="bp">𝕜</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">hV</span><span class="o">,</span> <span class="n">hUV</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">inf_eq_bot_iff.mp</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">U'</span><span class="o">,</span> <span class="n">hU'</span><span class="o">,</span> <span class="n">V'</span><span class="o">,</span> <span class="n">hV'</span><span class="o">,</span> <span class="n">hUV'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">inf_eq_bot_iff.mp</span> <span class="n">hq</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">η</span><span class="o">,</span> <span class="n">hη</span><span class="o">,</span> <span class="n">hV</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">metric.mem_nhds_iff.mp</span> <span class="n">hV</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">η'</span><span class="o">,</span> <span class="n">hη'</span><span class="o">,</span> <span class="n">hV'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">metric.mem_nhds_iff.mp</span> <span class="n">hV'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hηη'</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">η</span> <span class="bp">*</span> <span class="n">η'</span> <span class="o">:=</span> <span class="n">mul_pos</span> <span class="n">hη</span> <span class="n">hη'</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">u</span> <span class="n">hu</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ε</span><span class="o">,</span> <span class="n">hε</span><span class="o">,</span> <span class="n">hu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_uniformity_dist.mp</span> <span class="n">hu</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_map_iff_exists_image</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">inter_mem_inf</span> <span class="o">(</span><span class="n">dist_mem_uniformity</span> <span class="o">(</span><span class="n">mul_pos</span> <span class="n">hε</span> <span class="n">hηη'</span><span class="o">))</span> <span class="o">(</span><span class="n">prod_mem_prod</span> <span class="n">hU</span> <span class="n">hU'</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rintro</span> <span class="n">z</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">hx'1</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">∉</span> <span class="n">ball</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="n">η</span><span class="o">,</span>
  <span class="k">from</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">nonempty_of_mem</span> <span class="o">(</span><span class="n">mem_inter</span> <span class="n">hx2.1</span> <span class="o">(</span><span class="n">hV</span> <span class="n">h</span><span class="o">)))</span><span class="bp">.</span><span class="n">ne_empty</span> <span class="n">hUV</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx'2</span> <span class="o">:</span> <span class="n">x.2</span> <span class="bp">∉</span> <span class="n">ball</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="n">η'</span><span class="o">,</span>
  <span class="k">from</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">nonempty_of_mem</span> <span class="o">(</span><span class="n">mem_inter</span> <span class="n">hx2.2</span> <span class="o">(</span><span class="n">hV'</span> <span class="n">h</span><span class="o">)))</span><span class="bp">.</span><span class="n">ne_empty</span> <span class="n">hUV'</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">hu</span> <span class="o">((</span><span class="n">toto</span> <span class="n">hη</span> <span class="n">hη'</span> <span class="n">hx'1</span> <span class="n">hx'2</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_lt</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">div_lt_div_right</span> <span class="n">hηη'</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hx1</span><span class="o">,</span>
  <span class="n">field_simp</span> <span class="o">[</span><span class="n">hη.lt.ne.symm</span><span class="o">,</span> <span class="n">hη'.lt.ne.symm</span><span class="o">]</span><span class="bp">;</span> <span class="n">ring</span>
<span class="kd">end</span>
</code></pre></div>



<a name="305825227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305825227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305825227">(Oct 24 2022 at 13:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">hη</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">η</span><span class="o">)</span> <span class="o">:</span> <span class="n">uniform_continuous_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">(</span><span class="n">ball</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="n">η</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">uniform_continuous_on</span><span class="o">,</span> <span class="n">tendsto</span><span class="o">,</span> <span class="bp">←</span> <span class="n">prod_principal_principal</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">titi</span> <span class="o">(</span><span class="n">inf_eq_bot_iff.mpr</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">inf_eq_bot_iff.mpr</span> <span class="n">_</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">exact</span> <span class="o">⟨(</span><span class="n">ball</span> <span class="mi">0</span> <span class="n">η</span><span class="o">)</span><span class="bp">ᶜ</span><span class="o">,</span> <span class="n">mem_principal_self</span> <span class="n">_</span><span class="o">,</span> <span class="n">ball</span> <span class="mi">0</span> <span class="n">η</span><span class="o">,</span> <span class="n">ball_mem_nhds</span> <span class="n">_</span> <span class="n">hη</span><span class="o">,</span> <span class="n">compl_inter_self</span> <span class="n">_</span><span class="o">⟩</span>
<span class="kd">end</span>
</code></pre></div>



<a name="305825892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305825892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305825892">(Oct 24 2022 at 13:59)</a>:</h4>
<p>I mean,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">𝓟</span> <span class="n">s</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="n">uniform_continuous_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">uniform_continuous_on</span><span class="o">,</span> <span class="n">tendsto</span><span class="o">,</span> <span class="bp">←</span> <span class="n">prod_principal_principal</span><span class="o">]</span> <span class="n">using</span> <span class="n">titi</span> <span class="n">hs</span> <span class="n">hs</span>
</code></pre></div>



<a name="305866186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305866186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305866186">(Oct 24 2022 at 17:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I seem to be stuck at this point writing the proof that at the moment feels natural:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">𝓟</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto_uniformly_on</span> <span class="n">F</span><span class="bp">⁻¹</span> <span class="n">f</span><span class="bp">⁻¹</span> <span class="n">p</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">tendsto_uniformly_on_iff_tendsto</span><span class="o">,</span> <span class="n">tendsto</span><span class="o">]</span> <span class="n">at</span> <span class="n">hF</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">q.snd</span><span class="o">,</span> <span class="n">F</span> <span class="n">q.fst</span> <span class="n">q.snd</span><span class="o">))</span> <span class="o">(</span><span class="n">p</span> <span class="bp">×ᶠ</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">𝓟</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">×ᶠ</span> <span class="bp">𝓝ˢ</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">),</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="n">le_inf</span> <span class="n">hF</span> <span class="n">h1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">filter.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">𝕜</span> <span class="bp">×</span> <span class="bp">𝕜</span><span class="o">),</span> <span class="o">((</span><span class="n">x.fst</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="o">(</span><span class="n">x.snd</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">)))</span> <span class="o">:=</span> <span class="n">filter.map_mono</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">𝓝ˢ</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- but this should work</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h3</span> <span class="n">h2</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">titi</span> <span class="n">hf</span> <span class="n">h4</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>
<p>(with <code>titi</code> as above). <code>h1</code> fits very well with the rest, but I'm not sure it is true; I also have trouble proving the simpler <code>map (λ (q : ι × α), F q.1 q.2) (p ×ᶠ 𝓟 s) ≤ 𝓝ˢ (f '' s)</code>. I somehow convinced myself that it is not true and one should replace <code>𝓝ˢ (f '' s)</code> with a uniform version to be able to exploit hypothesis <code>hF</code> so that the same element of <code>p</code> works everywhere. Is that completely off?</p>



<a name="305890789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305890789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305890789">(Oct 24 2022 at 18:38)</a>:</h4>
<p>Indeed that suggestion was probably a bit too optimistic. There is clearly a notion of uniform neighborhood of a set in a uniform space, but I'm not sure how to phrase it nicely, and we clearly don't have it in mathlib.</p>



<a name="305892480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305892480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305892480">(Oct 24 2022 at 18:48)</a>:</h4>
<p><a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Uniform.20separation.20of.20compact.20and.20closed.20set/near/301848882">This topic</a> is about uniform neighborhoods right?</p>



<a name="305892822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305892822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305892822">(Oct 24 2022 at 18:51)</a>:</h4>
<p>So <code>⋃ x ∈ A, ball x V</code> for <code>V ∈ 𝓤 α</code> is the uniform neighborhood I was looking for</p>



<a name="305893419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305893419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305893419">(Oct 24 2022 at 18:55)</a>:</h4>
<p>It is a basis for the filter you were asking for</p>



<a name="305898840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305898840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305898840">(Oct 24 2022 at 19:25)</a>:</h4>
<p>Like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">uniform_thickening</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⋃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">uniform_space.ball</span> <span class="n">x</span> <span class="n">u</span>

<span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">filter.generate</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">uniform_thickening</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">})</span> <span class="bp">''</span> <span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span><span class="o">)</span>
</code></pre></div>



<a name="305899159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305899159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305899159">(Oct 24 2022 at 19:28)</a>:</h4>
<p>Yes, but the goal is to make it <del>less readable</del> more easy to apply the API to by defining it in terms of all the filter operations we have (e.g the usual infimum, supremum, pushforward and pullback, but also <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.lift">docs#filter.lift</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.lift'">docs#filter.lift'</a>)</p>



<a name="305899752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305899752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305899752">(Oct 24 2022 at 19:31)</a>:</h4>
<p>(I'm not sure that's possible, I didn't find anything like this for the uniformity generating the topology of uniform convergence, so it's completely possible we don't have a nice way to do it, but I'm mentioning it because it's worth thinking about)</p>



<a name="305901238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305901238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305901238">(Oct 24 2022 at 19:41)</a>:</h4>
<p>Yes, there should be a nice description but I don't immediately see it (and I'm really late with many things so I should really really resist the temptation to spend the evening thinking about this).</p>



<a name="305902456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305902456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305902456">(Oct 24 2022 at 19:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⨅</span> <span class="n">u</span> <span class="bp">∈</span> <span class="bp">𝓤</span> <span class="n">α</span><span class="o">,</span> <span class="bp">𝓟</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">uniform_thickening</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">}</span>
</code></pre></div>



<a name="305904046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305904046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305904046">(Oct 24 2022 at 19:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">uniform_thickening</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">})</span>
</code></pre></div>



<a name="305904096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305904096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305904096">(Oct 24 2022 at 19:59)</a>:</h4>
<p>Not sure which one is "more easy to apply the API to"</p>



<a name="305910518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305910518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305910518">(Oct 24 2022 at 20:41)</a>:</h4>
<p>Ah, actually this makes more sense probably:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift'</span> <span class="o">(</span><span class="n">uniform_thickening</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>



<a name="305911417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305911417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305911417">(Oct 24 2022 at 20:48)</a>:</h4>
<p>Oh indeed I didn't realize your first suggestion didn't have the good type (as in, not the same as <a href="https://leanprover-community.github.io/mathlib_docs/find/nhds_set">docs#nhds_set</a>)</p>



<a name="305976370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305976370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305976370">(Oct 25 2022 at 08:07)</a>:</h4>
<p>The definition above is quite workable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">uniform_thickening</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⋃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">uniform_space.ball</span> <span class="n">x</span> <span class="n">u</span>

<span class="kd">lemma</span> <span class="n">monotone_uniform_thickening</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">uniform_thickening</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span> <span class="n">huv</span><span class="o">,</span> <span class="n">Union₂_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">uniform_space.ball</span><span class="o">]</span> <span class="n">using</span> <span class="n">preimage_mono</span> <span class="n">huv</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift'</span> <span class="o">(</span><span class="n">uniform_thickening</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">lemma1</span> <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">𝓟</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">q.2</span><span class="o">,</span> <span class="n">F</span> <span class="n">q.1</span> <span class="n">q.2</span><span class="o">))</span> <span class="o">(</span><span class="n">p</span> <span class="bp">×ᶠ</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">𝓟</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">×ᶠ</span> <span class="n">uniform_nhds_set</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">u</span> <span class="n">hu</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">t1</span><span class="o">,</span> <span class="n">ht1</span><span class="o">,</span> <span class="n">t2</span><span class="o">,</span> <span class="n">ht2</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">filter.mem_prod_iff.mp</span> <span class="n">hu</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">uniform_nhds_set</span><span class="o">,</span> <span class="n">mem_lift'_sets</span> <span class="n">monotone_uniform_thickening</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">]</span> <span class="n">at</span> <span class="n">ht2</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv1</span><span class="o">,</span> <span class="n">hv2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ht2</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_map_iff_exists_image</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span> <span class="bp">×ˢ</span> <span class="n">s</span><span class="o">,</span> <span class="n">prod_mem_prod</span> <span class="o">(</span><span class="n">hF</span> <span class="n">v</span> <span class="n">hv1</span><span class="o">)</span> <span class="o">(</span><span class="n">mem_principal_self</span> <span class="n">s</span><span class="o">),</span> <span class="n">subset.trans</span> <span class="n">_</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">⟩</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span> <span class="n">h3</span><span class="o">⟩,</span>
  <span class="n">replace</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">v</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h1</span> <span class="n">a</span> <span class="n">h2</span><span class="o">]⟩,</span>
  <span class="n">rcases</span> <span class="n">prod.mk.inj_iff.mp</span> <span class="n">h3</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mem_principal.mp</span> <span class="n">ht1</span> <span class="o">(</span><span class="n">mem_image_of_mem</span> <span class="n">f</span> <span class="n">h2</span><span class="o">),</span> <span class="n">prod_mk_mem_set_prod_eq</span><span class="o">,</span> <span class="n">true_and</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">hv2</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">uniform_space.ball</span><span class="o">,</span> <span class="n">uniform_thickening</span><span class="o">]</span> <span class="n">using</span> <span class="n">h1</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">lemma2</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">𝓟</span> <span class="n">t</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">uniform_nhds_set</span> <span class="n">t</span><span class="o">)</span> <span class="bp">⊓</span> <span class="bp">𝓝</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>(the proof of <code>lemma1</code> is a bit clumsy but it works well enough for now). <span class="user-mention" data-user-id="268315">@Anatole Dedecker</span> what is your feeling about the separation lemma <code>lemma2</code> here? I can prove it in a metric space but the whole point is to work in a uniform space, where some additional assumption could be needed.</p>



<a name="305978072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305978072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305978072">(Oct 25 2022 at 08:18)</a>:</h4>
<p>I think this is true. You can certainly prove it as a direct consequence of <a href="https://leanprover-community.github.io/mathlib_docs/find/disjoint.exists_uniform_thickening">docs#disjoint.exists_uniform_thickening</a> applied to the compact <code>{0}</code> and to the closed set <code>closure t</code> (which 0 does not belong to by the hypothesis)</p>



<a name="305979525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305979525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305979525">(Oct 25 2022 at 08:28)</a>:</h4>
<p>That said a direct proof would work well too and maybe it is more “morally satisfying”: you take a <code>U</code> ball around 0 that does not meet <code>t</code>, split it in half using <a href="https://leanprover-community.github.io/mathlib_docs/find/comp_mem_uniformity_sets">docs#comp_mem_uniformity_sets</a>, and with the <code>V</code> you get, you have that the <code>V</code> ball around 0 does not meet the <code>V</code> uniform thickening of <code>t</code></p>



<a name="305980263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305980263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305980263">(Oct 25 2022 at 08:32)</a>:</h4>
<p>There’s also a more practical reason why this second proof is better, which is that we definitely want to rewrite some things using this <code>uniform_nhds_set</code> filter, like we have rewritten a lot of things using <code>nhds_set</code> (e.g in separation axioms). I need to look more at the current library to get a better feel of how it would fit the best, but at least it suggests that using “high level” results about uniform space is not a good choice</p>



<a name="305980988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305980988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305980988">(Oct 25 2022 at 08:36)</a>:</h4>
<p>Ah, this is what I did in a metric space but <code>comp_mem_uniformity_sets</code> is what I did not find (the name is difficult to guess ...) so thanks! I will try to use it and see what happens.</p>



<a name="305981227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305981227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305981227">(Oct 25 2022 at 08:38)</a>:</h4>
<p>For example, I’d argue <a href="https://leanprover-community.github.io/mathlib_docs/find/uniform_space.regular_space">docs#uniform_space.regular_space</a> should be proven using your lemma2 (or a variation of it), first because it feels more “mathlib”-y than the current proof, and because anyone looking at the proof would easily find your uniform version of regularity, which is arguably more useful and intuitive than closed entourages being a basis of uniformity</p>



<a name="305981325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305981325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305981325">(Oct 25 2022 at 08:38)</a>:</h4>
<p><code>𝓝ᵘ s</code> as a notation?</p>



<a name="305981346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305981346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305981346">(Oct 25 2022 at 08:38)</a>:</h4>
<p>Ah yes, this is the key fact that makes uniform spaces nice: you have an “epsilon/2” principle</p>



<a name="305981501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305981501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305981501">(Oct 25 2022 at 08:40)</a>:</h4>
<p>I'm sure the proof of <code>lemma1</code> can be made nicer, but I really don't have time so I'll let Anatole handle it. He will probably start with removing the <code>hf</code> argument that looks like a copy-paste mistake</p>



<a name="305983191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/305983191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#305983191">(Oct 25 2022 at 08:50)</a>:</h4>
<p>I will work further on that proof</p>



<a name="306001266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306001266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306001266">(Oct 25 2022 at 10:48)</a>:</h4>
<p>Sorry, I couldn't resist working on it anyway <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> There are probably a dozen more way to do it, so feel free to work on it too, we will almost surely learn something by comparing the versions.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lemma0</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">snd</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span> <span class="bp">⊓</span> <span class="n">comap</span> <span class="n">fst</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="n">s</span><span class="o">))</span> <span class="o">(</span><span class="n">uniform_nhds_set</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">comap_principal</span><span class="o">,</span> <span class="n">uniform_nhds_set</span><span class="o">,</span> <span class="n">tendsto_lift'</span><span class="o">,</span> <span class="n">eventually_inf_principal</span><span class="o">],</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span> <span class="n">mem_of_superset</span> <span class="n">hU</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">⟩</span> <span class="n">hxy</span> <span class="n">hx</span><span class="o">,</span> <span class="n">mem_bUnion</span> <span class="n">hx</span> <span class="n">hxy</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">lemma1</span> <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">q.2</span><span class="o">,</span> <span class="n">F</span> <span class="n">q.1</span> <span class="n">q.2</span><span class="o">))</span> <span class="o">(</span><span class="n">p</span> <span class="bp">×ᶠ</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">𝓟</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">×ᶠ</span> <span class="n">uniform_nhds_set</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">tendsto_uniformly_on_iff_tendsto</span><span class="o">]</span> <span class="n">at</span> <span class="n">hF</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">tendsto</span><span class="o">,</span> <span class="n">tendsto_prod_iff'</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">snd</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="bp">×ᶠ</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">tendsto_principal_principal.mpr</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">mem_image_of_mem</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">tendsto_snd</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">this</span><span class="o">,</span> <span class="n">tendsto.comp</span> <span class="n">lemma0</span> <span class="o">(</span><span class="n">tendsto_inf.mpr</span> <span class="o">⟨</span><span class="n">hF</span><span class="o">,</span> <span class="n">tendsto_comap_iff.mpr</span> <span class="n">this</span><span class="o">⟩)⟩,</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="306340525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306340525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306340525">(Oct 26 2022 at 21:57)</a>:</h4>
<p>Here is what I have for now for the uniform separation lemma, together with a bit of API around uniform neighborhoods of sets:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.uniform_space.uniform_convergence</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">uniform_space</span>
<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">uniformity</span> <span class="n">topological_space</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)}</span>

<span class="kd">lemma</span> <span class="n">comp_symm_of_uniformity'</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">∈</span> <span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">t</span> <span class="bp">∈</span> <span class="bp">𝓤</span> <span class="n">α</span><span class="o">,</span> <span class="n">symmetric_rel</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">t</span> <span class="bp">○</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">u</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hvu</span><span class="o">,</span> <span class="n">hu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">comp_symm_of_uniformity</span> <span class="n">hu</span> <span class="k">in</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">hvu</span><span class="o">,</span><span class="n">hvu</span><span class="o">⟩</span> <span class="o">},</span> <span class="n">hu</span><span class="o">⟩</span>

<span class="c1">-----------------------------------------------------------------------------</span>

<span class="kn">namespace</span> <span class="n">uniform_space</span> <span class="c1">-- uniform thickening</span>

<span class="kd">def</span> <span class="n">thickening</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⋃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">ball</span> <span class="n">x</span> <span class="n">u</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">thickening_singleton</span> <span class="o">:</span> <span class="n">thickening</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">=</span> <span class="n">ball</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">thickening</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">monotone_thickening</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">thickening</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span> <span class="n">huv</span><span class="o">,</span> <span class="n">Union₂_mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">ball</span><span class="o">]</span> <span class="n">using</span> <span class="n">preimage_mono</span> <span class="n">huv</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">thickening_mono</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">thickening</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">thickening</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">pi.le_def.mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">Union₂_mono'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span> <span class="n">ha</span><span class="o">,</span> <span class="n">subset_rfl</span><span class="o">⟩))</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">thickening_comp</span> <span class="o">:</span> <span class="n">thickening</span> <span class="o">(</span><span class="n">thickening</span> <span class="n">s</span> <span class="n">u</span><span class="o">)</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">thickening</span> <span class="n">s</span> <span class="o">(</span><span class="n">u</span> <span class="bp">○</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">thickening</span><span class="o">,</span> <span class="n">ball</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">disjoint_ball_iff</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="o">(</span><span class="n">ball</span> <span class="n">a</span> <span class="n">u</span><span class="o">)</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∉</span> <span class="n">u</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">compl_compl</span> <span class="o">(</span><span class="n">ball</span> <span class="n">a</span> <span class="n">u</span><span class="o">),</span> <span class="n">disjoint_compl_left_iff_subset</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">thickening_inter_eq_empty</span> <span class="o">:</span> <span class="n">thickening</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∉</span> <span class="n">u</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">thickening</span><span class="o">,</span> <span class="bp">←</span> <span class="n">disjoint_iff_inter_eq_empty</span><span class="o">,</span> <span class="n">disjoint_ball_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">thickening_inter_eq_empty_comm</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">symmetric_rel</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">thickening</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">thickening</span> <span class="n">t</span> <span class="n">u</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">thickening_inter_eq_empty</span><span class="o">,</span> <span class="n">inter_comm</span> <span class="n">s</span><span class="o">],</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">hab</span><span class="o">,</span> <span class="n">h</span> <span class="n">b</span> <span class="n">hb</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">(</span><span class="n">hu.mk_mem_comm.mp</span> <span class="n">hab</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">thickening_inter_thickening_eq_empty_of_comp</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">symmetric_rel</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hvu</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">○</span> <span class="n">v</span> <span class="bp">⊆</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hST</span> <span class="o">:</span> <span class="n">thickening</span> <span class="n">s</span> <span class="n">u</span> <span class="bp">∩</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">thickening</span> <span class="n">s</span> <span class="n">v</span> <span class="bp">∩</span> <span class="n">thickening</span> <span class="n">t</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">thickening_inter_eq_empty_comm</span> <span class="n">hv</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">subset_empty_iff.mp</span> <span class="o">(</span><span class="n">hST</span> <span class="bp">▸</span> <span class="n">inter_subset_inter_left</span> <span class="n">t</span> <span class="o">(</span><span class="n">monotone_thickening</span> <span class="n">hvu</span><span class="o">))</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">uniform_space</span>

<span class="c1">-----------------------------------------------------------------------------</span>

<span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift'</span> <span class="o">(</span><span class="n">uniform_space.thickening</span> <span class="n">s</span><span class="o">)</span>

<span class="n">localized</span> <span class="s2">"notation (name := uniform_nhds_set) `𝓝ᵘ` := uniform_nhds_set"</span> <span class="k">in</span> <span class="n">uniformity</span>

<span class="kn">namespace</span> <span class="n">uniform_space</span> <span class="c1">-- uniform_nhds_set</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">uniform_nhds_set_mono</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="bp">≤</span> <span class="bp">𝓝ᵘ</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">lift'_mono</span> <span class="n">le_rfl</span> <span class="o">(</span><span class="n">thickening_mono</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">uniform_nhds_set_singleton</span> <span class="o">:</span> <span class="bp">𝓝ᵘ</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">𝓝</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nhds_eq_uniformity</span><span class="o">,</span> <span class="n">uniform_nhds_set</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">mem_uniform_nhds_set_iff</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="bp">𝓝ᵘ</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">u</span> <span class="bp">∈</span> <span class="bp">𝓤</span> <span class="n">α</span><span class="o">,</span> <span class="n">thickening</span> <span class="n">t</span> <span class="n">u</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">uniform_nhds_set</span><span class="o">,</span> <span class="n">mem_lift'_sets</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">nhds_le_uniform_nhds_set</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="bp">𝓝</span> <span class="n">a</span> <span class="bp">≤</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">uniform_nhds_set_singleton</span><span class="o">]</span> <span class="n">using</span> <span class="n">uniform_nhds_set_mono</span> <span class="o">(</span><span class="n">singleton_subset_iff.mpr</span> <span class="n">ha</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">nhds_set_le_uniform_nhds_set</span> <span class="o">:</span> <span class="bp">𝓝ˢ</span> <span class="n">s</span> <span class="bp">≤</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">nhds_set</span><span class="o">]</span> <span class="n">using</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">nhds_le_uniform_nhds_set</span>

<span class="kd">lemma</span> <span class="n">uniform_nhds_inf_uniform_nhds_eq_bot</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="bp">⊓</span> <span class="bp">𝓝ᵘ</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">inf_principal_eq_bot</span><span class="o">,</span> <span class="n">inf_eq_bot_iff</span><span class="o">,</span> <span class="n">mem_uniform_nhds_set_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hsu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hvs</span><span class="o">,</span> <span class="n">hvu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">comp_symm_of_uniformity'</span> <span class="n">hu</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">subset_rfl</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">subset_rfl</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="n">thickening_inter_thickening_eq_empty_of_comp</span> <span class="n">hvs</span> <span class="n">hvu</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">subset_compl_iff_disjoint_right.mp</span> <span class="n">hsu</span><span class="o">)</span><span class="bp">.</span><span class="n">inter_eq</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nhds_inf_uniform_nhds_eq_bot</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">𝓝</span> <span class="n">a</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="bp">𝓝</span> <span class="n">a</span> <span class="bp">⊓</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">uniform_nhds_set_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">hf</span> <span class="bp">⊢;</span> <span class="n">exact</span> <span class="n">uniform_nhds_inf_uniform_nhds_eq_bot</span> <span class="n">hf</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">uniform_space</span>
</code></pre></div>



<a name="306632214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306632214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306632214">(Oct 28 2022 at 11:15)</a>:</h4>
<p>If you add</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">lift'_inter</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f.lift'</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="bp">∩</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f.lift'</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="n">f.lift'</span> <span class="n">h</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">f.lift'</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="bp">∩</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span>
    <span class="bp">=</span> <span class="n">f.lift</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">h</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">filter.lift'</span><span class="o">]</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">f.lift'</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="n">f.lift'</span> <span class="n">h</span> <span class="o">:</span> <span class="n">lift_inf</span>

<span class="kd">lemma</span> <span class="n">lift_eq_bot_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">filter</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.lift</span> <span class="n">g</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">f</span><span class="o">,</span> <span class="n">g</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">empty_mem_iff_bot</span><span class="o">,</span> <span class="n">mem_lift_sets</span> <span class="n">hm</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">lift'_eq_bot_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.lift'</span> <span class="n">g</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">f</span><span class="o">,</span> <span class="n">g</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">filter.lift'</span><span class="o">,</span> <span class="n">lift_eq_bot_iff</span> <span class="o">(</span><span class="n">monotone_principal.comp</span> <span class="n">hm</span><span class="o">),</span>
  <span class="bp">←</span> <span class="n">principal_empty</span><span class="o">,</span> <span class="n">principal_eq_iff_eq</span><span class="o">]</span>
</code></pre></div>
<p>You can do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">uniform_nhds_inf_uniform_nhds_eq_bot</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="bp">⊓</span> <span class="bp">𝓝ᵘ</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">uniform_nhds_set</span><span class="o">,</span> <span class="n">lift'_inf_principal_eq</span><span class="o">,</span> <span class="bp">←</span> <span class="n">lift'_inter</span><span class="o">,</span> <span class="n">lift'_eq_bot_iff</span><span class="o">,</span>
              <span class="n">monotone_thickening.inter</span> <span class="n">monotone_const</span><span class="o">,</span>
              <span class="n">monotone_thickening.inter</span> <span class="n">monotone_thickening</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hsu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hvs</span><span class="o">,</span> <span class="n">hvu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">comp_symm_of_uniformity'</span> <span class="n">hu</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">thickening_inter_thickening_eq_empty_of_comp</span> <span class="n">hvs</span> <span class="n">hvu</span> <span class="n">hsu</span><span class="o">⟩</span>
<span class="kd">end</span>
</code></pre></div>
<p>It's not really shorter so you can keep your version, I just really wanted to give it a try <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="306632400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306632400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306632400">(Oct 28 2022 at 11:17)</a>:</h4>
<p>But the whole thing is quite nice, I'd say you can open a PR with what you have right now (unless you want to do more things with it first of course)</p>



<a name="306632800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306632800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306632800">(Oct 28 2022 at 11:19)</a>:</h4>
<p>I want to add that the uniform neighborhood of a compact is its set neighborhood. (If it is true.) But first I have to go teach...</p>



<a name="306633859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306633859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306633859">(Oct 28 2022 at 11:27)</a>:</h4>
<p>Is it true and we do have it! You just have to rephrase <a href="https://leanprover-community.github.io/mathlib_docs/find/is_compact.nhds_set_basis_uniformity">docs#is_compact.nhds_set_basis_uniformity</a> as <code>𝓝ᵘ K = 𝓝ˢ K</code> but that should be straightforward</p>



<a name="306634153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306634153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306634153">(Oct 28 2022 at 11:29)</a>:</h4>
<p>But if you think you can shorten the proof using API then you should absolutely go for that!</p>



<a name="306634280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306634280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306634280">(Oct 28 2022 at 11:30)</a>:</h4>
<p>Also I wanted to swap the arguments of <code>uniform_space.thickening</code> to match <code>metric.thickening</code></p>



<a name="306644743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306644743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306644743">(Oct 28 2022 at 12:33)</a>:</h4>
<p>This is still abusing dot notation to obfuscate code. It is especially confusing when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is a filter and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> are maps...</p>



<a name="306656450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306656450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306656450">(Oct 28 2022 at 13:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Operations.20on.20uniform.20limits/near/306644743">said</a>:</p>
<blockquote>
<p>This is still abusing dot notation to obfuscate code. It is especially confusing when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is a filter and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> are maps...</p>
</blockquote>
<p>Which part exactly is abusing dot notation?</p>



<a name="306661192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306661192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306661192">(Oct 28 2022 at 13:52)</a>:</h4>
<p>Lines like <code>f.lift' (λx, g x ∩ h x) = f.lift' g ⊓ f.lift' h</code></p>



<a name="306666133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306666133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306666133">(Oct 28 2022 at 14:14)</a>:</h4>
<p>Also here then?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">uniform_nhds_set</span> <span class="o">[</span><span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">𝓤</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift'</span> <span class="o">(</span><span class="n">uniform_space.thickening</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>



<a name="306708180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Operations%20on%20uniform%20limits/near/306708180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Operations.20on.20uniform.20limits.html#306708180">(Oct 28 2022 at 17:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lemma3</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="bp">𝓝ˢ</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">𝓝ᵘ</span> <span class="n">s</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hs.nhds_set_basis_uniformity</span> <span class="o">(</span><span class="n">basis_sets</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">eq_of_same_basis</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">mem_uniform_nhds_set_iff</span><span class="o">⟩</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html">direct sums of submodules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="239700353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239700353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239700353">(May 21 2021 at 05:58)</a>:</h4>
<p>I would like to merely state the result:</p>
<blockquote>
<p>Let M be a noetherian module over R, and suppose K and L are submodules of M such that <code>K ≅ M ⊕ L</code>. Then <code>L = ⊥</code>.</p>
</blockquote>
<p>How do I talk about the direct sum of two submodules?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_noetherian</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="gr">sorry</span><span class="o">)</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="239700382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239700382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239700382">(May 21 2021 at 05:59)</a>:</h4>
<p>I don't particularly mind if we treat <code>L</code> just as another <code>R</code> module, rather than a submodule.</p>



<a name="239700994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239700994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239700994">(May 21 2021 at 06:06)</a>:</h4>
<p>Does the abstract product get a module structure?</p>



<a name="239701005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239701005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239701005">(May 21 2021 at 06:06)</a>:</h4>
<p>I mean <code>prod</code></p>



<a name="239701260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239701260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239701260">(May 21 2021 at 06:10)</a>:</h4>
<p>Ah, okay!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_noetherian</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="bp">×</span> <span class="n">L</span><span class="o">))</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>typechecks at least. I'll see if I can prove it.</p>



<a name="239704931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239704931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239704931">(May 21 2021 at 06:56)</a>:</h4>
<p>I don't even know a maths proof</p>



<a name="239705645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239705645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239705645">(May 21 2021 at 07:04)</a>:</h4>
<p>There's a copy of <code>K</code> inside <code>M</code>. But since <code>K ≃ₗ[R] (M × L)</code>, there an even smaller copy of <code>K</code> inside that, with a copy of <code>L</code> to spare. Repeat this over and over again, obtaining more and more copies of <code>L</code>. The successive direct sums of these form an ascending chain, so it stabilizes, which is only possible if <code>L = ⊥</code>.</p>



<a name="239711722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239711722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239711722">(May 21 2021 at 08:04)</a>:</h4>
<p>Can you get here by showing the <a href="https://leanprover-community.github.io/mathlib_docs/find/module.rank">docs#module.rank</a> of the prod of two modules is the sum of their ranks? So <code>rank K = rank M + rank L</code>, but K is a submodule of M so <code>rank K ≤ rank M</code> and <code>rank L = 0</code></p>



<a name="239711934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239711934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239711934">(May 21 2021 at 08:06)</a>:</h4>
<p>I think it's true more generally that if a submodule <code>K</code> of <code>M</code> surjects onto <code>M</code> via <code>f</code>, then <code>f</code> is an isomorphism. The proof is the same: let <code>X 0</code> be the zero submodule of <code>K</code>, and recursively let <code>X (i+1)</code> be the preimage of <code>X i</code> under <code>f</code>. Then this must stabilise which is only possible if <code>f</code> has zero kernel</p>



<a name="239712064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239712064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239712064">(May 21 2021 at 08:07)</a>:</h4>
<p>I don't think ranks will help you since <code>L</code> having zero rank does not mean <code>L</code> is zero, but it does provide the right intuition</p>



<a name="239712452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239712452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239712452">(May 21 2021 at 08:10)</a>:</h4>
<p>You're right, <a href="https://leanprover-community.github.io/mathlib_docs/find/dim_zero_iff">docs#dim_zero_iff</a> requires a field</p>



<a name="239712492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239712492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239712492">(May 21 2021 at 08:11)</a>:</h4>
<p>Also we now have lots of lemmas about <code>dim</code> that didn't get renamed when <code>rank</code> did...</p>



<a name="239717152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239717152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239717152">(May 21 2021 at 08:50)</a>:</h4>
<p>Yes, for general rings there is no good notion of rank. For integral domains you can tensor up to the field of factions and ask for the dimension, so then the rank of Z^n is Z but the rank of every finite abelian group and more generally every torsion abelian group will be 0</p>



<a name="239721520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239721520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239721520">(May 21 2021 at 09:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/direct.20sums.20of.20submodules/near/239711934">said</a>:</p>
<blockquote>
<p>I think it's true more generally that if a submodule <code>K</code> of <code>M</code> surjects onto <code>M</code> via <code>f</code>, then <code>f</code> is an isomorphism. The proof is the same: let <code>X 0</code> be the zero submodule of <code>K</code>, and recursively let <code>X (i+1)</code> be the preimage of <code>X i</code> under <code>f</code>. Then this must stabilise which is only possible if <code>f</code> has zero kernel</p>
</blockquote>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span>, could you explain this in more detail? I don't understand any of it. :-) Why are the <code>X i</code> increasing?</p>



<a name="239721887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239721887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239721887">(May 21 2021 at 09:30)</a>:</h4>
<p>I actually just yesterday proved that a surjective endomorphism (of a noetherian module) is injective, by looking at <code>(f ^ n).ker</code>. In fact I think this argument goes through unchanged if <code>f : K \to M</code>, (i.e. a surjective map out of a submodule) rather than an endomorphism.</p>



<a name="239721944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/direct%20sums%20of%20submodules/near/239721944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/direct.20sums.20of.20submodules.html#239721944">(May 21 2021 at 09:31)</a>:</h4>
<p>And... I'm an idiot. This is exactly what you said :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
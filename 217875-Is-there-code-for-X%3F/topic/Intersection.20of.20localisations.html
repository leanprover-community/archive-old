---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html">Intersection of localisations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="302776082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302776082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302776082">(Oct 07 2022 at 03:35)</a>:</h4>
<p>Do we have (or is it easy to prove given what we have) that the ring of integers of a number field is the intersection of all its local valuation rings? I think somewhere in the proof we need something like an integral domain is an intersection of its localisations at all primes?</p>



<a name="302785988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302785988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302785988">(Oct 07 2022 at 06:10)</a>:</h4>
<p>I'm quite sure we do not have this yet. But we seem to have most of the ingredients.</p>



<a name="302792243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302792243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302792243">(Oct 07 2022 at 07:10)</a>:</h4>
<p>I think that using <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation_def">docs#is_dedekind_domain.height_one_spectrum.int_valuation_def</a> this should be very easy.  Given <code>r/s</code> in the field of fractions <code>K</code>, you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation_of_mk'">docs#is_dedekind_domain.height_one_spectrum.valuation_of_mk'</a> to compute all its valuations and deduce that the <code>s</code> is a unit.</p>



<a name="302792724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302792724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302792724">(Oct 07 2022 at 07:14)</a>:</h4>
<p>s isn't a well-defined thing so I'm not sure it's as easy as that (there's no notion of "lowest terms" in general). Given an element k in the field of fractions of an integral domain you can construct the ideal of denominators of that element, which is all the elements r of the ring such that r*k is in the ring. It's not principal in general.</p>



<a name="302793045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302793045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302793045">(Oct 07 2022 at 07:17)</a>:</h4>
<p>But there is a <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation_div_eq_div">docs#is_dedekind_domain.height_one_spectrum.int_valuation_div_eq_div</a> so I think any choice would work.</p>



<a name="302793077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302793077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302793077">(Oct 07 2022 at 07:17)</a>:</h4>
<p>(ops, link broken, I'll fix: it says it is indep. of the choices of <code>s</code> and <code>r</code>)</p>



<a name="302795277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302795277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302795277">(Oct 07 2022 at 07:37)</a>:</h4>
<p>Oh no, I see the problem. I agree with <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> .</p>



<a name="302853111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302853111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302853111">(Oct 07 2022 at 13:35)</a>:</h4>
<p>The general assertion is that the integral closure of a domain in a field is the intersection of all valuation rings of the field field with a centre on your given domain.</p>



<a name="302853480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302853480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302853480">(Oct 07 2022 at 13:37)</a>:</h4>
<p>You can probably find a proof in Zariski-Samuel</p>



<a name="302855784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302855784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302855784">(Oct 07 2022 at 13:48)</a>:</h4>
<p>I don’t think mathlib even knows that valuation rings are normal!</p>



<a name="302855857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302855857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302855857">(Oct 07 2022 at 13:48)</a>:</h4>
<p>That should be a quick PR.</p>



<a name="302879610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302879610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302879610">(Oct 07 2022 at 15:36)</a>:</h4>
<p>There is another <a href="https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a">general statement</a> and the first answer seems pretty easy to formalize (we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.colon">docs#submodule.colon</a>). But I suspect what <span class="user-mention" data-user-id="464700">@David Ang</span> actually want is something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.dedekind_domain.adic_valuation</span>
<span class="kn">open</span> <span class="n">is_dedekind_domain</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_dedekind_domain</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">is_fraction_ring</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">height_one_spectrum.valuation_le_one'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span><span class="o">,</span> <span class="n">v.valuation</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- could also use is_localization.is_integer in statement --</span>
</code></pre></div>
<p>My outline for proving this is to show if we write x = r/s, then the multiset of normalized factors of the ideal (s) is less than or equal to the multiset of normalized factors of (r) using the condition <code>h</code>. (The definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation">docs#is_dedekind_domain.height_one_spectrum.valuation</a> uses counts of factors of <a href="http://associate.mk">associate.mk</a>, so there will need some glue.) Then you may write the latter multiset as the former multiset plus some other multiset, multiply up the multisets and use <a href="https://leanprover-community.github.io/mathlib_docs/find/prod_normalized_factors_eq_self">docs#prod_normalized_factors_eq_self</a> to get that (r)=(s)I for some ideal I, so r is s times some element in the ideal; then x=r/s equals that element.<br>
In fact I wrote down a more general statement a while ago but haven't got around to prove it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">localization_subalgebra_eq_integer</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hM</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≤</span> <span class="n">non_zero_divisors</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">localization.subalgebra.of_field</span> <span class="n">K</span> <span class="n">M</span> <span class="n">hM</span> <span class="bp">=</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">M</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">v.as_ideal</span><span class="o">}</span><span class="bp">.</span><span class="n">integer</span> <span class="n">K</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="302880257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302880257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302880257">(Oct 07 2022 at 15:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302879610">said</a>:</p>
<blockquote>
<p>There is another <a href="https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a">general statement</a> and the first answer seems pretty easy to formalize (we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.colon">docs#submodule.colon</a>). But I suspect what <span class="user-mention silent" data-user-id="464700">David Ang</span> actually want is something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.dedekind_domain.adic_valuation</span>
<span class="kn">open</span> <span class="n">is_dedekind_domain</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_dedekind_domain</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">is_fraction_ring</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">height_one_spectrum.valuation_le_one'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span><span class="o">,</span> <span class="n">v.valuation</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- could also use is_localization.is_integer in statement --</span>
</code></pre></div>
<p>My outline for proving this is to show if we write x = r/s, then the multiset of normalized factors of the ideal (s) is less than or equal to the multiset of normalized factors of (r) using the condition <code>h</code>. (The definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation">docs#is_dedekind_domain.height_one_spectrum.valuation</a> uses counts of factors of <a href="http://associate.mk">associate.mk</a>, so there will need some glue.) Then you may write the latter multiset as the former multiset plus some other multiset, multiply up the multisets and use <a href="https://leanprover-community.github.io/mathlib_docs/find/prod_normalized_factors_eq_self">docs#prod_normalized_factors_eq_self</a> to get that (r)=(s)I for some ideal I, so r is s times some element in the ideal; then x=r/s equals that element.<br>
In fact I wrote down a more general statement a while ago but haven't got around to prove it:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">localization_subalgebra_eq_integer</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hM</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≤</span> <span class="n">non_zero_divisors</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">localization.subalgebra.of_field</span> <span class="n">K</span> <span class="n">M</span> <span class="n">hM</span> <span class="bp">=</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">M</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">v.as_ideal</span><span class="o">}</span><span class="bp">.</span><span class="n">integer</span> <span class="n">K</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I currently only have a proof of the statement you linked:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">maximal_spectrum.localization_infi_eq_bot</span> <span class="o">:</span>
    <span class="o">(</span><span class="bp">⨅</span> <span class="n">v</span> <span class="o">:</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">I.is_maximal</span><span class="o">},</span> <span class="n">localization.subalgebra.of_field</span> <span class="n">K</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">ideal.prime_compl</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v.property.is_prime</span><span class="o">)</span> <span class="bp">$</span> <span class="n">le_non_zero_divisors_of_no_zero_divisors</span> <span class="bp">$</span>
      <span class="n">not_not_intro</span> <span class="n">v.val.zero_mem</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>I also have the <code>prime_spectrum</code> and <code>height_one_spectrum</code> versions that follow pretty much immediately.</p>



<a name="302880703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302880703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302880703">(Oct 07 2022 at 15:41)</a>:</h4>
<p>But yes, I also think that what I want is what you wrote after this.</p>



<a name="302909232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302909232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302909232">(Oct 07 2022 at 18:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302855857">said</a>:</p>
<blockquote>
<p>That should be a quick PR.</p>
</blockquote>
<p>scratch that, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/valuation_ring.is_bezout">docs#valuation_ring.is_bezout</a></p>



<a name="302909294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302909294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302909294">(Oct 07 2022 at 18:12)</a>:</h4>
<p>and <a href="https://leanprover-community.github.io/mathlib_docs/find/is_bezout.is_integrally_closed">docs#is_bezout.is_integrally_closed</a></p>



<a name="302943561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302943561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302943561">(Oct 07 2022 at 22:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302879610">said</a>:</p>
<blockquote>
<p>There is another <a href="https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a">general statement</a> </p>
</blockquote>
<p>Right -- this is the ideal of denominators proof that I was hinting at earlier.</p>



<a name="302954312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302954312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302954312">(Oct 08 2022 at 00:56)</a>:</h4>
<p>Just completed a proof of <code>mem_integers_of_valuation_le_one</code>!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.dedekind_domain.S_integer</span>

<span class="kn">namespace</span> <span class="n">is_dedekind_domain</span>

<span class="kn">open</span> <span class="n">unique_factorization_monoid</span> <span class="n">height_one_spectrum</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_dedekind_domain</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">is_fraction_ring</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">height_one_spectrum.mem_integers_of_valuation_le_one</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span><span class="o">,</span> <span class="n">v.valuation</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">is_localization.mk'_surjective</span> <span class="o">(</span><span class="n">non_zero_divisors</span> <span class="n">R</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">eq_or_ne</span> <span class="n">x</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">is_localization.mk'_zero</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subring.zero_mem</span> <span class="o">},</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">ideal.span</span> <span class="o">{</span><span class="n">y</span><span class="o">}</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">ideal.span</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ideal.span_singleton_le_span_singleton.1</span> <span class="o">(</span><span class="n">ideal.le_of_dvd</span> <span class="n">this</span><span class="o">),</span>
    <span class="n">use</span> <span class="n">z</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">is_localization.eq_mk'_iff_mul_eq</span><span class="o">,</span> <span class="n">map_mul</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">associates.mk_le_mk_iff_dvd_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">associates.factors_le</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hy'</span> <span class="o">:=</span> <span class="n">non_zero_divisors.ne_zero</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ine</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">},</span> <span class="n">mt</span> <span class="o">(</span><span class="bp">@</span><span class="n">ideal.span_singleton_eq_bot</span> <span class="n">R</span> <span class="n">_</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">associates.factors_mk</span> <span class="n">_</span> <span class="o">(</span><span class="n">ine</span> <span class="n">hx</span><span class="o">),</span> <span class="n">associates.factors_mk</span> <span class="n">_</span> <span class="o">(</span><span class="n">ine</span> <span class="n">hy'</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">with_top.coe_le_coe</span><span class="o">,</span> <span class="n">multiset.le_iff_count</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">associates.mk_surjective</span> <span class="n">v</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hv'</span> <span class="o">:=</span> <span class="n">hv</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">associates.irreducible_mk</span><span class="o">,</span> <span class="n">irreducible_iff_prime</span><span class="o">]</span> <span class="n">at</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">ideal.is_prime_of_prime</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hv.ne_zero</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">valuation_of_mk'</span><span class="o">,</span> <span class="n">int_valuation</span><span class="o">,</span> <span class="bp">←</span> <span class="n">valuation.to_fun_eq_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">int_valuation_def_if_neg</span> <span class="n">_</span> <span class="n">hx</span><span class="o">,</span> <span class="n">int_valuation_def_if_neg</span> <span class="n">_</span> <span class="n">hy'</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">with_zero.coe_div</span><span class="o">,</span> <span class="bp">←</span> <span class="n">with_zero.coe_one</span><span class="o">,</span> <span class="n">with_zero.coe_le_coe</span><span class="o">,</span>
      <span class="bp">←</span> <span class="n">of_add_sub</span><span class="o">,</span> <span class="bp">←</span> <span class="n">of_add_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">le_of_sub_nonpos</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">neg_le_neg_iff</span><span class="o">,</span> <span class="n">int.coe_nat_le</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">associates.factors_mk</span> <span class="n">_</span> <span class="o">(</span><span class="n">ine</span> <span class="n">hx</span><span class="o">),</span> <span class="n">associates.factors_mk</span> <span class="n">_</span> <span class="o">(</span><span class="n">ine</span> <span class="n">hy'</span><span class="o">),</span> <span class="n">option.coe_def</span> <span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">associates.count_some</span> <span class="n">hv'</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">is_dedekind_domain</span>
</code></pre></div>



<a name="302963996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302963996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302963996">(Oct 08 2022 at 03:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="464700">David Ang</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302880257">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302879610">said</a>:</p>
<blockquote>
<p>There is another <a href="https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a">general statement</a> and the first answer seems pretty easy to formalize (we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.colon">docs#submodule.colon</a>). But I suspect what <span class="user-mention silent" data-user-id="464700">David Ang</span> actually want is something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.dedekind_domain.adic_valuation</span>
<span class="kn">open</span> <span class="n">is_dedekind_domain</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_dedekind_domain</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">is_fraction_ring</span> <span class="n">R</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">height_one_spectrum.valuation_le_one'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span><span class="o">,</span> <span class="n">v.valuation</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- could also use is_localization.is_integer in statement --</span>
</code></pre></div>
<p>My outline for proving this is to show if we write x = r/s, then the multiset of normalized factors of the ideal (s) is less than or equal to the multiset of normalized factors of (r) using the condition <code>h</code>. (The definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation">docs#is_dedekind_domain.height_one_spectrum.valuation</a> uses counts of factors of <a href="http://associate.mk">associate.mk</a>, so there will need some glue.) Then you may write the latter multiset as the former multiset plus some other multiset, multiply up the multisets and use <a href="https://leanprover-community.github.io/mathlib_docs/find/prod_normalized_factors_eq_self">docs#prod_normalized_factors_eq_self</a> to get that (r)=(s)I for some ideal I, so r is s times some element in the ideal; then x=r/s equals that element.<br>
In fact I wrote down a more general statement a while ago but haven't got around to prove it:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">localization_subalgebra_eq_integer</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hM</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≤</span> <span class="n">non_zero_divisors</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">localization.subalgebra.of_field</span> <span class="n">K</span> <span class="n">M</span> <span class="n">hM</span> <span class="bp">=</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">height_one_spectrum</span> <span class="n">R</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">M</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">v.as_ideal</span><span class="o">}</span><span class="bp">.</span><span class="n">integer</span> <span class="n">K</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I currently only have a proof of the statement you linked:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">maximal_spectrum.localization_infi_eq_bot</span> <span class="o">:</span>
    <span class="o">(</span><span class="bp">⨅</span> <span class="n">v</span> <span class="o">:</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span> <span class="bp">//</span> <span class="n">I.is_maximal</span><span class="o">},</span> <span class="n">localization.subalgebra.of_field</span> <span class="n">K</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">ideal.prime_compl</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v.property.is_prime</span><span class="o">)</span> <span class="bp">$</span> <span class="n">le_non_zero_divisors_of_no_zero_divisors</span> <span class="bp">$</span>
      <span class="n">not_not_intro</span> <span class="n">v.val.zero_mem</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>I also have the <code>prime_spectrum</code> and <code>height_one_spectrum</code> versions that follow pretty much immediately.</p>
</blockquote>
<p>Here is the preliminary PR for this: <a href="https://github.com/leanprover-community/mathlib/pull/16860">https://github.com/leanprover-community/mathlib/pull/16860</a></p>



<a name="302964400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302964400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302964400">(Oct 08 2022 at 04:05)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> I don't think the result on localisations (the one I just proved :/) will be all that useful for the result I actually want (the one you have!), so perhaps they should be separate PRs?</p>



<a name="302964620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302964620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302964620">(Oct 08 2022 at 04:10)</a>:</h4>
<p>Actually, was there a discussion before on whether <code>maximal_spectrum</code> is a good thing to have, instead of just using <code>prime_spectrum</code> or <code>height_one_spectrum</code>?</p>



<a name="302964962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/302964962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#302964962">(Oct 08 2022 at 04:19)</a>:</h4>
<p>Yeah I think they should be separate PRs. In order to use your work, we need that for every maximal ideal p, localization at p gives exactly the {p}ᶜ-integers; the ⊆  direction seems nontrivial and likely requires a proof like mine above. I think I'd better extract some lemmas and add some related results like <code>localization_subalgebra_eq_integer</code> before PR'ing my proof above.</p>



<a name="303052448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/303052448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#303052448">(Oct 08 2022 at 18:47)</a>:</h4>
<p>I think it would make things easier if we redefine <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation_def">docs#is_dedekind_domain.height_one_spectrum.int_valuation_def</a> in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.normalized_factors">docs#unique_factorization_monoid.normalized_factors</a> instead of <a href="https://leanprover-community.github.io/mathlib_docs/find/associates.factors">docs#associates.factors</a>. Since we have <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal.normalization_monoid">docs#ideal.normalization_monoid</a> there is no need to pass to normalized_factors. In fact, I propose to generalize <a href="https://leanprover-community.github.io/mathlib_docs/find/associates.factors">docs#associates.factors</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/associates.factors'">docs#associates.factors'</a> to arbitrary <a href="https://leanprover-community.github.io/mathlib_docs/find/normalization_monoid">docs#normalization_monoid</a>, and since <a href="https://leanprover-community.github.io/mathlib_docs/find/associates">docs#associates</a> always form a normalization_monoid (which is already known to Lean via <a href="https://leanprover-community.github.io/mathlib_docs/find/normalization_monoid_of_unique_units">docs#normalization_monoid_of_unique_units</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/associates.unique_units">docs#associates.unique_units</a>), they can always be specialized to the associates monoid. associates.factors  is easier to work with than normalized_factors because the former is a multiset of irreducible elements, so when you apply e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.le_iff_count">docs#multiset.le_iff_count</a> you don't have to deal with the counts of reducible elements which are zero. If anyone would like to take up this that would be great.</p>
<p>BTW, <a href="https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation">docs#is_dedekind_domain.height_one_spectrum.int_valuation</a> is missing a <code>@[simps]</code> attribute or a lemma to simplify it to int_valuation_def.</p>



<a name="303064326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/303064326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#303064326">(Oct 08 2022 at 21:17)</a>:</h4>
<p>Regarding <code>maximal_spectrum</code>, I think it's harmless to add it as a definition, and it could potentially be used elsewhere, e.g. in <a href="https://math.stanford.edu/~conrad/papers/aws.pdf">these notes on non-archimedean geometry</a> it's denoted MaxSpec or M(A) and used throughout. <span class="user-mention" data-user-id="197836">@Jireh Loreaux</span> is working on some C*-algebra stuff and there are likely some parallels with the non-archimedean Banach algebras (complete <a href="https://leanprover-community.github.io/mathlib_docs/find/normed_algebra">docs#normed_algebra</a>) studied in the notes.</p>
<p>I don't know whether we want to put the Zariski topology on it now, as it may not be predominantly the topology we want on the set as is the case for prime_spectrum. It's interesting to note that in the context of <a href="https://github.com/leanprover-community/mathlib/pull/16719">#16719</a>, although the Zariski topology (whose closed sets are generated by zero loci of functions) is ostensibly coarser than the weak topology on <a href="https://leanprover-community.github.io/mathlib_docs/find/weak_dual.character_space">docs#weak_dual.character_space</a>, they are actually the same, because any compact t2_space is completely regular (cf. <a href="https://math.stackexchange.com/questions/1947834/when-is-every-closed-set-singleton-the-zero-set-of-complex-valued-functions">link 1</a>, <a href="https://mathoverflow.net/a/198595/3332">link 2</a>).</p>



<a name="303065106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/303065106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#303065106">(Oct 08 2022 at 21:29)</a>:</h4>
<p>In case my input matters at all: I have no issue with adding <code>maximal_spectrum</code>. We won't use it directly for the C⋆-algebra work I'm currently doing because we will also be concerned (eventually) with the non-unital case, so the character space is the way to go. However, I will probably add an equiv for convenience. You're welcome to put the Zariski topology on it. Some authors just use the maximal ideal space and the Zariski topology directly instead of (or in addition to) the character space.</p>



<a name="310744963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Intersection%20of%20localisations/near/310744963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Intersection.20of.20localisations.html#310744963">(Nov 18 2022 at 04:05)</a>:</h4>
<p>In fact <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302954312"><code>mem_integers_of_valuation_le_one</code></a> is the second defining property of a <a href="https://en.wikipedia.org/wiki/Krull_ring#Formal_definition">Krull ring</a>, which are higher dimensional generalization of Dedekind domains.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
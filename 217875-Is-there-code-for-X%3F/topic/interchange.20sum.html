---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html">interchange sum</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219584292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584292">(Dec 11 2020 at 10:02)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow></msub><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{0\leq i\leq j\leq n}F(i,j)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> can be written as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi></mrow><mi>n</mi></msubsup><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^n\sum_{j=i}^nF(i,j)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> and also as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>j</mi></msubsup><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{j=0}^n\sum_{i=0}^jF(i,j)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>. Do we have the equality of these last two sums in Lean? I looked in <code>algebra/big_operators/intervals</code> but couldn't find any double sum lemmas in there.</p>



<a name="219584406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584406">(Dec 11 2020 at 10:03)</a>:</h4>
<p>There should be a general purpose 2D summation lemma</p>



<a name="219584438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584438">(Dec 11 2020 at 10:04)</a>:</h4>
<p>(but I agree this particular diagonal interchange lemma should be in there)</p>



<a name="219584506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584506">(Dec 11 2020 at 10:04)</a>:</h4>
<p>how do I search mathlib for it? <code>library_search</code> just took my machine down for some reason</p>



<a name="219584562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584562">(Dec 11 2020 at 10:05)</a>:</h4>
<p>I'm just perusing big_ops.basic</p>



<a name="219584622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584622">(Dec 11 2020 at 10:06)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_sigma">docs#finset.prod_sigma</a></p>



<a name="219584702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219584702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219584702">(Dec 11 2020 at 10:07)</a>:</h4>
<p>and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_bij'">docs#finset.prod_bij'</a></p>



<a name="219585199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219585199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219585199">(Dec 11 2020 at 10:12)</a>:</h4>
<p>hells bells</p>



<a name="219585626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219585626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219585626">(Dec 11 2020 at 10:17)</a>:</h4>
<p>This just says that if X bijects with Y then some sum over X equals some sum over Y, and that a sum over a sigma type is what it obviously is. I can quite believe that I can put these together to make a proof! But my explicit lemma comes up a lot in basic undergraduate maths so I was hoping they'd be there already as a sum over Ico. I can make them, I just didn't want to waste my time if they were there already :-)</p>



<a name="219585911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219585911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219585911">(Dec 11 2020 at 10:21)</a>:</h4>
<p>Is there someway to tidy up the statement of <code>prod_bij</code> to use function.bijective or <a href="https://leanprover-community.github.io/mathlib_docs/find/set.bij_on">docs#set.bij_on</a>?</p>



<a name="219587537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219587537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219587537">(Dec 11 2020 at 10:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You are right, this is certainly a hole in the library. I would start by copying all the lemmas around <a href="http://us.metamath.org/mpeuni/mmtheorems138.html#fsum0diag">us.metamath.org/mpeuni/mmtheorems138.html#fsum0diag</a>, which contains this diagonal lemma as well as a few additional useful variations</p>



<a name="219587627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219587627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219587627">(Dec 11 2020 at 10:39)</a>:</h4>
<p>I've managed to write the first line using the <code>sum_sigma</code> approach and it wasn't much fun:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">dependent_double_sum</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">i</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span>
  <span class="bp">∑</span> <span class="n">j</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">a</span> <span class="o">(</span><span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@</span><span class="n">sum_sigma</span> <span class="n">ℕ</span> <span class="n">M</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">Ico</span> <span class="n">i</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">),</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219588218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219588218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219588218">(Dec 11 2020 at 10:42)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> which function is bijective though? In my example, the function is probably not bijective on all of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">N</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, it's only bijective on the finite sets in question. So you can use <code>function.bijective</code> but then you'll have to promote the sets to types and this adds an extra layer of confusion.</p>



<a name="219588663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219588663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219588663">(Dec 11 2020 at 10:45)</a>:</h4>
<p>Right, you'd end up having to coerce sets to types; or use <code>bij_on</code> which takes the sets as arguments</p>



<a name="219589958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219589958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219589958">(Dec 11 2020 at 10:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.linarith</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.intervals</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">nat</span>

<span class="kn">namespace</span> <span class="n">finset</span>

<span class="kd">lemma</span> <span class="n">dependent_double_sum</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">i</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span>
  <span class="bp">∑</span> <span class="n">j</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">Ico</span> <span class="n">a</span> <span class="o">(</span><span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@@</span><span class="n">sum_sigma</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">Ico</span> <span class="n">i</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">),</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@@</span><span class="n">sum_sigma</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">Ico</span> <span class="n">a</span> <span class="o">(</span><span class="n">j</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x.2</span> <span class="n">x.1</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">sum_bij'</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span> <span class="o">(⟨</span><span class="n">x.2</span><span class="o">,</span> <span class="n">x.1</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">))</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span> <span class="o">(⟨</span><span class="n">x.2</span><span class="o">,</span> <span class="n">x.1</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">))</span> <span class="n">_</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩</span> <span class="n">_</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨⟩</span> <span class="n">_</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Ico.mem</span><span class="o">,</span> <span class="n">sigma.forall</span><span class="o">,</span> <span class="n">mem_sigma</span><span class="o">]</span><span class="bp">;</span>
  <span class="n">rintros</span> <span class="n">a</span> <span class="n">b</span> <span class="o">⟨⟨</span><span class="n">h₁</span><span class="o">,</span><span class="n">h₂</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h₃</span><span class="o">,</span> <span class="n">h₄</span><span class="o">⟩⟩</span><span class="bp">;</span> <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩</span><span class="bp">;</span> <span class="n">linarith</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">finset</span>
</code></pre></div>



<a name="219590022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219590022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219590022">(Dec 11 2020 at 10:57)</a>:</h4>
<p>Double <code>@</code>!?</p>



<a name="219590032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219590032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219590032">(Dec 11 2020 at 10:57)</a>:</h4>
<p>The statement of <code>prod_bij</code> is designed specifically to give you the goals in the form you actually want to prove them, rather than wrapped in another layer of abstraction</p>



<a name="219590104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219590104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219590104">(Dec 11 2020 at 10:58)</a>:</h4>
<p>(deleted)</p>



<a name="219592561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219592561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219592561">(Dec 11 2020 at 11:16)</a>:</h4>
<p>Created <a href="https://github.com/leanprover-community/mathlib/issues/5318">#5318</a> to make the hypotheses to <code>prod_bij</code>-adjacent lemmas slightly easier to parse, without changing their statement</p>



<a name="219594266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219594266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219594266">(Dec 11 2020 at 11:32)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> there's what you needed :D</p>



<a name="219594513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219594513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219594513">(Dec 11 2020 at 11:35)</a>:</h4>
<p>Yayy!! Thank you!</p>



<a name="219595730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219595730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219595730">(Dec 11 2020 at 11:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, does that mean that in your opinion this statement is worse?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">prod_bij_subtype</span>  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">γ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">γ</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="bp">↑</span><span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">i_bij</span> <span class="o">:</span> <span class="n">function.bijective</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">x</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">prod_bij</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">i</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">prop</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">ha₁</span> <span class="n">ha₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">subtype.ext_iff.mp</span> <span class="o">(</span><span class="n">i_bij.1</span> <span class="o">(</span><span class="n">subtype.ext</span> <span class="n">h</span><span class="o">)))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">i_bij.2</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="k">in</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">a.prop</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">convert</span> <span class="n">subtype.ext_iff.mp</span> <span class="n">ha.symm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subtype.ext</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">⟩)</span>
</code></pre></div>



<a name="219595745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219595745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219595745">(Dec 11 2020 at 11:50)</a>:</h4>
<p>have you tried using it?</p>



<a name="219595773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219595773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219595773">(Dec 11 2020 at 11:51)</a>:</h4>
<p>Not yet, but my use-case is only when <code>s</code> and <code>t</code> are <code>set.univ</code> anyway</p>



<a name="219595798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219595798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219595798">(Dec 11 2020 at 11:51)</a>:</h4>
<p>okay, so you have a function from univ -&gt; univ then?</p>



<a name="219595823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219595823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219595823">(Dec 11 2020 at 11:51)</a>:</h4>
<p>that seems awkward compared to a function alpha -&gt; gamma</p>



<a name="219595990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219595990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219595990">(Dec 11 2020 at 11:52)</a>:</h4>
<p>My thinking was that there are various bits of API to produce <code>bijective</code> objects</p>



<a name="219596005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596005">(Dec 11 2020 at 11:52)</a>:</h4>
<p>plus you need a proof that it's bijective, probably the off the shelf theorem is going to give you that the alpha -&gt; gamma function is bijective</p>



<a name="219596101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596101">(Dec 11 2020 at 11:53)</a>:</h4>
<p>You're right that <code>univ</code> is a bad example</p>



<a name="219596135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596135">(Dec 11 2020 at 11:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">prod_bij_univ</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">i_bij</span> <span class="o">:</span> <span class="n">function.bijective</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∏</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">prod_bij</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">i</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">mem_univ</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">ha₁</span> <span class="n">ha₂</span> <span class="n">h</span><span class="o">,</span> <span class="n">i_bij.1</span> <span class="n">h</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="k">let</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">i_bij.2</span> <span class="n">b</span> <span class="k">in</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">mem_univ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ha.symm</span><span class="o">⟩)</span>
</code></pre></div>
<p>is the API that's convenient for univ</p>



<a name="219596167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596167">(Dec 11 2020 at 11:53)</a>:</h4>
<p>For the particular case of univ, I would expect a specialization of the <code>prod_bij</code> theorem for <code>univ</code></p>



<a name="219596175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596175">(Dec 11 2020 at 11:53)</a>:</h4>
<p>...like that</p>



<a name="219596183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596183">(Dec 11 2020 at 11:53)</a>:</h4>
<p>Should I PR the above?</p>



<a name="219596254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596254">(Dec 11 2020 at 11:54)</a>:</h4>
<p>I mean there isn't any harm in having it, I am just doubtful that it is better</p>



<a name="219596268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596268">(Dec 11 2020 at 11:54)</a>:</h4>
<p>Perhaps bundling <code>function.bijective i</code> into <code>i : equiv α γ</code>?</p>



<a name="219596296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596296">(Dec 11 2020 at 11:54)</a>:</h4>
<p>perhaps in some situations it's easier to use <code>equiv</code> theorems to prove facts about bundled finset functions, I don't know</p>



<a name="219596332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596332">(Dec 11 2020 at 11:55)</a>:</h4>
<p>Well, there's always <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.bijective">docs#equiv.bijective</a> if you want to work with equivs</p>



<a name="219596363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596363">(Dec 11 2020 at 11:55)</a>:</h4>
<p>I don't know whether there's a conversion in the other direction, but it would require choice</p>



<a name="219596402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219596402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219596402">(Dec 11 2020 at 11:55)</a>:</h4>
<p>the existing lemma has the drawback that the bijection property is splatted out so it's best for things like reindexing where you don't have anything packed up but you do have theorems <code>a + b - b = a</code> and such</p>



<a name="219597299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/interchange%20sum/near/219597299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/interchange.20sum.html#219597299">(Dec 11 2020 at 12:05)</a>:</h4>
<p>Having just tried to express the <code>_univ</code> version in terms of the <code>_subtype</code> version - I think the missing piece is a helper to construct the bijective object on the function over the subtype (ie, to splat it out)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
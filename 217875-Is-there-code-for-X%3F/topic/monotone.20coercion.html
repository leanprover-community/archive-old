---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html">monotone coercion</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="237392779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237392779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237392779">(May 04 2021 at 20:28)</a>:</h4>
<p>Is there an instance to say that a coercion is monotone (<code>↑x ≤ ↑y ↔ x ≤ y</code>)?</p>



<a name="237395067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395067">(May 04 2021 at 20:46)</a>:</h4>
<p>It can be antimono, like the coe for <a href="https://leanprover-community.github.io/mathlib_docs/find/order.pfilter.set.has_coe">docs#order.pfilter.set.has_coe</a>, if I understood correctly</p>



<a name="237395283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395283">(May 04 2021 at 20:48)</a>:</h4>
<p>Hmm I think I'm wrong about that</p>



<a name="237395321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395321">(May 04 2021 at 20:48)</a>:</h4>
<p>In my case I can stick to mono, but my prominent problem is that I need an instance to stick in lemmas.</p>



<a name="237395622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395622">(May 04 2021 at 20:50)</a>:</h4>
<p>mono is normally only a one-way implication.</p>



<a name="237395726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395726">(May 04 2021 at 20:51)</a>:</h4>
<p>Hmm... Surely I'm not the first to ask for a coercion to be well-behaved wrt orders?</p>



<a name="237395789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395789">(May 04 2021 at 20:52)</a>:</h4>
<p>Do you know about <code>norm_cast</code>?</p>



<a name="237395821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395821">(May 04 2021 at 20:52)</a>:</h4>
<p>I'm sure there are plenty of <code>coe_le</code> lemmas, but they're not instances.</p>



<a name="237395852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395852">(May 04 2021 at 20:52)</a>:</h4>
<p>They are registered as norm_cast lemmas.</p>



<a name="237395880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395880">(May 04 2021 at 20:53)</a>:</h4>
<p>Are all coercions assumed to respect the order? Surely not.</p>



<a name="237395993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237395993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237395993">(May 04 2021 at 20:53)</a>:</h4>
<p>Here's a MWE</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.basic</span>
<span class="kn">import</span> <span class="n">order.preorder_hom</span>
<span class="kn">import</span> <span class="n">order.galois_connection</span>
<span class="kn">import</span> <span class="n">tactic.monotonicity</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_coe_t</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">closure_operator</span> <span class="kd">extends</span> <span class="n">α</span> <span class="bp">→ₘ</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_closure'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">idempotent'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="237396070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396070">(May 04 2021 at 20:54)</a>:</h4>
<p>No, you prove <code>coe_le_coe</code> (which does seem to be an iff in all cases I looked at) and tag it with <code>norm_cast</code> and <code>simp</code>. It's this word "instance" I don't understand.</p>



<a name="237396130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396130">(May 04 2021 at 20:54)</a>:</h4>
<p>Aah, <code>coe_mono</code> is the one way implication</p>



<a name="237396213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396213">(May 04 2021 at 20:55)</a>:</h4>
<p>I have two types <code>α</code>  and <code>β</code>and I require <code>β</code>to coerce to <code>α</code>. Now, I want to require it to coerce "nicely".</p>



<a name="237396332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396332">(May 04 2021 at 20:56)</a>:</h4>
<p>I think we have <a href="https://leanprover-community.github.io/mathlib_docs/find/set_like.coe_mono">docs#set_like.coe_mono</a></p>



<a name="237396561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396561">(May 04 2021 at 20:58)</a>:</h4>
<p>This looks quite good! But I think my <code>α</code> can be more general than a set. And in general I would like the coercion stuff to go smoothly as I'm basically introducing coercions everywhere.</p>



<a name="237396624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396624">(May 04 2021 at 20:58)</a>:</h4>
<p>I think it's pretty unusual to require a <code>has_coe</code> typeclass in another definition</p>



<a name="237396687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237396687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237396687">(May 04 2021 at 20:59)</a>:</h4>
<p>Does that mean I am doing my definition wrong? Do you have any workaround?</p>



<a name="237397250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237397250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237397250">(May 04 2021 at 21:01)</a>:</h4>
<p>If you go down your current path you'll need a new <code>coe_monotone</code> typeclass</p>



<a name="237397352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237397352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237397352">(May 04 2021 at 21:01)</a>:</h4>
<p>And likely some others</p>



<a name="237397528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237397528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237397528">(May 04 2021 at 21:02)</a>:</h4>
<p>Yeah... I had assumed they already existed because it sounds sensible to have them.</p>



<a name="237397712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237397712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237397712">(May 04 2021 at 21:02)</a>:</h4>
<p>What other objects are you thinking of that aren't set-like?</p>



<a name="237398365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237398365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237398365">(May 04 2021 at 21:05)</a>:</h4>
<p>This sounds very <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a></p>



<a name="237398464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237398464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237398464">(May 04 2021 at 21:05)</a>:</h4>
<p>What about the radical of a natural? Or do we think of it as a multiset of its prime factors?</p>



<a name="237398954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237398954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237398954">(May 04 2021 at 21:07)</a>:</h4>
<p>I must say that I can't really think of an example where <code>set_like</code> wouldn't apply. But then I'm still worried about the amount of norm casting I would introduce.</p>



<a name="237400683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237400683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237400683">(May 04 2021 at 21:15)</a>:</h4>
<p>I mean, I'm virtually talking about ALL closure operators across mathlib. Surely we don't want to deal with <code>norm_cast</code> that often when the instance system could take care of it for us.</p>



<a name="237401387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237401387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237401387">(May 04 2021 at 21:18)</a>:</h4>
<p>You're talking about all closure operators <em>for which one direction is always spelled <code>coe</code></em>, right?</p>



<a name="237401632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237401632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237401632">(May 04 2021 at 21:20)</a>:</h4>
<p>What makes those more interesting than closure operators which are spelt with a different function name?</p>



<a name="237401960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237401960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237401960">(May 04 2021 at 21:21)</a>:</h4>
<p>More or less. I noticed that I could unify bundled and unbundled closure operators (where the bundling refers to their output) if only I could make Lean use <code>id </code> as a coercion from <code>α</code> to <code>α</code> when <code>α = β</code>.</p>



<a name="237402231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237402231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237402231">(May 04 2021 at 21:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion/near/237401632">said</a>:</p>
<blockquote>
<p>What makes those more interesting than closure operators which are spelt with a different function name?</p>
</blockquote>
<p>You mean <code>affine_span</code>/<code>span_points</code>, for example? I thought it would simplify the API by reducing the amount of duplication that goes into such an approach.</p>



<a name="237402479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237402479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237402479">(May 04 2021 at 21:23)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/affine_span">docs#affine_span</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/span_points">docs#span_points</a>?</p>



<a name="237403192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237403192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237403192">(May 04 2021 at 21:26)</a>:</h4>
<p>Are there any interesting closure operators that do use coe but aren't set_like (ie, don't have a compatible has_mem)</p>



<a name="237404037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237404037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237404037">(May 04 2021 at 21:34)</a>:</h4>
<p>I can't think of any.</p>



<a name="237445001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237445001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237445001">(May 05 2021 at 06:01)</a>:</h4>
<p>Actually I think the cleanest thing to do is to just ditch the ordering on <code>beta</code> and go full coercion. I still have the problem with <code>alpha = beta</code> but at worst this could be solved by defining another structure called <code>endo_closure_operator</code> or something.</p>



<a name="237445299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237445299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237445299">(May 05 2021 at 06:04)</a>:</h4>
<p>Why not just use a function <code>f</code>? I don't see why it has to be a coercion</p>



<a name="237446053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237446053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237446053">(May 05 2021 at 06:16)</a>:</h4>
<p>The whole point is that, for example, the subgroup closure of a set will be a subgroup, which can be coerced back to a set.</p>



<a name="237446646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237446646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237446646">(May 05 2021 at 06:25)</a>:</h4>
<p>yes, that coercion is a function</p>



<a name="237446665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237446665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237446665">(May 05 2021 at 06:25)</a>:</h4>
<p>if you want to be generic over possible closure systems then you should use a function, like is done with galois insertions</p>



<a name="237446905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237446905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237446905">(May 05 2021 at 06:29)</a>:</h4>
<p>Hmm, that's interesting. If I then feed a coercion as the function, will it automatically appear with up arrows in the pretty print?</p>



<a name="237447614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237447614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237447614">(May 05 2021 at 06:38)</a>:</h4>
<p>Also, if I feed in <code>id</code>, will it simplify it automatically?</p>



<a name="237450591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237450591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237450591">(May 05 2021 at 07:11)</a>:</h4>
<p>No, but you can use simp lemmas to clean up the expression</p>



<a name="237450632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237450632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237450632">(May 05 2021 at 07:11)</a>:</h4>
<p>you need such a thing anyway for applying a typeclass function on a particular instance</p>



<a name="237450746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237450746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237450746">(May 05 2021 at 07:13)</a>:</h4>
<p>Actually yes to the first thing: if you use <code>coe</code> as the function <code>coe x</code> will be in the expression and this gets displayed as <code>\u x</code>. But <code>id x</code> is not displayed as <code>x</code></p>



<a name="237450801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237450801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237450801">(May 05 2021 at 07:13)</a>:</h4>
<p>Okay well. It appears that what I want to do is really a Galois insertion, but bundled.</p>



<a name="237451272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237451272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237451272">(May 05 2021 at 07:18)</a>:</h4>
<p>In that case, you will have a special map associated to your structure, like <code>closure_operator.to_fun</code>, and there should be simp lemmas like <code>closure_operator.to_fun (set X) x = x</code>, <code>closure_operator.to_fun (subgroup X) x = \u x</code>, and so on</p>



<a name="237451352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237451352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237451352">(May 05 2021 at 07:19)</a>:</h4>
<p>A galois insertion bundling both <code>l</code> and <code>u</code> or just one of them?</p>



<a name="237452449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237452449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237452449">(May 05 2021 at 07:30)</a>:</h4>
<p>Both I'd say. I want <code>c : closure_operator a b</code> to coerce to <code>l : a -&gt; b</code>, but I also want any term of <code>b</code> to go through <code>u : b -&gt; a</code> when stating inequalities. In practice, <code>u</code> will be the coercion from <code>b</code> to <code>a</code> most of the time.</p>



<a name="237452610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237452610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237452610">(May 05 2021 at 07:32)</a>:</h4>
<p>I really feel like people here have thought harder about that than I did. But I still think there's something to be done about the way it is set up.</p>



<a name="237452892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237452892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237452892">(May 05 2021 at 07:34)</a>:</h4>
<p>We shouldn't have both <code>span_points</code> and <code>affine_span</code>. Only the latter ought to exist. And lemmas about closure operators should be accessible by dot notation: the proof of <code>subset_affine_span</code> should be <code>affine_span.le_closure</code>.</p>



<a name="237453056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237453056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237453056">(May 05 2021 at 07:36)</a>:</h4>
<p>What I want is to bundle the current closure operators we have with the information that they are in fact closure operators, and that through a structure that would support dot notation.</p>



<a name="237453914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237453914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237453914">(May 05 2021 at 07:44)</a>:</h4>
<p>This bundled structure would require as inputs: the closure operation so to speak <code>l : a -&gt; b</code>, the operation to get back to the original type <code>u : b -&gt; a</code>, the proof that <code>u o l</code> is inflationary, the proof that <code>u o l</code> is idempotent.</p>



<a name="237454573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237454573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237454573">(May 05 2021 at 07:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion/near/237451352">said</a>:</p>
<blockquote>
<p>A galois insertion bundling both <code>l</code> and <code>u</code> or just one of them?</p>
</blockquote>
<p>To be precise here, I'm suggesting the choice between these two:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.galois_connection</span>

<span class="kd">structure</span> <span class="n">fully_bundled</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">gc</span> <span class="o">:</span> <span class="n">galois_connection</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">partially_bundled</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">gc</span> <span class="o">:</span> <span class="n">galois_connection</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span>
</code></pre></div>



<a name="237454795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237454795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237454795">(May 05 2021 at 07:52)</a>:</h4>
<p><code>closure</code> could then have type <code>fully_bundled (subgroup G) (set G)</code> or <code>partially_bundled (coe : subgroup G → set G)</code></p>



<a name="237455126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455126">(May 05 2021 at 07:55)</a>:</h4>
<p>I think <code>fully_bundled</code> makes more sense here given the aim</p>



<a name="237455251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455251">(May 05 2021 at 07:56)</a>:</h4>
<p>That's what I think too. But there's not much difference functionally?</p>



<a name="237455402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455402">(May 05 2021 at 07:58)</a>:</h4>
<p>The types would be slightly different but it doesn't matter much as we'll define concrete terms.</p>



<a name="237455455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455455">(May 05 2021 at 07:58)</a>:</h4>
<p>the advantage of the partially bundled approach, or parameters more generally, is that you will not have to rewrite a term: in the lemma about <code>u (l x) = x</code>, when you apply that with <code>partially_bundled</code> it looks like <code>u (bundle.l x) = x</code> where <code>u</code> is whatever term you want, including <code>coe</code></p>



<a name="237455502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455502">(May 05 2021 at 07:59)</a>:</h4>
<p>I think that is one of the reasons why galois insertion uses parameters for <code>l</code> and <code>u</code></p>



<a name="237455764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455764">(May 05 2021 at 08:01)</a>:</h4>
<p>Ah, I see. Well, no I don't really. But it sounds as if I could see.</p>



<a name="237455983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237455983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237455983">(May 05 2021 at 08:03)</a>:</h4>
<p>You still have to feed in both <code>u</code> and <code>l</code> at some point, right?</p>



<a name="237456167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237456167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237456167">(May 05 2021 at 08:05)</a>:</h4>
<p>What woild it look like with <code>fully_bundled</code>?</p>



<a name="237457141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237457141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237457141">(May 05 2021 at 08:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.galois_connection</span>

<span class="kd">structure</span> <span class="n">fully_bundled</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">partially_bundled</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">fully_bundled.l_u</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">bu</span> <span class="o">:</span> <span class="n">fully_bundled</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">bu.l</span> <span class="o">(</span><span class="n">bu.u</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">bu.gi.l_u_eq</span> <span class="n">x</span>

<span class="kd">theorem</span> <span class="n">partially_bundled.l_u</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">bu</span> <span class="o">:</span> <span class="n">partially_bundled</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">bu.l</span> <span class="o">(</span><span class="n">u</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">bu.gi.l_u_eq</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">foo</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">bar</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">bar</span> <span class="n">foo</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">span</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">bar</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">gi</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="n">span</span> <span class="n">coe</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">full</span> <span class="o">:</span> <span class="n">fully_bundled</span> <span class="n">foo</span> <span class="n">bar</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">span</span><span class="o">,</span>
  <span class="n">u</span> <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">gi</span> <span class="o">:=</span> <span class="n">gi</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">full_l</span> <span class="o">:</span> <span class="n">full.l</span> <span class="bp">=</span> <span class="n">span</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">full_u</span> <span class="o">:</span> <span class="n">full.u</span> <span class="bp">=</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">part</span> <span class="o">:</span> <span class="n">partially_bundled</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">bar</span> <span class="bp">→</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">span</span><span class="o">,</span>
  <span class="n">gi</span> <span class="o">:=</span> <span class="n">gi</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">part_l</span> <span class="o">:</span> <span class="n">part.l</span> <span class="bp">=</span> <span class="n">span</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h_full</span> <span class="o">:=</span> <span class="n">full.l_u</span><span class="o">,</span> <span class="c1">-- ∀ (x : bar), full.l (full.u x) = x</span>
  <span class="k">have</span> <span class="n">h_part</span> <span class="o">:=</span> <span class="n">part.l_u</span><span class="o">,</span> <span class="c1">-- ∀ (x : bar), part.l ↑x = x</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h_full</span> <span class="n">h_part</span><span class="o">,</span>
  <span class="c1">-- both are now ∀ (x : bar), span ↑x = x</span>
<span class="kd">end</span>
</code></pre></div>



<a name="237468030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237468030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237468030">(May 05 2021 at 09:47)</a>:</h4>
<p>My intuition says you want this partially bundled, so that you can instantiate <code>α := set α</code> and <code>u := coe : β → set α</code>, so you can state lemmas along the lines of:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">subset_closure</span> <span class="o">[</span><span class="n">set_like</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="n">closure_operator</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">closure</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">c.gi.gc.le_u</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>



<a name="237586355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/237586355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#237586355">(May 06 2021 at 00:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion/near/237452892">said</a>:</p>
<blockquote>
<p>We shouldn't have both <code>span_points</code> and <code>affine_span</code>. Only the latter ought to exist. And lemmas about closure operators should be accessible by dot notation: the proof of <code>subset_affine_span</code> should be <code>affine_span.le_closure</code>.</p>
</blockquote>
<p>The purpose of <code>span_points</code> is really (a) as a detail of how <code>affine_span</code> is implemented, which might go away with some more general infrastructure handling closure operators, and (b) as an explicit description of what points are in the affine span, in relation to <code>vector_span</code>. The latter is still relevant in the presence of more general infrastructure, though maybe as a lemma rather than a definition.</p>
<p>(Lemmas about <code>span_points</code> should have corresponding <code>affine_span</code> lemmas, but I'm not sure they all do at present. Anything that uses a <code>span_points</code> lemma in a context where it actually has an <code>affine_span</code> ought to be fixed to avoid that abuse of defeq and use an <code>affine_span</code> lemma instead, independent of any more general refactoring of closure operators.)</p>



<a name="238172203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20coercion/near/238172203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20coercion.html#238172203">(May 10 2021 at 16:33)</a>:</h4>
<p>Wait, let's move to <a href="#narrow/stream/113488-general/topic/Closure.20operators">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Closure.20operators</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html">submodule.sup basic lemma</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273779410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273779410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273779410">(Mar 02 2022 at 09:40)</a>:</h4>
<p>I'm not able to find</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basic</span>

<span class="kn">open</span> <span class="n">submodule</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₂</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">{</span><span class="n">σ₁₂</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R₂</span><span class="o">}</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R₂</span> <span class="n">M₂</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">submodule.sup_eq_span_union</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊔</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">span_union</span><span class="o">,</span> <span class="n">span_eq</span> <span class="n">s</span><span class="o">,</span> <span class="n">span_eq</span> <span class="n">t</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">linear_map.eq_on_sup</span>  <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₁₂</span><span class="o">]</span> <span class="n">M₂</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">⊔</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">linear_map.eq_on_span</span> <span class="o">(</span><span class="k">show</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span><span class="bp">|</span><span class="n">h</span><span class="o">)</span> <span class="bp">;</span> <span class="n">tauto</span> <span class="o">})</span>
  <span class="o">((</span><span class="n">s.sup_eq_span_union</span> <span class="n">t</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">hx</span><span class="o">)</span>
</code></pre></div>
<p>Am I missing something?</p>



<a name="273780151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273780151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273780151">(Mar 02 2022 at 09:48)</a>:</h4>
<p>The first lemma strikes me as a bit specialized, unless we already have something analogous for supr</p>



<a name="273780242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273780242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273780242">(Mar 02 2022 at 09:49)</a>:</h4>
<p>The second feels like it might be nice to also have stated as an <code>ext</code> lemma for <code>f g : s ⊔ t →ₗ M</code>, with hypotheses <code>f.comp (submodule.of_le le_sup_left) = g.comp (submodule.of_le le_sup_left)</code> and similar for <code>right</code></p>



<a name="273780592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273780592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273780592">(Mar 02 2022 at 09:52)</a>:</h4>
<p>Probably we haven't bothered with many of these lemmas because <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.mem_sup">docs#submodule.mem_sup</a> is easy enough to use.</p>



<a name="273781819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273781819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273781819">(Mar 02 2022 at 10:01)</a>:</h4>
<p>Do we have <code>span_union</code> in the form <code>span (a ∪ b) = span a ⊔ span b</code>? This is true for lots of subobjects</p>



<a name="273782184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273782184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273782184">(Mar 02 2022 at 10:04)</a>:</h4>
<p>Yes Kevin, span_union already says that.</p>



<a name="273782254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273782254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273782254">(Mar 02 2022 at 10:05)</a>:</h4>
<p>Eric, I'm not convinced at all by your arguments, and the variation you suggest would be a lot less convenient to use (and we indeed already have the supr version). So I'm going to PR that at some point (it will first go to the sphere eversion project).</p>



<a name="273786633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273786633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273786633">(Mar 02 2022 at 10:43)</a>:</h4>
<p>We don't appear to have <code>linear_map.eq_on_supr</code>, unless if has another name</p>



<a name="273786728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/submodule.sup%20basic%20lemma/near/273786728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/submodule.2Esup.20basic.20lemma.html#273786728">(Mar 02 2022 at 10:44)</a>:</h4>
<p>But you're right, <a href="https://leanprover-community.github.io/mathlib_docs/find/supr_eq_span">docs#supr_eq_span</a> (<code>_Union</code>) does exist. Perhaps we should rename it to match your suggested <code>sup_eq_span_union</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
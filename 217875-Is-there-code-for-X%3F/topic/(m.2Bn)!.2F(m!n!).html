---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html">(m+n)!/(m!n!)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220798362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220798362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220798362">(Dec 23 2020 at 15:29)</a>:</h4>
<p>Do we have <code>f : nat -&gt; nat -&gt; nat</code> defined by <code>f m n := (m + n).choose n</code>? I've been refactoring Bernoulli numbers and I've been working with binomial coefficients <code>n.choose k</code> a lot. One is forever having to carry around a proof of <code>k &lt;= n</code> to ensure that the coefficient does not have pathological behaviour, the basic "symmetry" <code>n.choose k = n.choose (n - k)</code> needs it. And the rewrite lemmas are ugly e.g. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">choose_mul_succ_eq</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">n.choose</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>-- ugh. Is that even the best form? I think <code>(n - k + 1)</code> would be easier to work with because if you have <code>n.choose k</code> then you almost certainly have a proof of <code>k &lt;= n</code> in your context because you need it to do anything. But actually this just a clue that the corresponding theorem for <code>f</code> above will be more beautiful, and indeed it is. Currently Bernoullli numbers are defined in terms of <code>choose</code> but they would be easier to work with, I suspect, if I refactor the entire file and replace the definition with <code>f</code>. What is its name?</p>



<a name="220798928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220798928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220798928">(Dec 23 2020 at 15:35)</a>:</h4>
<p>I think I might be saying that there is an argument for interpreting the binomial theorem <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>n</mi><mi>i</mi></mfrac><mo fence="true">)</mo></mrow><msup><mi>X</mi><mi>i</mi></msup><msup><mi>Y</mi><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(X+Y)^n=\sum_{i=0}^n\binom niX^iY^{n-i}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7453919999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></span> as actually a sum over <code>i : nat.antidiagonal n</code> of <code>f i.1 i.2 * X^i.1 * Y^i.2</code></p>



<a name="220799151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220799151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220799151">(Dec 23 2020 at 15:38)</a>:</h4>
<p>I think this is a good idea</p>



<a name="220799161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220799161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220799161">(Dec 23 2020 at 15:38)</a>:</h4>
<p>how about <code>binom'</code> as name?</p>



<a name="220799180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220799180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220799180">(Dec 23 2020 at 15:38)</a>:</h4>
<p>the <code>'</code> should be a warning sign that it's not exactly <code>binom</code></p>



<a name="220800790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220800790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220800790">(Dec 23 2020 at 15:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">choose_succ_succ</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">choose</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">choose</span> <span class="n">n</span> <span class="n">k</span> <span class="bp">+</span> <span class="n">choose</span> <span class="n">n</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">bryan_succ_succ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">bryan</span> <span class="n">a.succ</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="n">bryan</span> <span class="n">a</span> <span class="n">b.succ</span> <span class="bp">+</span> <span class="n">bryan</span> <span class="n">a.succ</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>Bryan wins hands down. This must be some standard function in quantum stuff.</p>



<a name="220802514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220802514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220802514">(Dec 23 2020 at 16:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bryan</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">_</span>     <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">bryan</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">bryan</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">b</span>

<span class="kd">lemma</span> <span class="n">bryan_eq_choose</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">bryan</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="o">)</span> <span class="n">b</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="mi">0</span>     <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat.choose_self</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">bryan</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">bryan</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">b</span>
    <span class="bp">=</span> <span class="n">nat.choose</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">nat.choose</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="bp">+</span><span class="n">b</span><span class="o">)</span> <span class="n">b</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">bryan_eq_choose</span><span class="o">,</span> <span class="n">bryan_eq_choose</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="bp">+</span><span class="n">b</span><span class="o">)</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat.choose</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="bp">+</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">add_right_comm</span><span class="o">]</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">nat.choose</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="bp">+</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
</code></pre></div>



<a name="220802827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220802827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220802827">(Dec 23 2020 at 16:21)</a>:</h4>
<p>I don't know who Bryan is, but these coefficients show up in the multiplication table of divided power polynomial algebras. Maybe we can derive a name from that?</p>



<a name="220803568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220803568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220803568">(Dec 23 2020 at 16:29)</a>:</h4>
<p>how about we call the function <code>pascal</code>?</p>



<a name="220803598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220803598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220803598">(Dec 23 2020 at 16:29)</a>:</h4>
<p><code>pascal a b</code> is "<code>a</code> steps left, <code>b</code> steps right" in Pascal's triangle.</p>



<a name="220804431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220804431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220804431">(Dec 23 2020 at 16:38)</a>:</h4>
<p>I don't know. I would prefer <code>binom'</code> over <code>pascal</code>. Maybe <code>binom_symm</code> to emphasize that it's a symmetric version of <code>binom</code>?</p>



<a name="220804629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220804629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220804629">(Dec 23 2020 at 16:40)</a>:</h4>
<p>What about a generalization, <code>list.multinomial : list ℕ → ℕ</code> where <code>[c1, ..., cn].multinomial</code> is the coefficient of <code>x1^c1 * ... * xn^cn</code> in <code>(x1 + ... + xn)^(c1 + ... + cn)</code>?  Then <code>bryan a b = [a, b].multinomial</code>.</p>



<a name="220805125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220805125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220805125">(Dec 23 2020 at 16:46)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, your proposed <code>list.multinomial</code> is invariant to the order of the list, right? So maybe <code>multiset.multinomial</code> or perhaps a function <code>(ι → ℕ) → ℕ</code> would also make sense, then it would be <code>multinomial ![a, b]</code></p>



<a name="220805295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220805295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220805295">(Dec 23 2020 at 16:48)</a>:</h4>
<p>Indeed, it's invariant under <code>list.perm</code>, so it descends to <code>multiset</code>.  With <code>(ι → ℕ) → ℕ</code>, were you thinking that this is whenever <code>ι</code> is a <code>fintype</code>?</p>



<a name="220805367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220805367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220805367">(Dec 23 2020 at 16:49)</a>:</h4>
<p>Or you could use <code>finsupp</code></p>



<a name="220805395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220805395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220805395">(Dec 23 2020 at 16:50)</a>:</h4>
<p>This way the formula could be used in a polynomial ring generated by an arbitrary type :)</p>



<a name="220805513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220805513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220805513">(Dec 23 2020 at 16:50)</a>:</h4>
<p>I guess this general binomial formula should be in mathlib anyway</p>



<a name="220808205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220808205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220808205">(Dec 23 2020 at 17:18)</a>:</h4>
<p>Johan suggests <code>pascal</code> which I think is a lovely name if we can't get one. I asked on Twitter . Here's a basic API (with proofs, but it would probably be easier to prove everything from first principles if there is a need):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- pascal</span>

<span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="n">open_locale</span> <span class="n">nat</span>

<span class="kn">namespace</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">pascal</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">theorem</span> <span class="n">pascal_def</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="o">(</span><span class="n">a</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">!</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">pascal</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">choose_eq_factorial_div_factorial</span> <span class="o">(</span><span class="n">le.intro</span> <span class="n">rfl</span><span class="o">)]</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">pascal_spec</span> <span class="o">:</span> <span class="n">a</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">!</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">pascal</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">choose_mul_factorial_mul_factorial</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat.sub_eq_of_eq_add</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">]}</span>

<span class="kd">theorem</span> <span class="n">pascal_symm</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">pascal</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pascal_def</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_zero_right</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">choose_self</span> <span class="n">n</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_zero_left</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pascal_symm</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">▸</span> <span class="n">pascal_zero_right</span> <span class="n">n</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_one_left</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="mi">1</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">pascal</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">choose_one_right</span> <span class="n">n.succ</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">add_comm</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_one_right</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">n</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pascal_symm</span> <span class="mi">1</span> <span class="n">n</span> <span class="bp">▸</span> <span class="n">pascal_one_left</span> <span class="n">n</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_succ_succ</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">a.succ</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b.succ</span> <span class="bp">+</span> <span class="n">pascal</span> <span class="n">a.succ</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">pascal</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">choose_succ_succ</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a</span> <span class="n">using</span> <span class="mi">3</span><span class="bp">;</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">succ_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">succ_eq_add_one</span> <span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_two_left'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="mi">2</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="bp">*</span> <span class="n">n.succ.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_succ_succ</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">pascal_one_left</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_succ</span><span class="o">,</span> <span class="bp">←</span> <span class="n">succ_eq_add_one</span><span class="o">,</span> <span class="n">succ_mul</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mul_succ</span><span class="o">,</span> <span class="n">succ_mul</span><span class="o">,</span> <span class="n">succ_eq_add_one</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pascal_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">choose_pos</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">le.intro</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">succ_mul_pascal</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a.succ</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">pascal</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a.succ</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">succ_mul_choose_eq</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">succ_add</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">succ_mul_pascal'</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b.succ</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b.succ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_symm</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">succ_mul_pascal</span><span class="o">,</span> <span class="n">pascal_symm</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">succ_mul_pascal''</span> <span class="o">:</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a.succ</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b.succ</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b.succ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">succ_mul_pascal</span><span class="o">,</span> <span class="n">succ_mul_pascal'</span><span class="o">]</span>

<span class="c1">-- this is strictly stronger than choose_le_succ_of_lt_half_left (edge cases)</span>
<span class="kd">lemma</span> <span class="n">pascal_succ_le</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b.succ</span> <span class="bp">&lt;=</span> <span class="n">pascal</span> <span class="n">a.succ</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">_root_.mul_le_mul_left</span>
    <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a.succ</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b.succ</span><span class="bp">!</span><span class="o">,</span> <span class="k">from</span> <span class="n">mul_pos</span> <span class="o">(</span><span class="n">factorial_pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">factorial_pos</span> <span class="n">_</span><span class="o">)),</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b.succ</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b.succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">b.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a.succ</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">pascal</span> <span class="n">a.succ</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">convert</span> <span class="n">this</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">factorial_succ</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">factorial_succ</span> <span class="n">b</span><span class="o">,</span> <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_spec</span><span class="o">,</span> <span class="n">pascal_spec</span><span class="o">,</span> <span class="n">succ_add</span><span class="o">,</span> <span class="n">add_succ</span><span class="o">],</span>
    <span class="n">mono</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">zero_le</span> <span class="n">_</span><span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">succ_le_succ</span> <span class="n">h</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pascal_le_middle</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">pascal</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">-</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">nat</span>
</code></pre></div>



<a name="220808240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220808240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220808240">(Dec 23 2020 at 17:19)</a>:</h4>
<p>PS I had to import <code>tactic</code> because I am lazy.</p>



<a name="220808405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220808405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220808405">(Dec 23 2020 at 17:21)</a>:</h4>
<p>I think there's something in <code>data.nat.choose</code> which should make the last proof easier, possibly</p>



<a name="220808423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220808423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220808423">(Dec 23 2020 at 17:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">choose_le_middle</span> <span class="o">(</span><span class="n">r</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">choose</span> <span class="n">n</span> <span class="n">r</span> <span class="bp">≤</span> <span class="n">choose</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>



<a name="220811095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220811095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220811095">(Dec 23 2020 at 17:49)</a>:</h4>
<p>If you commit to always writing <code>(a+b).choose a</code>, does there need to be a special name for it?  Argument duplication is certainly annoying, but it seems like <code>pascal</code> would lead to API duplication.</p>
<p>I don't know how it looks for the Bernoulli number refactoring, but at least in the code you gave, writing the expanded version seems like it might be ok (except for the last lemma):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.choose.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="n">open_locale</span> <span class="n">nat</span>

<span class="kn">namespace</span> <span class="n">nat</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">theorem</span> <span class="n">pascal_def</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">!</span> <span class="bp">/</span> <span class="o">(</span><span class="n">a</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">!</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">choose_eq_factorial_div_factorial</span> <span class="o">(</span><span class="n">le.intro</span> <span class="n">rfl</span><span class="o">)]</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">pascal_spec</span> <span class="o">:</span> <span class="n">a</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">!</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">!</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">choose_mul_factorial_mul_factorial</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
     <span class="n">rw</span> <span class="o">[</span><span class="n">nat.sub_eq_of_eq_add</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">]}</span>

<span class="kd">theorem</span> <span class="n">pascal_symm</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_def</span><span class="o">,</span> <span class="n">pascal_def</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">b</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_zero_right</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">choose_self</span> <span class="n">n</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_zero_left</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">pascal_symm</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">▸</span> <span class="n">pascal_zero_right</span> <span class="n">n</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_one_left</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">choose_one_right</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">apply</span> <span class="n">add_comm</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_one_right</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">pascal_symm</span> <span class="mi">1</span> <span class="n">n</span> <span class="bp">▸</span> <span class="n">pascal_one_left</span> <span class="n">n</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_succ_succ</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">a.succ</span> <span class="bp">+</span> <span class="n">b.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a.succ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a.succ</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a.succ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">choose_succ_succ</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a</span> <span class="n">using</span> <span class="mi">3</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">succ_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">succ_eq_add_one</span> <span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pascal_two_left'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="mi">2</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="bp">*</span> <span class="n">n.succ.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_succ_succ</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">pascal_one_left</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_succ</span><span class="o">,</span> <span class="bp">←</span> <span class="n">succ_eq_add_one</span><span class="o">,</span> <span class="n">succ_mul</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mul_succ</span><span class="o">,</span> <span class="n">succ_mul</span><span class="o">,</span> <span class="n">succ_eq_add_one</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pascal_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">choose_pos</span> <span class="o">(</span><span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">le.intro</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">succ_mul_pascal</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a.succ</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a.succ</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">succ_mul_choose_eq</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">succ_add</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">succ_mul_pascal'</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_symm</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">succ_mul_pascal</span><span class="o">,</span> <span class="n">pascal_symm</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">succ_mul_pascal''</span> <span class="o">:</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a.succ</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a.succ</span> <span class="bp">=</span> <span class="n">b.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">succ_mul_pascal</span><span class="o">,</span> <span class="n">succ_mul_pascal'</span><span class="o">]</span>

<span class="c1">-- this is strictly stronger than choose_le_succ_of_lt_half_left (edge cases)</span>
<span class="kd">lemma</span> <span class="n">pascal_succ_le</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">&lt;=</span> <span class="o">(</span><span class="n">a.succ</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">_root_.mul_le_mul_left</span>
    <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a.succ</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b.succ</span><span class="bp">!</span><span class="o">,</span> <span class="k">from</span> <span class="n">mul_pos</span> <span class="o">(</span><span class="n">factorial_pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">factorial_pos</span> <span class="n">_</span><span class="o">)),</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b.succ</span><span class="bp">!</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">b.succ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a.succ</span><span class="bp">!</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">!</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a.succ</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a.succ</span><span class="o">),</span>
  <span class="n">convert</span> <span class="n">this</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">factorial_succ</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">factorial_succ</span> <span class="n">b</span><span class="o">,</span> <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pascal_spec</span><span class="o">,</span> <span class="n">pascal_spec</span><span class="o">,</span> <span class="n">succ_add</span><span class="o">,</span> <span class="n">add_succ</span><span class="o">],</span>
    <span class="n">mono</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">zero_le</span> <span class="n">_</span><span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">succ_le_succ</span> <span class="n">h</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">pascal_le_middle</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="bp">≤</span> <span class="o">(((</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">+</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">-</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)))</span><span class="bp">.</span><span class="n">choose</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">nat</span>
</code></pre></div>



<a name="220811333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220811333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220811333">(Dec 23 2020 at 17:52)</a>:</h4>
<p>I think the frustration is that you keep needing to prove <code>a &lt;= a + b</code> each time, but an api for <code>pascal</code> wouldn't need this (correct me if I'm wrong Kevin!)</p>



<a name="220813308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220813308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220813308">(Dec 23 2020 at 18:14)</a>:</h4>
<p>This is the correct thing to prove (and it works for me):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">pascal_le_middle</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">pascal</span> <span class="n">a</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">pascal</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">le_iff_exists_add</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span> <span class="n">hm</span> <span class="n">generalizing</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hn_1</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">succ_inj'</span><span class="o">,</span> <span class="n">hn_1</span><span class="o">,</span> <span class="n">add_succ</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">succ_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add_succ</span><span class="o">]</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">hn</span> <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_succ</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">h2</span> <span class="o">(</span><span class="n">le_succ</span> <span class="n">_</span><span class="o">)))</span> <span class="n">h3</span> <span class="n">hb</span><span class="o">)</span>
    <span class="o">(</span><span class="n">pascal_succ_le</span> <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">le_succ</span> <span class="n">_</span><span class="o">)</span> <span class="n">h2</span><span class="o">)),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220813568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220813568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220813568">(Dec 23 2020 at 18:17)</a>:</h4>
<p>Yes this is exactly the issue. When dealing with "trivial" statements about n choose k which follow immediately from the expression in terms of factorials and basic stuff like <code>factorial_succ</code>, you are forever hobbling along because any e.g. casts you're doing won't do <code>sub</code> unless you explicitly tell them to by feeding in the relevant inequality. The API has come out beautifully. <code>choose</code> is defined as junk values if k &gt; n but I think restricting the domain like this gives in some sense a more fundamental function.</p>



<a name="220815103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220815103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220815103">(Dec 23 2020 at 18:34)</a>:</h4>
<p>And furthermore I claim that if I define <code>Bernoulli</code> using <code>pascal</code> instead of <code>choose</code> then my proofs will be nicer.</p>



<a name="220815250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220815250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220815250">(Dec 23 2020 at 18:35)</a>:</h4>
<p>OK I've pushed a branch <code>binomial</code>. I've build the API mostly from the <code>choose</code> API but I strongly suspect it would have been easier to build it from the ground up, as it's much easier to steer than <code>choose</code>.</p>



<a name="220819355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220819355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220819355">(Dec 23 2020 at 19:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(m.2Bn)!.2F(m!n!)/near/220813568">said</a>:</p>
<blockquote>
<p>Yes this is exactly the issue. When dealing with "trivial" statements about n choose k which follow immediately from the expression in terms of factorials and basic stuff like <code>factorial_succ</code>, you are forever hobbling along because any e.g. casts you're doing won't do <code>sub</code> unless you explicitly tell them to by feeding in the relevant inequality. The API has come out beautifully. <code>choose</code> is defined as junk values if k &gt; n but I think restricting the domain like this gives in some sense a more fundamental function.</p>
</blockquote>
<p>The thing I'm wondering about is what <code>binomial</code>/<code>pascal</code> gives you that a bunch of lemmas about expressions of the form <code>(a+b).choose a</code> wouldn't?  All I'm really able to see is that you don't have to write the <code>a</code> argument twice.</p>
<p>Secondly (and more importantly), if you're going through the effort of defining <code>pascal</code>, why not do the natural generalization to the multinomial coefficient?  This is probably not the best way to define it, but there's at least</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">list.multinomial</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">m.sum</span><span class="bp">!</span> <span class="bp">/</span> <span class="o">(</span><span class="n">m.map</span> <span class="n">nat.factorial</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span>

<span class="kd">lemma</span> <span class="n">multinomial_eq_choose</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span><span class="bp">.</span><span class="n">multinomial</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">choose</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.multinomial</span><span class="o">,</span> <span class="n">nat.choose_eq_factorial_div_factorial</span> <span class="o">(</span><span class="n">nat.le.intro</span> <span class="n">rfl</span><span class="o">)]</span>
</code></pre></div>



<a name="220820078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220820078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220820078">(Dec 23 2020 at 19:32)</a>:</h4>
<p>(I'm not against <code>binomial</code> -- I wish this is what mathematicians used rather than <code>choose</code> -- but I'm worrying that <code>binomial</code> is "just" <code>choose</code>, and it will end up involving lots of duplication of the API since you would need to unfold the definition to rewrite.)</p>



<a name="220836880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220836880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220836880">(Dec 23 2020 at 23:37)</a>:</h4>
<p>The problem is that in practice you get <code>n.choose k</code> and a proof that <code>k &lt;= n</code> and this is just harder to deal with. The lemmas with <code>(a+b).choose a</code> are nice, but they force the user to get their binomial coefficients into this form. if your "default" API is <code>binomial</code> instead of <code>choose</code> then your proofs are shorter because the API is more natural.</p>



<a name="220839810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220839810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220839810">(Dec 24 2020 at 00:29)</a>:</h4>
<p>Is there some reason though to define <code>binomial a b</code> rather than <code>[a, b].multinomial</code> or something similar?  I was thinking that <code>multinomial</code> would be a useful generalization to have, it's not much more complex to define, and it seems to have the properties that you want.</p>



<a name="220839897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220839897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220839897">(Dec 24 2020 at 00:30)</a>:</h4>
<p>Yeah that would be fine</p>



<a name="220850768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220850768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220850768">(Dec 24 2020 at 05:51)</a>:</h4>
<p>off-topic: I think the binomial polynomial is nice to have, i.e. <code>x.choose k</code> where <code>k</code> is a natural number and <code>x</code> is an element of a ring on which <code>k!</code> is invertible</p>



<a name="220850833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220850833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220850833">(Dec 24 2020 at 05:53)</a>:</h4>
<p>sometimes <code>k!</code> is invertible is not necessary, for example <code>x.choose k</code> can be defined for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex"> x\in\mathbb{Z}_p </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.974998em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="220859788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220859788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220859788">(Dec 24 2020 at 09:49)</a>:</h4>
<p>Yes I agree, we will need this very soon in a project a student of mine is working on</p>



<a name="220873005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220873005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220873005">(Dec 24 2020 at 14:31)</a>:</h4>
<p>It would be a nice project to formalize the classification of integer values polynomials <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="220874177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220874177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220874177">(Dec 24 2020 at 14:56)</a>:</h4>
<p>That would need Jz Pan's generalisation of <code>choose</code>. In fact there are some subtleties there. As they point out, binomial coefficients can be evaluated if n is a p-adic integer but this isn't true for eg the Witt vectors of a field with p^2 elements.</p>



<a name="220874410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220874410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220874410">(Dec 24 2020 at 15:01)</a>:</h4>
<p>There's a generalization of the integer valued stuff to rings of integers of number fields here:<br>
<a href="http://www.ma.huji.ac.il/~deshalit/new_site/files/Integer-valued.pdf">http://www.ma.huji.ac.il/~deshalit/new_site/files/Integer-valued.pdf</a></p>



<a name="220874472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/220874472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#220874472">(Dec 24 2020 at 15:02)</a>:</h4>
<p>Yeah we need Lubin-Tate groups too! They're really fun and we have a lot of the framework available.</p>



<a name="221044572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/221044572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#221044572">(Dec 28 2020 at 07:43)</a>:</h4>
<p>... and local class field theory?</p>



<a name="221050928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/221050928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#221050928">(Dec 28 2020 at 10:08)</a>:</h4>
<p>Right</p>



<a name="221050947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/221050947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#221050947">(Dec 28 2020 at 10:09)</a>:</h4>
<p>I have a student who did group cohomology, we should start with the statements</p>



<a name="221064274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/221064274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#221064274">(Dec 28 2020 at 14:30)</a>:</h4>
<p>Seems to me that there are a LOT of prereqs to get done before one can even define the local reciprocity map...</p>



<a name="221065225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/221065225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#221065225">(Dec 28 2020 at 14:45)</a>:</h4>
<p>Yeah, but from where I'm standing they all look feasible.</p>



<a name="221065299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%28m%2Bn%29%21/%28m%21n%21%29/near/221065299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/(m.2Bn)!.2F(m!n!).html#221065299">(Dec 28 2020 at 14:46)</a>:</h4>
<p>I mean, making the type of the map, not making the map itself! The map itself will be hard work. But first one should state the theorem.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
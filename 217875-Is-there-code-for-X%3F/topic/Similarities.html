---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Similarities.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html">Similarities</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281605908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281605908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281605908">(May 08 2022 at 16:01)</a>:</h4>
<p><span class="user-mention" data-user-id="479299">@Jovan Gerbscheid</span> wrote a Python program which can solve moderately easy Euclidean geometry problems. I'm looking into what it would take to port it to Lean and the main blocking point is of course the scarcity of Euclidean geometry results in mathlib.</p>



<a name="281605947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281605947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281605947">(May 08 2022 at 16:02)</a>:</h4>
<p>We're thinking of first tackling triangle similarities. So I'm wondering whether we have the type of similarities (ratio-preserving maps) and the type of oriented similarities (oriented angle-preserving maps).</p>



<a name="281606095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281606095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281606095">(May 08 2022 at 16:05)</a>:</h4>
<p><span class="user-mention" data-user-id="266253">@Joseph Myers</span> is probably the most well-informed on the current state of Euclidean geometry in mathlib and might also have some comments on the best way forward.</p>



<a name="281606161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281606161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281606161">(May 08 2022 at 16:06)</a>:</h4>
<p>Ahah! I was about to send "cc <span class="user-mention silent" data-user-id="266253">Joseph Myers</span>"</p>



<a name="281607758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281607758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281607758">(May 08 2022 at 16:44)</a>:</h4>
<p>See <a href="#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/IMO.20Geometry">a recent discussion</a>. Pretty much everything about isometries in mathlib should generalise in some way to similarities (with the definition making sense in general metric spaces or indeed <code>pseudo_emetric_space</code>s; note that as in that discussion, many results for congruent or similar triangles should actually be stated for arbitrary indexed families of points, not for the special case of triangles), and a good starting point is probably applying the hom refactor to isometries so that lemmas that are true for all kinds of types for bundled similarities can then be stated for a single type class rather than separately for at least five types of bundled isometries and a corresponding five new types of bundled similarities. (Or more types if you also add types restricted to be orientation-preserving.)</p>
<p>One large group of trivial lemmas that we don't have is lemmas to transport various geometrical definitions across isometries / similarities. Pretty much every geometrical definition we have should transport across isometries and many also across similarities with appropriate scaling if the definition involves distance in some way.</p>
<p>Another fact I don't think we have is that a (not necessarily surjective) isometry of Euclidean spaces is an affine map (I did that some time ago outside of mathlib in the Euclidean context, but the appropriate form to add for mathlib would be stated for strictly convex spaces, which were added more recently).</p>



<a name="281608336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281608336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281608336">(May 08 2022 at 16:59)</a>:</h4>
<p>Ahah, I was trying to not get into refactoring isometries, but I guess the time has come. Can you explain me the naming convention around <a href="https://leanprover-community.github.io/mathlib_docs/find/isometric">docs#isometric</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/isometry">docs#isometry</a>? I would have swapped both names (or maybe renamed <code>isometry</code> to <code>is_isometry</code>).</p>



<a name="281625775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/281625775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#281625775">(May 09 2022 at 00:22)</a>:</h4>
<p><code>isometric</code> should be <code>isometry_equiv</code> to be consistent with <code>linear_isometry_equiv</code> and <code>affine_isometry_equiv</code>, unless there some other naming convention involved that I'm missing. We don't currently have a bundled type for not-necessarily-bijective isometries without additional properties such as linearity (but renaming <code>isometry</code> to <code>is_isometry</code> seems reasonable with or without adding such a bundled type).</p>



<a name="282543443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282543443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282543443">(May 16 2022 at 18:49)</a>:</h4>
<p>I will be trying to work on this soon as well. As I also asked in the other discussion, what exactly does "applying the hom refactor to isometries" mean? <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="282550165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282550165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282550165">(May 16 2022 at 19:42)</a>:</h4>
<p>Isometries survived both refactors so far, so I'm gonna change them to follow the latest design</p>



<a name="282550166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282550166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282550166">(May 16 2022 at 19:42)</a>:</h4>
<p>Oh that's technical. Originally, we had unbundled hom predicates/classes: "<code>f</code> is a function and <code>f</code> distributes over multiplication". Then we switched to bundled homs: "<code>f</code> is a group homomorphism". And now we added on top hom classes: "<code>ring_hom</code> is a type of group homomorphisms".</p>



<a name="282551514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282551514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282551514">(May 16 2022 at 19:53)</a>:</h4>
<p>Ah ok, I was aware of the bundled homs but not the top hom classes, thanks</p>



<a name="282556910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282556910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282556910">(May 16 2022 at 20:35)</a>:</h4>
<p>If you don't mind explaining, what led to these changes? (Or just link some relevant discussion lol.) Was it just to get rid of the duplicate code had to be rewritten every time a new hom-class was added? Were there downsides to this?</p>



<a name="282557109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282557109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282557109">(May 16 2022 at 20:37)</a>:</h4>
<p>Also, how soon do you plan on working on these refactors? Would you mind if I helped out? I don't really know what your plan would be though but I'd love to hear what you wanna do</p>



<a name="282562470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282562470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282562470">(May 16 2022 at 21:21)</a>:</h4>
<p>It's a matter of days now. I need to find some time in between my revisions.</p>



<a name="282629911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282629911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282629911">(May 17 2022 at 12:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Similarities/near/282556910">said</a>:</p>
<blockquote>
<p>If you don't mind explaining, what led to these changes? (Or just link some relevant discussion lol.) Was it just to get rid of the duplicate code had to be rewritten every time a new hom-class was added? Were there downsides to this?</p>
</blockquote>
<p><a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms">Here's the thread where we developed the morphism class pattern.</a></p>
<p>The point is indeed that each time you introduce a new, more specialized, type of morphisms (like <code>ring_hom</code> specializes <code>monoid_hom</code>), you need to copy over a huge amount of code: everything about <code>monoid_hom</code> is still true about <code>ring_hom</code>. Moreover, whenever you add a declaration involving <code>monoid_hom</code>s, you also need to duplicate it to <code>ring_hom</code>s. So with this setup you get a kind of multiplicative explosion of code. And it's quite possible you forget to copy new lemmas over, so the next time someone wants to use your results they have to go back and copy it over (as happened often in mathlib).</p>
<p>In the morphism class refactor, we decided that instead of taking a parameter <code>f : M →* N</code> of a fixed type <code>monoid_hom</code>, instead the type of <code>f</code> should be an arbitrary <code>F</code> as long as all elements of <code>F</code> are (also) monoid homomorphisms, expressed as <code>monoid_hom_class F M N</code>.</p>
<p><a href="https://arxiv.org/abs/2202.01629">If you want the full gory details, check out section 6 of my paper on the class-based patterns in mathlib.</a></p>



<a name="282699142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282699142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282699142">(May 17 2022 at 20:03)</a>:</h4>
<p>Oh! Thanks, the paper is wonderful btw. I always wondered how exactly typeclasses worked and could never understand any of the technical stuff, but your paper explained most everything very well</p>



<a name="282719389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282719389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282719389">(May 17 2022 at 23:13)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> At the end of section 6 you say that "work is still ongoing to provide a suitable generic form of standard operations such as composition and identity maps," which is interesting because I was wondering why we still had all the <code>*_hom.id</code> and <code>*_hom.comp</code> (and actualy a lot of <code>*_hom.map_add</code>?) lemmas sitting around. How do you think this will be done?</p>



<a name="282721364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282721364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282721364">(May 17 2022 at 23:37)</a>:</h4>
<p>I've started trying to refactor <code>topology.metric_space.isometry</code>. I'm working with the definitions below and the entire file actually ports very easily with minimal changes. <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> what do you think? I'm just wondering if you mind me just get started with the refactor now</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.antilipschitz</span>
<span class="kn">import</span> <span class="n">data.fun_like.basic</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">function</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">topological_space</span> <span class="n">ennreal</span>

<span class="kn">section</span> <span class="n">setup</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">β</span><span class="o">]</span>

<span class="sd">/-- An isometry (also known as isometric embedding) is a map preserving the edistance</span>
<span class="sd">between pseudoemetric spaces, or equivalently the distance between pseudometric space.  -/</span>
<span class="kd">structure</span> <span class="n">isometry</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">edist_eq'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">isometry_class</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">β</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="n">F</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edist_eq'</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">isometry.to_isometry_class</span> <span class="o">:</span>
  <span class="n">isometry_class</span> <span class="o">(</span><span class="n">isometry</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">isometry.to_fun</span><span class="o">,</span>
  <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">f</span><span class="o">,</span> <span class="n">cases</span> <span class="n">g</span><span class="o">,</span> <span class="n">congr'</span> <span class="o">},</span>
  <span class="n">edist_eq'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">isometry.edist_eq'</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">isometry</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fun_like.has_coe_to_fun</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_fun_eq_coe</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">isometry</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">f.to_fun</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[ext]</span> <span class="kd">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">isometry</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">fun_like.ext</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span>

<span class="sd">/-- Copy of a `isometry` with a new `to_fun` equal to the old one. Useful to fix definitional</span>
<span class="sd">equalities. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">copy</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">isometry</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f'</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">isometry</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f'</span><span class="o">,</span>
  <span class="n">edist_eq'</span> <span class="o">:=</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">f.edist_eq'</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">setup</span>
</code></pre></div>



<a name="282721486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282721486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282721486">(May 17 2022 at 23:39)</a>:</h4>
<p>It's a bit of a dirty and technical job which I know perfectly how to do so I would suggest not bothering with that, but you do you <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="282721493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282721493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282721493">(May 17 2022 at 23:39)</a>:</h4>
<p>One annoying thing is that I seem to have to manually insert <code>f : α → β</code> to get lean to coerce from <code>f : F</code>. Did I setup something wrong with the <code>fun_like</code> things?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">γ</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">isometry_class</span> <span class="n">F</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">isometry_class</span> <span class="n">G</span> <span class="n">β</span> <span class="n">γ</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">lipschitz</span> <span class="o">:</span> <span class="n">lipschitz_with</span> <span class="mi">1</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">lipschitz_with.of_edist_le</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">le_of_eq</span> <span class="o">(</span><span class="n">isometry_class.edist_eq'</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="282722142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282722142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282722142">(May 17 2022 at 23:48)</a>:</h4>
<p>Hm ok, I'll leave it to you then!</p>



<a name="282765958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282765958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282765958">(May 18 2022 at 10:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Similarities/near/282719389">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> At the end of section 6 you say that "work is still ongoing to provide a suitable generic form of standard operations such as composition and identity maps," which is interesting because I was wondering why we still had all the <code>*_hom.id</code> and <code>*_hom.comp</code> (and actualy a lot of <code>*_hom.map_add</code>?) lemmas sitting around. How do you think this will be done?</p>
</blockquote>
<p>I actually experimented with a couple of approaches for <code>id</code> and <code>comp</code> (and <code>symm</code> for isomorphisms), but found none completely convincing yet:</p>
<ul>
<li>Introduce a typeclass of the form <code>has_id (F : Type*) (A : out_param Type*) [fun_like F A A]</code> saying there is a map <code>(has_id.id : F)</code> which coerces to the identity: <code>((has_id.id : F) : A → A) = id</code>. Similarly for <code>has_comp (F G : Type*) (H A B C : out_param Type*) [fun_like F B C] [fun_like G A B] [fun_like H A C]</code>. Main drawback is that the typeclass system really isn't robust against so many (out) parameters, so I ended up writing a lot of type ascriptions.</li>
<li>Define a type of bundled identity/composition/inverse maps, which are structured basically the same as <code>has_id</code>/<code>has_comp</code>/<code>has_symm</code> but you use them as explicit parameters: <code>(compFGH : comp_like F G H A B C)</code> instead of <code>[has_comp F G H A B C]</code>. The drawback here is that have to explicitly distinguish all these different maps, and you can't make theorems like <code>comp f (symm f) = id</code> into <code>simp</code> lemmas since <code>id</code> is a free parameter now.</li>
<li>Use definitions from the category theory library. Main drawback is that this usually requires putting everything into the same universe level.</li>
</ul>
<p>I believe with some improvements to the typeclass system, something like the first approach could work out reasonably well, at the expense of putting even more stress onto that part of the system.</p>



<a name="282766157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282766157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282766157">(May 18 2022 at 10:10)</a>:</h4>
<p>The remaining duplicates like <code>*_hom.map_add</code> are deprecated and should be removed now that morphism classes are stable, it just takes a lot of work to clean up all occurrences. I would appreciate any help! :D</p>



<a name="282879053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/282879053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#282879053">(May 19 2022 at 04:10)</a>:</h4>
<p>Oh, that is nice to know. <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> I may attempt to at some point, indeed!</p>



<a name="283255031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283255031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283255031">(May 22 2022 at 22:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Similarities/near/282721486">said</a>:</p>
<blockquote>
<p>It's a bit of a dirty and technical job which I know perfectly how to do so I would suggest not bothering with that, but you do you <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>
</blockquote>
<p>I ended up starting similarities in <a href="https://github.com/leanprover-community/mathlib/pull/14315">#14315</a>, I hope you don't mind <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="283255128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283255128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283255128">(May 22 2022 at 22:25)</a>:</h4>
<p>Hmm, I would have bundled <code>r</code> in the structure.</p>



<a name="283256423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283256423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283256423">(May 22 2022 at 22:57)</a>:</h4>
<p>Usually the pattern is to have both versions of the bundling; I guess it depends which one is useful</p>



<a name="283256816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283256816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283256816">(May 22 2022 at 23:05)</a>:</h4>
<p>I see! I'm probably not the right person to decide which one it should be, so it's helpful to know what everyone thinks</p>



<a name="283256978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283256978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283256978">(May 22 2022 at 23:09)</a>:</h4>
<p>I was looking for any precedence with this kind of parameterized types but couldn't really find anything like this specifically. I just went unbundled to match the <code>lipschitz_with K f</code> pattern</p>



<a name="283256993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283256993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283256993">(May 22 2022 at 23:09)</a>:</h4>
<p>The big difference is that <a href="https://leanprover-community.github.io/mathlib_docs/find/lipschitz_with">docs#lipschitz_with</a> is a predicate, not a bundled hom.</p>



<a name="283257053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283257053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283257053">(May 22 2022 at 23:10)</a>:</h4>
<p>Yeah, so the analogy is probably very flawed</p>



<a name="283257079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283257079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283257079">(May 22 2022 at 23:11)</a>:</h4>
<p>Your current design can't work because <code>r</code> will typically not be uniquely inferrable from <code>α</code> and <code>β</code>.</p>



<a name="283257310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283257310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283257310">(May 22 2022 at 23:16)</a>:</h4>
<p>I guess the other question is whether we actually want to be bundling <code>f</code> here when things like <code>lipshitz_with</code> are not bundled</p>



<a name="283257335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283257335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283257335">(May 22 2022 at 23:17)</a>:</h4>
<p>Ok now I am thinking about it more and unbundling does mean you had to carry around <code>r</code> everywhere you go</p>



<a name="283258068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283258068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283258068">(May 22 2022 at 23:36)</a>:</h4>
<p>I'll try to see how it goes if I bundle everything</p>



<a name="283259319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Similarities/near/283259319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Similarities.html#283259319">(May 23 2022 at 00:06)</a>:</h4>
<p>I've pushed the changes.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
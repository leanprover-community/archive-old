---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html">Automating over structures</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204986843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Automating%20over%20structures/near/204986843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html#204986843">(Jul 25 2020 at 04:02)</a>:</h4>
<p>I see that lots of work is being put into refactoring the ideas of <code>submonoid</code>, <code>subgroup</code>, <code>subring</code>, etc. I've written a definition based on flypitch for a <code>substructure</code> of an arbitrary first-order structure, which should in theory generalize all of these, for the right choices of language. If we had an accepted mathlib definition for what a <code>substructure</code> should be in that context, how far away would we be from being able to actually apply it to all relevant structures?</p>



<a name="204986847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Automating%20over%20structures/near/204986847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html#204986847">(Jul 25 2020 at 04:02)</a>:</h4>
<p>(my code for <code>substructure</code> so far: <a href="https://github.com/leanprover-community/mathlib/blob/fol-attempt/src/model_theory/substructure.lean#L9">https://github.com/leanprover-community/mathlib/blob/fol-attempt/src/model_theory/substructure.lean#L9</a>)</p>



<a name="204986857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Automating%20over%20structures/near/204986857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html#204986857">(Jul 25 2020 at 04:03)</a>:</h4>
<p>Is this the kind of thing that could be done with a tactic like <code>to_additive</code>,  a significantly harder-to-write tactic, or is it somehow beyond what Lean can do at the moment?</p>



<a name="204987289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Automating%20over%20structures/near/204987289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html#204987289">(Jul 25 2020 at 04:17)</a>:</h4>
<p>I wonder if it's possible to generate something definitionally equal to the current lemmas based on the type of <code>mk</code> etc.</p>



<a name="204987340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Automating%20over%20structures/near/204987340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html#204987340">(Jul 25 2020 at 04:18)</a>:</h4>
<p>I mean, if you have a list of types of functions, then you can generate <code>fun_mem</code> using some <code>list.foldl</code> or <code>list.foldr</code>.</p>



<a name="204987650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Automating%20over%20structures/near/204987650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Automating.20over.20structures.html#204987650">(Jul 25 2020 at 04:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Automating.20over.20structures/near/204986857">said</a>:</p>
<blockquote>
<p>Is this the kind of thing that could be done with a tactic like <code>to_additive</code>,  a significantly harder-to-write tactic, or is it somehow beyond what Lean can do at the moment?</p>
</blockquote>
<p>I think this would be your best bet, but it also sounds like it will be quite a bit harder-to-write...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html">pattern matching prop?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212907350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212907350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212907350">(Oct 10 2020 at 09:24)</a>:</h4>
<p>Hello. Is it possible to pattern match against propositions? I.e. <code>a &gt; 1 ∨ b = 3</code> to extract metavariables and (in)equalities. I'd like to be able to write constraints in a monad a la <code>do a &lt;- get_arg "a", b &lt;- get_arg "b", constrain (a &gt; 1 ∨ b = 3)</code> Let say the output is the ANDs-of-ORs-of-maybe-NOTs, as a string, canonicalized after all constraints have been added. I'd be okay with a partial solution which only recognizes some forms of propositions. Such as freely nested ANDs, ORs, and NOTs. But it needs to reduce higher level code, such as <code>a ∈ [1, 2, 3]</code> to ORs.</p>
<p>If I understand correctly, we can't pattern match directly and would need to use metaprogramming to introduce the metavariables (<code>a</code> and <code>b</code> above) and to decompose the reduced type. But this should be possible. I hope.</p>



<a name="212907993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212907993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212907993">(Oct 10 2020 at 09:41)</a>:</h4>
<p>Related. It'd also be nice to be able to write arithmetic constraints too. I.e. <code>3 * a - 2 * b + 5 * z = 0</code>.</p>



<a name="212908115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212908115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212908115">(Oct 10 2020 at 09:44)</a>:</h4>
<p>Hmm.. Could double-quote an expression. Not as nice but certainly easier.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">``</span><span class="o">(</span><span class="mi">3</span> <span class="bp">*</span> <span class="bp">`</span><span class="n">a</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">`</span><span class="n">b</span> <span class="bp">+</span> <span class="mi">5</span> <span class="bp">*</span> <span class="bp">`</span><span class="n">z</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="212908525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212908525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212908525">(Oct 10 2020 at 09:56)</a>:</h4>
<p><code>rcases</code> can do lots of interesting pattern matching on props</p>



<a name="212908534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212908534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212908534">(Oct 10 2020 at 09:57)</a>:</h4>
<p>That said it doesn't exactly match the use case you describe later, which I don't really understand</p>



<a name="212908539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212908539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212908539">(Oct 10 2020 at 09:57)</a>:</h4>
<p>what is <code>get_arg</code></p>



<a name="212908582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212908582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212908582">(Oct 10 2020 at 09:58)</a>:</h4>
<p>Do you have a simple example of what you would like to do?</p>



<a name="212910016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212910016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212910016">(Oct 10 2020 at 10:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'd like to be able to write both logical and arithmetic constraints as ordinary propositions, to compile them to a canonicalized inductive type which I can process over. Below an example for each variant.</p>
<p>(Logical constraint system) Macaroons are a Hash-based credential constructed as a list of caveats where each caveat is an ORs-of-maybe-NOTs and the list is the AND of these. A naive attenuation may append many redundant caveats and grow the size of the credential quickly. Ideally, the attenuating actor can specify their caveats as propositions, then let a higher level canonicalize the prop to ANDs-of-ORs-of-maybe-NOTs, stripping out redundancies. The result should be zero or more caveats appended to the original set. The optimization must be correct / cannot match differently to the naive approach of just appending all caveats.</p>
<p>Macaroons =&gt; <a href="https://research.google/pubs/pub41892/">https://research.google/pubs/pub41892/</a></p>
<p>(Arithmetic constraint system) Bulletproofs are zero-knowledge proofs that a set of possibly hidden variables of a rank-1 constraint system satisfy a set of constraints. The cryptography involved is more expensive when there are more gates. Thus the propositions need to be simplified to eliminate redundancies.</p>
<p>Bulletproofs R1CS =&gt; <a href="https://doc-internal.dalek.rs/bulletproofs/notes/r1cs_proof/index.html">https://doc-internal.dalek.rs/bulletproofs/notes/r1cs_proof/index.html</a></p>
<p>To summarize: I want to write the potentially redundant constraints as propositions, then eliminate the redundancies at a post-processing stage.</p>



<a name="212910181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212910181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212910181">(Oct 10 2020 at 10:45)</a>:</h4>
<p>I mean could you produce some code that approximates what you are attempting to do, perhaps with a <code>sorry</code> where you aren't sure what to put something</p>



<a name="212910338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212910338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212910338">(Oct 10 2020 at 10:49)</a>:</h4>
<p>Sorry, yes, crude example I wrote for a friend while explaining macaroons. The <code>get_arg</code> results are typed as <code>fn : string</code> and <code>arg1 : nat</code>. This monad style is not necessary, it just seemed like a natural option.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">fn</span> <span class="bp">&lt;-</span> <span class="n">get_arg</span> <span class="s2">"fn"</span><span class="o">,</span>
   <span class="n">arg1</span> <span class="bp">&lt;-</span> <span class="n">get_arg</span> <span class="s2">"1"</span><span class="o">,</span>
   <span class="n">constrain</span> <span class="o">(</span><span class="n">fn</span> <span class="bp">∈</span> <span class="o">[</span><span class="s2">"f"</span><span class="o">,</span> <span class="s2">"g"</span><span class="o">,</span> <span class="s2">"h"</span><span class="o">]),</span>
   <span class="n">implies</span> <span class="o">(</span><span class="n">fn</span> <span class="bp">=</span> <span class="s2">"f"</span><span class="o">)</span> <span class="o">(</span><span class="n">arg1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="212910566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212910566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212910566">(Oct 10 2020 at 10:55)</a>:</h4>
<p>Here <code>implies p q</code> is <code>constrain ((not p) or q)</code>.</p>



<a name="212911993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212911993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212911993">(Oct 10 2020 at 11:35)</a>:</h4>
<p>so how is <code>macaroon</code> defined?</p>



<a name="212912040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212912040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212912040">(Oct 10 2020 at 11:36)</a>:</h4>
<p>this looks doable, but it is not clear to me where  <code>"fn"</code>, <code>"1"</code> etc are coming from</p>



<a name="212913522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212913522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212913522">(Oct 10 2020 at 12:22)</a>:</h4>
<p>Uh. Connection cut and seems my last message was lost.</p>
<p>Consider something like this. A caveat is a list of triples containing the key/name, (in)equality, and a value/string; where at least one must be true. Ideally the caveat should be any semi-lattice; but a string key-value should suffice for now.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">caveat</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ors</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">name</span> <span class="bp">×</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">string</span><span class="o">))</span>

<span class="kd">structure</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">caveats</span> <span class="o">:</span> <span class="n">list</span> <span class="n">caveat</span><span class="o">)</span>
<span class="o">(</span><span class="n">tag</span> <span class="o">:</span> <span class="n">hmac_digest</span><span class="o">)</span>
</code></pre></div>



<a name="212913657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212913657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212913657">(Oct 10 2020 at 12:26)</a>:</h4>
<p><code>"fn"</code> and <code>"1"</code> are the keys for the constraints.</p>



<a name="212913915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212913915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212913915">(Oct 10 2020 at 12:33)</a>:</h4>
<p>To reiterate; I want to write <code>Prop</code>s because they are more natural and may not be canonicalized. Whereas the target type is canonically an ANDs-of-ORs-of-maybe-NOTs, or similarly structured when generalized to naturals or integers using less-than or greater-or-equal. Which is still the same thing just more expressive.</p>



<a name="212914001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212914001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212914001">(Oct 10 2020 at 12:35)</a>:</h4>
<p>Or generalized further to any semilattice; but that just wouldn't need the <code>caveats.of_prop</code> method and would do its own thing.</p>



<a name="212914075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212914075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212914075">(Oct 10 2020 at 12:37)</a>:</h4>
<p>The macaroon <code>tag</code> is computed as the <code>HMAC(previous tag, new caveat)</code> for each caveat appended to the list. The constraint builder would canonicalize and reduce the caveats before committing to them and updating the tag.</p>



<a name="212914578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212914578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212914578">(Oct 10 2020 at 12:53)</a>:</h4>
<p>The test above would expand to, with these definitions, lazily treating hmac_digest as nat and <code>arg1</code> of type <code>string</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="o">⟨[</span>
    <span class="c1">-- `fn ∈ ["f", "g", "h"]</span>
    <span class="o">⟨[</span>
        <span class="o">(</span><span class="bp">`</span><span class="n">fn</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="s2">"f"</span><span class="o">),</span>
        <span class="o">(</span><span class="bp">`</span><span class="n">fn</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="s2">"g"</span><span class="o">),</span>
        <span class="o">(</span><span class="bp">`</span><span class="n">fn</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="s2">"h"</span><span class="o">)</span>
    <span class="o">]⟩,</span>
    <span class="c1">-- `fn = "f" =&gt; arg1 = "1"</span>
    <span class="o">⟨[</span>
        <span class="o">(</span><span class="bp">`</span><span class="n">fn</span><span class="o">,</span> <span class="n">false</span><span class="o">,</span> <span class="s2">"f"</span><span class="o">),</span>
        <span class="o">(</span><span class="bp">`</span><span class="n">arg1</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="s2">"1"</span><span class="o">)</span>
    <span class="o">]⟩</span>
 <span class="o">],</span> <span class="mi">0</span><span class="o">⟩</span>
</code></pre></div>



<a name="212917905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212917905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212917905">(Oct 10 2020 at 14:10)</a>:</h4>
<p>I think the nicest way to get good syntax and parse correctly is to use a tactic wrapper, like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kd">@[derive has_reflect]</span>
<span class="kd">structure</span> <span class="n">caveat</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ors</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">name</span> <span class="bp">×</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">string</span><span class="o">))</span>

<span class="kd">@[derive has_reflect]</span>
<span class="kd">structure</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">caveats</span> <span class="o">:</span> <span class="n">list</span> <span class="n">caveat</span><span class="o">)</span>
<span class="c1">-- (tag : hmac_digest)</span>

<span class="kd">def</span> <span class="n">macaroon.false</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="o">:=</span> <span class="o">⟨[⟨[]⟩]⟩</span>
<span class="kd">def</span> <span class="n">macaroon.true</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="o">:=</span> <span class="o">⟨[]⟩</span>
<span class="kd">def</span> <span class="n">macaroon.and</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="bp">→</span> <span class="n">macaroon</span> <span class="bp">→</span> <span class="n">macaroon</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">c₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">c₁</span> <span class="bp">++</span> <span class="n">c₂</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">macaroon.or</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="bp">→</span> <span class="n">macaroon</span> <span class="bp">→</span> <span class="n">macaroon</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">c₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="k">do</span> <span class="o">⟨</span><span class="n">a</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">c₁</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">⟩</span> <span class="bp">←</span> <span class="n">c₂</span><span class="o">,</span> <span class="o">[⟨</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">⟩]⟩</span>
<span class="kd">def</span> <span class="n">macaroon.sn</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="o">⟨[⟨[(</span><span class="n">n</span><span class="o">,</span> <span class="n">pos</span><span class="o">,</span> <span class="n">s</span><span class="o">)]⟩]⟩</span>

<span class="kd">meta</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="n">caveat</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">l</span><span class="o">⟩,</span> <span class="n">string.intercalate</span> <span class="s2">" ∨ "</span> <span class="bp">$</span> <span class="n">l.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">pos</span><span class="o">,</span> <span class="n">s</span><span class="o">⟩,</span>
  <span class="n">to_string</span> <span class="n">n</span> <span class="bp">++</span> <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="s2">" = "</span> <span class="k">else</span> <span class="s2">" ≠ "</span><span class="o">)</span> <span class="bp">++</span> <span class="n">s</span><span class="o">⟩</span>

<span class="kd">meta</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">m</span><span class="o">⟩,</span> <span class="n">string.intercalate</span> <span class="s2">" ∧</span><span class="se">\n</span><span class="s2"> "</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="s2">"("</span> <span class="bp">++</span> <span class="n">repr</span> <span class="n">x</span> <span class="bp">++</span> <span class="s2">")"</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">m</span><span class="o">)⟩</span>

<span class="kn">open</span> <span class="n">tactic</span> <span class="n">interactive</span> <span class="n">interactive.types</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">macaroonify_core</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">macaroon</span>
<span class="bp">|</span> <span class="n">e</span> <span class="n">pos</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">whnf</span> <span class="n">e</span> <span class="n">transparency.all</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">∧</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">macaroon.and</span> <span class="k">else</span> <span class="n">macaroon.or</span><span class="o">)</span>
      <span class="bp">&lt;$&gt;</span> <span class="n">macaroonify_core</span> <span class="n">e₁</span> <span class="n">pos</span> <span class="bp">&lt;*&gt;</span> <span class="n">macaroonify_core</span> <span class="n">e₂</span> <span class="n">pos</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">∨</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">macaroon.or</span> <span class="k">else</span> <span class="n">macaroon.and</span><span class="o">)</span>
      <span class="bp">&lt;$&gt;</span> <span class="n">macaroonify_core</span> <span class="n">e₁</span> <span class="n">pos</span> <span class="bp">&lt;*&gt;</span> <span class="n">macaroonify_core</span> <span class="n">e₂</span> <span class="n">pos</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">→</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">macaroon.or</span> <span class="k">else</span> <span class="n">macaroon.and</span><span class="o">)</span>
      <span class="bp">&lt;$&gt;</span> <span class="n">macaroonify_core</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="n">macaroonify_core</span> <span class="n">e₂</span> <span class="n">pos</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">false</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">macaroon.false</span> <span class="k">else</span> <span class="n">macaroon.true</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">true</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">macaroon.true</span> <span class="k">else</span> <span class="n">macaroon.false</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">a.is_local_constant</span> <span class="k">then</span> <span class="k">do</span>
      <span class="n">pb</span> <span class="bp">←</span> <span class="n">pp</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">return</span> <span class="bp">$</span> <span class="n">macaroon.sn</span> <span class="n">a.local_pp_name</span> <span class="n">pos</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">pb</span><span class="o">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">b.is_local_constant</span> <span class="k">then</span> <span class="k">do</span>
      <span class="n">pa</span> <span class="bp">←</span> <span class="n">pp</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">return</span> <span class="bp">$</span> <span class="n">macaroon.sn</span> <span class="n">b.local_pp_name</span> <span class="n">pos</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">pa</span><span class="o">)</span>
    <span class="k">else</span> <span class="n">failed</span>
  <span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">failed</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.macaroonify</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">(</span><span class="n">args</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="bp">←</span> <span class="n">open_lambdas</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">m</span> <span class="bp">←</span> <span class="n">macaroonify_core</span> <span class="n">e</span> <span class="n">tt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">reflect</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">macaroon</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">macaroonify</span> <span class="bp">λ</span> <span class="n">fn</span> <span class="n">arg1</span><span class="o">,</span>
  <span class="n">fn</span> <span class="bp">∈</span> <span class="o">[</span><span class="s2">"f"</span><span class="o">,</span> <span class="s2">"g"</span><span class="o">,</span> <span class="s2">"h"</span><span class="o">]</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="n">fn</span> <span class="bp">=</span> <span class="s2">"f"</span> <span class="bp">→</span> <span class="n">arg1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">foo</span>
<span class="c1">-- (fn = "f" ∨ fn = "g" ∨ fn = "h") ∧</span>
<span class="c1">--  (fn ≠ "f" ∨ arg1 = 1)</span>
</code></pre></div>



<a name="212918048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212918048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212918048">(Oct 10 2020 at 14:14)</a>:</h4>
<p>This... looks like exactly what I wanted, thanks. Just no <code>open_lambdas</code>. This intended as a sorry or missing an import?</p>



<a name="212918323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212918323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212918323">(Oct 10 2020 at 14:22)</a>:</h4>
<p>Missing import I guess. <a href="https://leanprover-community.github.io/mathlib_docs/tactic/binder_matching.html">https://leanprover-community.github.io/mathlib_docs/tactic/binder_matching.html</a></p>



<a name="212918392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212918392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212918392">(Oct 10 2020 at 14:24)</a>:</h4>
<p>Ah, I'm a few weeks too late!</p>



<a name="212919375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212919375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212919375">(Oct 10 2020 at 14:52)</a>:</h4>
<p>After updating mathlib, I can confirm it works. Thanks again! Exactly what I was after. :)</p>



<a name="212937907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212937907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212937907">(Oct 10 2020 at 22:35)</a>:</h4>
<p>The <code>whnf</code> normalization trick is really pretty. It had me wondering how nots were handled, needed to add a <code>tactic.trace e</code> to see what it presented the match. Elegant. :D</p>



<a name="212947554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212947554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212947554">(Oct 11 2020 at 04:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> This produces garbage with inequalities on the LHS of an implication. Any idea how to fix this? I.e. <code>not a = 1 -&gt; b = 2</code> =&gt; <code>(a = 1 or b = 2) and (b = 2)</code>.</p>



<a name="212947696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212947696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212947696">(Oct 11 2020 at 04:07)</a>:</h4>
<p>(deleted)</p>



<a name="212949586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212949586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212949586">(Oct 11 2020 at 05:17)</a>:</h4>
<p>I can't replicate the issue</p>



<a name="212949624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212949624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212949624">(Oct 11 2020 at 05:18)</a>:</h4>
<p>but be aware that I changed the code snippet above after you first saw it, because there was a bug in the translation of <code>true</code> and <code>false</code> when in negative mode</p>



<a name="212949850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212949850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212949850">(Oct 11 2020 at 05:26)</a>:</h4>
<p>Ah. I didn't notice the update. This fixes the issue. Thanks. :)</p>



<a name="212950903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212950903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212950903">(Oct 11 2020 at 06:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I've generalized it a bit to just Conjunctive Normal Form (instead of specifically macaroons). Added <code>&lt;-&gt;</code> and it now rejects bad inputs with descriptive errors. I.e. these are invalid <code>λ a, a = not a string ∧ b = "b may exist but isn't a valid constraint name"</code>. Next step: generalize to linear (in)equalities. For maximization, minimization and validation.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kd">@[derive has_reflect]</span>
<span class="kd">structure</span> <span class="n">cnf</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ands_of_ors_of_maybe_nots</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">name</span> <span class="bp">×</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">string</span><span class="o">)))</span>

<span class="kd">def</span> <span class="n">cnf.false</span> <span class="o">:</span> <span class="n">cnf</span> <span class="o">:=</span> <span class="o">⟨[[]]⟩</span>
<span class="kd">def</span> <span class="n">cnf.true</span> <span class="o">:</span> <span class="n">cnf</span> <span class="o">:=</span> <span class="o">⟨[]⟩</span>
<span class="kd">def</span> <span class="n">cnf.and</span> <span class="o">:</span> <span class="n">cnf</span> <span class="bp">→</span> <span class="n">cnf</span> <span class="bp">→</span> <span class="n">cnf</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">c₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">c₁</span> <span class="bp">++</span> <span class="n">c₂</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">cnf.or</span> <span class="o">:</span> <span class="n">cnf</span> <span class="bp">→</span> <span class="n">cnf</span> <span class="bp">→</span> <span class="n">cnf</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">c₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">c₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="k">do</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">c₁</span><span class="o">,</span> <span class="n">b</span> <span class="bp">←</span> <span class="n">c₂</span><span class="o">,</span> <span class="o">[</span><span class="n">a</span> <span class="bp">++</span> <span class="n">b</span><span class="o">]⟩</span>
<span class="kd">def</span> <span class="n">cnf.sn</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">cnf</span> <span class="o">:=</span>
<span class="o">⟨[[(</span><span class="n">n</span><span class="o">,</span> <span class="n">pos</span><span class="o">,</span> <span class="n">s</span><span class="o">)]]⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="n">cnf</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">m</span><span class="o">⟩,</span> <span class="n">string.intercalate</span> <span class="s2">" ∧</span><span class="se">\n</span><span class="s2"> "</span>
  <span class="o">((</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">name</span> <span class="bp">×</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">string</span><span class="o">),</span>
    <span class="s2">"("</span> <span class="bp">++</span> <span class="o">(</span><span class="n">string.intercalate</span> <span class="s2">" ∨ "</span> <span class="bp">$</span> <span class="n">x.map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">pos</span><span class="o">,</span> <span class="n">s</span><span class="o">⟩,</span>
          <span class="n">to_string</span> <span class="n">n</span> <span class="bp">++</span> <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="s2">" = "</span> <span class="k">else</span> <span class="s2">" ≠ "</span><span class="o">)</span> <span class="bp">++</span> <span class="n">s</span><span class="o">)</span>
        <span class="bp">++</span> <span class="s2">")"</span><span class="o">)</span>
    <span class="bp">&lt;$&gt;</span> <span class="n">m</span><span class="o">)⟩</span>

<span class="kn">open</span> <span class="n">tactic</span> <span class="n">interactive</span> <span class="n">interactive.types</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">cnfify_core</span> <span class="o">(</span><span class="n">args</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">cnf</span>
<span class="bp">|</span> <span class="n">e</span> <span class="n">pos</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">whnf</span> <span class="n">e</span> <span class="n">transparency.all</span><span class="o">,</span>
  <span class="c1">-- tactic.trace e,</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">∧</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.and</span> <span class="k">else</span> <span class="n">cnf.or</span><span class="o">)</span>
      <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span>
      <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">∨</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.or</span> <span class="k">else</span> <span class="n">cnf.and</span><span class="o">)</span>
      <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span>
      <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">→</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.or</span> <span class="k">else</span> <span class="n">cnf.and</span><span class="o">)</span>
      <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">)</span>
      <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">↔</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">cnf.and</span>
      <span class="bp">&lt;$&gt;</span> <span class="o">((</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.or</span> <span class="k">else</span> <span class="n">cnf.and</span><span class="o">)</span>
        <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">)</span>
        <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span><span class="o">)</span>
      <span class="bp">&lt;*&gt;</span> <span class="o">((</span><span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.or</span> <span class="k">else</span> <span class="n">cnf.and</span><span class="o">)</span>
        <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">)</span>
        <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">false</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.false</span> <span class="k">else</span> <span class="n">cnf.true</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">true</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="n">cnf.true</span> <span class="k">else</span> <span class="n">cnf.false</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">args</span> <span class="k">then</span>
      <span class="k">do</span> <span class="n">ba</span> <span class="bp">&lt;-</span> <span class="n">whnf</span> <span class="n">b</span><span class="o">,</span>
         <span class="n">pb</span> <span class="bp">&lt;-</span> <span class="n">pp</span> <span class="n">b</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">ba.is_app_of</span> <span class="bp">`</span><span class="n">string_imp.mk</span> <span class="k">then</span>
        <span class="n">return</span> <span class="bp">$</span> <span class="n">cnf.sn</span> <span class="n">a.local_pp_name</span> <span class="n">pos</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">pb</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="n">fail</span> <span class="bp">$</span> <span class="s2">"Expected string; found: "</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">pb</span>
    <span class="k">else</span>
      <span class="n">fail</span> <span class="bp">$</span> <span class="s2">"Expected one of: "</span>
        <span class="bp">++</span> <span class="n">string.intercalate</span> <span class="s2">", "</span> <span class="o">(</span><span class="n">args.map</span> <span class="n">to_string</span><span class="o">)</span>
        <span class="bp">++</span> <span class="s2">"; found: "</span> <span class="bp">++</span> <span class="n">a.local_pp_name.to_string</span>
  <span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"Unhandled proposition?"</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.cnfify</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">(</span><span class="n">args</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="bp">←</span> <span class="n">open_lambdas</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">m</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">args</span> <span class="n">e</span> <span class="n">tt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">reflect</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span> <span class="n">arg1</span><span class="o">,</span>
  <span class="n">fn</span> <span class="bp">∈</span> <span class="o">[</span><span class="s2">"f"</span><span class="o">,</span> <span class="s2">"g"</span><span class="o">,</span> <span class="s2">"h"</span><span class="o">]</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="n">fn</span> <span class="bp">=</span> <span class="s2">"f"</span> <span class="bp">→</span> <span class="n">arg1</span> <span class="bp">=</span> <span class="s2">"1"</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span> <span class="n">target</span> <span class="n">message</span><span class="o">,</span>
  <span class="c1">-- we may send and receive messages</span>
  <span class="n">fn</span> <span class="bp">∈</span> <span class="o">[</span><span class="s2">"send"</span><span class="o">,</span> <span class="s2">"recv"</span><span class="o">]</span> <span class="bp">∧</span>
  <span class="c1">-- if we send a message to alice, the message must be "Hello"</span>
  <span class="o">(</span><span class="n">fn</span> <span class="bp">=</span> <span class="s2">"send"</span> <span class="bp">∧</span> <span class="n">target</span> <span class="bp">=</span> <span class="s2">"alice"</span> <span class="bp">→</span> <span class="n">message</span> <span class="bp">=</span> <span class="s2">"Hello"</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="c1">-- we can only receive messages as bob</span>
  <span class="o">(</span><span class="n">fn</span> <span class="bp">=</span> <span class="s2">"recv"</span> <span class="bp">→</span> <span class="n">target</span> <span class="bp">=</span> <span class="s2">"bob"</span><span class="o">)</span>
</code></pre></div>



<a name="212951020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951020">(Oct 11 2020 at 06:09)</a>:</h4>
<p>I think your translation of <code>&lt;-&gt;</code> isn't correct. When in positive mode <code>p &lt;-&gt; q</code> should translate to <code>(!p \/ q) /\ (!q \/ p)</code>, which looks ok, but in negative mode it should translate to <code>(p \/ q) /\ (!p \/ !q)</code>, while you are currently translating to <code>(p /\ !q) /\  (q /\ !p)</code></p>



<a name="212951069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951069">(Oct 11 2020 at 06:10)</a>:</h4>
<p>The <code>pos</code> argument is supposed to negate the whole proposition when false, so <code>&lt;-&gt;</code> should translate to xor in negative mode</p>



<a name="212951085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951085">(Oct 11 2020 at 06:11)</a>:</h4>
<p>otherwise it looks good</p>



<a name="212951131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951131">(Oct 11 2020 at 06:12)</a>:</h4>
<p>Oops, nice catch.</p>



<a name="212951385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951385">(Oct 11 2020 at 06:23)</a>:</h4>
<p>Hmm. I've adjusted it as follows but this just produces contradictions. <code>a = 1 and b = 2 and a /= 1 and b /= 2</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">↔</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span>
      <span class="n">cnf.and</span>
        <span class="bp">&lt;$&gt;</span> <span class="o">(</span><span class="n">cnf.or</span>
          <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">ff</span>
          <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">tt</span><span class="o">)</span>
        <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">cnf.or</span>
          <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">ff</span>
          <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">tt</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">cnf.and</span>
        <span class="bp">&lt;$&gt;</span> <span class="o">(</span><span class="n">cnf.and</span>
          <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">tt</span>
          <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">tt</span><span class="o">)</span>
        <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">cnf.and</span>
          <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">ff</span>
          <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">ff</span><span class="o">)</span>
</code></pre></div>



<a name="212951388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951388">(Oct 11 2020 at 06:23)</a>:</h4>
<p>For <code>not (a = "1" &lt;-&gt; b = "2")</code></p>



<a name="212951450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951450">(Oct 11 2020 at 06:25)</a>:</h4>
<p>Er duh. <code>cnf.or</code>***</p>



<a name="212951459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951459">(Oct 11 2020 at 06:25)</a>:</h4>
<p>All good now :)</p>



<a name="212951696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212951696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212951696">(Oct 11 2020 at 06:33)</a>:</h4>
<p>Not quite.. fixed for real. :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">↔</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span>
      <span class="n">cnf.and</span>
        <span class="bp">&lt;$&gt;</span> <span class="o">(</span><span class="n">cnf.or</span>
          <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">)</span>
          <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">tt</span><span class="o">)</span>
        <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">cnf.or</span>
          <span class="bp">&lt;$&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span>
          <span class="bp">&lt;*&gt;</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">ff</span><span class="o">)</span>
</code></pre></div>



<a name="212993185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212993185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212993185">(Oct 12 2020 at 02:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> BTW: It seemed necessary to switch from <code>tactic cnf</code> to <code>tactic expr</code> to support returning arbitrary expressions from the RHS of <code>=</code>. For instance, this now works as expected without returning <code>"to_string 1"</code>. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">map</span> <span class="n">to_string</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span><span class="o">,</span> <span class="n">fn</span> <span class="bp">∈</span> <span class="n">q</span>
</code></pre></div>

<p>Do you have any tips to clean it up? Notably the <code> return `(cnf.sn %%`(a.local_pp_name) %%`(pos) %%b) </code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">cnfify_core</span> <span class="o">(</span><span class="n">args</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">e</span> <span class="n">pos</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">whnf</span> <span class="n">e</span> <span class="n">transparency.all</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">∧</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">a</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">b</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.and</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="k">else</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.or</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">∨</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">a</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">b</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.or</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="k">else</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.and</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">→</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">a</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">),</span>
    <span class="n">b</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.or</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="k">else</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.and</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">e₁</span> <span class="bp">↔</span> <span class="bp">%%</span><span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">a</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="o">(</span><span class="n">bnot</span> <span class="n">pos</span><span class="o">),</span>
    <span class="n">b</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">tt</span><span class="o">,</span>
    <span class="n">c</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₁</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">d</span> <span class="bp">←</span> <span class="n">cnfify_core</span> <span class="n">e₂</span> <span class="n">ff</span><span class="o">,</span>
    <span class="n">return</span> <span class="bp">$</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.and</span> <span class="o">(</span><span class="n">cnf.or</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">cnf.or</span> <span class="bp">%%</span><span class="n">c</span> <span class="bp">%%</span><span class="n">d</span><span class="o">))</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">false</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.false</span><span class="o">)</span> <span class="k">else</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.true</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">true</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">then</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.true</span><span class="o">)</span> <span class="k">else</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.false</span><span class="o">)</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">if</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">args</span> <span class="k">then</span> <span class="k">do</span>
      <span class="n">type</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">b</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">type</span> <span class="bp">=</span> <span class="bp">`</span><span class="o">(</span><span class="n">string</span><span class="o">)</span> <span class="k">then</span>
        <span class="n">return</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.sn</span> <span class="bp">%%`</span><span class="o">(</span><span class="n">a.local_pp_name</span><span class="o">)</span> <span class="bp">%%`</span><span class="o">(</span><span class="n">pos</span><span class="o">)</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>
      <span class="k">else</span> <span class="k">do</span>
        <span class="n">pb</span> <span class="bp">&lt;-</span> <span class="n">to_string</span> <span class="bp">&lt;$&gt;</span> <span class="n">pp</span> <span class="n">b</span><span class="o">,</span>
        <span class="n">pt</span> <span class="bp">&lt;-</span> <span class="n">to_string</span> <span class="bp">&lt;$&gt;</span> <span class="n">pp</span> <span class="n">type</span><span class="o">,</span>
        <span class="n">fail</span> <span class="bp">$</span> <span class="s2">"Expected string; found: "</span> <span class="bp">++</span> <span class="n">pb</span> <span class="bp">++</span> <span class="s2">" of type "</span> <span class="bp">++</span> <span class="n">pt</span>
    <span class="k">else</span>
      <span class="n">fail</span> <span class="bp">$</span> <span class="s2">"Invalid variable; expected one of: "</span>
        <span class="bp">++</span> <span class="n">string.intercalate</span> <span class="s2">", "</span> <span class="o">(</span><span class="n">args.map</span> <span class="n">to_string</span><span class="o">)</span>
        <span class="bp">++</span> <span class="s2">"; found: "</span> <span class="bp">++</span> <span class="n">a.local_pp_name.to_string</span>
  <span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"Unhandled proposition?"</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.cnfify</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="o">(</span><span class="n">args</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">p</span> <span class="bp">&gt;&gt;=</span> <span class="n">open_lambdas</span><span class="o">,</span>
  <span class="n">cnfify_core</span> <span class="n">args</span> <span class="n">e</span> <span class="n">tt</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</code></pre></div>



<a name="212993374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212993374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212993374">(Oct 12 2020 at 02:58)</a>:</h4>
<p>OOps that should read as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>        <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">a.local_pp_name</span> <span class="k">in</span>
        <span class="n">return</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.sn</span> <span class="bp">%%`</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">%%`</span><span class="o">(</span><span class="n">pos</span><span class="o">)</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>
</code></pre></div>

<p>Necessary because <code>a.local_pp_name</code> is meta and I don't want that meta to leak into the result.</p>



<a name="212993773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212993773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212993773">(Oct 12 2020 at 03:09)</a>:</h4>
<p>The dynamic handling falls apart if the tactic can't reduce it to the terms it matches; so this fails.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span><span class="o">,</span> <span class="n">fn</span> <span class="bp">∈</span> <span class="n">l</span>
</code></pre></div>

<p>But it is really nice that I could just implement this. Adding it to the special cases, but there will likely be more and it could be a bad objective to try to handle everything. More dynamic code should probably construct the CNF itself, without this sugar.</p>



<a name="212998188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212998188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212998188">(Oct 12 2020 at 05:03)</a>:</h4>
<p>Hm. Counterexample discovered. <code>cnfify λ a b, (a = "1" -&gt; b = "1") \or (a = "2" -&gt; b = "2")</code> compiles to <code>(a /= "1" or b = "1" or a /= "2" or b = "2")</code> which incorrectly accepts <code>a = "1" and b = 2</code>.</p>



<a name="212998558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212998558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212998558">(Oct 12 2020 at 05:12)</a>:</h4>
<p>Actually I'm not sure if it is incorrect... <code>a = "1" and b = "2"</code> does indeed satisfy the right implication.</p>



<a name="212998564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212998564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212998564">(Oct 12 2020 at 05:12)</a>:</h4>
<p>Just a weird concept to think of, heh.</p>



<a name="212999389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212999389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212999389">(Oct 12 2020 at 05:34)</a>:</h4>
<p><span class="user-mention" data-user-id="328454">@SnowFox</span> I sort of dodged the question of how you want to represent the RHS of the CNF equalities. All your examples so far have been integers or strings, so if that is sufficient you can evaluate the expression at the appropriate type, which would allow running arbitrary string returning functions like <code>to_string 1</code></p>



<a name="212999533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212999533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212999533">(Oct 12 2020 at 05:38)</a>:</h4>
<p>My current code with a few working as intended examples. These do run the arbitrary code. Just nothing "too dynamic" as demonstrated above where we can't reduce around an unknown list; but we can reduce around promised terms so long that their eventual result has type string.  <a href="https://gist.github.com/1fe4300d59a830320f603ab3f5a9a0b6">https://gist.github.com/1fe4300d59a830320f603ab3f5a9a0b6</a></p>



<a name="212999619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212999619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212999619">(Oct 12 2020 at 05:41)</a>:</h4>
<p>I'm not sure what you mean by evaluating the expression at the appropriate type? Do you mean the <code>tactic cnf</code> variant could evaluate the expression to produce its string in its result?</p>



<a name="212999696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212999696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212999696">(Oct 12 2020 at 05:43)</a>:</h4>
<p>If so, then I don't think that'd cover the first two examples in this file. Which both work as intended with the <code>tactic expr</code> variant.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span> <span class="n">arg1</span><span class="o">,</span>
  <span class="n">fn</span> <span class="bp">∈</span> <span class="o">[</span><span class="s2">"f"</span><span class="o">,</span> <span class="s2">"g"</span><span class="o">,</span> <span class="n">s</span><span class="o">]</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="n">fn</span> <span class="bp">=</span> <span class="s2">"f"</span> <span class="bp">→</span> <span class="n">arg1</span> <span class="bp">=</span> <span class="s2">"1"</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">map</span> <span class="n">to_string</span> <span class="k">in</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span><span class="o">,</span> <span class="n">fn</span> <span class="bp">∈</span> <span class="n">q</span>
</code></pre></div>



<a name="212999868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212999868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212999868">(Oct 12 2020 at 05:47)</a>:</h4>
<p>If you stick this in the variable case:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>        <span class="k">if</span> <span class="n">type</span> <span class="bp">=</span> <span class="bp">`</span><span class="o">(</span><span class="n">string</span><span class="o">)</span> <span class="k">then</span> <span class="k">do</span>
          <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">a.local_pp_name</span><span class="o">,</span>
          <span class="n">s</span> <span class="bp">←</span> <span class="o">(</span><span class="k">do</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">eval_expr'</span> <span class="n">string</span> <span class="n">b</span><span class="o">,</span> <span class="n">return</span> <span class="o">(</span><span class="n">reflect</span> <span class="n">s</span> <span class="o">:</span> <span class="n">expr</span><span class="o">))</span> <span class="bp">&lt;|&gt;</span> <span class="n">return</span> <span class="n">b</span><span class="o">,</span>
          <span class="n">return</span> <span class="bp">`</span><span class="o">(</span><span class="n">cnf.new</span> <span class="bp">%%</span><span class="o">(</span><span class="n">reflect</span> <span class="n">n</span><span class="o">)</span> <span class="bp">%%</span><span class="o">(</span><span class="n">reflect</span> <span class="n">pos</span><span class="o">)</span> <span class="bp">%%</span><span class="n">s</span><span class="o">)</span>
</code></pre></div>

<p>it works here</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cnfify</span> <span class="bp">λ</span> <span class="n">fn</span><span class="o">,</span> <span class="n">fn</span> <span class="bp">∈</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">map</span> <span class="n">to_string</span>
<span class="k">#print</span> <span class="n">F</span>
<span class="c1">-- def F : ℕ → cnf :=</span>
<span class="c1">-- λ (n : ℕ),</span>
<span class="c1">--   (cnf.new (name.mk_string "fn" name.anonymous) tt "1").or</span>
<span class="c1">--     ((cnf.new (name.mk_string "fn" name.anonymous) tt (to_string n)).or</span>
<span class="c1">--        ((cnf.new (name.mk_string "fn" name.anonymous) tt "3").or cnf.false))</span>
</code></pre></div>



<a name="212999930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/212999930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#212999930">(Oct 12 2020 at 05:49)</a>:</h4>
<p>It's kind of a hack, but here we are either evaluating the string or sticking the expression inline</p>



<a name="213000272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000272">(Oct 12 2020 at 05:56)</a>:</h4>
<p>Right, but if I understand correctly this wouldn't work in the <code>tactic cnf</code> case due to the <code>return b</code> part. It'd only work when the expression can be reduced to a string. Thus little benefit to adding this tweak to my current code. The hack might be useful to reduce computation at runtime if the virtual machine doesn't hold onto a partially reduced program.</p>



<a name="213000496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000496">(Oct 12 2020 at 06:00)</a>:</h4>
<p>Thanks for the <code>eval_expr'</code> tip, I was looking for this earlier but didn't find it.</p>



<a name="213000697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000697">(Oct 12 2020 at 06:05)</a>:</h4>
<p>That's about right. It falls back to the behavior that you originally wrote, so it's really just a fancy inliner</p>



<a name="213000707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000707">(Oct 12 2020 at 06:06)</a>:</h4>
<p>Where are these magical constants defined? In the C++? <code>tactic.eval_expr``tactic.whnf</code> et al.</p>



<a name="213000759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000759">(Oct 12 2020 at 06:06)</a>:</h4>
<p>Fancy inliner, yes. Unnecessary here but certainly useful for other uses.</p>



<a name="213000764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000764">(Oct 12 2020 at 06:06)</a>:</h4>
<p><code>eval_expr</code> and <code>whnf</code> are in core, <code>init.meta.tactic</code></p>



<a name="213000780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000780">(Oct 12 2020 at 06:07)</a>:</h4>
<p>if you have vscode you should be able to ctrl-click on definitions to go to the source</p>



<a name="213000797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000797">(Oct 12 2020 at 06:07)</a>:</h4>
<p><code>eval_expr'</code> is a mathlib patch of <code>eval_expr</code> because it has a bug</p>



<a name="213000853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000853">(Oct 12 2020 at 06:08)</a>:</h4>
<p>I mean, I did exactly that and they are just <code>constant</code>, not code. Yet we use them as code. Are they defined in the C++ or are they just ordinary constants being reduced by other code?</p>



<a name="213000860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000860">(Oct 12 2020 at 06:08)</a>:</h4>
<p>they are in C++</p>



<a name="213000864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000864">(Oct 12 2020 at 06:08)</a>:</h4>
<p>Okay.</p>



<a name="213000902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000902">(Oct 12 2020 at 06:10)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/blob/master/src/library/tactic/eval.cpp">https://github.com/leanprover-community/lean/blob/master/src/library/tactic/eval.cpp</a></p>



<a name="213000951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000951">(Oct 12 2020 at 06:10)</a>:</h4>
<p>the <code>DECLARE_VM_BUILTIN</code> at the bottom is what hooks the big <code>eval()</code> function to the lean constant</p>



<a name="213000960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000960">(Oct 12 2020 at 06:11)</a>:</h4>
<p>Speaking of the C++.. is there an ETA for Lean 4? ;)</p>



<a name="213000985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213000985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213000985">(Oct 12 2020 at 06:11)</a>:</h4>
<p>heh, don't ask me, I'm just the rumor mill</p>



<a name="213001036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001036">(Oct 12 2020 at 06:12)</a>:</h4>
<p>:)</p>



<a name="213001404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001404">(Oct 12 2020 at 06:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I don't mean to push but I'm not sure how the pings work on zulip. I've pinged you in the RISC-V ISA thread. <a href="#narrow/stream/236449-Program-verification/topic/RISC-V.20ISA.20in.20Lean/near/213000987">https://leanprover.zulipchat.com/#narrow/stream/236449-Program-verification/topic/RISC-V.20ISA.20in.20Lean/near/213000987</a></p>



<a name="213001424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001424">(Oct 12 2020 at 06:20)</a>:</h4>
<p>Pings are cheap. I use 100 pings per day (-;</p>



<a name="213001464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001464">(Oct 12 2020 at 06:21)</a>:</h4>
<p>so you have</p>



<a name="213001479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001479">(Oct 12 2020 at 06:21)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Do they raise any indication that you've been ping'd?</p>



<a name="213001550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001550">(Oct 12 2020 at 06:23)</a>:</h4>
<p><span class="user-mention" data-user-id="328454">@SnowFox</span> yup</p>



<a name="213001565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001565">(Oct 12 2020 at 06:23)</a>:</h4>
<p>You can see them in the menu under <code>Mentions</code></p>



<a name="213001569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001569">(Oct 12 2020 at 06:23)</a>:</h4>
<p>And the message get's a red background</p>



<a name="213001757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> SnowFox <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001757">(Oct 12 2020 at 06:26)</a>:</h4>
<p>Thanks. I've noticed the red but didn't notice the mentions... Actually, not sure it even lit up before I switched back here.</p>



<a name="213001873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001873">(Oct 12 2020 at 06:28)</a>:</h4>
<p>it only lights up if you have unread mentions</p>



<a name="213001886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/pattern%20matching%20prop%3F/near/213001886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/pattern.20matching.20prop.3F.html#213001886">(Oct 12 2020 at 06:29)</a>:</h4>
<p>but you can click on mentions and see them all</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html">Inserting into `is_scalar_tower`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="285946399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285946399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285946399">(Jun 13 2022 at 15:34)</a>:</h4>
<p>I have rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi><mo>⊆</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A\subseteq B\subseteq C\subseteq D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>. The rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A,B,D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> are given, and I can build <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> as an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-subalgebra of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> which contains <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. I'm now having trouble putting the finishing touches to the <code>is_scalar_tower</code> glue. Am I doing it wrong?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.intermediate_field</span>

<span class="kd">constants</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="c1">-- A ⊆ B ⊆ D</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">B</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="n">B</span> <span class="n">D</span><span class="o">]</span>

<span class="c1">-- I now have a ring C sitting between B and D, but defined initially</span>
<span class="c1">-- as sitting between A and D</span>

<span class="kd">constant</span> <span class="n">C</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">A</span> <span class="n">D</span> <span class="c1">-- A ⊆ C ⊆ D; I will be thinking of C as a type not a term.</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="n">B</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="c1">-- so far so good</span>

<span class="c1">-- in fact I can prove B ⊆ C</span>
<span class="kd">lemma</span> <span class="n">B_subset_C</span> <span class="o">:</span> <span class="o">(</span><span class="n">is_scalar_tower.to_alg_hom</span> <span class="n">A</span> <span class="n">B</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">range</span> <span class="bp">≤</span> <span class="n">C</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- need to build this somehow</span>
<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
<span class="o">((</span><span class="n">subalgebra.inclusion</span> <span class="o">(</span><span class="n">B_subset_C</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span>
  <span class="o">((</span><span class="n">is_scalar_tower.to_alg_hom</span> <span class="n">A</span> <span class="n">B</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">range_restrict</span><span class="o">))</span> <span class="c1">-- is this a bad idea?</span>

<span class="c1">-- this one I can do</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="c1">-- this one I can't</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩</span> <span class="n">d</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



<a name="285952371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285952371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285952371">(Jun 13 2022 at 16:12)</a>:</h4>
<blockquote>
<p>is this a bad idea?</p>
</blockquote>
<p>Both <code>noncomputable</code> and <code>ring_hom.to_algebra</code> are red flags to me, so I think yes</p>



<a name="285953057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285953057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285953057">(Jun 13 2022 at 16:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">C'</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">B</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">algebra_map_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">B_subset_C</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="bp">..</span><span class="n">C</span> <span class="o">}</span>

<span class="c1">-- need to build this somehow</span>
<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:=</span>
<span class="n">subalgebra.algebra</span> <span class="n">C'</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C'</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">B</span> <span class="n">C'</span> <span class="n">D</span><span class="o">)</span>
</code></pre></div>



<a name="285953072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285953072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285953072">(Jun 13 2022 at 16:16)</a>:</h4>
<p>Saves you from having to prove anything</p>



<a name="285953264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285953264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285953264">(Jun 13 2022 at 16:18)</a>:</h4>
<p>My guess is that the best answer is actually to just build <code>C'</code> directly, since you didn't mention where <code>C</code> came from</p>



<a name="285960612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285960612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285960612">(Jun 13 2022 at 17:09)</a>:</h4>
<p>I make <code>C</code> as a sup (of objects including B), so it's coming from the lattice structure on <code>subalgebra A D</code>. I'm more than happy to do it this way! Your code makes me think that my <code>C</code> should be called <code>C_aux</code> and your <code>C'</code> should be my <code>C</code>. Is <code>ring_hom.to_algebra</code> a code smell? I hadn't realised.</p>



<a name="285961329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285961329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285961329">(Jun 13 2022 at 17:15)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom.to_algebra">docs#ring_hom.to_algebra</a> is pretty much guaranteed to introduce a diamond in <code>smul</code></p>



<a name="285961356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285961356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285961356">(Jun 13 2022 at 17:15)</a>:</h4>
<p>Because it implements it as <code>f r * x</code></p>



<a name="285961490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285961490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285961490">(Jun 13 2022 at 17:16)</a>:</h4>
<blockquote>
<p>Your code makes me think that my <code>C</code> should be called <code>C_aux</code> and your <code>C'</code> should be my <code>C</code>.</p>
</blockquote>
<p>This sounds good to me</p>



<a name="285978402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285978402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285978402">(Jun 13 2022 at 19:34)</a>:</h4>
<p>Hmm. In my use case I run into an exciting new problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>
<span class="kn">import</span> <span class="n">field_theory.is_alg_closed.algebraic_closure</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">middle_field</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">L</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⊥</span> <span class="c1">-- or anything</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">L</span> <span class="o">(</span><span class="n">middle_field</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">middle_field</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">is_scalar_tower_mid'</span> <span class="c1">-- works fine and this is an instance</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">L</span> <span class="o">(</span><span class="n">middle_field</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="c1">-- deterministic timeout :-(</span>
</code></pre></div>
<p>Looking at the trace with <code>set_option trace.class_instances true</code> it seems to me that typeclass inference actually does succeed and finds a monster term and then for some reason falls over later. Should I be worried about this? I can just add the instance manually I guess, or will this cause problems later on?</p>



<a name="285997332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Inserting%20into%20%60is_scalar_tower%60/near/285997332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Inserting.20into.20.60is_scalar_tower.60.html#285997332">(Jun 13 2022 at 22:25)</a>:</h4>
<p>I think you probably are in trouble here and I'm not sure there's all that much you can do about it. Adding special cases of instances manually that already exist like you do above is a fairly typical workaround, which has the main drawback of forcing you to come up with stupid names for your instances</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html">total preorder to linear order</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233822974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233822974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233822974">(Apr 09 2021 at 13:44)</a>:</h4>
<p>Does mathlib contain anything like a proof of the following? (I am interested in the finite case, which can be done by induction, but it presumably holds in general). </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">total_preorder_to_linear_order</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_total_preorder</span> <span class="n">β</span> <span class="n">r</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">r'</span><span class="o">,</span> <span class="o">(</span><span class="n">is_linear_order</span> <span class="n">β</span> <span class="n">r'</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r'</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="233827921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233827921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233827921">(Apr 09 2021 at 14:14)</a>:</h4>
<p>On a related note, would it make sense for <code>total_preorder</code> to be a class? It arises naturally as an order lift of a linear order.</p>



<a name="233869583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233869583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233869583">(Apr 09 2021 at 18:29)</a>:</h4>
<p>Perhaps I'm missing something, but I don't think this works, since there could be elements <code>x</code> and <code>y</code> in <code>β</code> which are related both ways but aren't equal - ie <code>r'</code> won't be antisymmetric</p>



<a name="233869676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233869676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233869676">(Apr 09 2021 at 18:29)</a>:</h4>
<p>If you want an extension of a partial order to a linear order I have code for that lying around somewhere which I can PR</p>



<a name="233870848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233870848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233870848">(Apr 09 2021 at 18:38)</a>:</h4>
<p>ah, you're right. I do still want a preorder though - I suppose I mean that if x &lt; y then x &lt;' y (where &lt; is the preorder and &lt;' is the linear order). What I'm thinking about is sorting a set by the value of some function to a linear order (hence giving a total preorder) with ties being broken arbitrarily. This is a bit annoying to express in terms of the unbundled order typeclasses, though.</p>



<a name="233870972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233870972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233870972">(Apr 09 2021 at 18:39)</a>:</h4>
<p>You can convert a preorder to a partial order by taking quotients by the relation r x y or r y x, and then make that into a linear order... Does that work for your use case?</p>



<a name="233871129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233871129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233871129">(Apr 09 2021 at 18:40)</a>:</h4>
<p>I suppose it doesn't, it's different from your notion of breaking ties arbitrarily</p>



<a name="233871356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233871356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233871356">(Apr 09 2021 at 18:42)</a>:</h4>
<p>The case where every pair is comparable both ways in the preorder is asking for a linear order on an arbitrary type - i.e. a weak version of the well-ordering principle. I can't see this anywhere in mathlib, though.</p>



<a name="233871967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233871967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233871967">(Apr 09 2021 at 18:46)</a>:</h4>
<p>I think it might be with Zorn's lemma if anywhere?</p>



<a name="233872042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233872042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233872042">(Apr 09 2021 at 18:47)</a>:</h4>
<p>If not, I have a branch which upgrades any partial order to a linear order, in particular the empty partial order, which also gives a linear order on any type</p>



<a name="233875773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233875773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233875773">(Apr 09 2021 at 19:12)</a>:</h4>
<p>I don't see this in an obvious way in <code>order.zorn</code>. If you could link to the branch, that'd be great!</p>



<a name="233878815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233878815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233878815">(Apr 09 2021 at 19:35)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7142">#7142</a></p>



<a name="233880098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233880098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233880098">(Apr 09 2021 at 19:44)</a>:</h4>
<p>I'm not finding the well-ordering principle in mathlib anywhere either...</p>



<a name="233883106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233883106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233883106">(Apr 09 2021 at 20:06)</a>:</h4>
<p>Found it! <a href="https://leanprover-community.github.io/mathlib_docs/find/well_ordering_rel">docs#well_ordering_rel</a></p>



<a name="233883956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233883956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233883956">(Apr 09 2021 at 20:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329425">Peter Nelson</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/total.20preorder.20to.20linear.20order/near/233870848">said</a>:</p>
<blockquote>
<p>ah, you're right. I do still want a preorder though - I suppose I mean that if x &lt; y then x &lt;' y (where &lt; is the preorder and &lt;' is the linear order). What I'm thinking about is sorting a set by the value of some function to a linear order (hence giving a total preorder) with ties being broken arbitrarily. This is a bit annoying to express in terms of the unbundled order typeclasses, though.</p>
</blockquote>
<p>If I'm understanding correctly, you want an extension of an <code>is_strict_total_order</code> from an <code>is_strict_weak_order</code>?</p>



<a name="233884008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233884008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233884008">(Apr 09 2021 at 20:13)</a>:</h4>
<p>Specifically where the strict_weak_order comes from something like <code>is_strict_weak_order_of_is_total_preorder</code></p>



<a name="233887784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233887784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233887784">(Apr 09 2021 at 20:47)</a>:</h4>
<p>That looks right, yes</p>



<a name="233888142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/total%20preorder%20to%20linear%20order/near/233888142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/total.20preorder.20to.20linear.20order.html#233888142">(Apr 09 2021 at 20:50)</a>:</h4>
<p>It looks like this is easy to do, with the heavy lifting done by your extension lemma.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html">linear_map_bound_of_ball_bound</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="258238787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258238787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258238787">(Oct 19 2021 at 17:33)</a>:</h4>
<p>Do the following exist? Can they be proven under meaningful more general assumptions than <code>[is_R_or_C 𝕜]</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.dual</span>

<span class="kn">open</span> <span class="n">metric</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">is_R_or_C</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">linear_map_bound_of_sphere_bound</span>
  <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">r_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">sphere</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="n">r</span><span class="o">,</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">/</span> <span class="n">r</span> <span class="bp">*</span> <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">linear_map_bound_of_ball_bound</span>
  <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">r_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">closed_ball</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="n">r</span><span class="o">,</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">/</span> <span class="n">r</span> <span class="bp">*</span> <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="258238826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258238826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258238826">(Oct 19 2021 at 17:33)</a>:</h4>
<p>I am asking because in <a href="https://github.com/kkytola/lean-questions/blob/main/alaoglu.lean">a proof of the Banach-Alaoglu theorem</a> I had to resort to the following very clumsy way... Something better should exist, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.dual</span>

<span class="kn">open</span> <span class="n">metric</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">is_R_or_C</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">linear_map_bound_of_sphere_bound</span>
  <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">r_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">sphere</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="n">r</span><span class="o">,</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">/</span> <span class="n">r</span> <span class="bp">*</span> <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">z_zero</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">z_zero</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map.map_zero</span><span class="o">,</span> <span class="n">norm_zero</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">],</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">norm_z_eq</span> <span class="o">:</span> <span class="bp">∥</span><span class="o">(</span><span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span><span class="bp">∥</span> <span class="bp">=</span>  <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="o">:=</span> <span class="n">norm_norm'</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="n">z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">norm_r_eq</span> <span class="o">:</span> <span class="bp">∥</span><span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span><span class="bp">∥</span> <span class="bp">=</span> <span class="n">r</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">is_R_or_C.norm_eq_abs</span><span class="o">,</span> <span class="n">is_R_or_C.abs_of_real</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">abs_of_pos</span> <span class="n">r_pos</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">set</span> <span class="n">z₁</span> <span class="o">:=</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥⁻¹</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="bp">•</span> <span class="n">z</span> <span class="k">with</span> <span class="n">hz₁</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">norm_f_z₁</span> <span class="o">:</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z₁</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">h</span> <span class="n">z₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mem_sphere_zero_iff_norm</span><span class="o">,</span> <span class="n">hz₁</span><span class="o">,</span> <span class="n">norm_smul</span><span class="o">,</span> <span class="n">normed_field.norm_mul</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">normed_field.norm_inv</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">norm_z_eq</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">inv_mul_cancel</span> <span class="o">(</span><span class="n">norm_pos_iff.mpr</span> <span class="n">z_zero</span><span class="o">)</span><span class="bp">.</span><span class="n">ne.symm</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">],</span>
    <span class="n">unfold_coes</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">norm_algebra_map_eq</span><span class="o">,</span> <span class="n">ring_hom.to_fun_eq_coe</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">abs_of_pos</span> <span class="n">r_pos</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">r_ne_zero</span> <span class="o">:</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℝ</span> <span class="bp">𝕜</span><span class="o">)</span><span class="bp">.</span><span class="n">map_ne_zero.mpr</span> <span class="n">r_pos.ne.symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">/</span> <span class="n">r</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">z₁</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hz₁</span><span class="o">,</span> <span class="n">linear_map.map_smul</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">div_mul_cancel</span> <span class="n">_</span> <span class="n">r_ne_zero</span><span class="o">,</span> <span class="n">mul_inv_cancel</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">z_zero</span><span class="o">,</span> <span class="n">is_R_or_C.of_real_eq_zero</span><span class="o">,</span> <span class="n">norm_eq_zero</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">eq</span><span class="o">,</span> <span class="n">normed_field.norm_mul</span><span class="o">,</span> <span class="n">normed_field.norm_div</span><span class="o">,</span> <span class="n">norm_z_eq</span><span class="o">,</span> <span class="n">norm_r_eq</span><span class="o">,</span>
      <span class="n">div_mul_eq_mul_div</span><span class="o">,</span> <span class="n">div_mul_eq_mul_div</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">div_le_div</span> <span class="n">_</span> <span class="n">_</span> <span class="n">r_pos</span> <span class="n">rfl.ge</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">mul_nonneg</span> <span class="o">((</span><span class="n">norm_nonneg</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">norm_f_z₁</span><span class="o">)</span> <span class="o">(</span><span class="n">norm_nonneg</span> <span class="n">z</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">mul_le_mul</span> <span class="n">norm_f_z₁</span> <span class="n">rfl.le</span> <span class="o">(</span><span class="n">norm_nonneg</span> <span class="n">z</span><span class="o">)</span> <span class="o">((</span><span class="n">norm_nonneg</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">norm_f_z₁</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">linear_map_bound_of_ball_bound</span>
  <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">r_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="bp">𝕜</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">closed_ball</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="n">r</span><span class="o">,</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="bp">∥</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">∥</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">/</span> <span class="n">r</span> <span class="bp">*</span> <span class="bp">∥</span> <span class="n">z</span> <span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">linear_map_bound_of_sphere_bound</span> <span class="n">r_pos</span> <span class="n">c</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">h</span> <span class="n">z</span> <span class="n">hz.le</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="258256724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258256724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258256724">(Oct 19 2021 at 19:23)</a>:</h4>
<p>There is stuff that is at least related to this in <code>src/analysis/normed_space/operator_norm.lean</code>. Search for shell</p>



<a name="258263746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258263746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258263746">(Oct 19 2021 at 20:11)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map.op_norm_le_of_ball">docs#continuous_linear_map.op_norm_le_of_ball</a></p>



<a name="258264215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258264215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258264215">(Oct 19 2021 at 20:13)</a>:</h4>
<p>Sorry, it's not the right form, it assumes a bound <code>∥f x∥ ≤ C * ∥x∥</code>.</p>



<a name="258264402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258264402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258264402">(Oct 19 2021 at 20:14)</a>:</h4>
<p>I had found <code>linear_map.bound_of_shell</code>, which is indeed morally quite similar to the <code>linear_map_bound_of_sphere_bound</code> above, and which works more generally under the assumption <code>[nondiscrete_normed_field 𝕜]</code>. By contrast, I don't think <code>linear_map_bound_of_sphere_bound</code> would work in this generality, since one can't necessarily rescale by exactly the norm (there might not be scalars of the desired norm). I also didn't find great ways of using these "shell"-lemmas for my purpose. (Although I must say that after I decided to give up the generality of <code>[nondiscrete_normed_field 𝕜]</code>, I also didn't try hard to use the "shell"-lemmas, as they appear overly complicated for <code>𝕜=ℝ</code> or <code>𝕜=ℂ</code>).</p>



<a name="258264409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258264409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258264409">(Oct 19 2021 at 20:14)</a>:</h4>
<p>So I believe <code>linear_map_bound_of_sphere_bound</code> is useful when <code>𝕜=ℝ</code> or <code>𝕜=ℂ</code>. But I do view <code>linear_map_bound_of_ball_bound</code> more fundamental, and it is not as obvious that it doesn't generalize. That said, with some trying I failed to generalize it to <code>[nondiscrete_normed_field 𝕜]</code> --- I never work with such fields, but e.g. one property that I would have liked was <code>∥ n • x ∥ = n * ∥ x ∥</code> for <code>n : ℕ</code> and <code>x : 𝕜</code>, which obviously fails for positive characteristic... This is partly why I asked for meaningful generalizations of the second lemma --- perhaps there are people to whom positive characteristic nondiscrete normed fields exist (to me they very nearly don't <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span>).</p>



<a name="258264921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258264921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258264921">(Oct 19 2021 at 20:18)</a>:</h4>
<p><code>linear_map_bound_of_ball_bound</code> is not true over a general nondiscrete normed field, for the same reason as the shell one. Think of the case where there is no element of norm between <code>1</code> and <code>2</code>. Then if you have the assumptions of your lemma with <code>r = 3/2</code>, in fact it is only speaking of points in the ball of radius <code>1</code>.</p>



<a name="258265122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258265122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258265122">(Oct 19 2021 at 20:19)</a>:</h4>
<p>Probably the right way to state general lemmas is to introduce a quantity <code>a</code> which would be the infimum of the norms of elements of norm <code>&gt; 1</code>, and get statements in term of this (where there would be a loss of a constant compared to the real or complex case, which would be exactly <code>a</code>). But it also makes sense to just state and prove your lemmas over <code>is_R_or_C</code>, I think.</p>



<a name="258265374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258265374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258265374">(Oct 19 2021 at 20:21)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>!</p>
<p>If these lemmas are done assuming <code>[is_R_or_C 𝕜]</code> then my question is a golfing challenge <span aria-label="golf" class="emoji emoji-1f3cc" role="img" title="golf">:golf:</span>.</p>



<a name="258271369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258271369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258271369">(Oct 19 2021 at 21:02)</a>:</h4>
<p>[EDIT: Sorry, what I say below doesn't show what I said it did...]</p>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/linear_map_bound_of_ball_bound/near/258264921">said</a>:</p>
<blockquote>
<p><code>linear_map_bound_of_ball_bound</code> is not true over a general nondiscrete normed field, for the same reason as the shell one. Think of the case where there is no element of norm between <code>1</code> and <code>2</code>. Then if you have the assumptions of your lemma with <code>r = 3/2</code>, in fact it is only speaking of points in the ball of radius <code>1</code>.</p>
</blockquote>
<p>This one I didn't quite understand... I thought <em>[EDIT: incorrectly]</em> that the combination of the following shows that there are always elements of norm between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">1+\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span> for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varepsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="o">(</span><span class="n">x_ne_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∥</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span> <span class="n">x</span> <span class="bp">∥⁻¹</span> <span class="o">:=</span> <span class="n">normed_field.norm_inv</span> <span class="n">_</span>

<span class="kd">example</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ε_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">ε</span> <span class="bp">&lt;</span> <span class="bp">∥</span> <span class="n">x</span> <span class="bp">∥</span> <span class="bp">∧</span> <span class="bp">∥</span> <span class="n">x</span> <span class="bp">∥</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">ε</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">normed_field.exists_norm_lt</span> <span class="bp">𝕜</span> <span class="n">ε_pos</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span> <span class="o">⟨</span><span class="n">norm_z_pos</span><span class="o">,</span> <span class="n">norm_z_lt</span><span class="o">⟩⟩,</span>
  <span class="n">use</span> <span class="mi">1</span><span class="bp">+</span><span class="n">z</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">le_abs_self</span> <span class="o">(</span><span class="bp">∥</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span><span class="bp">∥</span> <span class="bp">-</span> <span class="bp">∥-</span><span class="n">z</span><span class="bp">∥</span><span class="o">))</span> <span class="o">(</span><span class="n">abs_norm_sub_norm_le</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="n">z</span><span class="o">)),</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">key</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">lt_of_lt_of_le</span> <span class="n">_</span> <span class="n">key</span><span class="o">,</span>
    <span class="n">linarith</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">lt_of_le_of_lt</span> <span class="o">(</span><span class="n">norm_add_le</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>But as I said, I don't really work with nondiscrete normed fields that do not satisfy the assumption <code>[is_R_or_C 𝕜]</code>.</p>



<a name="258274259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258274259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258274259">(Oct 19 2021 at 21:20)</a>:</h4>
<p>Sorry about the above thoughtless post.</p>
<p>Anyway, following Sébastien's comment that <code>[is_R_or_C 𝕜]</code>-generality makes some sense, I think I will soon PR the Banach-Alaoglu. Golfing the lemmas in that generality will then anyway be done either before or during the review...</p>
<p>(Actually, perhaps Banach-Alaoglu holds under weaker assumptions than <code>[is_R_or_C 𝕜]</code>. How about <code>[nondiscrete_normed_field 𝕜] [proper_space 𝕜]</code>? Anyways, I think I have formally proven that I am confused about such fields, so someone else can generalize later <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.)</p>



<a name="258378294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear_map_bound_of_ball_bound/near/258378294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear_map_bound_of_ball_bound.html#258378294">(Oct 20 2021 at 14:31)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/9827">#9827</a></p>
<p>In order to keep the review more manageable to both me and the reviewers, I separated the above lemmas from the Banach-Alaoglu PR. Very sorry that I did not manage to get nicer proofs yet! I hope someone generous reviewer is willing to help golf them (provided they are deemed worthy in mathlib in the first place). Thank you in advance!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
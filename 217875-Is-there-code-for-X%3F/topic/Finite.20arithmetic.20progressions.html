---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html">Finite arithmetic progressions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="282454131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282454131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282454131">(May 16 2022 at 06:31)</a>:</h4>
<p>Is there code for finite arithmetic progressions? Either as lists or (preferably) finite sets, such as <code>{5,7,9,11}</code> (4 integers starting from 5 with step 2). I know of <code>data.finset.intervals</code> which seems very handy, but only has "step 1" progressions. I would need these for results in finite additive combinatorics. Obviously I can create a step-<em>s</em> progression by taking an interval of integers and multiplying pointwise by <em>s</em>, but next I will be needing results on sums and cardinalities of such beasts.</p>



<a name="282454492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282454492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282454492">(May 16 2022 at 06:37)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/linear_recurrence">docs#linear_recurrence</a>? edit: no, that's not for arithmetic progressions</p>



<a name="282454661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282454661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282454661">(May 16 2022 at 06:41)</a>:</h4>
<p>It seem a little strange to me to represent progressions as a set rather than a list or tuple, since progressions seem inherently ordered</p>



<a name="282454758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282454758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282454758">(May 16 2022 at 06:42)</a>:</h4>
<p>The tuple version could look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.vec_notation</span>

<span class="k">#eval</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*↑</span><span class="n">x</span><span class="o">)</span>
<span class="c1">-- ![5, 8, 11, 14]</span>
</code></pre></div>



<a name="282454987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282454987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282454987">(May 16 2022 at 06:46)</a>:</h4>
<p>I don't have any strong preference between set and list here. What I essentially need is ability to form pointwise sums and have some characterization of the result (e.g. adding two progressions that have the same step is a new progression with the same step, and we know its endpoints and cardinality).</p>



<a name="282455334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282455334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282455334">(May 16 2022 at 06:51)</a>:</h4>
<p>You want to do pointwise sums of sequences that are the same length, right?</p>



<a name="282455362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282455362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282455362">(May 16 2022 at 06:51)</a>:</h4>
<p>In that case, tuples are a better fit for you than lists or sets, as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="bp">+</span> <span class="mi">3</span><span class="bp">*↑</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*↑</span><span class="n">x</span><span class="o">)</span>
<span class="c1">-- ![6, 11, 16, 21]</span>
</code></pre></div>



<a name="282455519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282455519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282455519">(May 16 2022 at 06:53)</a>:</h4>
<p>No, different lengths, "pointwise" really meaning "pairwise" as in <code>data.finset.pointwise</code>. We call these sumsets in additive combinatorics. For example <code>{1,2,3} + {40,50} = {41,42,43,51,52,53}</code>.</p>



<a name="282455938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282455938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282455938">(May 16 2022 at 06:59)</a>:</h4>
<p>So you probably don't want to use lists for that</p>



<a name="282456251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282456251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282456251">(May 16 2022 at 07:02)</a>:</h4>
<p>I do have some rudimentary code already, based on <code>data.finset.Ico</code> and multiplying by the steplength, but then I thought I may be reinventing the wheel. But perhaps not?</p>



<a name="282456870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282456870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282456870">(May 16 2022 at 07:10)</a>:</h4>
<p>This might be a nice way to formulate it (assuming its true!)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- `seq step (n, start)` is a sequence of `n.succ` terms starting at `start` -/</span>
<span class="kd">def</span> <span class="n">seq</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">step</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">finset</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">p.1.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">+</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">step</span><span class="o">),</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">prod.fst_add</span><span class="o">,</span> <span class="bp">←</span><span class="n">nat.succ_add</span><span class="o">,</span> <span class="n">finset.range_add</span><span class="o">,</span> <span class="n">nat.cast_add</span><span class="o">,</span>
      <span class="n">finset.image_union</span><span class="o">,</span> <span class="n">finset.map_eq_image</span><span class="o">,</span> <span class="n">finset.image_image</span><span class="o">],</span>
   <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>You can then use <code>(seq step).mrange</code> to talk about the set of sequences of a fixed step, which are closed under addition</p>



<a name="282456912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282456912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282456912">(May 16 2022 at 07:10)</a>:</h4>
<p>An example of an auxiliary result I'm trying to prove: If <code>A</code> is a progression with step length <code>s</code>, and <code>B</code> is an interval of at least <code>s</code> consecutive integers, then the sumset <code>A+B</code> is a specific interval. (Borrowing Matlab notation for an example: the sumset of <code>100:10:200</code> and <code>0:9</code> is exactly the interval <code>100:209</code>.) Next I'll generalize to both <code>A</code> and <code>B</code> having steplengths greater than 1, etc.</p>



<a name="282457207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282457207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282457207">(May 16 2022 at 07:15)</a>:</h4>
<p>Ah, if you're mixing step sizes then my suggestion above is also probably not helpful (other than perhaps <code>(finset.range n.succ).image (λ i, start + i • step)</code> being a useful spelling)</p>



<a name="282457314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282457314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282457314">(May 16 2022 at 07:16)</a>:</h4>
<p>Thanks Eric! I think this suggestion essentially leads to something similar as my original idea of multiplying intervals with constants like <code>{s} * (finset.Ico a a+l)</code>. In both cases I get finsets with whatever tools already exist for them. Intervals have "pointwise" addition already.</p>



<a name="282457365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282457365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282457365">(May 16 2022 at 07:17)</a>:</h4>
<p>Note that when <code>a</code> is not a <code>nat</code> those mean different things</p>



<a name="282457435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282457435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282457435">(May 16 2022 at 07:17)</a>:</h4>
<p>That is, if <code>R</code> is "the integer multiples of 1/2" and <code>a : R</code>, then <code>(finset.Ico a a+l)</code> will produce <code>2*l</code> items</p>



<a name="282460949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282460949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282460949">(May 16 2022 at 07:58)</a>:</h4>
<p>Yes, cardinalities of intervals will be heavily dependent on the element type, I'll have to be careful with that. For my own purposes the elements will be integers or vectors of integers, but for generality...</p>



<a name="282462639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282462639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282462639">(May 16 2022 at 08:14)</a>:</h4>
<p>Regarding vector of integers; note that <code>finset.Ico ![0, 0] ![1, 1]</code> is <code>{![0, 0], ![1, 0], ![0, 1]}</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/pi.locally_finite_order">docs#pi.locally_finite_order</a>)</p>



<a name="282463316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282463316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282463316">(May 16 2022 at 08:21)</a>:</h4>
<p>Hey, welcome! What are you trying to formalize? I've been working a lot on <code>data.finset.pointwise</code> to prepare for Plünnecke and Freiman's theorem.</p>



<a name="282463553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282463553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282463553">(May 16 2022 at 08:23)</a>:</h4>
<p>Relatingly, <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> and I already have Roth's theorem on a branch, but we cheated because we didn't need a predicate for arbitrary arithmetic progressions, just arithmetic progressions of length 3, so we settled on <a href="https://leanprover-community.github.io/mathlib_docs/find/add_salem_spencer">docs#add_salem_spencer</a>.</p>



<a name="282463650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282463650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282463650">(May 16 2022 at 08:24)</a>:</h4>
<p>Bhavik also has a proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo>+</mo><mi>B</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|A| + |B| - 1 ≤ |A + B|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span></span> but I don't remember what he used as a predicate.</p>



<a name="282467575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282467575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282467575">(May 16 2022 at 09:02)</a>:</h4>
<p>I'm trying to formalize efficiency results on additive bases, basically, how many consecutive integers you can cover by the sumset <em>A</em>+<em>A</em> when cardinality |<em>A</em>¦ is fixed. Generic lower bounds (= you can cover <em>at least</em> this many integers, parameterized by |<em>A</em>|) are proven by explicit constructions where <em>A</em> is a union of arithmetic progressions (of different step sizes). The coverage of <em>consecutive</em> integers is essential in this context.</p>



<a name="282468341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282468341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282468341">(May 16 2022 at 09:09)</a>:</h4>
<p>So this is slightly aside from typical arithmetic combinatorics because we are not looking at the cardinality of the sumset as such. We are trying to maximize the coefficient <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">c=n/k^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> where <em>n</em> is the length of the interval covered by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A+A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">k=|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span></span></span></span>. A classical construction for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">c=1/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/4</span></span></span></span> is very simple, it is a union of two arithmetic progressions (with different steps). I believe the most recent is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>85</mn><mi mathvariant="normal">/</mi><mn>294</mn></mrow><annotation encoding="application/x-tex">c=85/294</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">85/294</span></span></span></span> by myself in <a href="https://arxiv.org/abs/1606.04770">https://arxiv.org/abs/1606.04770</a> using a union of 42 progressions.</p>



<a name="282468414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282468414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282468414">(May 16 2022 at 09:10)</a>:</h4>
<p>(note math is <code>$$double dollars$$</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8988em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.905em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord"><span class="mord textrm mtight sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4678em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>)</p>



<a name="282468687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282468687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282468687">(May 16 2022 at 09:13)</a>:</h4>
<p>Oh that's very cool! And that also means we won't step on each other's toes <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="282468977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282468977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282468977">(May 16 2022 at 09:16)</a>:</h4>
<p><span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> Indeed fixed-length progressions (e.g. three) can be handled pretty smoothly compared to these parameterized-length ones. Anyway if someone comes up with a very smooth representation of arbitrary-length progressions (with a wonderful API for sumsets and coverage) I'd love to hear. Meanwhile I'll be stumbling ahead with my homebrew representation...</p>



<a name="282469255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/282469255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#282469255">(May 16 2022 at 09:18)</a>:</h4>
<p>I will have to write this API for myself in the next month or two, so watch out!</p>



<a name="302654500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Finite%20arithmetic%20progressions/near/302654500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jukka Kohonen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Finite.20arithmetic.20progressions.html#302654500">(Oct 06 2022 at 13:41)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Did you by any chance do something on this? I've been doind other things but now possibly going to continue my additive-basis efforts.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
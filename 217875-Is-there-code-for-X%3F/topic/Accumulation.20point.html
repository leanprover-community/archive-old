---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html">Accumulation point</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="302725931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302725931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302725931">(Oct 06 2022 at 19:30)</a>:</h4>
<p>Since we now have a version of the identity theorem in mathlib, I'm trying to write a version which matches <a href="https://en.wikipedia.org/wiki/Identity_theorem">wikipedia's statement</a> more closely - in particular using accumulation points. My understanding was that <a href="https://leanprover-community.github.io/mathlib_docs/find/cluster_pt">docs#cluster_pt</a> is how mathlib talks about accumulation points, but stating the theorem like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">identity_theorem</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">â„‚</span> <span class="bp">â†’</span> <span class="n">â„‚</span><span class="o">}</span> <span class="o">{</span><span class="n">D</span> <span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">â„‚</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hfD</span> <span class="o">:</span> <span class="n">analytic_on</span> <span class="n">â„‚</span> <span class="n">f</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">hD</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">D</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hD'</span> <span class="o">:</span> <span class="n">is_connected</span> <span class="n">D</span><span class="o">)</span> <span class="c1">-- probably preconnected is enough</span>
  <span class="o">(</span><span class="n">hSD</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">âŠ†</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">hfS</span> <span class="o">:</span> <span class="n">S.eq_on</span> <span class="n">f</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">â„‚</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="n">cluster_pt</span> <span class="n">z</span> <span class="o">(</span><span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">))</span> <span class="o">:</span> <span class="c1">-- z is an accumulation point of S</span>
  <span class="n">D.eq_on</span> <span class="n">f</span> <span class="mi">0</span> <span class="o">:=</span>
</code></pre></div>
<p>can't work (it's not hard to show this is false). So what am I misunderstanding here? Presumably it's about accumulation points vs cluster_pt, but I can't quite figure it out</p>



<a name="302726895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302726895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302726895">(Oct 06 2022 at 19:37)</a>:</h4>
<p>I commeted about this here: <a href="https://github.com/leanprover-community/mathlib/pull/16489#discussion_r971039654">https://github.com/leanprover-community/mathlib/pull/16489#discussion_r971039654</a></p>



<a name="302727296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302727296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302727296">(Oct 06 2022 at 19:40)</a>:</h4>
<p>Ah I see, so <a href="https://leanprover-community.github.io/mathlib_docs/find/cluster_pt">docs#cluster_pt</a> on principal filters doesn't correspond to accumulation points of sets, thanks!</p>



<a name="302727350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302727350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302727350">(Oct 06 2022 at 19:40)</a>:</h4>
<p>Don't you simply want the analogue of <code>cluster_pt</code> but with punctured neighborhoods?</p>



<a name="302727487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302727487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302727487">(Oct 06 2022 at 19:41)</a>:</h4>
<p>I mean <code>ğ“[â‰ ]  x</code> instead of  <code>ğ“ x</code></p>



<a name="302727609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302727609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302727609">(Oct 06 2022 at 19:42)</a>:</h4>
<p>Ah, so <code>hz</code> should instead be <code>(hz : (ğ“[â‰ ] z âŠ“ ğ“Ÿ S).ne_bot)</code>? That seems reasonable to me</p>



<a name="302727682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302727682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302727682">(Oct 06 2022 at 19:42)</a>:</h4>
<p>Indeed it is suspicious that <code>cluster_pt</code> doesn't give back the right notion for set. Maybe mathlib's definition is not the right one. We should check that.</p>



<a name="302728896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302728896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302728896">(Oct 06 2022 at 19:51)</a>:</h4>
<p>I checked the definition of cluster point of a filter is the same in Bourbaki and in mathlib.</p>



<a name="302729347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302729347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302729347">(Oct 06 2022 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302728896">said</a>:</p>
<blockquote>
<p>I checked the definition of cluster point of a filter is the same in Bourbaki and in mathlib.</p>
</blockquote>
<p>Hmm, does this then mean that cluster points of filters don't align as closely as I guessed to cluster points of sets?</p>



<a name="302729796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302729796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302729796">(Oct 06 2022 at 19:56)</a>:</h4>
<p>No, it's just that cluster points and accumulation points are in general different concepts.</p>



<a name="302730002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302730002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302730002">(Oct 06 2022 at 19:57)</a>:</h4>
<p>(At least, with the terminology I am used to)</p>



<a name="302730003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302730003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302730003">(Oct 06 2022 at 19:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302729796">said</a>:</p>
<blockquote>
<p>No, it's just that cluster points and accumulation points are in general different concepts.</p>
</blockquote>
<p>In this case I'm confused at the docstring for <code>cluster_pt</code>, which says that these are also called accumulation points</p>



<a name="302730598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302730598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302730598">(Oct 06 2022 at 20:00)</a>:</h4>
<p>aha, well, Wikipedia says my version of the terminology is nonstandard. It says that cluster point, accumulation point and limit point are all synonymous (with punctured nhds definition), and that <em>adherent point</em> is what mathlib currently calls cluster point. (I've never heard anyone use the term "adherent point" before though.)</p>



<a name="302731026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302731026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302731026">(Oct 06 2022 at 20:03)</a>:</h4>
<p>Personally, I've frequently heard "cluster point" or "limit point" for the nhds version, and "accumulation point" for the punctured nhds version, but maybe I have just been exposed to weird sources.</p>



<a name="302731462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302731462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302731462">(Oct 06 2022 at 20:05)</a>:</h4>
<p>It's pretty clear there are different notions and people disagree on terminology. It simply means we need to write really clear docstrings.</p>



<a name="302731743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302731743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302731743">(Oct 06 2022 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302730598">said</a>:</p>
<blockquote>
<p>(I've never heard anyone use the term "adherent point" before though.)</p>
</blockquote>
<p>This may come from French. In French the closure of a set is called the "adhÃ©rence" of the set.</p>



<a name="302732725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302732725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302732725">(Oct 06 2022 at 20:14)</a>:</h4>
<p>So now that I understand <code>cluster_pt</code>, my new goal is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">â„‚</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>
</code></pre></div>
<p>Any hints?</p>



<a name="302734206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302734206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302734206">(Oct 06 2022 at 20:24)</a>:</h4>
<p>It would certainly be useful to have some API around accumulation points and variants of that. I chose to spell it as <code>âˆƒá¶  z in ğ“[â‰ ] w, p z</code> because that felt natural at the time, but it probably isn't optimal.</p>



<a name="302734405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302734405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302734405">(Oct 06 2022 at 20:26)</a>:</h4>
<p>Bahvik, are you asking for a Lean proof or a paper proof?</p>



<a name="302734506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302734506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302734506">(Oct 06 2022 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302734405">said</a>:</p>
<blockquote>
<p>Bahvik, are you asking for a Lean proof or a paper proof?</p>
</blockquote>
<p>I understand the proof on paper - but I suspected there'd be a cleaner filter proof that I wouldn't be able to come up with on paper</p>



<a name="302734879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302734879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302734879">(Oct 06 2022 at 20:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302732725">said</a>:</p>
<blockquote>
<p>So now that I understand <code>cluster_pt</code>, my new goal is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">â„‚</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>
</code></pre></div>
<p>Any hints?</p>
</blockquote>
<p>The same statement is true with bounded, instead of compact, right?  It might be easier to prove with bounded, since any subset of a bounded set is again bounded.</p>



<a name="302734880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302734880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302734880">(Oct 06 2022 at 20:29)</a>:</h4>
<p>(In particular, on paper I'd pick a point from S, construct a sequence in S which is never equal to that point, then find a convergent subsequence, and its limit would be my choice of z. But my hope was that a cleverer filters proof could avoid going to sequences at all?)</p>



<a name="302735004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302735004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302735004">(Oct 06 2022 at 20:30)</a>:</h4>
<p>Ah, sorry, I missed <code>z</code> is in <code>S</code>, not in the closure!</p>



<a name="302735259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302735259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302735259">(Oct 06 2022 at 20:31)</a>:</h4>
<p>There is no need to use sequences</p>



<a name="302736127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302736127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302736127">(Oct 06 2022 at 20:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302735259">said</a>:</p>
<blockquote>
<p>There is no need to use sequences</p>
</blockquote>
<p>In that case I don't see how to proceed, other than using sequences... I can't seem to find much linking infinite sets and topology in mathlib</p>



<a name="302738368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302738368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302738368">(Oct 06 2022 at 20:51)</a>:</h4>
<p>Something to do with <a href="https://leanprover-community.github.io/mathlib_docs/find/is_seq_compact.subseq_of_frequently_in">docs#is_seq_compact.subseq_of_frequently_in</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/is_compact.is_seq_compact">docs#is_compact.is_seq_compact</a> and <code>(âˆƒá¶  x in ğ“[â‰ ] z, x âˆˆ s) â†” (ğ“[â‰ ] z âŠ“ ğ“Ÿ s).ne_bot</code> (which I'm not sure is true)?</p>



<a name="302738450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302738450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302738450">(Oct 06 2022 at 20:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302738368">said</a>:</p>
<blockquote>
<p>Something to do with <a href="https://leanprover-community.github.io/mathlib_docs/find/is_seq_compact.subseq_of_frequently_in">docs#is_seq_compact.subseq_of_frequently_in</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/is_compact.is_seq_compact">docs#is_compact.is_seq_compact</a> and <code>(âˆƒá¶  x in ğ“[â‰ ] z, x âˆˆ s) â†” (ğ“[â‰ ] z âŠ“ ğ“Ÿ s).ne_bot</code> (which I'm not sure is true)?</p>
</blockquote>
<p>Yeah this is what I guessed too - but this uses sequences!</p>



<a name="302739092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302739092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302739092">(Oct 06 2022 at 20:56)</a>:</h4>
<p>Ok, I'll have a look.</p>



<a name="302739118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302739118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302739118">(Oct 06 2022 at 20:56)</a>:</h4>
<p>Thanks!</p>



<a name="302739347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302739347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302739347">(Oct 06 2022 at 20:57)</a>:</h4>
<p>you can always choose a nonprincipal ultrafilter on S, push it forward to C, and take its limit as your z.</p>



<a name="302739453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302739453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302739453">(Oct 06 2022 at 20:58)</a>:</h4>
<p>I'm sure Patrick has a more elegant argument in mind ;)</p>



<a name="302740447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302740447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302740447">(Oct 06 2022 at 21:04)</a>:</h4>
<p>It's getting late here so I wrote a blunt proof.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.subset_properties</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">inf_principal_ne_bot_iff</span><span class="o">,</span>
  <span class="n">by_contra'</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hS'</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">â†</span> <span class="n">ne_empty_iff_nonempty</span><span class="o">,</span> <span class="n">not_ne_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">choose</span><span class="bp">!</span> <span class="n">U</span> <span class="n">hU</span> <span class="n">hU'</span> <span class="n">using</span> <span class="n">H</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">(</span><span class="n">U</span> <span class="n">x</span><span class="o">)</span> <span class="bp">âˆˆ</span> <span class="bp">ğ“</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">insert_mem_nhds_iff.mpr</span> <span class="o">(</span><span class="n">hU</span> <span class="n">z</span> <span class="n">hz</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">hS.elim_nhds_subcover</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">a</span><span class="o">,</span> <span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">U</span> <span class="n">a</span><span class="o">))</span> <span class="n">this</span> <span class="k">with</span> <span class="o">âŸ¨</span><span class="n">T</span><span class="o">,</span> <span class="n">hT</span><span class="o">,</span> <span class="n">hT'</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">âŠ†</span> <span class="bp">â‹ƒ</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">T</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">(</span><span class="n">U</span> <span class="n">x</span><span class="o">)âŸ©,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">subset.antisymm</span> <span class="n">_</span> <span class="n">hT</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hT'</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_Union</span><span class="o">,</span> <span class="n">mem_insert_iff</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">]</span> <span class="n">at</span> <span class="n">hT'</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hT'</span> <span class="k">with</span> <span class="o">âŸ¨</span><span class="n">y</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hzy</span><span class="o">âŸ©,</span>
    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">U</span> <span class="n">y</span> <span class="bp">âˆ©</span> <span class="n">S</span><span class="o">,</span> <span class="k">from</span> <span class="o">âŸ¨</span><span class="n">hzy</span><span class="o">,</span> <span class="n">hz</span><span class="o">âŸ©,</span>
    <span class="n">rwa</span> <span class="n">hU'</span> <span class="n">y</span> <span class="o">(</span><span class="n">hT</span> <span class="n">y</span> <span class="n">H</span><span class="o">)</span> <span class="n">at</span> <span class="n">this</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">T.finite_to_set</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302740498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302740498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302740498">(Oct 06 2022 at 21:04)</a>:</h4>
<p>It's really not polished at all, but it types-check.</p>



<a name="302740532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302740532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302740532">(Oct 06 2022 at 21:04)</a>:</h4>
<p>Thank you!</p>



<a name="302741786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302741786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302741786">(Oct 06 2022 at 21:12)</a>:</h4>
<p>A bit of polish:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">inf_principal_ne_bot_iff</span><span class="o">,</span>
  <span class="n">by_contra'</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hS'</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">â†</span> <span class="n">ne_empty_iff_nonempty</span><span class="o">,</span> <span class="n">not_ne_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">choose</span><span class="bp">!</span> <span class="n">U</span> <span class="n">hU</span> <span class="n">hU'</span> <span class="n">using</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">T</span><span class="o">:</span> <span class="n">finset</span> <span class="n">Î±</span><span class="o">,</span>  <span class="n">hT</span> <span class="o">:</span> <span class="bp">â†‘</span><span class="n">T</span> <span class="bp">âŠ†</span> <span class="n">S</span><span class="o">,</span> <span class="n">hT'</span><span class="o">:</span> <span class="n">S</span> <span class="bp">âŠ†</span> <span class="bp">â‹ƒ</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">T</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">(</span><span class="n">U</span> <span class="n">x</span><span class="o">)âŸ©</span> <span class="o">:=</span>
    <span class="n">hS.elim_nhds_subcover</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">a</span><span class="o">,</span> <span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">U</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">insert_mem_nhds_iff.mpr</span> <span class="o">(</span><span class="n">hU</span> <span class="n">z</span> <span class="n">hz</span><span class="o">)),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">subset.antisymm</span> <span class="n">_</span> <span class="n">hT</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hT'</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_Union</span><span class="o">,</span> <span class="n">mem_insert_iff</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">]</span> <span class="n">at</span> <span class="n">hT'</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hT'</span> <span class="k">with</span> <span class="o">âŸ¨</span><span class="n">y</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hzy</span><span class="o">âŸ©,</span>
    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">U</span> <span class="n">y</span> <span class="bp">âˆ©</span> <span class="n">S</span><span class="o">,</span> <span class="k">from</span> <span class="o">âŸ¨</span><span class="n">hzy</span><span class="o">,</span> <span class="n">hz</span><span class="o">âŸ©,</span>
    <span class="n">rwa</span> <span class="n">hU'</span> <span class="n">y</span> <span class="o">(</span><span class="n">hT</span> <span class="n">H</span><span class="o">)</span> <span class="n">at</span> <span class="n">this</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">T.finite_to_set</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302751965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302751965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302751965">(Oct 06 2022 at 22:27)</a>:</h4>
<p>With a sequence <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">â„‚</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">hS'.nat_embedding</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">â„“</span><span class="o">,</span> <span class="n">hâ„“</span><span class="o">,</span> <span class="n">Ï†</span><span class="o">,</span> <span class="n">hÏ†1</span><span class="o">,</span> <span class="n">hÏ†2</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">hS.is_seq_compact</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">prop</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">âŸ¨</span><span class="n">â„“</span><span class="o">,</span> <span class="n">hâ„“</span><span class="o">,</span> <span class="n">inf_principal_ne_bot_iff.mpr</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span> <span class="n">_</span><span class="o">)âŸ©,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:=</span> <span class="n">hÏ†2</span> <span class="o">(</span><span class="n">insert_mem_nhds_iff.mpr</span> <span class="n">hU</span><span class="o">),</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h3</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="n">N</span><span class="o">,</span> <span class="bp">âˆ€</span> <span class="n">n</span><span class="o">,</span> <span class="n">N</span> <span class="bp">â‰¤</span> <span class="n">n</span> <span class="bp">â†’</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">â‰ </span> <span class="n">â„“</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">by_contra'</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">nâ‚</span><span class="o">,</span> <span class="n">hâ‚</span><span class="o">,</span> <span class="n">h'â‚</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">this</span> <span class="mi">0</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">nâ‚‚</span><span class="o">,</span> <span class="n">hâ‚‚</span><span class="o">,</span> <span class="n">h'â‚‚</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">nâ‚</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
      <span class="n">linarith</span> <span class="o">[</span><span class="n">f.inj'</span> <span class="o">(</span><span class="n">subtype.coe_injective</span> <span class="o">(</span><span class="n">h'â‚.trans</span> <span class="n">h'â‚‚.symm</span><span class="o">))]</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">N</span><span class="o">,</span> <span class="n">hN</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">N'</span><span class="o">,</span> <span class="n">hN'</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">h3</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hN'</span> <span class="o">(</span><span class="n">N</span> <span class="bp">âŠ”</span> <span class="n">N'</span><span class="o">)</span> <span class="n">le_sup_right</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hN</span> <span class="o">(</span><span class="n">Ï†</span> <span class="o">(</span><span class="n">N</span> <span class="bp">âŠ”</span> <span class="n">N'</span><span class="o">))</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">le_sup_left.trans</span> <span class="o">(</span><span class="n">hÏ†1.id_le</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">âŸ¨</span><span class="n">f</span> <span class="o">(</span><span class="n">Ï†</span> <span class="o">(</span><span class="n">N</span> <span class="bp">âŠ”</span> <span class="n">N'</span><span class="o">)),</span> <span class="n">_</span><span class="o">âŸ©,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hN</span><span class="o">,</span> <span class="n">hN'</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">hN'.resolve_left</span> <span class="n">hN</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302757275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302757275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302757275">(Oct 06 2022 at 23:18)</a>:</h4>
<p>Generalization to any topological space:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.basic</span>
<span class="kn">import</span> <span class="n">topology.subset_properties</span>
<span class="kn">import</span> <span class="n">topology.basic</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hS'</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">filter.not_ne_bot</span><span class="o">,</span> <span class="n">filter.inf_principal_eq_bot</span><span class="o">,</span> <span class="n">mem_nhds_within</span><span class="o">]</span> <span class="n">at</span> <span class="n">hS'</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">hS.elim_nhds_subcover'</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">S</span><span class="bp">á¶œ</span> <span class="bp">âˆª</span> <span class="o">{</span><span class="n">z</span><span class="o">})</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.not_infinite.2</span> <span class="o">((</span><span class="n">t.finite_to_set.image</span> <span class="bp">$</span> <span class="bp">Î»</span> <span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">x.1</span><span class="o">)</span><span class="bp">.</span><span class="n">subset</span> <span class="bp">$</span> <span class="bp">Î»</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">specialize</span> <span class="n">ht</span> <span class="n">hx</span><span class="o">,</span> <span class="n">simp_rw</span> <span class="n">set.mem_Union</span> <span class="n">at</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hx'</span><span class="bp">|</span><span class="n">hx'</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">exacts</span> <span class="o">[(</span><span class="n">hx'</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">âŸ¨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hx'.symm</span><span class="o">âŸ©]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">âŸ¨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hzu</span><span class="o">,</span> <span class="n">hs</span><span class="o">âŸ©</span> <span class="o">:=</span> <span class="n">hS'</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_nhds_iff</span><span class="o">,</span> <span class="n">set.union_comm</span><span class="o">],</span>
    <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">u</span><span class="o">,</span> <span class="n">set.diff_subset_iff.1</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hzu</span><span class="o">âŸ©</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302757361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302757361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302757361">(Oct 06 2022 at 23:19)</a>:</h4>
<p>The idea is that if S has no accumulation point then every point is isolated so it's a discrete subspace of X, which is compact iff it's finite.</p>



<a name="302798494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302798494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302798494">(Oct 07 2022 at 08:03)</a>:</h4>
<p>My version was already in the same generality, with almost the same proof. The issue is not to compress a couple of lines, it is adding some api lemmas to make it obvious. Concretely, the target is to avoid using covers (which are really bad taste from a mathlib point of view). I'm away from my computer all day but I will do it tonight.</p>



<a name="302799774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302799774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302799774">(Oct 07 2022 at 08:13)</a>:</h4>
<p>Ah, itâ€™s a shame that I didnâ€™t see that earlier because Iâ€™ve thought quite deeply about this last year during my course on holomorphic functions (and Iâ€™ve been explaining it periodically to some of my friends since then). Of course we werenâ€™t talking about filters but the generalization is pretty straightforward. The proof Iâ€™ve been taught is the one Junyan describes, and I think that this is the right one but we donâ€™t have the API ready for this. Basically I think any mathlib proof should go through <a href="https://leanprover-community.github.io/mathlib_docs/find/finite_of_compact_of_discrete">docs#finite_of_compact_of_discrete</a>.</p>



<a name="302800586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302800586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302800586">(Oct 07 2022 at 08:18)</a>:</h4>
<p>We might also be able to cook up a direct proof not going through covers, but I think we want to have all the API to make that proof trivial anyway, so I donâ€™t think it is a problem to transitively use covers</p>



<a name="302812397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302812397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302812397">(Oct 07 2022 at 09:36)</a>:</h4>
<p>That said, Adam's suggestion <em>does</em> look nice, at least in the non-relative case:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.subset_properties</span>
<span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">hyperfilter</span> <span class="n">Î±</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="o">{</span><span class="n">f.Lim</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">â†</span> <span class="n">not_mem_iff_inf_principal_compl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">finite_singleton</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">nmem_hyperfilter</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">f.Lim</span><span class="o">,</span> <span class="bp">@@</span><span class="n">ne_bot_of_le</span> <span class="n">this</span> <span class="o">(</span><span class="n">inf_le_inf_right</span> <span class="o">(</span><span class="bp">ğ“Ÿ</span> <span class="o">{</span><span class="n">f.Lim</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">)</span> <span class="n">f.le_nhds_Lim</span><span class="o">)âŸ©</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302814523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302814523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302814523">(Oct 07 2022 at 09:51)</a>:</h4>
<p>Going from the absolute case to the relative case is then a bit annoying, but here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">compact_space</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">is_compact_iff_compact_space.mp</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">infinite</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">hS'.to_subtype</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">foo</span> <span class="n">S</span> <span class="k">with</span> <span class="o">âŸ¨âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">âŸ©,</span> <span class="n">hz</span><span class="o">âŸ©,</span>
  <span class="n">refine</span> <span class="o">âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">,</span> <span class="bp">@@</span><span class="n">ne_bot_of_le</span> <span class="o">(</span><span class="bp">@@</span><span class="n">filter.map_ne_bot</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="n">hz</span><span class="o">)</span> <span class="n">_</span><span class="o">âŸ©,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_within</span><span class="o">,</span> <span class="n">nhds_within</span><span class="o">,</span> <span class="n">map_inf</span> <span class="n">subtype.coe_injective</span><span class="o">,</span> <span class="n">inf_assoc</span><span class="o">,</span> <span class="n">inf_principal</span><span class="o">,</span>
      <span class="n">map_principal</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">subtype.image_preimage_coe</span><span class="o">,</span> <span class="n">preimage_compl</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">inf_le_inf</span> <span class="o">(</span><span class="n">continuous_subtype_coe</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_at</span>
    <span class="o">(</span><span class="n">principal_mono.mpr</span> <span class="bp">$</span> <span class="n">monotone_image</span> <span class="bp">$</span> <span class="n">compl_subset_compl.mpr</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rintros</span> <span class="n">x</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">coe</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">),</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302817386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302817386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302817386">(Oct 07 2022 at 10:09)</a>:</h4>
<p>Here is my last word, now I have to focus on the lecture:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.subset_properties</span>
<span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">hyperfilter</span> <span class="n">Î±</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="o">{</span><span class="n">f.Lim</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">â†</span> <span class="n">not_mem_iff_inf_principal_compl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">finite_singleton</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">nmem_hyperfilter</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">f.Lim</span><span class="o">,</span> <span class="bp">@@</span><span class="n">ne_bot_of_le</span> <span class="n">this</span> <span class="o">(</span><span class="n">inf_le_inf_right</span> <span class="o">(</span><span class="bp">ğ“Ÿ</span> <span class="o">{</span><span class="n">f.Lim</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">)</span> <span class="n">f.le_nhds_Lim</span><span class="o">)âŸ©</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">nhds_within_inf_principal</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">ğ“</span><span class="o">[</span><span class="n">S</span><span class="o">]</span> <span class="n">x</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">T</span> <span class="bp">=</span> <span class="bp">ğ“</span><span class="o">[</span><span class="n">T</span><span class="o">]</span> <span class="n">x</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_within</span><span class="o">,</span> <span class="n">nhds_within</span><span class="o">,</span> <span class="n">inf_assoc</span><span class="o">,</span> <span class="bp">@</span><span class="n">inf_comm</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">ğ“Ÿ</span> <span class="n">_</span><span class="o">),</span> <span class="bp">â†</span> <span class="n">inf_assoc</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">compact_space</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">is_compact_iff_compact_space.mp</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">infinite</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">hS'.to_subtype</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">foo</span> <span class="n">S</span> <span class="k">with</span> <span class="o">âŸ¨âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">âŸ©,</span> <span class="n">hz</span><span class="o">âŸ©,</span>
  <span class="n">refine</span> <span class="o">âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">,</span> <span class="bp">@@</span><span class="n">ne_bot_of_le</span> <span class="o">(</span><span class="bp">@@</span><span class="n">filter.map_ne_bot</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="n">hz</span><span class="o">)</span> <span class="n">_</span><span class="o">âŸ©,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_within</span><span class="o">,</span> <span class="n">map_inf</span> <span class="n">subtype.coe_injective</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">nhds_within_eq_map_subtype_coe</span><span class="o">,</span>
      <span class="n">nhds_within_inf_principal</span><span class="o">,</span> <span class="n">map_principal</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">inf_le_inf_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">principal_mono.mpr</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">convert</span> <span class="n">image_compl_subset</span> <span class="n">subtype.coe_injective</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">image_singleton</span><span class="o">,</span> <span class="n">singleton_eq_singleton_iff</span><span class="o">],</span>
  <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302862405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302862405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302862405">(Oct 07 2022 at 14:20)</a>:</h4>
<p>I realised that we can use <code>cluster_pt</code>, just slightly differently: <code>cluster_pt x (ğ“Ÿ (S \ {x})) â†” (ğ“[â‰ ] x âŠ“ ğ“Ÿ S).ne_bot â†” x âˆˆ closure (S \ {x})</code></p>



<a name="302875216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302875216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302875216">(Oct 07 2022 at 15:14)</a>:</h4>
<p>Last version, proving directly the relative case, is still not satisfying, and I need to stop playing with this <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.subset_properties</span>
<span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">map_coe_le_principal</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">S</span><span class="o">}</span> <span class="o">:</span> <span class="n">map</span> <span class="n">coe</span> <span class="n">f</span> <span class="bp">â‰¤</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">le_principal_iff.mpr</span> <span class="bp">$</span> <span class="bp">@@</span><span class="n">mem_of_superset</span> <span class="o">(</span><span class="bp">@</span><span class="n">univ_mem</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span> <span class="n">x.2</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">nhds_within</span><span class="o">,</span> <span class="n">inf_assoc</span><span class="o">,</span> <span class="n">inf_principal</span><span class="o">],</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">infinite</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">hS'.to_subtype</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Î±</span> <span class="o">:=</span> <span class="n">ultrafilter.map</span> <span class="n">coe</span> <span class="o">(</span><span class="n">hyperfilter</span> <span class="n">S</span><span class="o">),</span>
  <span class="n">rcases</span> <span class="n">hS.ultrafilter_le_nhds</span> <span class="n">f</span> <span class="n">map_coe_le_principal</span> <span class="k">with</span> <span class="o">âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">,</span> <span class="n">hz</span><span class="o">âŸ©,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="o">({</span><span class="n">z</span><span class="o">}</span><span class="bp">á¶œ</span> <span class="bp">âˆ©</span> <span class="n">S</span><span class="o">))</span><span class="bp">.</span><span class="n">ne_bot</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">â†</span> <span class="n">compl_compl</span> <span class="n">S</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">compl_union</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">not_mem_iff_inf_principal_compl</span><span class="o">],</span>
    <span class="n">change</span> <span class="n">coe</span> <span class="bp">â»Â¹'</span> <span class="n">_</span> <span class="bp">âˆ‰</span> <span class="n">hyperfilter</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">preimage_union</span><span class="o">,</span> <span class="n">subtype.preimage_coe_compl</span><span class="o">,</span> <span class="n">union_empty</span><span class="o">],</span>
    <span class="n">exact</span> <span class="o">((</span><span class="n">finite_singleton</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">preimage</span> <span class="bp">$</span> <span class="n">subtype.coe_injective.inj_on</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">nmem_hyperfilter</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="o">âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">,</span> <span class="bp">@@</span><span class="n">ne_bot_of_le</span> <span class="n">this</span> <span class="o">(</span><span class="n">inf_le_inf_right</span> <span class="n">_</span> <span class="n">hz</span><span class="o">)âŸ©</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302875604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302875604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302875604">(Oct 07 2022 at 15:16)</a>:</h4>
<p>I'd say we should add API for both the version through <a href="https://leanprover-community.github.io/mathlib_docs/find/finite_of_compact_of_discrete">docs#finite_of_compact_of_discrete</a> and the version using ultrafilters and then see which one is cleaner, because both proofs should be easier than what they are right now</p>



<a name="302914085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302914085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302914085">(Oct 07 2022 at 18:41)</a>:</h4>
<p>Here is my proposal filling API holes for the <code>finite_of_compact_of_discrete</code> route:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.subset_properties</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">filter.principal_eq_map_coe_top</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">map</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ¤</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">lemma</span> <span class="n">filter.inf_principal_eq_bot_iff_comap</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="bp">â†”</span> <span class="n">comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">filter.principal_eq_map_coe_top</span> <span class="n">s</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">filter.push_pull'</span><span class="o">,</span><span class="n">inf_top_eq</span><span class="o">,</span> <span class="n">map_eq_bot_iff</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">discrete_topology_iff_nhds</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">Î±</span> <span class="bp">â†”</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="bp">ğ“</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span> <span class="bp">;</span> <span class="n">introI</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nhds_discrete</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">eq_of_nhds_eq_nhds</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">nhds_discrete</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_topology_iff_nhds_neq</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">Î±</span> <span class="bp">â†”</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">discrete_topology_iff_nhds</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_within</span><span class="o">,</span> <span class="n">inf_principal_eq_bot</span><span class="o">,</span> <span class="n">compl_compl</span><span class="o">],</span>
  <span class="n">split</span> <span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">singleton_mem_pure</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_pure_iff.mpr</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">pure_le_nhds</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">subtype.discrete_topology_iff</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">S</span> <span class="bp">â†”</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">x</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">discrete_topology_iff_nhds_neq</span><span class="o">,</span> <span class="n">set_coe.forall'</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">filter.inf_principal_eq_bot_iff_comap</span><span class="o">,</span> <span class="n">nhds_within</span><span class="o">,</span> <span class="n">nhds_within</span><span class="o">,</span> <span class="n">comap_inf</span><span class="o">,</span> <span class="n">comap_principal</span><span class="o">,</span>
      <span class="n">preimage_compl</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">image_singleton</span><span class="o">,</span> <span class="n">function.injective.preimage_image</span> <span class="n">subtype.coe_injective</span><span class="o">,</span>
      <span class="n">nhds_induced</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_compact.finite</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">S.finite</span> <span class="o">:=</span>
<span class="n">finite_coe_iff.mp</span> <span class="o">(</span><span class="bp">@</span><span class="n">finite_of_compact_of_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">is_compact_iff_compact_space.mp</span> <span class="n">hS</span><span class="o">)</span> <span class="n">hS'</span><span class="o">)</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra'</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">not_ne_bot</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hS'</span> <span class="o">(</span><span class="n">hS.finite</span> <span class="bp">$</span> <span class="n">subtype.discrete_topology_iff.mpr</span> <span class="n">H</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302914136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302914136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302914136">(Oct 07 2022 at 18:42)</a>:</h4>
<p>I'll do the ultrafilter road later.</p>



<a name="302940875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302940875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302940875">(Oct 07 2022 at 22:02)</a>:</h4>
<p>I went back to this. Now I claim the preliminaries for both roads are:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.subset_properties</span>

<span class="n">open_locale</span> <span class="n">filter</span> <span class="n">topological_space</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">namespace</span> <span class="n">filter</span>
<span class="kd">lemma</span> <span class="n">principal_eq_map_coe_top</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">map</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ¤</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>

<span class="kd">lemma</span> <span class="n">inf_principal_eq_bot_iff_comap</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="bp">â†”</span> <span class="n">comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">filter.principal_eq_map_coe_top</span> <span class="n">s</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">filter.push_pull'</span><span class="o">,</span><span class="n">inf_top_eq</span><span class="o">,</span> <span class="n">map_eq_bot_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">ne_bot_of_comap</span> <span class="o">{</span><span class="n">Î±</span> <span class="n">Î²</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">Î±</span> <span class="bp">â†’</span> <span class="n">Î²</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î²</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span><span class="o">)</span> <span class="o">:</span> <span class="n">F.ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ne_bot_iff</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">comap_bot</span>
<span class="kd">end</span>
<span class="kd">end</span> <span class="n">filter</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">discrete_topology_iff_nhds</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">Î±</span> <span class="bp">â†”</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="bp">ğ“</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span> <span class="bp">;</span> <span class="n">introI</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">nhds_discrete</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">eq_of_nhds_eq_nhds</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">nhds_discrete</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">discrete_topology_iff_nhds_neq</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">Î±</span> <span class="bp">â†”</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">discrete_topology_iff_nhds</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">forall_congr</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nhds_within</span><span class="o">,</span> <span class="n">inf_principal_eq_bot</span><span class="o">,</span> <span class="n">compl_compl</span><span class="o">],</span>
  <span class="n">split</span> <span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">singleton_mem_pure</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">le_pure_iff.mpr</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">pure_le_nhds</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">subtype.nhds_within_eq_bot_iff</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">ğ“</span><span class="o">[(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">â»Â¹'</span> <span class="n">t</span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="bp">â†”</span> <span class="bp">ğ“</span><span class="o">[</span><span class="n">t</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">inf_principal_eq_bot_iff_comap</span><span class="o">,</span> <span class="n">nhds_within</span><span class="o">,</span> <span class="n">nhds_within</span><span class="o">,</span> <span class="n">comap_inf</span><span class="o">,</span> <span class="n">comap_principal</span><span class="o">,</span>
       <span class="n">nhds_induced</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">subtype.nhds_ne_eq_bot_iff</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">}</span> <span class="o">:</span> <span class="bp">ğ“</span><span class="o">[{</span><span class="n">x</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">]</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="bp">â†”</span> <span class="bp">ğ“</span><span class="o">[{</span><span class="n">x</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">â†</span> <span class="n">subtype.nhds_within_eq_bot_iff</span><span class="o">,</span> <span class="n">preimage_compl</span><span class="o">,</span> <span class="bp">â†</span> <span class="n">image_singleton</span><span class="o">,</span>
       <span class="n">subtype.coe_injective.preimage_image</span> <span class="o">]</span>

<span class="kd">lemma</span> <span class="n">subtype.nhds_ne_ne_bot_iff</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">ğ“</span><span class="o">[{</span><span class="n">x</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">]</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="bp">â†”</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[{</span><span class="n">x</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ne_bot_iff</span><span class="o">,</span> <span class="n">ne_bot_iff</span><span class="o">,</span> <span class="n">not_iff_not</span><span class="o">,</span> <span class="n">subtype.nhds_ne_eq_bot_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">subtype.discrete_topology_iff</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">S</span> <span class="bp">â†”</span> <span class="bp">âˆ€</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">x</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span> <span class="bp">=</span> <span class="bp">âŠ¥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">discrete_topology_iff_nhds_neq</span><span class="o">,</span> <span class="n">set_coe.forall'</span><span class="o">,</span> <span class="n">subtype.nhds_ne_eq_bot_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">is_compact.finite</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">discrete_topology</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">S.finite</span> <span class="o">:=</span>
<span class="n">finite_coe_iff.mp</span> <span class="o">(</span><span class="bp">@</span><span class="n">finite_of_compact_of_discrete</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">is_compact_iff_compact_space.mp</span> <span class="n">hS</span><span class="o">)</span> <span class="n">hS'</span><span class="o">)</span>
</code></pre></div>



<a name="302940941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302940941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302940941">(Oct 07 2022 at 22:03)</a>:</h4>
<p>And then we get to choose between the discrete road:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra'</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">not_ne_bot</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">discrete_topology_iff_nhds_neq.mpr</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">infinite.not_finite</span> <span class="o">(</span><span class="n">finite_of_compact_of_discrete</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">Î±</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra'</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">not_ne_bot</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hS'</span> <span class="o">(</span><span class="n">hS.finite</span> <span class="bp">$</span> <span class="n">subtype.discrete_topology_iff.mpr</span> <span class="n">H</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>and the ultrafilter road:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">hyperfilter</span> <span class="n">Î±</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="o">{</span><span class="n">f.Lim</span><span class="o">}</span><span class="bp">á¶œ</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">not_mem_iff_inf_principal_compl.mp</span> <span class="o">(</span><span class="n">finite_singleton</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">nmem_hyperfilter</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">f.Lim</span><span class="o">,</span> <span class="bp">@@</span><span class="n">ne_bot_of_le</span> <span class="n">this</span> <span class="o">(</span><span class="n">inf_le_inf_right</span> <span class="n">_</span> <span class="n">f.le_nhds_Lim</span><span class="o">)âŸ©</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">}</span> <span class="o">(</span><span class="n">hS</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">hS'</span> <span class="o">:</span> <span class="n">S.infinite</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">âˆƒ</span> <span class="n">z</span> <span class="bp">âˆˆ</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="bp">ğ“</span><span class="o">[</span><span class="bp">â‰ </span><span class="o">]</span> <span class="n">z</span> <span class="bp">âŠ“</span> <span class="bp">ğ“Ÿ</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">compact_space</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">is_compact_iff_compact_space.mp</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">infinite</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">hS'.to_subtype</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">foo</span> <span class="n">S</span> <span class="k">with</span> <span class="o">âŸ¨âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">âŸ©,</span> <span class="n">hz</span><span class="o">âŸ©,</span>
  <span class="n">refine</span> <span class="o">âŸ¨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzS</span><span class="o">,</span> <span class="n">subtype.nhds_ne_ne_bot_iff.mp</span> <span class="n">hz</span><span class="o">âŸ©</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302940972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302940972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302940972">(Oct 07 2022 at 22:03)</a>:</h4>
<p>Anatole, note in particular how deducing the relative version from the absolute one is now painless.</p>



<a name="302941531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302941531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302941531">(Oct 07 2022 at 22:08)</a>:</h4>
<p>And of course the last proof above deducing the relative version from the absolute one could also be used in the discrete road.</p>



<a name="302985670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/302985670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#302985670">(Oct 08 2022 at 09:06)</a>:</h4>
<p>I just opened <a href="https://github.com/leanprover-community/mathlib/pull/16862">#16862</a>. I used the discrete set path since it is more elementary and not longer, but I included preliminary lemmas for both proofs.</p>



<a name="303005021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303005021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303005021">(Oct 08 2022 at 11:44)</a>:</h4>
<p>Should we also settle on one definition to be named <code>accumulation_pt</code> and something or other for the relative version, and add two tfae lemmas for the various equivalent versions? And use that instead of the explicit <code>ne_bot</code> version in mathlib where possible?</p>



<a name="303044122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303044122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303044122">(Oct 08 2022 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/303005021">said</a>:</p>
<blockquote>
<p>Should we also settle on one definition to be named <code>accumulation_pt</code> and something or other for the relative version, and add two tfae lemmas for the various equivalent versions? And use that instead of the explicit <code>ne_bot</code> version in mathlib where possible?</p>
</blockquote>
<p>I don't think this is necessary any more, since we can use <code>cluster_pt x (ğ“Ÿ (S \ {x}))</code> in place of <code>(ğ“[â‰ ] x âŠ“ ğ“Ÿ S).ne_bot</code></p>



<a name="303044210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303044210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303044210">(Oct 08 2022 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302985670">said</a>:</p>
<blockquote>
<p>I just opened <a href="https://github.com/leanprover-community/mathlib/pull/16862">#16862</a>. I used the discrete set path since it is more elementary and not longer, but I included preliminary lemmas for both proofs.</p>
</blockquote>
<p>Thanks so much for this Patrick!</p>



<a name="303205628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303205628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303205628">(Oct 10 2022 at 06:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/303044122">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/303005021">said</a>:</p>
<blockquote>
<p>Should we also settle on one definition to be named <code>accumulation_pt</code> and something or other for the relative version, and add two tfae lemmas for the various equivalent versions? And use that instead of the explicit <code>ne_bot</code> version in mathlib where possible?</p>
</blockquote>
<p>I don't think this is necessary any more, since we can use <code>cluster_pt x (ğ“Ÿ (S \ {x}))</code> in place of <code>(ğ“[â‰ ] x âŠ“ ğ“Ÿ S).ne_bot</code></p>
</blockquote>
<p>I'm not sure I agree with this, especially if one of our goals is to cover the whole undergrad curriculum and be accessible to "normal mathematicians" who know about accumulation points and not about filters. They would likely prefer either <code>x âˆˆ closure (S \ {x})</code> or perhaps  <code>âˆƒá¶  z in ğ“[â‰ ] x, z âˆˆ S</code> (which I always read in my head as "there is a sequence tending to x, except without the pathological stuff about sequences not appearing because something something filter). That being the same as a statement in terms of principal filters, which indeed make some proofs easier further down the line, is an "implementation detail", and IMHO should be hidden from the API.</p>
<p>After all we do have a definition of <code>continuous_at</code> in mathlib even though we could inline it everywhere as <code>tendsto f (ğ“ x) (ğ“ (f x))</code> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="303214785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303214785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303214785">(Oct 10 2022 at 08:16)</a>:</h4>
<p>The <code>cluster_pt</code> definition was already introduced  for the sake of having more readable statements. This has a cost since every definition must come with lemmas, otherwise the first step in any proof is always to unfold the definition. But if there are sufficiently many statements that would benefit from the definition then it can be worth the trouble. So you can try. Note also that <code>tendsto f A B</code> is already a somewhat useless wrapper around the core definitions which are <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.map">docs#filter.map</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.partial_order">docs#filter.partial_order</a>, and <code>map f A â‰¤ B</code> is actually shorter to type and more evocative. And you can read <code>âˆƒá¶  z in ğ“[â‰ ] x, z âˆˆ S</code> as "there exist a point near x but different from x that belongs to S", without thinking in terms of sequences.</p>



<a name="303219530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303219530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303219530">(Oct 10 2022 at 08:46)</a>:</h4>
<p>Agreed on everything, except that very few people in math departments would find <code>map f A â‰¤ B</code> on filters to be more evocative than <code>tendsto</code> or <code>continuous_at</code> :-) and <code>tendsto</code> is not so useless if it is close to everyday mathematicians' use while at the same time enabling dot-notation use in proofs.</p>
<p>I was partly joking about <code>âˆƒá¶ </code> (only partly because depending on the kind of math one is doing, "you can find a point arbitrarily close to x" and "you can find a sequence that converges to x" can feel indistinguishable), but I maintain that informal mathematicians would prefer it to cluster points of filters...</p>



<a name="303220114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Accumulation%20point/near/303220114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Accumulation.20point.html#303220114">(Oct 10 2022 at 08:50)</a>:</h4>
<p>Sure, I wasn't suggesting we get rid of <code>tendsto</code>, this was an argument in favor of keeping "useless" definitions. It would still be nice to have more mathematicians thinking in terms of filters, but this is unlikely to happen.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html">"sort" a function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="298770188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298770188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298770188">(Sep 14 2022 at 13:25)</a>:</h4>
<p>Is there something along the lines of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span>
</code></pre></div>
<p>? (One could, of course, do this more generally, with <code>fin n.succ</code> and <code>ℕ</code> replaced by arbitrary types with suitable (pre)order structures.)</p>



<a name="298770733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298770733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298770733">(Sep 14 2022 at 13:28)</a>:</h4>
<p>Can you recycle <a href="https://leanprover-community.github.io/mathlib_docs/find/list.of_fn">docs#list.of_fn</a> and combine it with one of the <a href="https://leanprover-community.github.io/mathlib_docs/find/list.merge">docs#list.merge</a> like functions?</p>



<a name="298770909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298770909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298770909">(Sep 14 2022 at 13:29)</a>:</h4>
<p>Ah, do you actually want the permutation, or sorting it would be enough?</p>



<a name="298777239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298777239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298777239">(Sep 14 2022 at 14:03)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> Yes, there's <a href="https://leanprover-community.github.io/mathlib_docs/find/tuple.sort">docs#tuple.sort</a> and the associated lemma <a href="https://leanprover-community.github.io/mathlib_docs/find/tuple.monotone_sort">docs#tuple.monotone_sort</a></p>



<a name="298777267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298777267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298777267">(Sep 14 2022 at 14:03)</a>:</h4>
<p>If you search "perm monotone" in the chat you find a couple of relevant threads, including <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Sorting.20by.20function.20value/near/291074607">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Sorting.20by.20function.20value/near/291074607</a></p>



<a name="298777745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298777745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298777745">(Sep 14 2022 at 14:05)</a>:</h4>
<p>But that required an injection, so it doesn't immediately apply here, in fact the proof I gave there also works for <code>strict_mono</code></p>



<a name="298779296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298779296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298779296">(Sep 14 2022 at 14:14)</a>:</h4>
<p>Oh and you are permuting the domain! So that is also different</p>



<a name="298780336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298780336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298780336">(Sep 14 2022 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> Thanks, that should do what I want.</p>



<a name="298780661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298780661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298780661">(Sep 14 2022 at 14:21)</a>:</h4>
<p>Wow, I don't know how I managed to miss Heather's message completely, sorry!</p>



<a name="298781324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298781324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298781324">(Sep 14 2022 at 14:25)</a>:</h4>
<p>Now the follow-up question: Do we have some kind of "bubble sort principle"?. I.e.,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">P</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span> <span class="n">P</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">equiv.swap</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">P</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">tuple.sort</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div>



<a name="298827942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298827942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298827942">(Sep 14 2022 at 18:36)</a>:</h4>
<p>Related to a proof attempt: I wold have assumed that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_well_founded</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>works, but it doesn't. How do I easily obtain that instance? (It should follow from <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.lex.is_well_founded">docs#prod.lex.is_well_founded</a> by induction, but this looks a bit complicated to carry out.)</p>



<a name="298828738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298828738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298828738">(Sep 14 2022 at 18:40)</a>:</h4>
<p>Another question:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">preorder</span> <span class="o">(</span><span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">preorder.lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span> <span class="n">to_lex</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">))</span>
</code></pre></div>
<p>complains <code>failed to synthesize type class instance for preorder (lex (fin n.succ → ℕ))</code>, even though</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">preorder</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>works. What am I missing here?</p>



<a name="298833836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298833836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298833836">(Sep 14 2022 at 19:09)</a>:</h4>
<p>I don't know the root cause, but by turning on</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.class_instances</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">trace.type_context.is_def_eq_detail</span> <span class="n">true</span>
</code></pre></div>
<p>and staring at the output I figure its some issue with universes. Then it turns out the following (specifying universe levels to be 0 0) fixes it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">preorder</span> <span class="o">(</span><span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">preorder.lift.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span> <span class="n">to_lex</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">))</span>
</code></pre></div>



<a name="298834073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298834073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298834073">(Sep 14 2022 at 19:10)</a>:</h4>
<p>OK, thanks.</p>



<a name="298835261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298835261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298835261">(Sep 14 2022 at 19:17)</a>:</h4>
<p>Here is an idea for the proof of the "bubble sort principle".<br>
If  <code>i &lt; j</code> and <code>g j &lt; g i</code>. then <code>g ∘ equiv.swap i j</code> is lexicorgaphically strictly smaller than <code>g</code>. If <code>f</code> is not yet increasing, we can move to a lexicographically smaller <code>f ∘ σ</code> in this way. This cannot go on forever, since the lexicorgraphic order is a well-order, and when it stops, the last <code>f ∘ σ</code> must be increasing.<br>
But I'm having difficulties in translating this to Lean. I'd like to state the principle behind this somewhat like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">well_order_bot</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">well_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="bp">⊥</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">⊥</span>
</code></pre></div>
<p>but there is no bundled <code>well_order</code> structure, and trying something like <code>[has_lt α] [is_well_order α (&lt;)]</code> then runs into the problem that <code>has_bot α</code> cannot be deduced (which should follow from the well-ordering and the existence of <code>a</code>). Any ideas? (Of course, one needs the well-ordering on <code>lex (fin n.succ → ℕ)</code> first to apply this...)</p>



<a name="298841363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298841363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298841363">(Sep 14 2022 at 19:55)</a>:</h4>
<p>OK, here is a version of <code>well_order_bot</code> that seems to work.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">well_order_bot</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">hwf</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="o">((</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">))</span> <span class="o">{</span><span class="n">a</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">bot</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">well_founded.induction</span> <span class="n">hwf</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">ih'</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hbot</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">bot</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hbot</span> <span class="bp">▸</span> <span class="n">hP</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy₁</span><span class="o">,</span> <span class="n">hy₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="n">x</span> <span class="n">hbot</span> <span class="n">hP</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ih'</span> <span class="n">y</span> <span class="n">hy₁</span> <span class="n">hy₂</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="298852578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298852578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298852578">(Sep 14 2022 at 21:12)</a>:</h4>
<p>Hopefully someone like <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> can come and tell us how to do this properly, but here is a proof of well foundedness for lex</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.perm.sign</span>
<span class="bp">.</span>

<span class="kd">lemma</span> <span class="n">logic</span> <span class="o">{</span><span class="n">Plt0</span> <span class="n">Peq0</span> <span class="n">Peq</span> <span class="n">Peqe</span> <span class="n">Plt</span><span class="o">}</span> <span class="o">(</span><span class="n">hhh</span> <span class="o">:</span> <span class="n">Peq</span> <span class="bp">↔</span> <span class="n">Peqe</span> <span class="bp">∧</span> <span class="n">Peq0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Plt0</span> <span class="bp">∨</span> <span class="n">Peq0</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">Peqe</span> <span class="bp">∨</span> <span class="n">Plt</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">Peq</span> <span class="bp">∨</span> <span class="n">Plt0</span> <span class="bp">∨</span> <span class="n">Peq0</span> <span class="bp">∧</span> <span class="n">Plt</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">tauto</span><span class="bp">!</span>

<span class="kd">lemma</span> <span class="n">prod.lex.le_iff'</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×ₗ</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a.1</span> <span class="bp">&lt;</span> <span class="n">b.1</span> <span class="bp">∨</span> <span class="n">a.1</span> <span class="bp">=</span> <span class="n">b.1</span> <span class="bp">∧</span> <span class="n">a.2</span> <span class="bp">≤</span> <span class="n">b.2</span> <span class="o">:=</span> <span class="n">prod.lex_def</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">pi.lex.lt_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span>
<span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">y</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">y</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">lemma</span> <span class="n">pi.lex.le_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">β</span> <span class="n">i</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">β</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span>
<span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">y</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">y</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">def</span> <span class="n">lex_succ_order_equiv_prod</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">ℕ</span> <span class="bp">×ₗ</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">equiv.pi_fin_succ_apply</span><span class="o">,</span> <span class="n">equiv.to_fun_as_coe</span><span class="o">,</span> <span class="n">equiv.coe_fn_mk</span><span class="o">],</span>
    <span class="n">erw</span> <span class="o">[</span><span class="n">prod.lex.le_iff'</span><span class="o">,</span> <span class="n">pi.lex.le_iff</span><span class="o">,</span> <span class="n">pi.lex.le_iff</span><span class="o">,</span> <span class="n">fin.exists_fin_succ</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fin.forall_fin_succ</span><span class="o">,</span> <span class="n">and_assoc</span><span class="o">,</span> <span class="n">fin.not_lt_zero</span><span class="o">,</span> <span class="n">is_empty.forall_iff</span><span class="o">,</span>
      <span class="n">implies_true_iff</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">fin.succ_pos</span><span class="o">,</span> <span class="n">forall_true_left</span><span class="o">,</span> <span class="n">fin.succ_lt_succ_iff</span><span class="o">,</span>
      <span class="n">exists_and_distrib_left</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">logic</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">and_comm</span><span class="o">,</span> <span class="n">function.funext_iff</span><span class="o">,</span> <span class="n">function.funext_iff</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">fin.forall_fin_succ</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">equiv.pi_fin_succ</span> <span class="n">n</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">is_well_founded</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">unique</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)),</span>
  <span class="n">exact</span> <span class="n">pi.unique_of_is_empty</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)),</span>
  <span class="n">exact</span> <span class="n">unique.subsingleton</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">well_founded.intro</span><span class="o">,</span> <span class="n">intro</span> <span class="n">a</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">revert</span> <span class="n">hy</span><span class="o">,</span> <span class="n">change</span> <span class="bp">¬</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">,</span> <span class="n">rw</span> <span class="n">not_lt</span><span class="o">,</span> <span class="n">apply</span> <span class="n">eq.le</span><span class="o">,</span> <span class="n">exact</span> <span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">end</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">order_embedding.well_founded</span> <span class="o">(</span><span class="n">lex_succ_order_equiv_prod</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">to_order_embedding</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">prod.lex.is_well_founded.wf</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">is_well_order.to_is_well_founded</span><span class="o">,</span>
  <span class="n">apply_assumption</span><span class="o">,</span>
<span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



<a name="298854653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298854653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298854653">(Sep 14 2022 at 21:26)</a>:</h4>
<p>Thanks! I'll look at it tomorrow.<br>
This should be a good addition to mathlib (with <code>ℕ</code> in the codomain replaced by an arbitrary well-founded order).</p>



<a name="298854982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298854982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298854982">(Sep 14 2022 at 21:29)</a>:</h4>
<p>That should be generalisable to two well orders (and dependent functions). Indeed this is basically ordinal multiplication.</p>



<a name="298855013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298855013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298855013">(Sep 14 2022 at 21:29)</a>:</h4>
<p>I've made one generalization as an edit, I'll PR it at somepoint to this week, unless it turns out there is an easier way</p>



<a name="298855038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298855038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298855038">(Sep 14 2022 at 21:29)</a>:</h4>
<p>Indeed the dependent case should be easy</p>



<a name="298855048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298855048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298855048">(Sep 14 2022 at 21:29)</a>:</h4>
<p>But making the domain not fin n scares me <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="298855678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298855678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298855678">(Sep 14 2022 at 21:34)</a>:</h4>
<p>Actually <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.pi_fin_succ">docs#equiv.pi_fin_succ</a> is only for non-dependent functions it seems, so I'll leave it like this for now</p>



<a name="298857940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/298857940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#298857940">(Sep 14 2022 at 21:53)</a>:</h4>
<p>But <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.pi_fin_succ_above_equiv">docs#equiv.pi_fin_succ_above_equiv</a> isn't...</p>



<a name="299043974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299043974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299043974">(Sep 15 2022 at 20:09)</a>:</h4>
<p>With the help of <span class="user-mention" data-user-id="127136">@Alex J. Best</span>'s code from above, I have now managed to reduce the proof of <code>bubble_sort</code> to the following lemma.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">tuple.unique_monotone</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hfσ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">))</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">f</span>
</code></pre></div>
<p>I find this surprisingly hard to prove.</p>



<a name="299044301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299044301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299044301">(Sep 15 2022 at 20:11)</a>:</h4>
<p>One attempt is to use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.eq_of_perm_of_sorted">docs#list.eq_of_perm_of_sorted</a>. This would work if one had proofs of (for <code>f : fin n → ℕ</code> and <code>σ : equiv.perm (fin n)</code>) <code>list.of_fn (f ∘ σ) ~ list.of_fn f</code> and <code>monotone f → (list.of_fn f).sorted (≤)</code>. But these don't look straightforward either (in particular the first).</p>



<a name="299044518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299044518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299044518">(Sep 15 2022 at 20:13)</a>:</h4>
<p>Ideas?</p>



<a name="299045396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299045396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299045396">(Sep 15 2022 at 20:19)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> Is this true, or do you maybe need strict monotonicity?</p>



<a name="299045549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299045549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299045549">(Sep 15 2022 at 20:20)</a>:</h4>
<p>This is true. If you permute a weakly increasing sequence so that the result is again weakly increasing, then both are the same.</p>



<a name="299045584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299045584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299045584">(Sep 15 2022 at 20:20)</a>:</h4>
<p>(I don't claim that <code>σ</code> must be the identity.)</p>



<a name="299045586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299045586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299045586">(Sep 15 2022 at 20:21)</a>:</h4>
<p>I think this is true, and the reason you don't strict monotonicity is because it's written <code>f o s = f</code> as opposed to <code>s = id</code></p>



<a name="299045649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299045649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299045649">(Sep 15 2022 at 20:21)</a>:</h4>
<p>an induction argument would be quite easy if you can prove that wlog s 0 = 0, which is a bit annoying</p>



<a name="299045790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299045790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299045790">(Sep 15 2022 at 20:22)</a>:</h4>
<p>You can fairly easily show that <code>f (s 0) = f 0</code>. It is not clear to me that this helps a lot.</p>



<a name="299046382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299046382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299046382">(Sep 15 2022 at 20:27)</a>:</h4>
<p>Aside: I was trying to define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function.count</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">set.preimage</span> <span class="n">f</span> <span class="o">{</span><span class="n">x</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset.card</span>
</code></pre></div>
<p>but got the complaint <code>failed to synthesize type class instance for fintype ↥(f ⁻¹' {x})</code> (and adding <code>[decidable_pred (λ a, f a = x)]</code> to the arguments does not help...). How to do that in a way Lean understands?<br>
(The idea being that <code>f ∘ σ</code> and <code>f</code> take a given value the same number of times...)</p>



<a name="299046610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299046610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299046610">(Sep 15 2022 at 20:29)</a>:</h4>
<p><code>decidable_pred (∈ f ⁻¹' {x})</code></p>



<a name="299046678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299046678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299046678">(Sep 15 2022 at 20:29)</a>:</h4>
<p>Is this not defeq?</p>



<a name="299046897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299046897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299046897">(Sep 15 2022 at 20:31)</a>:</h4>
<p>Typeclass inference doesn't know about defeq. Luckily, otherwise type synonyms wouldn't work!</p>



<a name="299048941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299048941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299048941">(Sep 15 2022 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299045790">said</a>:</p>
<blockquote>
<p>You can fairly easily show that <code>f (s 0) = f 0</code>. It is not clear to me that this helps a lot.</p>
</blockquote>
<p>my idea is that if we can assume assume the _stronger_ <code>s 0 = 0</code> in the theorem statement, it lets us induct easier using a function of the form <code>λ x, (σ x.succ).pred sorry</code></p>



<a name="299048962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299048962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299048962">(Sep 15 2022 at 20:46)</a>:</h4>
<p>this doesn't work though, sadly</p>



<a name="299049017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299049017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299049017">(Sep 15 2022 at 20:47)</a>:</h4>
<p>because we then end up requiring that that function maps zero to zero</p>



<a name="299049051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299049051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299049051">(Sep 15 2022 at 20:47)</a>:</h4>
<p>and so this exact method only proves that s = id, which isn't always true</p>



<a name="299049967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299049967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299049967">(Sep 15 2022 at 20:54)</a>:</h4>
<p>I'm missing a specification lemma for <code>list.sorted</code>, i.e.,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.sorted_iff</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">l.sorted</span> <span class="n">r</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">l.length</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">i.1</span> <span class="n">i.2</span><span class="o">)</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">j.1</span> <span class="n">j.2</span><span class="o">)</span>
</code></pre></div>
<p>Versions of the <code>→</code> direction are there (<a href="https://leanprover-community.github.io/mathlib_docs/find/list.sorted.rel_nth_le_of_le">docs#list.sorted.rel_nth_le_of_le</a>), but the converse seems to be missing.<br>
How do you prove that a list is sorted? (This came up while attempting the second missing ingredient above.)</p>



<a name="299050524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299050524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299050524">(Sep 15 2022 at 20:59)</a>:</h4>
<p>sorted is defeq to <code>pairwise</code>, so maybe look there</p>



<a name="299050665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299050665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299050665">(Sep 15 2022 at 21:00)</a>:</h4>
<p>For the first, something like the following would be helpful.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.perm_iff</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">l'.length</span><span class="o">)</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">~</span> <span class="n">l'</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">l.length</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">l.length</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="o">(</span><span class="n">σ</span> <span class="n">i</span><span class="o">)</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">l'.nth_le</span> <span class="n">i</span> <span class="n">_</span>
</code></pre></div>



<a name="299051218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299051218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299051218">(Sep 15 2022 at 21:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299050524">said</a>:</p>
<blockquote>
<p>sorted is defeq to <code>pairwise</code>, so maybe look there</p>
</blockquote>
<p>Possibly <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise_iff">docs#list.pairwise_iff</a>, but it looks a bit unwieldy.</p>



<a name="299052139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299052139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299052139">(Sep 15 2022 at 21:11)</a>:</h4>
<p>I think I nearly have the first, I'm not sure how we don't have this yet:</p>
<p><code>lemma of_fn_eq_map : list.of_fn f = list.map f (list.fin_range n) :=</code></p>



<a name="299052159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299052159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299052159">(Sep 15 2022 at 21:11)</a>:</h4>
<p>(for the record, I  proved it already, don't bother reproving it)</p>



<a name="299054269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299054269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299054269">(Sep 15 2022 at 21:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299052139">said</a>:</p>
<blockquote>
<p>I think I nearly have the first</p>
</blockquote>
<p>In my counting, the first is <code>list.of_fn (f ∘ σ) ~ list.of_fn f</code>, which one should be able to reduce to <code>list.perm_iff</code> above. Is that what you mean, or are you talking about <code>list.sorted_iff</code>?</p>



<a name="299055108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299055108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299055108">(Sep 15 2022 at 21:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.abel_ruffini</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">lemma</span> <span class="n">perm.map_congr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁.map</span> <span class="n">f</span> <span class="bp">~</span> <span class="n">l₂.map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">perm.swap</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">list.perm.trans</span> <span class="o">:</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₁₂</span> <span class="n">h₂₃</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h₁₂.trans</span> <span class="n">h₂₃</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">list.of_fn</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span> <span class="bp">~</span> <span class="n">list.of_fn</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">of_fn_eq_map</span><span class="o">,</span> <span class="n">of_fn_eq_map</span><span class="o">,</span> <span class="bp">←</span><span class="n">map_map</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">perm.map_congr</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">perm_ext</span> <span class="o">((</span><span class="n">nodup_fin_range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">σ.injective</span><span class="o">)</span> <span class="bp">$</span> <span class="n">nodup_fin_range</span> <span class="n">n</span><span class="o">],</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_map</span><span class="o">,</span> <span class="n">mem_fin_range</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">iff_true</span><span class="o">]</span> <span class="n">using</span> <span class="n">σ.surjective</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">list</span>
</code></pre></div>
<p>(ignore the imports, I'm lazy)</p>



<a name="299116820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299116820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299116820">(Sep 16 2022 at 08:48)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> thanks!<br>
I've come up with a (fairly direct) pen-and-paper proof of <code>tuple.unique_monotone</code>, which I'll try to formalize. Let's see which approach gives the shorter proof <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="299124142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299124142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299124142">(Sep 16 2022 at 09:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.abel_ruffini</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">lemma</span> <span class="n">perm.map_congr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁.map</span> <span class="n">f</span> <span class="bp">~</span> <span class="n">l₂.map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">perm.swap</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">list.perm.trans</span> <span class="o">:</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₁₂</span> <span class="n">h₂₃</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h₁₂.trans</span> <span class="n">h₂₃</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">_root_.equiv.perm.of_fn_comp_perm</span> <span class="o">:</span> <span class="n">list.of_fn</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span> <span class="bp">~</span> <span class="n">list.of_fn</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">of_fn_eq_map</span><span class="o">,</span> <span class="n">of_fn_eq_map</span><span class="o">,</span> <span class="bp">←</span><span class="n">map_map</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">perm.map_congr</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">perm_ext</span> <span class="o">((</span><span class="n">nodup_fin_range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">σ.injective</span><span class="o">)</span> <span class="bp">$</span> <span class="n">nodup_fin_range</span> <span class="n">n</span><span class="o">],</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_map</span><span class="o">,</span> <span class="n">mem_fin_range</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">iff_true</span><span class="o">]</span> <span class="n">using</span> <span class="n">σ.surjective</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">_root_.monotone.of_fn_sorted</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">sorted</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">sorted</span><span class="o">,</span> <span class="n">pairwise_iff_nth_le</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hj</span> <span class="n">hij</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nth_le_of_fn'</span><span class="o">,</span> <span class="n">nth_le_of_fn'</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hij.le</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">tuple.unique_monotone</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hfσ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">))</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">of_fn_injective</span> <span class="bp">$</span> <span class="n">eq_of_perm_of_sorted</span> <span class="o">(</span><span class="n">σ.of_fn_comp_perm</span> <span class="n">f</span><span class="o">)</span> <span class="n">hfσ.of_fn_sorted</span> <span class="n">hf.of_fn_sorted</span>

<span class="kd">end</span> <span class="n">list</span>
</code></pre></div>



<a name="299124217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299124217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299124217">(Sep 16 2022 at 09:36)</a>:</h4>
<p>here is a full proof modulo golfing imports</p>



<a name="299124381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299124381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299124381">(Sep 16 2022 at 09:37)</a>:</h4>
<p>I'd say the <code>perm</code> and the <code>monotone</code> one should definitely be theorems regardless, so in some ways this is a "8 line proof"</p>



<a name="299124773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299124773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299124773">(Sep 16 2022 at 09:39)</a>:</h4>
<p>(bonus golfing question: it'd be really nice to make <code>perm.map_congr</code> using the equation compiler; does anyone know how to golf it to that? I tried and couldn't get it to work)</p>



<a name="299134721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299134721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299134721">(Sep 16 2022 at 10:47)</a>:</h4>
<p>Nice! I doubt I can get my proof down to comparable length (it is not even finished and already quite a bit longer, though certainly golfable to some extent).</p>



<a name="299134789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299134789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299134789">(Sep 16 2022 at 10:48)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> Would you like to PR the four lemmas?</p>



<a name="299134955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299134955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299134955">(Sep 16 2022 at 10:49)</a>:</h4>
<p>I'm happy for you to PR them, but if you don't want to I'll PR them later today</p>



<a name="299136057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136057">(Sep 16 2022 at 10:57)</a>:</h4>
<p>Here is my proof of the "bubble sort principle", based on the above (including the <code>well_founded</code> instance for the lexicographic order provided by <span class="user-mention" data-user-id="127136">@Alex J. Best</span>). Some golfing is certainly possible...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">tuple.unique_sort</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">tuple.sort</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">τ</span> <span class="o">:=</span> <span class="n">tuple.sort</span> <span class="n">f</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">σ'</span> <span class="o">:=</span> <span class="n">τ</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">σ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">τ</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">σ'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="n">equiv.perm.coe_mul</span><span class="o">,</span> <span class="n">equiv.perm.apply_inv_self</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h'</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">tuple.unique_monotone</span> <span class="o">(</span><span class="n">tuple.monotone_sort</span> <span class="n">f</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">h'</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">antitone_pair_of_not_sorted</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">≠</span> <span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">tuple.sort</span> <span class="n">f</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra'</span> <span class="n">hf</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hij</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">eq_or_lt_of_le</span> <span class="n">hij</span> <span class="k">with</span> <span class="n">heq</span> <span class="n">hlt</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">heq</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hf</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hlt</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">tuple.unique_sort</span> <span class="n">hm</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">lex_desc</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_lex</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">equiv.swap</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">to_lex</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">has_lt.lt</span><span class="o">,</span> <span class="n">pi.lex</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">k</span> <span class="o">(</span><span class="n">hik</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">equiv.swap_apply_of_ne_of_ne</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">hik</span><span class="o">)</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="bp">$</span> <span class="n">hik.trans</span> <span class="n">h₁</span><span class="o">)],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">equiv.swap_apply_left</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">well_founded_bot</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hwf</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">bot</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">r</span> <span class="n">c</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">bot</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">well_founded.induction</span> <span class="n">hwf</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">ih'</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hbot</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">bot</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hbot</span> <span class="bp">▸</span> <span class="n">hP</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy₁</span><span class="o">,</span> <span class="n">hy₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="n">x</span> <span class="n">hbot</span> <span class="n">hP</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ih'</span> <span class="n">y</span> <span class="n">hy₁</span> <span class="n">hy₂</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">bubble_sort</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">P</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">g</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">equiv.swap</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">P</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">tuple.sort</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">σ</span><span class="o">,</span> <span class="n">to_lex</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">Of</span> <span class="o">:=</span> <span class="n">set.range</span> <span class="n">φ</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">φ'</span> <span class="o">:=</span> <span class="n">set.cod_restrict</span> <span class="n">φ</span> <span class="n">Of</span> <span class="n">set.mem_range_self</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hφ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">σ</span><span class="o">,</span> <span class="o">(</span><span class="n">φ'</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="bp">=</span> <span class="n">φ</span> <span class="n">σ</span> <span class="o">:=</span> <span class="n">set.coe_cod_restrict_apply</span> <span class="n">φ</span> <span class="n">Of</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">Of_to_lex</span> <span class="o">:</span> <span class="n">Of</span> <span class="bp">→</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">Of_to_map</span> <span class="o">:</span> <span class="n">Of</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">of_lex</span> <span class="bp">∘</span> <span class="n">Of_to_lex</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">inv_image</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_lt.lt</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="n">_</span><span class="o">)</span> <span class="n">Of_to_lex</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">wf'</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">inv_image.wf</span> <span class="n">_</span> <span class="o">(</span><span class="n">lex_well_founded</span> <span class="n">n.succ</span><span class="o">)</span><span class="bp">.</span><span class="n">wf</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">POf</span> <span class="o">:</span> <span class="n">Of</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">Of_to_map</span> <span class="n">g</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hf₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">equiv.perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span><span class="o">),</span>  <span class="n">P</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">POf</span> <span class="o">(</span><span class="n">φ'</span> <span class="n">σ</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">σ</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">POf</span><span class="o">,</span> <span class="n">φ'</span><span class="o">,</span> <span class="n">Of_to_map</span><span class="o">,</span> <span class="n">Of_to_lex</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">],</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">hf₁</span><span class="o">],</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">well_founded_bot</span> <span class="n">Of</span> <span class="n">r</span> <span class="n">wf'</span> <span class="o">(</span><span class="n">φ'</span> <span class="mi">1</span><span class="o">)</span> <span class="n">_</span> <span class="n">POf</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span> <span class="n">hg₁</span> <span class="n">hg₂</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">POf</span><span class="o">,</span> <span class="n">Of_to_map</span><span class="o">,</span> <span class="n">Of_to_lex</span><span class="o">,</span> <span class="n">φ'</span><span class="o">,</span> <span class="n">φ</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">],</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">set.coe_cod_restrict_apply</span><span class="o">,</span> <span class="n">of_lex_to_lex</span><span class="o">,</span> <span class="n">equiv.perm.coe_one</span><span class="o">,</span> <span class="n">function.comp.right_id</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">σ</span><span class="o">,</span> <span class="n">hσ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.mem_range.mp</span> <span class="o">(</span><span class="n">subtype.mem</span> <span class="n">g</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">hg₁'</span> <span class="o">:</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="bp">≠</span> <span class="n">φ</span> <span class="o">(</span><span class="n">tuple.sort</span> <span class="n">f</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hφ</span><span class="o">],</span>
      <span class="n">by_contra'</span> <span class="n">hf</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hg₁</span> <span class="o">(</span><span class="n">subtype.coe_injective</span> <span class="n">hf</span><span class="o">),</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hσ</span><span class="o">]</span> <span class="n">at</span> <span class="n">hg₁'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hσ'</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">≠</span> <span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">tuple.sort</span> <span class="n">f</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">to_lex_inj</span><span class="o">]</span> <span class="n">at</span> <span class="n">hg₁'</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hg₁'</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">hij₁</span><span class="o">,</span> <span class="n">hij₂</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">antitone_pair_of_not_sorted</span> <span class="n">hσ'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hσ''</span><span class="o">:</span> <span class="n">POf</span> <span class="o">(</span><span class="n">φ'</span> <span class="n">σ</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">convert</span> <span class="n">hg₂</span><span class="o">,</span>
      <span class="n">apply_fun</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">Of</span> <span class="bp">→</span> <span class="n">lex</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">))</span> <span class="n">using</span> <span class="n">subtype.coe_injective</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="n">hφ</span><span class="o">,</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">hh</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">σ</span><span class="o">)</span> <span class="n">i</span> <span class="n">j</span> <span class="n">hij₁</span> <span class="n">hij₂</span> <span class="o">((</span><span class="n">hf₁</span> <span class="n">σ</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hσ''</span><span class="o">),</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">φ'</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">*</span> <span class="o">(</span><span class="n">equiv.swap</span> <span class="n">i</span> <span class="n">j</span><span class="o">)),</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">convert</span> <span class="n">lex_desc</span> <span class="n">hij₁</span> <span class="n">hij₂</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">r</span><span class="o">,</span> <span class="n">inv_image</span><span class="o">,</span> <span class="n">φ'</span><span class="o">,</span> <span class="n">Of_to_lex</span><span class="o">,</span> <span class="bp">←</span><span class="n">hσ</span><span class="o">,</span> <span class="n">φ</span><span class="o">,</span> <span class="n">set.coe_cod_restrict_apply</span><span class="o">,</span> <span class="n">equiv.perm.coe_mul</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">hf₁</span><span class="o">,</span> <span class="n">equiv.perm.coe_mul</span><span class="o">],</span>
      <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp.assoc</span><span class="o">],</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="299136246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136246">(Sep 16 2022 at 10:58)</a>:</h4>
<p>Wooah! This turned out to be more complex than I was expecting.</p>



<a name="299136306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136306">(Sep 16 2022 at 10:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> did you see this thread?</p>



<a name="299136317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136317">(Sep 16 2022 at 10:58)</a>:</h4>
<p>I may not have hit on the simplest proof possible <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="299136353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136353">(Sep 16 2022 at 10:59)</a>:</h4>
<p>But I was also expecting it to be simpler, to be honest.</p>



<a name="299136408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136408">(Sep 16 2022 at 10:59)</a>:</h4>
<p>yeah that seems weirdly hard</p>



<a name="299136632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136632">(Sep 16 2022 at 11:00)</a>:</h4>
<p>although I guess it's a weird statement too. If you just want a sorted version of the function you could just do that, this induction principle is doing something else</p>



<a name="299136719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136719">(Sep 16 2022 at 11:01)</a>:</h4>
<p>The first <code>have</code> can be proved by <code>ext, simp</code>.</p>



<a name="299136822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299136822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299136822">(Sep 16 2022 at 11:02)</a>:</h4>
<p>The induction principle is what I was after, so perhaps the name of the topic was slightly misleading. Sorry about the <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>...</p>



<a name="299137019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299137019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299137019">(Sep 16 2022 at 11:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299136719">said</a>:</p>
<blockquote>
<p>The first <code>have</code> can be proved by <code>ext, simp</code>.</p>
</blockquote>
<p>I did have a nagging feeling that there should be a simpler way of doing this, I have edited the proof.</p>



<a name="299146104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299146104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299146104">(Sep 16 2022 at 12:05)</a>:</h4>
<p>I have generalized <span class="user-mention" data-user-id="284160">@Eric Rodriguez</span>'s code and my code so that it works with suitable ordered types <code>α</code> in place of <code>ℕ</code> (edited in the long message above).</p>



<a name="299146397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299146397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299146397">(Sep 16 2022 at 12:07)</a>:</h4>
<p>It would make sense to PR this together with <span class="user-mention" data-user-id="127136">@Alex J. Best</span>'s well-foundedness instance for <code>lex (fin n → α)</code>. Any suggestions regarding in which files these should go? A better name for <code>bubble_sort</code>?</p>



<a name="299147784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299147784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299147784">(Sep 16 2022 at 12:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299124773">said</a>:</p>
<blockquote>
<p>(bonus golfing question: it'd be really nice to make <code>perm.map_congr</code> using the equation compiler; does anyone know how to golf it to that? I tried and couldn't get it to work)</p>
</blockquote>
<p>Same - I got as far as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.abel_ruffini</span>
<span class="kd">lemma</span> <span class="n">perm.map_congr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span><span class="o">),</span> <span class="n">l₁.map</span> <span class="n">f</span> <span class="bp">~</span> <span class="n">l₂.map</span> <span class="n">f</span>
<span class="bp">|</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">list.perm.nil</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">list.perm.cons</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">perm.map_congr</span> <span class="n">hx</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">list.perm.swap</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">perm.swap</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">list.perm.trans</span> <span class="n">h₁₂</span> <span class="n">h₂₃</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">perm.map_congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₁₂.trans</span> <span class="n">h₂₃</span> <span class="o">}</span>
</code></pre></div>
<p>but lean fails to prove well-founded recursion in the trans case</p>



<a name="299237757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299237757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299237757">(Sep 16 2022 at 20:35)</a>:</h4>
<p>It looks like we are also missing a well-foundedness instance for the product order on function types with finite domain and well-founded codomain(s). It would be good to add that together with the instance for the lex order.</p>



<a name="299256970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299256970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299256970">(Sep 16 2022 at 23:49)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> <span class="user-mention" data-user-id="479359">@Michael Stoll</span> <br>
I've successfully <a href="https://gist.github.com/alreadydone/f043f5432faead3872c037a5bc670765">generalized the well-foundedness result to `finsupp</a>; the signature of the result is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finsupp.lex'</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">),</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">s</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">x</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">y</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">r</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="bp">⇑</span><span class="n">x</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">y</span> <span class="n">b</span>
<span class="n">well_founded_lex'</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">N</span><span class="o">],</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="o">⦃</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">⦄,</span> <span class="bp">¬</span><span class="n">s</span> <span class="n">n</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">→</span> <span class="n">well_founded</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">well_founded</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">well_founded</span> <span class="o">(</span><span class="n">lex'</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>
<p>The condition <code>∀ ⦃n : N⦄, ¬s n 0</code> is necessary: otherwise if α is infinite then every coordinate in <code>0 : α →₀ N</code> can be decreased, yielding an infinite decreasing sequence; similarly if the function is infinitely supported then each coordinate in the support could potentially be decreased, so finite support is crucial. It should be easy to generalize to <code>dfinsupp</code>.</p>
<p>I actually started thinking about the problem a few days earlier because I also needed it for the fundamental theorem of symmetric polynomials. The proof closely follows the proof of <a href="https://leanprover-community.github.io/mathlib_docs/find/well_founded.cut_expand/src">src#well_founded.cut_expand</a> (which is essentially the special case N = ℕ), but it took me some days to figure out the correct generalization of <a href="https://leanprover-community.github.io/mathlib_docs/find/relation.cut_expand_fibration">docs#relation.cut_expand_fibration</a>; in the presence of a monoid structure (as is the case for ℕ) you can just use addition to combine two finsupp functions, but in general you need to consider all possible ways of merging them, parametrized by a function <code>α → bool</code> specifying which coordinates to take from one function and which to take from the other.</p>



<a name="299271273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299271273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299271273">(Sep 17 2022 at 04:27)</a>:</h4>
<p>I've updated <a href="https://gist.github.com/alreadydone/f043f5432faead3872c037a5bc670765">the gist</a> to include a derivation of <code>pi.well_founded_lex</code> from the finsupp version when the domain is finite with a linear_order. The signature is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">pi.well_founded_lex'</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">α</span><span class="o">],</span>
    <span class="n">well_founded</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">well_founded</span> <span class="o">(</span><span class="n">pi.lex</span> <span class="n">has_lt.lt</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">s</span><span class="o">))</span>
</code></pre></div>
<p>I plan to generalize to dfinsupp and derive the finsupp version and then the original multiset version from it, and PR it in 1-2 days.</p>



<a name="299289703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299289703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299289703">(Sep 17 2022 at 08:49)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Can you include the version for the product order (which does not need an order on <code>α</code>, just finiteness, but it should follow from the lex version by imposing any linear order, since it is a subrelation)? In any case, thanks for doing this!</p>



<a name="299295814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299295814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299295814">(Sep 17 2022 at 09:47)</a>:</h4>
<p>I have PRed the induction principle</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">well_founded.induction_bot</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hwf</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">bot</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">c</span><span class="o">,</span> <span class="n">r</span> <span class="n">c</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">C</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">bot</span>
</code></pre></div>
<p>see <a href="https://github.com/leanprover-community/mathlib/pull/16536">#16536</a>. I have put it in <code>order.well_founded</code> (the other well-founded induction principles are in core). Please have a look!</p>



<a name="299419173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299419173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299419173">(Sep 18 2022 at 11:06)</a>:</h4>
<p>I have now come up with a proof of <code>bubble_sort</code> that does not require the well-foundedness of the lex order (by using instead that an irreflexive relation on a finite set is always well-founded). (But the well-foundedness of lex is still a good thing to have, and I will need the well-foundedness of the product order for something else, too!)<br>
This relies on a number of other lemmas on tuples and also on <code>well_founded.induction_bot</code>, which is in <a href="https://github.com/leanprover-community/mathlib/pull/16536">#16536</a>.<br>
How should I proceed:</p>
<ul>
<li>Wait until <a href="https://github.com/leanprover-community/mathlib/pull/16536">#16536</a> gets merged and then open another PR?</li>
<li>Extend <a href="https://github.com/leanprover-community/mathlib/pull/16536">#16536</a> to include the additional material?<br>
Thanks for comments!</li>
</ul>



<a name="299420861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299420861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299420861">(Sep 18 2022 at 11:23)</a>:</h4>
<p>you can always make a dependent PR so people see what you're building up to, but sometimes they're annoying to follow up on. it's your choice</p>



<a name="299433603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/299433603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#299433603">(Sep 18 2022 at 13:17)</a>:</h4>
<p>Then I prefer to have everything in one place. I'll update <a href="https://github.com/leanprover-community/mathlib/pull/16536">#16536</a> accordingly.</p>



<a name="301990430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%22sort%22%20a%20function/near/301990430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.22sort.22.20a.20function.html#301990430">(Oct 03 2022 at 02:16)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> The well-foundedness of the lexicographic/product order on (d)finsupp/pi/function is finally ready at <a href="https://github.com/leanprover-community/mathlib/pull/16772">#16772</a>. Takes much longer than I expected to streamline everything, and I probably need to break it down to several PRs. <a href="https://github.com/leanprover-community/mathlib/pull/16720">#16720</a> and <a href="https://github.com/leanprover-community/mathlib/pull/16740">#16740</a> both overlap with this branch and should be easy to review; the diff will become smaller when they're merged. I also ported the files <em>finsupp.ne_locus</em> and <em>finsupp.lex</em> to <code>dfinsupp</code>, and those could be one PR.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
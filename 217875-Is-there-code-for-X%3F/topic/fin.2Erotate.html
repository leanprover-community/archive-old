---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html">fin.rotate</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227873440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227873440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227873440">(Feb 26 2021 at 02:34)</a>:</h4>
<p>I would like to know that <code>fin.snoc</code> is a permutation of <code>fin.cons</code> (ie. given by precomposition by some <code>equiv</code>). Does anyone see a cheap way to get this?</p>
<p>I was trying to build</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">rotate</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">equiv.refl</span> <span class="n">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="k">if</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">last</span> <span class="n">n</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">last</span> <span class="n">n</span> <span class="k">else</span> <span class="n">k</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>
<p>and finding it quite painful.</p>



<a name="227873947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227873947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227873947">(Feb 26 2021 at 02:43)</a>:</h4>
<p>I would generalize to swaps of the parts of <code>fin (m + n)</code></p>



<a name="227876003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227876003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227876003">(Feb 26 2021 at 03:15)</a>:</h4>
<p>Isn't this <code>\lambda i, i+1</code>?</p>



<a name="227877691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227877691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227877691">(Feb 26 2021 at 03:39)</a>:</h4>
<p>That works as well, but <code>left_inv</code> and <code>right_inv</code> don't get any easier, because we have no theorems about addition in <code>fin n</code>.</p>



<a name="227877703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227877703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227877703">(Feb 26 2021 at 03:39)</a>:</h4>
<p>(In part because we keep considering changing the definition.)</p>



<a name="227877942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227877942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227877942">(Feb 26 2021 at 03:42)</a>:</h4>
<p>We do have <code>add_comm_monoid (fin (n + 1))</code></p>



<a name="227878035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227878035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227878035">(Feb 26 2021 at 03:43)</a>:</h4>
<p>That doesn't say anything about the invertibility of the operation though, it would be true with saturating add too</p>



<a name="227878259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227878259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227878259">(Feb 26 2021 at 03:46)</a>:</h4>
<p>Hopefully we have <code>fin (n+m) ≃ fin n \oplus fin m</code> somewhere, which would make Mario's suggestion nice and straightforward.</p>



<a name="227878265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227878265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227878265">(Feb 26 2021 at 03:46)</a>:</h4>
<p>Wait, it has a monoid instance but not a group instance?</p>



<a name="227878309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227878309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227878309">(Feb 26 2021 at 03:47)</a>:</h4>
<p>Yeah that's there. I think <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_sum_equiv">docs#fin_sum_equiv</a> or something like that?</p>



<a name="227878398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227878398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227878398">(Feb 26 2021 at 03:48)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/sum_fin_sum_equiv">docs#sum_fin_sum_equiv</a></p>



<a name="227878399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227878399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227878399">(Feb 26 2021 at 03:48)</a>:</h4>
<p>Oh it's <a href="https://leanprover-community.github.io/mathlib_docs/find/sum_fin_sum_equiv">docs#sum_fin_sum_equiv</a></p>



<a name="227885734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227885734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227885734">(Feb 26 2021 at 05:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/fin.2Erotate/near/227878265">said</a>:</p>
<blockquote>
<p>Wait, it has a monoid instance but not a group instance?</p>
</blockquote>
<p>If you want the group instance you should be using <code>zmod</code>. It's a bit awkward that we have both, but the idea is that <code>fin n</code> is mostly meant to be algebraically structureless... Of course it inevitably has some.</p>



<a name="227902186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227902186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227902186">(Feb 26 2021 at 09:25)</a>:</h4>
<p>It only has some because some pesky people want to talk about <code>37 : fin 3</code> (even though they don't know what they want it to mean ;-) ).</p>



<a name="227903423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227903423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227903423">(Feb 26 2021 at 09:38)</a>:</h4>
<p>Why use evil addition on <code>fin n</code>? Haven't we got some "next" and "prev" structure on <code>fin n</code>?</p>
<p>I am one of these terrible people who has never got involved with <code>fin n</code> but just watches from the sidelines thinking "why is this such a mess"? For me <code>fin n</code> is some finite totally ordered set, and given any nonempty finite totally ordered set at all (including <code>fin n</code> with its nightmare dependently typed definition and its two definitions of +) there should be functions like "bottom", "top", "next" and "previous" and a cute little API for them which does not ever get tangled up with this pathological fin + question (which is as bad as nat subtraction as far as I'm concerned and as far as I can see the only reason we have it so that we can use numerals). However I moan about all this and then don't actually ever do anything about it :-(</p>



<a name="227903839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227903839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227903839">(Feb 26 2021 at 09:42)</a>:</h4>
<p>At least this point of view abstracts away the whole + issue because the API writes itself -- if x!=top then previous(next x)=x, if x!=bottom then next(previous x)=x, next(top) can be 37 for all I care, the only assumption should be a finite nonempty total order and then we have the advantage that it applies more generally.</p>



<a name="227904037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904037">(Feb 26 2021 at 09:44)</a>:</h4>
<p>Is there such a thing as a discrete total order? I mean a total order such that everything other than "top" has a "next" and everything other than "bottom" has a "previous"? I guess I'm saying I want all nonempty bounded-above sets to have a max and all non-empty bounded-below sets to have a min.</p>



<a name="227904272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904272">(Feb 26 2021 at 09:46)</a>:</h4>
<blockquote>
<p>At least this point of view abstracts away the whole + issue because the API writes itself -- if x!=top then previous(next x)=x, if x!=bottom then next(previous x)=x, next(top) can be 37 for all I care, the only assumption should be a finite nonempty total order and then we have the advantage that it applies more generally.</p>
</blockquote>
<p>Unfortunately, the fact that <code>fin 0</code> is empty is a recurring thorn in your side if you want to totalize everything</p>



<a name="227904291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904291">(Feb 26 2021 at 09:46)</a>:</h4>
<blockquote>
<p>fin n is some finite totally ordered set [...] including fin n with its nightmare dependently typed definition and its two definitions of +</p>
</blockquote>
<p>I feel like fin has been repurposed for stuff it wasn't meant to do, and now people complain that it doesn't fit their vision.</p>
<ol>
<li><code>fin n</code> is not some abstract totally ordered set, it is literally the naturals less than n.</li>
<li>"nightmare dependently typed definition" please use go-to-definition.  It's literally a subtype.  It's literally <em>the natural numbers less than n</em>...</li>
<li>"two definitions of +".  There is one definition of + on fin n, it's addition modulo n and this is the right choice.</li>
</ol>



<a name="227904366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904366">(Feb 26 2021 at 09:47)</a>:</h4>
<blockquote>
<p>"two definitions of +". There is one definition of + on fin n, it's addition modulo n and this is the right choice.</p>
</blockquote>
<p>If that's the case, then subtraction should also be modulo n</p>



<a name="227904382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904382">(Feb 26 2021 at 09:47)</a>:</h4>
<p>Addition wraps, subtraction saturates</p>



<a name="227904385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904385">(Feb 26 2021 at 09:47)</a>:</h4>
<p>wtf</p>



<a name="227904391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904391">(Feb 26 2021 at 09:48)</a>:</h4>
<p>Indeed wtf.</p>



<a name="227904482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904482">(Feb 26 2021 at 09:48)</a>:</h4>
<p>Finally one argument for changing + that I can get behind.  Although I'd prefer both to be modulo.</p>



<a name="227904531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904531">(Feb 26 2021 at 09:49)</a>:</h4>
<p>I think part of the confounding issue is that <code>zmod</code> exists, in part because fin subtraction was broken during the core freeze</p>



<a name="227904563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904563">(Feb 26 2021 at 09:49)</a>:</h4>
<p>since <code>zmod</code> exists now, people want <code>fin n</code> to not just be a poor man's <code>zmod</code></p>



<a name="227904699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227904699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227904699">(Feb 26 2021 at 09:51)</a>:</h4>
<p>I'm so happy that Lean 4 gets this right:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">Fin</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="o">))</span> <span class="bp">%</span> <span class="n">n</span><span class="o">,</span> <span class="n">mlt</span> <span class="n">h</span><span class="o">⟩</span>
</code></pre></div>



<a name="227906074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227906074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227906074">(Feb 26 2021 at 10:05)</a>:</h4>
<p>Gabriel's point is interesting. I am always thinking of <code>fin n</code> in terms of simplicial sets because at the back of my mind I have things like simplicial homology in Lean. That particular <code>fin n</code> is equipped with a structure which is well-defined within that sphere, there is the total order, the maps <code>fin n -&gt; fin (n+1)</code> which "miss out i", and the maps <code>fin (n+1) -&gt; fin n</code> which "identify j and j+1" and that's it, other than the obvious lemmas about what happens if you compose these maps. Once we have this right (and maybe we have it right already) we can do algebraic topology and this would be really cool. It would be crazy to introduce another type which played this role, but the problem is that the naive definitions of these maps use addition, which for me is a dangerous function because there's more than one definition of it (saturating or wrapping). Scott is probably thinking about something else, so he is somehow using <code>fin n</code> in a different way, but again he's using addition. Maybe there are better functions that one needs on <code>fin n</code>, like "next" and "previous" (on fin n.succ at least).</p>



<a name="227906167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227906167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227906167">(Feb 26 2021 at 10:06)</a>:</h4>
<p>My point is that I'm realising I have a different mental model of <code>fin n</code> to others, and am wondering whether all these different mental models can coexist. Probably they should.</p>



<a name="227907266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227907266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227907266">(Feb 26 2021 at 10:16)</a>:</h4>
<p>If you only care about two functions <code>fin.next</code> and <code>fin.prev</code>, then why does it matter if addition is defined or not?  (In any case, I didn't see any addition on fin in this thread, only addition of natural numbers.)</p>



<a name="227908939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227908939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227908939">(Feb 26 2021 at 10:32)</a>:</h4>
<p>It matters to Scott because he defined them using addition, which is intuitively the way to define them, and then got into a mess. I think my only worthwhile contribution to this thread is suggesting that these functions should be defined (or are perhaps defined already) and a little API made for them and Scott should be using these instead.</p>



<a name="227909555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227909555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227909555">(Feb 26 2021 at 10:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> which maps are you talking about now? We have the face/degeneracy maps + the simplicial identities now.</p>



<a name="227909598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227909598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227909598">(Feb 26 2021 at 10:39)</a>:</h4>
<p>of course, for the simplicial identities you need an ordering on <code>fin n</code></p>



<a name="227909878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227909878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227909878">(Feb 26 2021 at 10:42)</a>:</h4>
<p>Yes, I thought we would have them by now. Are they in mathlib? For Scott we need "next" and "prev" but I am arguing that these could be defined as "min of {x : x &gt; a}" and "max of {x : x &lt; a}" (which clearly exist for an arbitrary finite totally ordered set) and this would remove dependence on + which might be a good thing.</p>



<a name="227910264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227910264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227910264">(Feb 26 2021 at 10:46)</a>:</h4>
<p>the simplex category is on the current PR queue</p>



<a name="227911685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227911685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227911685">(Feb 26 2021 at 11:03)</a>:</h4>
<p>To answer the original question of the thread, it is straightforward to build <code>rotate</code> because we have modulo arithmetic:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">fin.n_add_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fin.coe_add</span><span class="o">,</span> <span class="n">fin.coe_one'</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">fin.one_add_n</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="n">fin.n_add_one</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">rotate</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">,</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">equiv.refl</span> <span class="n">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="bp">+</span><span class="n">n</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">],</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">]⟩</span>
</code></pre></div>
<p>(It would be even easier if <code>fin (n+1)</code> had a ring instance.)</p>



<a name="227915620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227915620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227915620">(Feb 26 2021 at 11:40)</a>:</h4>
<p>Aah, one could also do this by proving <code>rotate</code> for <code>zmod n</code> (true even without the case split!) and then deducing it for <code>fin n</code> using our HoTT substitution tool (equiv.trans).</p>



<a name="227933856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227933856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227933856">(Feb 26 2021 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> The point about simplicial sets is interesting! But if we ever want to do cyclic homology, we would need <code>fin.rotate</code> :)</p>



<a name="227934050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227934050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227934050">(Feb 26 2021 at 14:20)</a>:</h4>
<p>I just think it's strange to give <code>fin (n+1)</code> an <code>add_monoid</code> structure which is not an <code>add_group</code> structure.</p>



<a name="227935501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227935501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227935501">(Feb 26 2021 at 14:31)</a>:</h4>
<p>The <code>add_monoid</code> would hold even if addition was redefined. The <code>add_group</code> could be misleading because the <code>-</code> isn't what the <code>add_group</code> would suggest.</p>



<a name="227935995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227935995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227935995">(Feb 26 2021 at 14:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/fin.2Erotate/near/227904037">said</a>:</p>
<blockquote>
<p>Is there such a thing as a discrete total order? I mean a total order such that everything other than "top" has a "next" and everything other than "bottom" has a "previous"? I guess I'm saying I want all nonempty bounded-above sets to have a max and all non-empty bounded-below sets to have a min.</p>
</blockquote>
<p>I'm not sure "discrete" is the correct word for this. Doesn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo><mo>∪</mo><mo stretchy="false">{</mo><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0\} \cup \{1/2^n \ | \ n \in \mathbb{N}\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mclose">}</span></span></span></span> satisfy these conditions?</p>



<a name="227936095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227936095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227936095">(Feb 26 2021 at 14:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/fin.2Erotate/near/227935501">said</a>:</p>
<blockquote>
<p>The <code>add_monoid</code> would hold even if addition was redefined. The <code>add_group</code> could be misleading because the <code>-</code> isn't what the <code>add_group</code> would suggest.</p>
</blockquote>
<p>Yeah, I see what you mean here.</p>



<a name="227936619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227936619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227936619">(Feb 26 2021 at 14:39)</a>:</h4>
<p>Rob said in the PR (<a href="https://github.com/leanprover-community/mathlib/issues/5010">#5010</a>) where I added <code>add_monoid</code>:</p>
<blockquote>
<p>Although you could argue that cleaning things up encourages people to use the controversial operations...</p>
</blockquote>



<a name="227937136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227937136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227937136">(Feb 26 2021 at 14:43)</a>:</h4>
<p>Here is how things are organized in my mind (for better or worse):</p>
<ol>
<li><code>fin n</code> could be endowed with the usual abelian groups structure, while <code>zmod n</code> is a commutative ring.</li>
<li><code>fin n</code> can be endowed with the usual order structure, with the understanding that this is really a cyclic order which is compatible with the additive group structure. If you just want the non-cyclic order, just don't use the additive group structure.</li>
</ol>
<p>I was under the impression that this controversy about arithmetic operations in <code>fin n</code> arose from some coercion <code>fin n -&gt; \N</code></p>



<a name="227937525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227937525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227937525">(Feb 26 2021 at 14:46)</a>:</h4>
<p>Re 1, given that <code>fin n</code> has a <code>has_mul</code>, do we just ignore that?</p>



<a name="227937606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227937606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227937606">(Feb 26 2021 at 14:47)</a>:</h4>
<p>Oh I wasn't aware it had a <code>has_mul</code>. I would say to remove that completely.</p>



<a name="227937679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227937679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227937679">(Feb 26 2021 at 14:47)</a>:</h4>
<p>Ah, but all those operations are defined in core. Because it's a shortcut to getting <code>unsigned</code> working.</p>



<a name="227938060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227938060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227938060">(Feb 26 2021 at 14:50)</a>:</h4>
<p>I want to repeat that in Lean 4, subtraction will be defined correctly on Fin (i.e. as an inverse to addition).  We can (should?) backport this change to Lean 3.</p>



<a name="227938231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227938231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227938231">(Feb 26 2021 at 14:51)</a>:</h4>
<p>The coercion of <code>fin n -&gt; \N</code>, if it is the <code>coe_subtype</code>, that is fine. The other coercion comes from <code>nat.cast</code>, which relies on <code>has_add</code>. The reverse direction <code>\N -&gt; fin (n + 1)</code> comes from core <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.of_nat">docs#fin.of_nat</a></p>



<a name="227938450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227938450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227938450">(Feb 26 2021 at 14:53)</a>:</h4>
<p>Gabriel, would you then separate the <code>unsigned.has_sub</code> from <code>fin.has_sub</code>?</p>



<a name="227938658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227938658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227938658">(Feb 26 2021 at 14:54)</a>:</h4>
<p>Give me a second.</p>



<a name="227939196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227939196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227939196">(Feb 26 2021 at 14:58)</a>:</h4>
<p>(Relatedly, does it make sense for unsigned ints that subtraction is saturating? According to the C spec,</p>
<blockquote>
<p>A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type)</p>
</blockquote>



<a name="227939493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227939493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227939493">(Feb 26 2021 at 15:00)</a>:</h4>
<p>Lean is certainly not C.</p>



<a name="227939713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227939713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227939713">(Feb 26 2021 at 15:02)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/issues/541">lean#541</a><br>
I think this worth it just for the fact that this is how Lean 4 does it.</p>



<a name="227958206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227958206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227958206">(Feb 26 2021 at 17:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/fin.2Erotate/near/227935995">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/fin.2Erotate/near/227904037">said</a>:</p>
<blockquote>
<p>Is there such a thing as a discrete total order? I mean a total order such that everything other than "top" has a "next" and everything other than "bottom" has a "previous"? I guess I'm saying I want all nonempty bounded-above sets to have a max and all non-empty bounded-below sets to have a min.</p>
</blockquote>
<p>I'm not sure "discrete" is the correct word for this. Doesn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo><mo>∪</mo><mo stretchy="false">{</mo><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0\} \cup \{1/2^n \ | \ n \in \mathbb{N}\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mclose">}</span></span></span></span> satisfy these conditions?</p>
</blockquote>
<p>No, because <code>0</code> is not <code>top</code> and doesn't have a <code>next</code>.</p>



<a name="227963343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/227963343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#227963343">(Feb 26 2021 at 17:42)</a>:</h4>
<p>Oh right.</p>



<a name="231677346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/fin.rotate/near/231677346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/fin.2Erotate.html#231677346">(Mar 24 2021 at 17:40)</a>:</h4>
<p>Coming back to this: should we make <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.comm_ring">docs#fin.comm_ring</a> a global instance now? <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> suggested that would be reasonable in <a href="https://github.com/leanprover-community/mathlib/issues/6848">#6848</a>, and I'd be loosely in favor too</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html">prod version of nat.coprime.lcm_eq_mul</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270761911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270761911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270761911">(Feb 04 2022 at 19:31)</a>:</h4>
<p>The lemma nat.coprime.lcm_eq_mul states that if natural numbers <code>a</code> and <code>b</code> are <code>coprime</code>, then <code>lcm a b = a * b</code>. Does a version of this lemma for more than two elements exist, i.e. something like: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.range</span>
<span class="kn">import</span> <span class="n">ring_theory.int.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span>
<span class="kn">import</span> <span class="n">data.nat.log</span>
<span class="kn">import</span> <span class="n">algebra.gcd_monoid.multiset</span>
<span class="kn">import</span> <span class="n">algebra.gcd_monoid.finset</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">lemma</span> <span class="n">finset.lcm_eq_prod_of_coprime</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">nat.coprime</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">p</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">s.lcm</span> <span class="n">id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270765965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270765965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270765965">(Feb 04 2022 at 20:05)</a>:</h4>
<p>You should use <a href="https://leanprover-community.github.io/mathlib_docs/find/set.pairwise">docs#set.pairwise</a> for <code>h</code></p>



<a name="270766315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270766315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270766315">(Feb 04 2022 at 20:08)</a>:</h4>
<p>Probably we don't have this lemma.</p>



<a name="270766397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270766397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270766397">(Feb 04 2022 at 20:08)</a>:</h4>
<p>Note that the name should mention <code>nat</code> somewhere</p>



<a name="270767355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270767355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270767355">(Feb 04 2022 at 20:17)</a>:</h4>
<p>Thanks. I will try to understand how the pairwise comes in after having proved the lemma. The following is my current attempt. I feel like I am simply missing some <code>generalizing</code> trick. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.range</span>
<span class="kn">import</span> <span class="n">ring_theory.int.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span>
<span class="kn">import</span> <span class="n">data.nat.log</span>
<span class="kn">import</span> <span class="n">algebra.gcd_monoid.multiset</span>
<span class="kn">import</span> <span class="n">algebra.gcd_monoid.finset</span>



<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">lemma</span> <span class="n">nat.coprime_prod_of_pairwise_coprime</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">nat.coprime</span> <span class="n">x</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat.coprime</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∏</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">finset.induction_on</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat.coprime_one_right_iff</span><span class="o">,</span> <span class="n">finset.prod_empty</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">t</span> <span class="n">hynt</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.prod_insert</span> <span class="n">hynt</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">nat.coprime.mul_right</span> <span class="n">_</span> <span class="n">ih</span><span class="o">,</span>
     <span class="gr">sorry</span> <span class="o">},</span>
<span class="kd">end</span>


<span class="kd">lemma</span> <span class="n">finset.nat.lcm_eq_prod_of_coprime</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">nat.coprime</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">p</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">s.lcm</span> <span class="n">id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">finset.induction_on</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.prod_empty</span><span class="o">,</span> <span class="n">finset.lcm_empty</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">t</span> <span class="n">hxnt</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.prod_insert</span> <span class="n">hxnt</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.lcm_insert</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">ih</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hco</span> <span class="o">:</span> <span class="n">nat.coprime</span> <span class="n">x</span> <span class="o">(</span><span class="bp">∏</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">p</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">nat.coprime_prod_of_pairwise_coprime</span><span class="o">,</span>
        <span class="gr">sorry</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">id.def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">lcm_eq_nat_lcm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hco.lcm_eq_mul</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270767764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270767764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270767764">(Feb 04 2022 at 20:21)</a>:</h4>
<p>Try starting your first proof with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">finset.induction_on</span> <span class="k">with</span> <span class="n">y</span> <span class="n">t</span> <span class="n">hynt</span> <span class="n">ih</span><span class="o">,</span>
</code></pre></div>
<p>That should make it pretty straightforward</p>



<a name="270767869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270767869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270767869">(Feb 04 2022 at 20:22)</a>:</h4>
<p>Thanks. I just looked again in the docs and found finset.induction_on' which works much better.</p>



<a name="270767886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270767886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270767886">(Feb 04 2022 at 20:22)</a>:</h4>
<p>Or <code>revert h,</code> before <code>apply finset.induction_on s,</code>, but I didn't try that</p>



<a name="270772074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270772074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270772074">(Feb 04 2022 at 21:01)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> How would I go about formulating <code>h</code> using <code>pairwise</code>?</p>



<a name="270772597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270772597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270772597">(Feb 04 2022 at 21:06)</a>:</h4>
<p>Ah, got it. You need <code>coe_t</code> to convert a finset to a set.</p>



<a name="270777921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270777921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270777921">(Feb 04 2022 at 21:52)</a>:</h4>
<p>We should generalize <code>set.pairwise</code> to <code>has_mem</code>.</p>



<a name="270778296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270778296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270778296">(Feb 04 2022 at 21:56)</a>:</h4>
<p>Unfortunately, <code>pairwise</code> is already taken globally</p>



<a name="270780424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270780424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270780424">(Feb 04 2022 at 22:14)</a>:</h4>
<p><code>pairwise_on</code>?</p>



<a name="270780504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270780504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270780504">(Feb 04 2022 at 22:15)</a>:</h4>
<p>You won me!</p>



<a name="270780560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prod%20version%20of%20nat.coprime.lcm_eq_mul/near/270780560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prod.20version.20of.20nat.2Ecoprime.2Elcm_eq_mul.html#270780560">(Feb 04 2022 at 22:15)</a>:</h4>
<p>That's actually even better than the current state of things because <code>open set</code> often results in rapid death by ambiguity.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html">profinite sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218214108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218214108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218214108">(Nov 29 2020 at 14:01)</a>:</h4>
<p>We don't have them, right? What's the definition? I was taught "a projective limit of finite sets", that sounds like a disaster. "compact and totally disconnected" sounds like a better bet.</p>



<a name="218215073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215073">(Nov 29 2020 at 14:29)</a>:</h4>
<p>Totally disconnected compact Hausdorff is easy to write down</p>



<a name="218215139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215139">(Nov 29 2020 at 14:31)</a>:</h4>
<p>And I've been (very slowly) adding stuff to make this usable.</p>



<a name="218215294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215294">(Nov 29 2020 at 14:36)</a>:</h4>
<p>E.g. only as of a few days ago does mathlib have the fact that the disjoint union of two t2 spaces is t2.</p>



<a name="218215340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215340">(Nov 29 2020 at 14:36)</a>:</h4>
<p>Should I just make some new file <code>profinite.lean</code> in <code>topology</code>?</p>



<a name="218215613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215613">(Nov 29 2020 at 14:44)</a>:</h4>
<p>My inclination is to make the category of profinite sets directly in <code>topology/category/Profinite.lean</code> since we already have the three classes <code>compact_space</code> <code>t2_space</code> and <code>totally_disconnected</code></p>



<a name="218215702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215702">(Nov 29 2020 at 14:47)</a>:</h4>
<p>I agree that "projective limit of finite sets" sounds like a potential disaster as a definition but somehow it's the definition we want, so maybe we can create an API around the "totally disconnected compact Hausdorff" definition. For example, we should know that a map to a discrete space is continuous iff it factors through a finite quotient.</p>



<a name="218215752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215752">(Nov 29 2020 at 14:48)</a>:</h4>
<p>And we need to prove that <code>Profinite</code> has limits (all limits? or is it just filtered? I don't remember), this way we can construct profinite sets as inverse limits of finite sets</p>



<a name="218215762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215762">(Nov 29 2020 at 14:48)</a>:</h4>
<p>And we should be able to construct examples as cofiltered limits of finite sets (e.g. build the p-adics from just algebraic data) and know that the original diagram presents the profinite set in this sense</p>



<a name="218215827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215827">(Nov 29 2020 at 14:51)</a>:</h4>
<p>By the way, there is a more or less canonical way to write a profinite set as an inverse limit of finites, see e.g. the proof in the stacks project</p>



<a name="218215900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215900">(Nov 29 2020 at 14:53)</a>:</h4>
<p>that makes sense because as a category, profinite sets is (Ind(FinSet^op))^op</p>



<a name="218215904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218215904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218215904">(Nov 29 2020 at 14:53)</a>:</h4>
<p>so it's the opposite of a locally finitely presentable category</p>



<a name="218216025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216025">(Nov 29 2020 at 14:56)</a>:</h4>
<p>Does mathlib have Ind?</p>



<a name="218216026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216026">(Nov 29 2020 at 14:56)</a>:</h4>
<p>Or Pro?</p>



<a name="218216159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216159">(Nov 29 2020 at 15:00)</a>:</h4>
<p>Not sure but it's definitely capable of expressing one definition of Ind</p>



<a name="218216160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216160">(Nov 29 2020 at 15:00)</a>:</h4>
<p>whether that's useful is another matter</p>



<a name="218216364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216364">(Nov 29 2020 at 15:06)</a>:</h4>
<p>If we unfold the definitions it says that a profinite set is something that we know how to map into finite sets, in a way that respects finite limits. But this only gives us access to the "locale" side, e.g., we know what all the ways to split our profinite set into two clopen subsets are, because they're the maps into {0,1}</p>



<a name="218216424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216424">(Nov 29 2020 at 15:08)</a>:</h4>
<p>To get the points of the profinite set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> you'd need some Stone duality-like "assignment of an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> to every map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">X \to S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>"</p>



<a name="218216444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216444">(Nov 29 2020 at 15:09)</a>:</h4>
<p>which I guess is just saying: natural transformations from the one-point space to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, so maybe it's not too bad</p>



<a name="218216511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216511">(Nov 29 2020 at 15:11)</a>:</h4>
<p>So in this picture a profinite set is just a finite limit-preserving (covariant) functor from finite sets to sets</p>



<a name="218216593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216593">(Nov 29 2020 at 15:13)</a>:</h4>
<p>I think Scott did add recently-ish that filtered colimits commute with finite limits, which is the main thing you need to make this workable at all</p>



<a name="218216777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218216777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218216777">(Nov 29 2020 at 15:18)</a>:</h4>
<p>So a profinite set X is identified with the functor sending a finite set F to the set of continuous maps X to F?</p>



<a name="218217164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218217164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218217164">(Nov 29 2020 at 15:29)</a>:</h4>
<p>This raises the question as to how important the underlying topological space is. I guess that depends on what you're trying to do.</p>



<a name="218217443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218217443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218217443">(Nov 29 2020 at 15:36)</a>:</h4>
<p>The topology is easy to describe too, it should be the coarsest one that makes the maps to finite sets continuous. So we can write down both categories and both functors and if we prove they form an equivalence then we probably have a pretty good API for either side.</p>



<a name="218217604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218217604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218217604">(Nov 29 2020 at 15:41)</a>:</h4>
<p>Of course finite sets are sufficiently more annoying than expected that it might actually be technically easier to use topological spaces</p>



<a name="218217773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218217773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218217773">(Nov 29 2020 at 15:46)</a>:</h4>
<p>I still like my half-joking suggestion to make <code>Type 0</code> only allow finite types</p>



<a name="218217777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218217777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218217777">(Nov 29 2020 at 15:46)</a>:</h4>
<p>I think it's a mistake to divorce from topological spaces (even if there is a way to describe the topology). E.g. we will want to ensure that talking about closed subgroups of a profinite group is as easy as possible</p>



<a name="218217959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218217959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218217959">(Nov 29 2020 at 15:52)</a>:</h4>
<p>In general I think the answer to choice of representation questions like this has to be to choose both representations</p>



<a name="218218053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218218053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218218053">(Nov 29 2020 at 15:55)</a>:</h4>
<p>Right. For example, we can start like this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Profinite</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_Top</span> <span class="o">:</span> <span class="n">Top</span><span class="o">)</span>
<span class="o">[</span><span class="n">is_compact</span> <span class="o">:</span> <span class="n">compact_space</span> <span class="n">to_Top</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_t2</span> <span class="o">:</span> <span class="n">t2_space</span> <span class="n">to_Top</span><span class="o">]</span>
<span class="o">[</span><span class="n">is_td</span> <span class="o">:</span> <span class="n">totally_disconnected_space</span> <span class="n">to_Top</span><span class="o">]</span>
</code></pre></div>
<p>Then construct the functor to <code>FinType \functor Type*</code> that we discussed above and prove it's fully faithful, and describe its essential image as well.</p>



<a name="218218123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218218123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218218123">(Nov 29 2020 at 15:56)</a>:</h4>
<p>Proving that <code>Profinite</code> has finite coproducts should be easy, and proving that it has limits shouldn't be too bad (e.g. the category <code>CompHaus</code> has limits, as can be proved using the equivalence with <code>Compactum</code>)</p>



<a name="218218137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218218137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218218137">(Nov 29 2020 at 15:57)</a>:</h4>
<p>I guess the forgetful functor <code>Profinite \functor CompHaus</code> creates limits?</p>



<a name="218218443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218218443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218218443">(Nov 29 2020 at 16:04)</a>:</h4>
<p>This is another recent addition which will help in proving that finite sets are profinite <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span> <br>
<a href="https://github.com/leanprover-community/mathlib/blob/1f1ba587f272d203a40801c6b21af453f7de6ee3/src/topology/subset_properties.lean#L1305">https://github.com/leanprover-community/mathlib/blob/1f1ba587f272d203a40801c6b21af453f7de6ee3/src/topology/subset_properties.lean#L1305</a></p>



<a name="218218522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218218522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218218522">(Nov 29 2020 at 16:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/profinite.20sets/near/218217773">said</a>:</p>
<blockquote>
<p>I still like my half-joking suggestion to make <code>Type 0</code> only allow finite types</p>
</blockquote>
<p>What we really need is a whole new proof assistant where everything takes place internally in the topos of condensed sets.</p>



<a name="218223201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218223201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218223201">(Nov 29 2020 at 18:16)</a>:</h4>
<p>i'm waiting for the magical day when there's a usable soundness theorem for replaying proofs in {algebraic, coherent, etc} theories in the internal logic of toposes that interpret them</p>



<a name="218571139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/profinite%20sets/near/218571139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/profinite.20sets.html#218571139">(Dec 02 2020 at 15:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/profinite.20sets/near/218218522">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/profinite.20sets/near/218217773">said</a>:</p>
<blockquote>
<p>I still like my half-joking suggestion to make <code>Type 0</code> only allow finite types</p>
</blockquote>
<p>What we really need is a whole new proof assistant where everything takes place internally in the topos of condensed sets.</p>
</blockquote>
<p>I agree this somehow feels very natural. Inductive types are discrete while coinductive types are profinite. Lean doesn't have coinductive types built in, but you can build them using functions and I think this construction produces the right topology when internalized in condensed sets. If you combine inductive and coinductive types then you get things like infinite unions of profinite sets that appear everywhere in the condensed theory, and if you also add in (exact) quotients then you get things that look like arbitrary condensed sets.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
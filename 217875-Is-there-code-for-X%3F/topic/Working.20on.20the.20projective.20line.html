---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html">Working on the projective line</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281283687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281283687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281283687">(May 05 2022 at 11:13)</a>:</h4>
<p>I am trying to work on CP1 and to define charts, but so far my attempts at proving continuity have had limited success. Here is a minimal example of what I am trying to write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.projective_space.basic</span>

<span class="kn">open</span> <span class="n">projectivization</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="n">ℙ</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="n">quotient.topological_space</span>

<span class="kd">def</span> <span class="n">D</span> <span class="o">:</span> <span class="n">set</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">quotient.lift_on'</span> <span class="n">z</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">w.val.2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">CP1</span> <span class="bp">→</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">quotient.lift_on'</span> <span class="n">z</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">w.val.1</span> <span class="bp">/</span> <span class="n">w.val.2</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">l5</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">D</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">continuous_on_iff</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">t</span> <span class="n">ht</span> <span class="n">hzt</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="bp">∩</span> <span class="n">D</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_open_coinduced</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.preimage_comp</span><span class="o">,</span> <span class="n">set.preimage</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">set.mem_def</span><span class="o">,</span> <span class="n">D</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">is_open_induced_iff</span><span class="o">],</span>
    <span class="n">use</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span> <span class="bp">|</span> <span class="n">z.1</span> <span class="bp">/</span> <span class="n">z.2</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">z.2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">},</span>
    <span class="gr">sorry</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>I am using <code>lift_on'</code> everywhere because for other parts it has been easier than using <code>rep</code> (i.e., <code>quotient.out</code> if I tracked it right), but as far as I can tell it is not the source of my issue. Do we need a restricted version of <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_quotient_lift_on'">docs#continuous_quotient_lift_on'</a> somewhere?</p>



<a name="281291917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281291917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281291917">(May 05 2022 at 12:33)</a>:</h4>
<p>Not familiar with the continuity library but mathlib already has <a href="https://leanprover-community.github.io/mathlib_docs/find/projectivization">docs#projectivization</a> (<a href="#narrow/stream/116395-maths/topic/Projective.20spaces">Zulip thread</a>).</p>



<a name="281294752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281294752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281294752">(May 05 2022 at 12:55)</a>:</h4>
<p>I believe this is what Vincent is using already.</p>



<a name="281294904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281294904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281294904">(May 05 2022 at 12:56)</a>:</h4>
<p>Oh yes indeed! Sorry for my oversight.</p>



<a name="281295960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281295960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281295960">(May 05 2022 at 13:04)</a>:</h4>
<p>I am using it, but there does not seem to be a lot of API yet there</p>



<a name="281297481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281297481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281297481">(May 05 2022 at 13:17)</a>:</h4>
<p>I think a nicer approach would be to take a perfect pairing of vector spaces <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>×</mo><mi>W</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">V \times W \to k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> and use that to construct affine charts. E.g. this lets you identify the projectivization of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> with the dual projective space of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, so points in the projectivization of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> correspond to hyperplanes in the projective space of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, and their complements give you affine charts. This would make the situation much more symmetric, which will probably simplify a lot of things (similar to <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> ‘s approach to the sphere). I should also mention that I have a student <span class="user-mention" data-user-id="488747">@Michael Blyth</span> who will build up some of the API around projective spaces as a summer project.</p>



<a name="281297768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281297768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281297768">(May 05 2022 at 13:19)</a>:</h4>
<p>(Of course, this is still orthogonal to the question asked regarding <code>continuous_on</code>…)</p>



<a name="281298090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281298090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281298090">(May 05 2022 at 13:22)</a>:</h4>
<p>And let's not forget connecting to <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.Proj.to_LocallyRingedSpace">docs#algebraic_geometry.Proj.to_LocallyRingedSpace</a> !</p>



<a name="281322124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281322124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281322124">(May 05 2022 at 16:18)</a>:</h4>
<p><code>projectivization</code> should be generalized to division rings, and there's also OP^2, then we can define all the Hopf fibrations.</p>



<a name="281322409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281322409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281322409">(May 05 2022 at 16:20)</a>:</h4>
<p>I agree <code>projectivization</code> should be generalised to <code>division_ring</code>s but we won't get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi mathvariant="double-struck">O</mi><mi mathvariant="double-struck">P</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{OP}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0596em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">OP</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8929em;"><span style="top:-3.1418em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> that way. Indeed there is no such thing as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi mathvariant="double-struck">O</mi><mi mathvariant="double-struck">P</mi></mrow><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{OP}^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0946em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">OP</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9279em;"><span style="top:-3.1418em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> so I'd say that case will have to be ad hoc.</p>



<a name="281322422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281322422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281322422">(May 05 2022 at 16:20)</a>:</h4>
<p>I tried making that generalization when I defined the projectivization originally, but I got bogged down with a lot of the <code>finite_dimensional</code> stuff being done only in the commutative case.</p>



<a name="281322640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281322640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281322640">(May 05 2022 at 16:22)</a>:</h4>
<p>Once the finite dimensional stuff is generalized, it should be very quick to generalize the assumptions on <code>projectivization</code></p>



<a name="281322741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281322741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281322741">(May 05 2022 at 16:23)</a>:</h4>
<p>recent developments like <a href="https://github.com/leanprover-community/mathlib/pull/13870">#13870</a> <a href="https://github.com/leanprover-community/mathlib/pull/13845">#13845</a> seems relevant</p>



<a name="281359522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281359522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281359522">(May 05 2022 at 21:08)</a>:</h4>
<p>OK so I finally made it, and it is not too ugly in the end:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.projective_space.basic</span>

<span class="kn">open</span> <span class="n">projectivization</span>

<span class="kd">noncomputable theory</span>

<span class="kd">def</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="n">ℙ</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="n">quotient.topological_space</span>

<span class="kd">def</span> <span class="n">D</span> <span class="o">:</span> <span class="n">set</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">quotient.lift_on'</span> <span class="n">z</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">w.val.2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">CP1</span> <span class="bp">→</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">quotient.lift_on'</span> <span class="n">z</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">w.val.1</span> <span class="bp">/</span> <span class="n">w.val.2</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">l5</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">D</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">continuous_on_iff</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">t</span> <span class="n">ht</span> <span class="n">hzt</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="bp">∩</span> <span class="n">D</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hz</span><span class="o">,</span> <span class="n">hzt</span><span class="o">],</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨{</span><span class="n">z</span> <span class="bp">|</span> <span class="n">z.1</span> <span class="bp">/</span> <span class="n">z.2</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">z.2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">},</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">set.set_of_and</span><span class="o">,</span> <span class="n">set.inter_comm</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">continuous_on.preimage_open_of_open</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ht</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">continuous_on.div</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">continuous_fst.continuous_on</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">continuous_snd.continuous_on</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">imp_self</span><span class="o">,</span> <span class="n">forall_const</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">is_open.preimage</span> <span class="n">continuous_snd</span> <span class="n">is_open_compl_singleton</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">set.inter_subset_left</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>(the <code>sorry</code>s in the definitions are not a problem). All in all I have a <code>local_homeomorph (ℙ ℂ (ℂ × ℂ)) ℂ</code>, built in an ad hoc way but it should be usable even if it doesn't win any beauty contest.</p>



<a name="281361491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281361491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281361491">(May 05 2022 at 21:27)</a>:</h4>
<p>I think a general approach is to compose the continuous map from C^n to C^(n+1) (sending one coordinate to 1) with the quotient map C^(n+1)\{0} → CP^n to get an injective map C^n → CP^n whose inverse is your <code>f</code>. Restricted to each closed ball, it's an injective continuous map from compact to Hausdorff, hence an homeomorphism onto its image, so <code>f</code> is continuous on the image. You still need to show that CP^n is Hausdorff (<code>t2_space</code>) though.</p>



<a name="281363123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281363123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281363123">(May 05 2022 at 21:41)</a>:</h4>
<p>Indeed that was my other option (<a href="https://leanprover-community.github.io/mathlib_docs/find/is_open_map.continuous_on_image_of_left_inv_on">docs#is_open_map.continuous_on_image_of_left_inv_on</a>) but my <code>f</code> was simple enough that I thought it would be easy, and that was the opening of this particular rabbit hole. You are certainly right that in all generality it will be easier to work with the inverse map.</p>



<a name="281363862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281363862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281363862">(May 05 2022 at 21:50)</a>:</h4>
<p>Hmm, it seems you still have to show that the image contains an open neighborhood of the point around which you want to find a chart. So maybe this approach isn't that simpler after all. (simply showing <code>is_open_map</code> bypasses all these compact Hausdorff argument)</p>



<a name="281612337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281612337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281612337">(May 08 2022 at 18:38)</a>:</h4>
<p>So here is a definition of the manifold structure on the Riemann sphere / CP1. It has all kinds of problems and I am not going to PR it anytime soon, but I am putting it here for future reference, and if possible for comments :-)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">geometry.manifold.charted_space</span>
<span class="kn">import</span> <span class="n">geometry.manifold.smooth_manifold_with_corners</span>
<span class="kn">import</span> <span class="n">linear_algebra.projective_space.basic</span>
<span class="kn">import</span> <span class="n">topology.constructions</span>

<span class="kd">noncomputable theory</span>

<span class="n">open_locale</span> <span class="n">manifold</span>

<span class="kn">namespace</span> <span class="n">projectivization</span>

<span class="kd">abbreviation</span> <span class="n">C'2</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span> <span class="bp">//</span> <span class="n">z</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">}</span>
<span class="kd">abbreviation</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="n">ℙ</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="n">x</span><span class="bp">`</span><span class="o">:</span><span class="bp">`</span><span class="n">y</span><span class="bp">`</span><span class="o">,</span> <span class="bp">`</span><span class="n">h</span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mk</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="n">h</span> <span class="o">:</span> <span class="n">CP1</span><span class="o">)</span>
<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="n">x</span><span class="bp">`</span><span class="o">:</span><span class="bp">`</span><span class="n">y</span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="o">[</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="n">quotient.topological_space</span>

<span class="c">/-</span><span class="cm"> General-purpose lemmas (not about projectivization itself) -/</span>

<span class="kd">lemma</span> <span class="n">is_open_preimage_div</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_open</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span> <span class="bp">|</span> <span class="n">z.2</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">z.1</span> <span class="bp">/</span> <span class="n">z.2</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_fst.continuous_on.div</span> <span class="n">continuous_snd.continuous_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span><span class="o">))</span><span class="bp">.</span><span class="n">preimage_open_of_open</span>
  <span class="o">(</span><span class="n">is_open_compl_singleton.preimage</span> <span class="n">continuous_snd</span><span class="o">)</span> <span class="n">ht</span>

<span class="c">/-</span><span class="cm"> Technical lemmas about projectivization -/</span>

<span class="kd">lemma</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">x</span> <span class="n">hx</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">y</span> <span class="n">hy</span> <span class="bp">↔</span> <span class="n">x.1</span> <span class="bp">*</span> <span class="n">y.2</span> <span class="bp">=</span> <span class="n">x.2</span> <span class="bp">*</span> <span class="n">y.1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mk_eq_mk_iff</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">units.smul_def</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">y.1</span> <span class="n">_</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">x</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">⟩,</span>
    <span class="n">by_cases</span> <span class="n">y1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">prod.mk_eq_zero</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">true_and</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">mul_eq_zero</span><span class="o">,</span> <span class="n">or_false</span><span class="o">]</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hxy</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">prod.mk_eq_zero</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">true_and</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">units.mk0</span> <span class="o">(</span><span class="n">x2</span><span class="bp">/</span><span class="n">y2</span><span class="o">)</span> <span class="o">(</span><span class="n">div_ne_zero</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">),</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">units.smul_def</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hxy</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h'</span> <span class="o">:</span> <span class="n">x1</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h'</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">prod.mk_eq_zero</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">true_and</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h'</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">zero_eq_mul</span><span class="o">,</span> <span class="n">false_or</span><span class="o">]</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
        <span class="n">contradiction</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">units.mk0</span> <span class="o">(</span><span class="n">x1</span><span class="bp">/</span><span class="n">y1</span><span class="o">)</span> <span class="o">(</span><span class="n">div_ne_zero</span> <span class="n">h'</span> <span class="n">h</span><span class="o">),</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">units.smul_def</span><span class="o">,</span> <span class="n">div_mul_cancel</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">mul_comm_div'</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_div_assoc</span><span class="o">,</span> <span class="n">hxy</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">div_eq_div_of_mk_eq_mk</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">x</span> <span class="n">hx</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x.1</span> <span class="bp">/</span> <span class="n">x.2</span> <span class="bp">=</span> <span class="n">y.1</span> <span class="bp">/</span> <span class="n">y.2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="o">(</span><span class="n">mk_eq_mk_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">units.smul_def</span><span class="o">,</span> <span class="n">mul_div_mul_left</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">lift_on_mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">C'2</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hf</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">quotient.lift_on'</span> <span class="o">(</span><span class="n">mk</span> <span class="n">ℂ</span> <span class="n">z</span> <span class="n">h</span><span class="o">)</span> <span class="n">f</span> <span class="n">hf</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> Topological results -/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">t1_space</span> <span class="n">CP1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">induction</span> <span class="n">x</span> <span class="n">using</span> <span class="n">projectivization.ind</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">is_open_compl_iff</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">is_open</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">¬</span> <span class="n">mk'</span> <span class="n">ℂ</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">},</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">mk'_eq_mk</span><span class="o">,</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hc</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span> <span class="o">:</span> <span class="n">C'2</span><span class="o">,</span> <span class="n">z.val.1</span> <span class="bp">*</span> <span class="n">x.2</span> <span class="bp">-</span> <span class="n">z.val.2</span> <span class="bp">*</span> <span class="n">x.1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">continuity</span><span class="o">,</span>
  <span class="n">convert</span> <span class="bp">←</span> <span class="n">is_open_compl_singleton.preimage</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">sub_ne_zero</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"> Chart constructions -/</span>

<span class="kd">def</span> <span class="n">rec1</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">CP1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="n">quotient.lift_on'</span> <span class="n">z</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">w.val.1</span> <span class="bp">/</span> <span class="n">w.val.2</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">div_eq_div_of_mk_eq_mk</span> <span class="n">x.prop</span> <span class="n">y.prop</span> <span class="o">(</span><span class="n">quotient.eq'.mpr</span> <span class="n">h</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">continuous_rec1</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">rec1</span> <span class="o">{[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">]}</span><span class="bp">ᶜ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">continuous_on_iff</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">t</span> <span class="n">ht</span> <span class="n">hzt</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">rec1</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="bp">∩</span> <span class="o">{[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">]}</span><span class="bp">ᶜ</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hzt</span><span class="o">,</span> <span class="n">hz</span><span class="o">⟩,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set.inter_assoc</span><span class="o">,</span> <span class="n">set.inter_subset_left</span><span class="o">]⟩,</span>
  <span class="n">refine</span> <span class="o">⟨{</span><span class="n">z</span> <span class="bp">|</span> <span class="n">z.2</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">z.1</span> <span class="bp">/</span> <span class="n">z.2</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">},</span> <span class="n">is_open_preimage_div</span> <span class="n">ht</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">rec1</span><span class="o">,</span> <span class="n">and_comm</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">),</span> <span class="n">not_iff_not</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span>
    <span class="n">set.mem_inter_eq</span><span class="o">,</span> <span class="n">set.mem_preimage</span><span class="o">,</span> <span class="n">quotient.lift_on'_mk</span><span class="o">,</span> <span class="n">set.mem_compl_eq</span><span class="o">,</span>
    <span class="n">set.mem_singleton_iff</span><span class="o">,</span> <span class="n">and.congr_right_iff</span><span class="o">],</span>
  <span class="n">change</span> <span class="n">_</span> <span class="bp">→</span> <span class="o">(</span><span class="n">_</span> <span class="bp">↔</span> <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">x</span> <span class="n">hx</span> <span class="bp">=</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">lh1</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">CP1</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">rec1</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="o">[</span><span class="n">z</span><span class="o">:</span><span class="mi">1</span><span class="o">],</span>
  <span class="n">source</span> <span class="o">:=</span> <span class="o">{[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">]}</span><span class="bp">ᶜ</span><span class="o">,</span>
  <span class="n">target</span> <span class="o">:=</span> <span class="n">set.univ</span><span class="o">,</span>

  <span class="n">map_source'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">set.mem_univ</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_target'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">],</span>

  <span class="n">left_inv'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">induction</span> <span class="n">z</span> <span class="n">using</span> <span class="n">projectivization.ind</span> <span class="k">with</span> <span class="n">z</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_compl_iff</span><span class="o">,</span> <span class="n">set.mem_singleton_iff</span><span class="o">,</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span>
      <span class="bp">←</span> <span class="n">ne.def</span><span class="o">]</span> <span class="n">at</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">rec1</span><span class="o">,</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">,</span> <span class="n">hz.symm</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">right_inv'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">rec1</span><span class="o">],</span>

  <span class="n">open_source</span> <span class="o">:=</span> <span class="n">is_open_compl_singleton</span><span class="o">,</span>
  <span class="n">open_target</span> <span class="o">:=</span> <span class="n">is_open_univ</span><span class="o">,</span>
  <span class="n">continuous_to_fun</span> <span class="o">:=</span> <span class="n">continuous_rec1</span><span class="o">,</span>
  <span class="n">continuous_inv_fun</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">apply</span> <span class="n">continuous.continuous_on</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">continuous_quot_mk.comp</span><span class="o">,</span>
    <span class="n">continuity</span> <span class="o">},</span>
<span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">l1</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">×</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">:</span> <span class="n">z.swap</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">z</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">⟩,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">and_comm</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">antip</span> <span class="o">:</span> <span class="n">CP1</span> <span class="bp">→</span> <span class="n">CP1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">quotient.lift_on'</span> <span class="n">z</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">mk</span> <span class="n">ℂ</span> <span class="n">w.val.swap</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">w.prop</span><span class="o">]))</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">⟩,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">⟨⟨</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">⟩,</span> <span class="n">hy</span><span class="o">⟩</span> <span class="n">hxy</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">,</span> <span class="o">(</span><span class="n">mk_eq_mk_iff_mul_eq_mul</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">quotient.eq'.mpr</span> <span class="n">hxy</span><span class="o">)]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">antip.involutive</span> <span class="o">:</span> <span class="n">function.involutive</span> <span class="n">antip</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">z</span> <span class="n">using</span> <span class="n">projectivization.ind</span> <span class="k">with</span> <span class="n">z</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">antip</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">antip.continuous</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">antip</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">continuous_quotient_lift_on'</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_quotient_mk.comp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_subtype_mk</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">continuous_swap.comp</span> <span class="n">continuous_subtype_val</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">antipode</span> <span class="o">:</span> <span class="n">homeomorph</span> <span class="n">CP1</span> <span class="n">CP1</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">antip</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">antip</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">antip.involutive</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">antip.involutive</span><span class="o">,</span>
  <span class="n">continuous_to_fun</span> <span class="o">:=</span> <span class="n">antip.continuous</span><span class="o">,</span>
  <span class="n">continuous_inv_fun</span> <span class="o">:=</span> <span class="n">antip.continuous</span>
<span class="o">}</span>

<span class="kd">lemma</span> <span class="n">antip_infty</span> <span class="o">:</span> <span class="n">antip</span> <span class="o">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="o">]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">antip</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">lh2</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">CP1</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="n">antipode.to_local_homeomorph.trans</span> <span class="n">lh1</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">charted_space</span> <span class="n">ℂ</span> <span class="n">CP1</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">atlas</span> <span class="o">:=</span> <span class="o">{</span><span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">},</span>
  <span class="n">chart_at</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">by_cases</span> <span class="n">z</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">],</span> <span class="n">exact</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">exact</span> <span class="n">lh1</span> <span class="o">},</span>
  <span class="n">mem_chart_source</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span>
    <span class="kd">by</span> <span class="o">{</span> <span class="n">by_cases</span> <span class="n">z</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">antipode</span><span class="o">,</span> <span class="n">antip</span><span class="o">,</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">chart_mem_atlas</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">by_cases</span> <span class="n">z</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">lemma</span> <span class="n">invC1</span> <span class="o">:</span> <span class="n">cont_diff_on</span> <span class="n">ℂ</span> <span class="bp">⊤</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="o">({</span><span class="mi">0</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">cont_diff_on_inv</span> <span class="n">ℂ</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">dom1</span> <span class="o">:</span> <span class="n">lh1.target</span> <span class="bp">∩</span> <span class="n">lh1.symm</span> <span class="bp">⁻¹'</span> <span class="n">lh2.source</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">antipode</span><span class="o">,</span> <span class="n">antip</span><span class="o">,</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">dom2</span> <span class="o">:</span> <span class="n">lh2.target</span> <span class="bp">∩</span> <span class="n">lh2.symm</span> <span class="bp">⁻¹'</span> <span class="n">lh1.source</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">antipode</span><span class="o">,</span> <span class="n">antip</span><span class="o">,</span> <span class="n">mk_eq_mk_iff_mul_eq_mul</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">smooth_manifold_with_corners</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="n">CP1</span> <span class="o">:=</span>
<span class="n">smooth_manifold_with_corners_of_cont_diff_on</span> <span class="bp">𝓘</span><span class="o">(</span><span class="n">ℂ</span><span class="o">)</span> <span class="n">CP1</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">e</span> <span class="n">e'</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">he</span><span class="o">)</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">he'</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">cont_diff_on_id.congr</span><span class="o">,</span> <span class="n">lh1</span><span class="o">,</span> <span class="n">rec1</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">he'</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">invC1.congr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">antipode</span><span class="o">,</span> <span class="n">antip</span><span class="o">,</span> <span class="n">rec1</span><span class="o">])</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">he</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">invC1.congr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">antipode</span><span class="o">,</span> <span class="n">antip</span><span class="o">,</span> <span class="n">rec1</span><span class="o">])</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">he</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">cont_diff_on_id.congr</span><span class="o">,</span> <span class="n">lh1</span><span class="o">,</span> <span class="n">lh2</span><span class="o">,</span> <span class="n">he</span><span class="o">,</span> <span class="n">he'</span><span class="o">,</span> <span class="n">rec1</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">projectivization</span>
</code></pre></div>



<a name="281612527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/281612527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#281612527">(May 08 2022 at 18:43)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> I totally agree that this is not the correct way to do it, more of a learning exercise...</p>



<a name="282459980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/282459980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#282459980">(May 16 2022 at 07:47)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> sorry for pinging you, do you have comments on my PR <a href="https://github.com/leanprover-community/mathlib/pull/14059">#14059</a> that adds some API to <code>projective/basic.lean</code>? I am mostly wondering about two things:</p>
<ul>
<li>the choice of <code>k \times k</code> as opposed to <code>fin 2 \to k</code> as the underlying space: <code>fin n</code> would be the natural generalization here, OTOH there is a lot of special-casing for projective lines and using <code>k \times k</code> for that case felt more natural;</li>
<li>then the addition of normalizing <code>simp</code> lemmas into the <code>projectivization.mk</code> form: this in my experience made things smoother to use, especially since some lemmas made some <code>quotient.mk</code> and <code>quotient.mk'</code> terms appear, but unfortunately it broke two of your proofs that relied on <code>by simp [mk]</code> so I thought I should let you know.</li>
</ul>
<p>What do you think?</p>



<a name="282468648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/282468648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#282468648">(May 16 2022 at 09:12)</a>:</h4>
<p>Ideally we would have a smooth API to work with vector spaces with a given basis (of size <code>2</code>, or <code>3</code>, or <code>n</code>).</p>



<a name="282518930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/282518930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#282518930">(May 16 2022 at 16:15)</a>:</h4>
<p>I do think it would be better to come up with a more uniform way to do this for an arbitrary (finite dimensional) vector space.</p>



<a name="282519112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/282519112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#282519112">(May 16 2022 at 16:16)</a>:</h4>
<p>Concerning <code>projectivization.mk</code>, that seems fine to me, but my one (small) concern is that it might require duplicating more of the <code>quotient</code> api.</p>



<a name="282522560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Working%20on%20the%20projective%20line/near/282522560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Working.20on.20the.20projective.20line.html#282522560">(May 16 2022 at 16:40)</a>:</h4>
<p>BTW your <code>mk_eq_mk_iff_mul_eq_mul</code> can be generalized as follows (the following proof is very golfable)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.projective_space.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">projectivization</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="kd">lemma</span> <span class="n">foobar</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mk</span> <span class="n">K</span> <span class="n">x</span> <span class="n">hx</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">K</span> <span class="n">y</span> <span class="n">hy</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">x</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">y</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mk_eq_mk_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">erw</span> <span class="o">[</span><span class="n">pi.smul_apply</span><span class="o">,</span> <span class="n">pi.smul_apply</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">y</span> <span class="n">i</span><span class="o">)]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">y</span> <span class="n">j</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hy</span><span class="o">,</span> <span class="n">ext</span> <span class="n">j</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hy</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span><span class="n">hj</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hj'</span> <span class="o">:</span> <span class="n">x</span> <span class="n">j</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">c</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hx</span><span class="o">,</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span> <span class="n">specialize</span> <span class="n">h</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
      <span class="n">dsimp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">c</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">apply_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="n">j</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">field_simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">assumption</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">mk_eq_mk_iff</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">((</span><span class="n">units.mk0</span> <span class="o">(</span><span class="n">x</span> <span class="n">j</span><span class="o">)</span> <span class="n">hj'</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">units.mk0</span> <span class="o">(</span><span class="n">y</span> <span class="n">j</span><span class="o">)</span> <span class="n">hj</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">),</span>
    <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">erw</span> <span class="o">[</span><span class="n">pi.smul_apply</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">],</span>
    <span class="n">push_cast</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">smul_eq_mul</span><span class="o">],</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">field_simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">y</span> <span class="n">i</span><span class="o">),</span> <span class="n">apply</span> <span class="n">h</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
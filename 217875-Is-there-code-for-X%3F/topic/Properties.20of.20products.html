---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html">Properties of products</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="296224614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296224614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296224614">(Aug 30 2022 at 21:31)</a>:</h4>
<p>Is a version of the following in mathlib?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.big_operators</span>
<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">lemma</span> <span class="n">prod_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">P</span> <span class="n">l.prod</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">prod_nil</span><span class="o">,</span> <span class="n">h₁</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">prod_cons</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">h₃</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">h₂</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_cons_self</span> <span class="n">_</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h₂</span> <span class="n">a</span> <span class="bp">$</span> <span class="n">mem_cons_of_mem</span> <span class="n">_</span> <span class="n">ha</span><span class="o">)),</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/list.prod_hom_rel">docs#list.prod_hom_rel</a>, which looks somewhat related, but is different...</p>



<a name="296226559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296226559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296226559">(Aug 30 2022 at 21:48)</a>:</h4>
<p>I think it's easy enough to construct a submonoid from the hypotheses and apply <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.list_prod_mem">docs#submonoid.list_prod_mem</a> .</p>



<a name="296226881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296226881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296226881">(Aug 30 2022 at 21:50)</a>:</h4>
<p>Thanks. I'll look at this tomorrow.</p>



<a name="296246976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296246976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296246976">(Aug 31 2022 at 02:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">lemma</span> <span class="n">prod_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">P</span> <span class="n">l.prod</span> <span class="o">:=</span>
<span class="n">foldl_rec_on</span> <span class="n">l</span> <span class="n">_</span> <span class="n">_</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h₃</span> <span class="n">_</span> <span class="n">_</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">(</span><span class="n">h₂</span> <span class="n">_</span> <span class="n">hy</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">list</span>
</code></pre></div>



<a name="296258667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296258667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296258667">(Aug 31 2022 at 05:35)</a>:</h4>
<p>Nice proof! I weakened the assumptions to [has_one] [has_mul] and filled in the ‹_›.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod_prop</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">P</span> <span class="n">l.prod</span> <span class="o">:=</span>
<span class="n">foldl_rec_on</span> <span class="n">l</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₁</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">h</span> <span class="n">_</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h₃</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="o">(</span><span class="n">h₂</span> <span class="n">_</span> <span class="n">hy</span><span class="o">)</span>
</code></pre></div>
<p>Although it's just a trivial application of <a href="https://leanprover-community.github.io/mathlib_docs/find/list.foldl_rec_on">docs#list.foldl_rec_on</a>, I think it would be nice to have a specialization of it to <a href="http://list.prod">list.prod</a> in mathlib. A direct specialization would be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod_prop'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">P</span> <span class="n">l.prod</span> <span class="o">:=</span> <span class="n">foldl_rec_on</span> <span class="n">l</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₁</span> <span class="n">h₂</span>
</code></pre></div>
<p>Which one should we prefer?</p>



<a name="296260422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296260422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296260422">(Aug 31 2022 at 05:57)</a>:</h4>
<p>Although <code>prod_prop</code> would be nice to have, for the purpose of the Jacobi symbol PR (which I think is the application <span class="user-mention" data-user-id="479359">@Michael Stoll</span> has in mind) the following is probably the easiest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">jacobi_sym_trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="n">submonoid.list_prod_mem</span>
  <span class="o">⟨({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℤ</span><span class="o">),</span>
   <span class="kd">by</span> <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">))</span><span class="bp">;</span> <span class="n">dec_trivial</span><span class="o">,</span>
   <span class="n">or.inr</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">)⟩</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">ha'</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">list.mem_pmap.mp</span> <span class="n">ha'</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">p.prime</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">prime_of_mem_factors</span> <span class="n">hp</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">quadratic_char_is_quadratic</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>and I also think it's a good idea to extract the submonoid to a separate definition.</p>



<a name="296359024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296359024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296359024">(Aug 31 2022 at 15:32)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span>  Nice. I'm defining <code>int.sign_monoid</code> as the submonoid in question and use that in your proof.</p>



<a name="296374309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296374309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296374309">(Aug 31 2022 at 15:58)</a>:</h4>
<p>Actually, do people think we should generalize <code>sign_monoid</code> to <code>non_assoc_ring</code>? (I think <code>dec_trivial</code> won't work then.) And should the name be <code>sign_submonoid</code>?</p>



<a name="296381531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296381531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296381531">(Aug 31 2022 at 16:08)</a>:</h4>
<p><code>sign_submonoid</code> is better, I think. In which file should this go eventually?</p>



<a name="296381873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296381873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296381873">(Aug 31 2022 at 16:10)</a>:</h4>
<p>Is this meant to be units + zero, or <code>{-1, 0, 1}</code>?</p>



<a name="296382045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296382045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296382045">(Aug 31 2022 at 16:11)</a>:</h4>
<p>The latter.</p>



<a name="296382416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296382416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296382416">(Aug 31 2022 at 16:13)</a>:</h4>
<p>I assume you cannot use <a href="https://leanprover-community.github.io/mathlib_docs/find/sign_type">docs#sign_type</a> because you want a submonoid?</p>



<a name="296387253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296387253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296387253">(Aug 31 2022 at 16:14)</a>:</h4>
<p>Yes, and you may want to compute with the values of the Jacobi symbol as integers (in particular, add them up or use them as coefficients of a linear combination).</p>



<a name="296402526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296402526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296402526">(Aug 31 2022 at 16:32)</a>:</h4>
<p>I think there's a possibility of defining <code>quadratic_char</code>, <code>legendre_sym</code>, and <code>jacobi_sym</code> all taking values in <code>sign_type</code>, and use <a href="https://leanprover-community.github.io/mathlib_docs/find/sign_type.cast_hom">docs#sign_type.cast_hom</a> when we want to work in Z; I think we've considered something like that before, but I forgot about the reasoning that led to the current design.</p>



<a name="296406369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296406369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296406369">(Aug 31 2022 at 16:52)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> i used the French quote syntax as a shorthand for the assumption tactic</p>



<a name="296406744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296406744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296406744">(Aug 31 2022 at 16:54)</a>:</h4>
<p>Yes I know but why not pure term-mode when it can be easily achieved :)</p>



<a name="296420412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296420412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296420412">(Aug 31 2022 at 18:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Properties.20of.20products/near/296402526">said</a>:</p>
<blockquote>
<p>I think there's a possibility of defining <code>quadratic_char</code>, <code>legendre_sym</code>, and <code>jacobi_sym</code> all taking values in <code>sign_type</code>, and use <a href="https://leanprover-community.github.io/mathlib_docs/find/sign_type.cast_hom">docs#sign_type.cast_hom</a> when we want to work in Z; I think we've considered something like that before, but I forgot about the reasoning that led to the current design.</p>
</blockquote>
<p>You want to be able to work with more general multiplicative characters (e.g., for cubic reciprocity <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>), not just ones that take values in {0, 1, -1}. I think it makes sense to have quadratic characters as a special case of multiplicative characters (and avoid the cast from <code>sign_type</code> to the integers whenever you want to do some nontrivial computation with the values).</p>



<a name="296430893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296430893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296430893">(Aug 31 2022 at 19:04)</a>:</h4>
<p>I think it would be nice to make definitions more polymorphic. For example, <a href="https://leanprover-community.github.io/mathlib_docs/find/add_char.primitive_add_char">docs#add_char.primitive_add_char</a> is defined with domain <code>cyclotomic_field n R'</code>, but it could be defined for any ring, and <a href="https://leanprover-community.github.io/mathlib_docs/find/add_char.primitive_zmod_char">docs#add_char.primitive_zmod_char</a> could be defined for any ring with a primitive n-th root of unity. <del>If you make them polymorphic like this, I think you won't need to map the values from the cyclotomic field to a larger field in some of your Gauss sum proofs.</del> (Edit: seems I got it backwards, you're mapping something smaller into the cyclotomic field, not the other way.)<br>
For quadratic characters, I think defining a <code>sign_type</code> version and using cast to get to any ring will make it the most polymorphic, but some work may be needed to make it pleasant to work with casts.<br>
Moreover, the cubic stuff doesn't take values in Z, so it seems to strengthen the point of being able to work with different domains.</p>



<a name="296433166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296433166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296433166">(Aug 31 2022 at 19:18)</a>:</h4>
<p>You can already do the following, if you like.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">number_theory.legendre_symbol.mul_character</span>
<span class="kn">import</span> <span class="n">data.sign</span>

<span class="kd">def</span> <span class="n">χ</span> <span class="o">:</span> <span class="n">mul_char</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">3</span><span class="o">)</span> <span class="n">sign_type</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">is_square</span> <span class="n">x</span><span class="o">)</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)),</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">map_nonunit'</span> <span class="o">:=</span> <span class="n">dec_trivial</span> <span class="o">}</span>
</code></pre></div>



<a name="296433303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296433303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296433303">(Aug 31 2022 at 19:19)</a>:</h4>
<p>But as soon as you want to do Gauss sums, say, you'll have to cast to a ring anyway (and ℤ is the universal ring, so it makes sense to have ℤ as the domain).</p>



<a name="296433791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296433791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296433791">(Aug 31 2022 at 19:23)</a>:</h4>
<p>The only possible advantage I see right now is that the proof of the trichotomy gets simpler. I'm not sure this is worth it.</p>



<a name="296434260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296434260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296434260">(Aug 31 2022 at 19:25)</a>:</h4>
<p>How would you prove <a href="https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_fun_eq_pow_of_char_ne_two">docs#quadratic_char_fun_eq_pow_of_char_ne_two</a> in a setting where the character takes values in <code>sign_type</code>?</p>



<a name="296434448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296434448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296434448">(Aug 31 2022 at 19:26)</a>:</h4>
<p>By using injectivity of <code>coe : sign_type → F</code>?</p>



<a name="296434778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296434778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296434778">(Aug 31 2022 at 19:28)</a>:</h4>
<p>Yes, but it will be more complicated. The point I'm trying to make is that there is a trade-off, and I am not convinced that the pros outweigh the cons.</p>



<a name="296434820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296434820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296434820">(Aug 31 2022 at 19:29)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_eq_pow_of_char_ne_two'">docs#quadratic_char_eq_pow_of_char_ne_two'</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_card_sqrts">docs#quadratic_char_card_sqrts</a></p>



<a name="296434913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296434913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296434913">(Aug 31 2022 at 19:29)</a>:</h4>
<p>You are about to define something isomorphic to <code>sign_type</code> for each ring. There are reasons to be worried!</p>



<a name="296435150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296435150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296435150">(Aug 31 2022 at 19:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_sum_zero">docs#quadratic_char_sum_zero</a></p>



<a name="296435181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296435181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296435181">(Aug 31 2022 at 19:31)</a>:</h4>
<p><code>sign_submonoid</code> is only defined for integers now, it's me who suggested non_assoc_ring.</p>



<a name="296435323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296435323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296435323">(Aug 31 2022 at 19:31)</a>:</h4>
<p>Michael, all lemmas you're linking to genuinely all seem fine with <code>sign_type</code> to me.</p>



<a name="296435351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296435351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296435351">(Aug 31 2022 at 19:32)</a>:</h4>
<p>Is there a way to define <code>sign_submonoid</code> as the image of the monoid(_with_zero) homomorphism from <code>sign_type</code>into any (non_assoc_)ring? (And use it as easily!)</p>



<a name="296435898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296435898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296435898">(Aug 31 2022 at 19:34)</a>:</h4>
<p>The last one uses <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_char.is_nontrivial.sum_eq_zero">docs#mul_char.is_nontrivial.sum_eq_zero</a>, for which your target needs to be a domain.</p>



<a name="296441680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296441680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296441680">(Aug 31 2022 at 20:11)</a>:</h4>
<p>In my example above, <code>#check χ 1 + 1</code> complains <code>failed to synthesize type class instance for ⊢ has_add sign_type</code>, so it looks like you have to cast to ℤ explicitly: <code>(χ 1 : ℤ) + 1</code> (<code>↑(χ 1) + 1</code> doesn't cut it; it wants to cast to ℕ).</p>



<a name="296441868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296441868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296441868">(Aug 31 2022 at 20:12)</a>:</h4>
<p>Is that a problem?</p>



<a name="296442079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296442079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296442079">(Aug 31 2022 at 20:14)</a>:</h4>
<p>It looks clumsy in the statements. I prefer the statements to look as similar as possible to the way you'd write the mathematics they represent.</p>



<a name="296442579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296442579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296442579">(Aug 31 2022 at 20:17)</a>:</h4>
<p>Coercions are on the least clumsy end of the spectrum of things formalisation can introducate in a statement.</p>



<a name="296442925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296442925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296442925">(Aug 31 2022 at 20:20)</a>:</h4>
<p>But why introduce them if they are not necessary?<br>
It is not clear to me what you are trying to optimize here. I don't think the mere fact that <code>sign_type</code> exists implies that it has to be used at all costs. As I said earlier, I think using it here would have more disadvantages than advantages.</p>



<a name="296443561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296443561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296443561">(Aug 31 2022 at 20:24)</a>:</h4>
<p>Here it gives you a unique interface for all rings, rather than several submonoids you will need to connect with explicit maps (which might mess you up because submonoids have a coercion to <code>Type</code>).</p>



<a name="296443672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296443672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296443672">(Aug 31 2022 at 20:25)</a>:</h4>
<p>Further, all the basic logic would shared between both types and that makes yet another pair of API that we have to keep in sync.</p>



<a name="296444018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296444018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296444018">(Aug 31 2022 at 20:27)</a>:</h4>
<p>I just need the submonoid of the integers (the universal ring). As <span class="user-mention" data-user-id="224323">@Junyan Xu</span> said, generalizing this was his idea.</p>



<a name="296519842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296519842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296519842">(Sep 01 2022 at 05:38)</a>:</h4>
<p>The submonoid is <code>(⊤ : submonoid sign_type).map sign_type.cast_hom</code>, right?</p>



<a name="296521437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296521437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296521437">(Sep 01 2022 at 06:00)</a>:</h4>
<p>Or even <code>monoid_hom.mrange sign_type.cast_hom</code></p>



<a name="296529832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296529832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296529832">(Sep 01 2022 at 07:19)</a>:</h4>
<p>In the concrete case, <code>monoid_hom.mrange $ @sign_type.cast_hom ℤ _ _</code> or so. But then the proof which uses it does not work anymore; I'll have to look into that.</p>



<a name="296546284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296546284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296546284">(Sep 01 2022 at 09:13)</a>:</h4>
<p>It looks like it's hard to get a reasonably simple proof of the result I want (<code>jacobi_sym_trichotomy</code>) with the <code>monoid_hom.mrange sign_type.cast_hom</code> approach.<br>
Since I need this submonoid <em>olny</em> for this one proof, I will just use it locally (as in <span class="user-mention" data-user-id="224323">@Junyan Xu</span>'s original suggestion).</p>



<a name="296619235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296619235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296619235">(Sep 01 2022 at 15:35)</a>:</h4>
<p>What does "doesn't work" mean here?</p>



<a name="296643351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296643351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296643351">(Sep 01 2022 at 15:52)</a>:</h4>
<p>The following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">sign_type</span>
<span class="kd">lemma</span> <span class="n">range_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sign_type</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set.range</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">{</span><span class="n">f</span> <span class="n">zero</span><span class="o">,</span> <span class="n">f</span> <span class="n">pos</span><span class="o">,</span> <span class="n">f</span> <span class="n">neg</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">s</span><span class="bp">|</span><span class="n">s</span><span class="bp">|</span><span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">exacts</span> <span class="o">[</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">or.inr</span> <span class="bp">$</span> <span class="n">or.inr</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">or.inr</span> <span class="bp">$</span> <span class="n">or.inl</span> <span class="n">rfl</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">))</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">set.mem_range_self</span> <span class="o">},</span>
<span class="kd">end</span>
<span class="kd">end</span> <span class="n">sign_type</span>

<span class="kd">lemma</span> <span class="n">jacobi_sym_trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="o">((</span><span class="bp">@</span><span class="n">sign_type.cast_hom</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">to_monoid_hom.mrange.copy</span> <span class="n">_</span>
  <span class="o">(</span><span class="n">sign_type.range_eq</span> <span class="n">sign_type.cast_hom</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span><span class="bp">.</span><span class="n">list_prod_mem</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">ha'</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">list.mem_pmap.mp</span> <span class="n">ha'</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">p.prime</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">prime_of_mem_factors</span> <span class="n">hp</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">quadratic_char_is_quadratic</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="296647310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296647310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296647310">(Sep 01 2022 at 16:00)</a>:</h4>
<p>Yes, but I think your original proof is simpler (no need to introduce <code>sign_type.range_eq</code>).</p>



<a name="296647426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296647426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296647426">(Sep 01 2022 at 16:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Properties.20of.20products/near/296619235">said</a>:</p>
<blockquote>
<p>What does "doesn't work" mean here?</p>
</blockquote>
<p>"Doesn't work" means that one needs the additional step provided by <span class="user-mention" data-user-id="224323">@Junyan Xu</span>'s code above.</p>



<a name="296649158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296649158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296649158">(Sep 01 2022 at 16:10)</a>:</h4>
<p>The original seems simpler but is slower (about 2s, while the one that uses sign_type takes ~0.25s), and <code>sign_type.range_eq</code> could be used elsewhere (it also takes about 0.25s). By the way should lemmas like <code>range_eq</code> be auto-generated? Though the auto-generated lemma would have {zero, neg, pos} instead of what we want ({zero, pos, neg}).</p>



<a name="296650110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296650110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296650110">(Sep 01 2022 at 16:15)</a>:</h4>
<p>Yeah I feel like we should generate this change statement as a lemma automagically as part of derive fintype, then a proof could be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.sign</span>
<span class="kn">namespace</span> <span class="n">sign_type</span>
<span class="kd">lemma</span> <span class="n">range_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sign_type</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set.range</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">{</span><span class="n">f</span> <span class="n">zero</span><span class="o">,</span> <span class="n">f</span> <span class="n">neg</span><span class="o">,</span> <span class="n">f</span> <span class="n">pos</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">fintype.coe_image_univ</span><span class="o">,</span>
  <span class="n">change</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">sign_type</span><span class="o">)</span> <span class="k">with</span> <span class="o">{</span><span class="n">zero</span><span class="o">,</span> <span class="n">neg</span><span class="o">,</span> <span class="n">pos</span><span class="o">},</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="296663113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296663113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296663113">(Sep 01 2022 at 17:24)</a>:</h4>
<p>This should work for any fintype:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">range_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sign_type</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set.range</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">{</span><span class="n">f</span> <span class="n">zero</span><span class="o">,</span> <span class="n">f</span> <span class="n">neg</span><span class="o">,</span> <span class="n">f</span> <span class="n">pos</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.coe_singleton</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.image_singleton</span><span class="o">,</span>
    <span class="bp">←</span> <span class="n">fintype.coe_image_univ</span><span class="o">,</span> <span class="n">finset.coe_image</span><span class="o">,</span> <span class="bp">←</span> <span class="n">set.image_insert_eq</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="296664272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296664272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296664272">(Sep 01 2022 at 17:30)</a>:</h4>
<p>So what should I do now?<br>
Add <code>sign_type.range_eq</code> (with <code>[fintype α]</code> added?) to <code>data.sign</code> and change the order in the definition of <code>mul_char.is_quadratic</code> (and everything that uses it) to <code>0, -1, 1</code>, so that it is compatible with the order given in <code>range_eq</code>?</p>



<a name="296665428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296665428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296665428">(Sep 01 2022 at 17:36)</a>:</h4>
<p>(I would like to get on with getting the Jacobi symbol into mathlib without getting lost in too many rabbit holes...)</p>



<a name="296686248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296686248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296686248">(Sep 01 2022 at 19:30)</a>:</h4>
<p>To me the order {0,1,-1} is more natural than {0,-1,1}, so if any definition is to be changed it should be <code>sign_type</code>. However you don't have to change any definition; you could just do a rewrite:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">jacobi_sym_trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="o">[</span><span class="n">a</span> <span class="bp">|</span> <span class="n">b</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="o">((</span><span class="bp">@</span><span class="n">sign_type.cast_hom</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">to_monoid_hom.mrange.copy</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="bp">$</span>
  <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">set.pair_comm</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">sign_type.range_eq</span> <span class="n">sign_type.cast_hom</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">})</span><span class="bp">.</span><span class="n">list_prod_mem</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">ha'</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">list.mem_pmap.mp</span> <span class="n">ha'</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">p.prime</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">prime_of_mem_factors</span> <span class="n">hp</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">quadratic_char_is_quadratic</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="296690847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296690847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296690847">(Sep 01 2022 at 20:00)</a>:</h4>
<p>OK; then I'll do that (and add <code>eq_range</code>).</p>



<a name="296868242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296868242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296868242">(Sep 02 2022 at 17:49)</a>:</h4>
<p>Just to check; is <a href="https://leanprover-community.github.io/mathlib_docs/find/jacobi_sym">docs#jacobi_sym</a> in master? I don't see the definition upthread</p>



<a name="296868635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Properties%20of%20products/near/296868635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Properties.20of.20products.html#296868635">(Sep 02 2022 at 17:51)</a>:</h4>
<p>It's not in master; it was in PR <a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a> but now removed from it, to be added in a later PR. (<a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a> now is preliminary lemmas only.) Discussions are in <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol">this thread</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html">ring tactics for characteristic p?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235262411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262411">(Apr 19 2021 at 22:59)</a>:</h4>
<p>Is ring tactics make use of the fact that the ring has characteristic p?</p>



<a name="235262551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262551">(Apr 19 2021 at 23:00)</a>:</h4>
<p>no</p>



<a name="235262599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262599">(Apr 19 2021 at 23:01)</a>:</h4>
<p>For example if given the fact that a ring has characteristic p, then the tactic will rewrite all "-" to "+" and rewrite the integer appeared in the expression to [0,p-1]</p>



<a name="235262713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262713">(Apr 19 2021 at 23:01)</a>:</h4>
<p>I don't even know if we have any examples of characteristic p fields in mathlib where p is not a variable</p>



<a name="235262765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262765">(Apr 19 2021 at 23:02)</a>:</h4>
<p>Oh ok. How can I implement such tactics? Any suggestions?</p>



<a name="235262789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262789">(Apr 19 2021 at 23:02)</a>:</h4>
<p>If p is a variable then that will do more harm than good</p>



<a name="235262804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262804">(Apr 19 2021 at 23:02)</a>:</h4>
<p>Ok I mean p is a constant, not a variable</p>



<a name="235262822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262822">(Apr 19 2021 at 23:02)</a>:</h4>
<p>right. who does that?</p>



<a name="235262920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235262920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235262920">(Apr 19 2021 at 23:03)</a>:</h4>
<p>plus the typeclass problem could be tricky - it has to discover this char p fact somehow</p>



<a name="235263014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263014">(Apr 19 2021 at 23:04)</a>:</h4>
<p>Ask the user to provide that information explicitly</p>



<a name="235263031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263031">(Apr 19 2021 at 23:04)</a>:</h4>
<p>Do you have an example?</p>



<a name="235263072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263072">(Apr 19 2021 at 23:04)</a>:</h4>
<p>That is used a lot, for example, some basic properties of Weierstrass equations in char 2 or 3 case</p>



<a name="235263125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263125">(Apr 19 2021 at 23:05)</a>:</h4>
<p>What I would suggest is something similar to our faux-grobner basis proof method: use <code>ring</code> to prove that your polynomial is equal to a multiple of 2 or 3, then rewrite with <code>2 = 0</code></p>



<a name="235263327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263327">(Apr 19 2021 at 23:06)</a>:</h4>
<p>In fact this might even just be a special case of grobner basis</p>



<a name="235263374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263374">(Apr 19 2021 at 23:07)</a>:</h4>
<p>Currently I just use ring tactics and manually identify which integers I need to rewrite to make both sides equal, then I write a simple lemma to produce such identities</p>



<a name="235263397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263397">(Apr 19 2021 at 23:07)</a>:</h4>
<p>Do you have an example?</p>



<a name="235263467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263467">(Apr 19 2021 at 23:08)</a>:</h4>
<p>Please wait a moment; let me extract a piece of code</p>



<a name="235263470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235263470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235263470">(Apr 19 2021 at 23:08)</a>:</h4>
<p>It should be possible to do this in ~2 lines without a lemma</p>



<a name="235265010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235265010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235265010">(Apr 19 2021 at 23:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.field</span>
<span class="kn">import</span> <span class="n">algebra.char_zero</span>
<span class="kn">import</span> <span class="n">algebra.char_p</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable theory</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">weierstrass_equation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">a1</span> <span class="n">a2</span> <span class="n">a3</span> <span class="n">a4</span> <span class="n">a6</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">weierstrass_equation.b2</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="o">:=</span>
<span class="n">E.a1</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">4</span><span class="bp">*</span><span class="n">E.a2</span>

<span class="kd">def</span> <span class="n">weierstrass_equation.b4</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="o">:=</span>
<span class="mi">2</span><span class="bp">*</span><span class="n">E.a4</span> <span class="bp">+</span> <span class="n">E.a1</span><span class="bp">*</span><span class="n">E.a3</span>

<span class="kd">def</span> <span class="n">weierstrass_equation.b6</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="o">:=</span>
<span class="n">E.a3</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">4</span><span class="bp">*</span><span class="n">E.a6</span>

<span class="kd">def</span> <span class="n">weierstrass_equation.b8</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="o">:=</span>
<span class="n">E.a1</span><span class="bp">^</span><span class="mi">2</span><span class="bp">*</span><span class="n">E.a6</span> <span class="bp">+</span> <span class="mi">4</span><span class="bp">*</span><span class="n">E.a2</span><span class="bp">*</span><span class="n">E.a6</span> <span class="bp">-</span> <span class="n">E.a1</span><span class="bp">*</span><span class="n">E.a3</span><span class="bp">*</span><span class="n">E.a4</span> <span class="bp">+</span> <span class="n">E.a2</span><span class="bp">*</span><span class="n">E.a3</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">E.a4</span><span class="bp">^</span><span class="mi">2</span>

<span class="kd">def</span> <span class="n">weierstrass_equation.disc</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="o">:=</span>
<span class="bp">-</span><span class="n">E.b2</span><span class="bp">^</span><span class="mi">2</span><span class="bp">*</span><span class="n">E.b8</span> <span class="bp">-</span> <span class="mi">8</span><span class="bp">*</span><span class="n">E.b4</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">27</span><span class="bp">*</span><span class="n">E.b6</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">9</span><span class="bp">*</span><span class="n">E.b2</span><span class="bp">*</span><span class="n">E.b4</span><span class="bp">*</span><span class="n">E.b6</span>

<span class="kd">def</span> <span class="n">weierstrass_equation.is_model_of_char_2_j_non_zero</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">E.a1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">E.a3</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">E.a4</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">dvd_char_is_zero</span>
<span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">@</span><span class="n">char_p.int_cast_eq_zero_iff</span> <span class="n">K</span> <span class="n">_</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hdvd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- unused in this example but you got the point</span>
<span class="kd">lemma</span> <span class="n">cong_char_is_eq</span>
<span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">@</span><span class="n">char_p.int_coe_eq_int_coe_iff</span> <span class="n">K</span> <span class="n">_</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">int.modeq.modeq_iff_dvd</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hdvd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">weierstrass_equation.disc_of_model_of_char_2_j_non_zero</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">E.is_model_of_char_2_j_non_zero</span><span class="o">)</span> <span class="o">(</span><span class="n">hchar2</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">K</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E.disc</span> <span class="bp">=</span> <span class="n">E.a6</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">weierstrass_equation.disc</span>
  <span class="n">weierstrass_equation.b2</span>
  <span class="n">weierstrass_equation.b4</span>
  <span class="n">weierstrass_equation.b6</span>
  <span class="n">weierstrass_equation.b8</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h.1</span><span class="o">,</span> <span class="n">h.2.1</span><span class="o">,</span> <span class="n">h.2.2</span><span class="o">],</span>
  <span class="c1">-- here I imagine a tactic 'ring_char_p hchar2' should do all the tricks</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">zero_pow</span><span class="o">],</span> <span class="n">ring</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">dvd_char_is_zero</span> <span class="n">hchar2</span> <span class="mi">432</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">dvd_char_is_zero</span> <span class="n">hchar2</span> <span class="mi">64</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">dvd_char_is_zero</span> <span class="n">hchar2</span> <span class="mi">48</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">dvd_char_is_zero</span> <span class="n">hchar2</span> <span class="mi">12</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>
  <span class="k">calc</span> <span class="bp">-</span><span class="n">E.a6</span> <span class="bp">=</span> <span class="n">E.a6</span> <span class="bp">-</span> <span class="mi">2</span><span class="bp">*</span><span class="n">E.a6</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">ring</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">E.a6</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">dvd_char_is_zero</span> <span class="n">hchar2</span> <span class="mi">2</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="235265097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235265097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235265097">(Apr 19 2021 at 23:25)</a>:</h4>
<p>In this example I need to manually find out all integer constants 432,64,48,12 and rewrites all of them to zero. I imagine there could be an automatic way to do this.</p>



<a name="235266590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266590">(Apr 19 2021 at 23:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">weierstrass_equation.disc_of_model_of_char_2_j_non_zero</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">weierstrass_equation</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">E.is_model_of_char_2_j_non_zero</span><span class="o">)</span> <span class="o">(</span><span class="n">hchar2</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">K</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
<span class="n">E.disc</span> <span class="bp">=</span> <span class="n">E.a6</span> <span class="o">:=</span>
<span class="n">sub_eq_zero.1</span> <span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ring_char.spec</span> <span class="n">K</span> <span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="n">hchar2</span><span class="o">),</span> <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">transitivity</span> <span class="mi">2</span> <span class="bp">*</span> <span class="bp">-</span><span class="o">(</span><span class="n">E.a6</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">6</span> <span class="bp">*</span> <span class="n">E.a2</span> <span class="bp">+</span> <span class="mi">24</span> <span class="bp">*</span> <span class="n">E.a2</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">32</span> <span class="bp">*</span> <span class="n">E.a2</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">+</span> <span class="mi">216</span> <span class="bp">*</span> <span class="n">E.a6</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">weierstrass_equation.disc</span><span class="o">,</span> <span class="n">weierstrass_equation.b2</span><span class="o">,</span> <span class="n">weierstrass_equation.b4</span><span class="o">,</span>
      <span class="n">weierstrass_equation.b6</span><span class="o">,</span> <span class="n">weierstrass_equation.b8</span><span class="o">,</span> <span class="n">h.1</span><span class="o">,</span> <span class="n">h.2.1</span><span class="o">,</span> <span class="n">h.2.2</span><span class="o">],</span> <span class="n">ring</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="235266628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266628">(Apr 19 2021 at 23:43)</a>:</h4>
<p><del>I didn't prove 2=0 but I'm sure you have theorems for that</del></p>



<a name="235266652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266652">(Apr 19 2021 at 23:44)</a>:</h4>
<p>Do we have a typeclass for <code>ring_char K = 2</code>? If so, could we add a special case for that that says <code>bit0 x = 0</code> and <code>bit1 x = 1</code>?</p>



<a name="235266709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266709">(Apr 19 2021 at 23:44)</a>:</h4>
<p>Which would knock out all the integer literals very quickly</p>



<a name="235266718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266718">(Apr 19 2021 at 23:44)</a>:</h4>
<p>yeah it's <code>char_p K 2</code></p>



<a name="235266739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266739">(Apr 19 2021 at 23:44)</a>:</h4>
<p>This wouldn't work for 3 though</p>



<a name="235266886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266886">(Apr 19 2021 at 23:46)</a>:</h4>
<p>Do you think those lemmas would be a bad idea then?</p>



<a name="235266913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266913">(Apr 19 2021 at 23:46)</a>:</h4>
<p>Because of the trick I just showed above, I don't find the need for a new decision procedure particularly pressing. <code>norm_fin</code> does a lot of similar reasoning but that's on <code>fin n</code>, not a ring of finite characteristic</p>



<a name="235266958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235266958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235266958">(Apr 19 2021 at 23:46)</a>:</h4>
<p>Reducing the constants is only one possible thing you can do here, and it's not particularly helpful to solving the goal</p>



<a name="235267029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235267029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235267029">(Apr 19 2021 at 23:47)</a>:</h4>
<p>what you actually want is to factor the polynomial into sums of multiples of things that you know are zero, which is what a grobner basis tactic would do</p>



<a name="235267366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235267366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235267366">(Apr 19 2021 at 23:51)</a>:</h4>
<p>See <a href="#narrow/stream/116395-maths/topic/groebner.20basis.20algorithm">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/groebner.20basis.20algorithm</a></p>



<a name="235269074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235269074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235269074">(Apr 20 2021 at 00:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/ring.20tactics.20for.20characteristic.20p.3F/near/235266886">said</a>:</p>
<blockquote>
<p>Do you think those lemmas would be a bad idea then?</p>
</blockquote>
<p>It would fire on every subterm of every numeral, triggering a typeclass search that almost always fails. Sounds like a bad idea</p>



<a name="235269108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235269108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235269108">(Apr 20 2021 at 00:11)</a>:</h4>
<p>maybe as an opt in simp lemma</p>



<a name="235292511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235292511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235292511">(Apr 20 2021 at 06:13)</a>:</h4>
<p>I think they are great lemmas, but they shouldn't be in the default simp-set.</p>



<a name="235292618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235292618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235292618">(Apr 20 2021 at 06:14)</a>:</h4>
<p>Special case calculations for <code>p = 2</code> show up often enough that I think a bit of extra support for them doesn't hurt.</p>



<a name="235293125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293125">(Apr 20 2021 at 06:20)</a>:</h4>
<p>For the <code>ring_char K = 3</code>, could you use <code>bit0 x = - x</code> and <code>bit1 x = 1 - x</code>?</p>
<p>Or would the <code>bit1</code> lemma be undoing the good that <code>bit1</code> does?</p>



<a name="235293329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293329">(Apr 20 2021 at 06:23)</a>:</h4>
<p>Hah, I guess that would help! Together with <code>neg_neg</code> which will cancel all the negations.</p>



<a name="235293368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293368">(Apr 20 2021 at 06:23)</a>:</h4>
<p>Ok, I just got myself confused with signs and <code>bit1</code>: is what I wrote correct for <code>bit1</code>?  [<code>bit1 x = 1 - x</code>]</p>



<a name="235293479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293479">(Apr 20 2021 at 06:24)</a>:</h4>
<p>This is like "divisibility by 11" in decimals: the alternating sign of the digits-mod-two is the remainder of division by 3.</p>



<a name="235293496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293496">(Apr 20 2021 at 06:24)</a>:</h4>
<p><code>bit1 x = 2x + 1 = -x + 1</code></p>



<a name="235293533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293533">(Apr 20 2021 at 06:25)</a>:</h4>
<p>Ok, so I did get it right!  Thanks, Johan!</p>



<a name="235293602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235293602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235293602">(Apr 20 2021 at 06:26)</a>:</h4>
<p>I would say that, by far, the most computations modulo a specific prime happen <code>mod 2</code> or <code>mod 3</code>.  Other primes are very often just "generic".</p>



<a name="235330274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235330274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235330274">(Apr 20 2021 at 11:56)</a>:</h4>
<p>Sorry, but I think I don't quite understand your discussions. (Why are they only applicable for char 2 or 3 case? And why are there bit0, bit1, etc. Why do you need a Grobener basis algorithm?)</p>
<p>What tactics I think, in its basic form, only reduces all integer literals appears in the expression. I assume it's easy to implement? Just traverse the whole expression, find all integer literals <code>m</code>, check that if it's in a ring whose characteristic is also an integer literal <code>n</code>, then replace <code>m</code> by <code>m%n</code>. Also it replaces all <code>A - m * B</code> by <code>A + ((-m)%n) * B</code>.</p>
<p>Example: if R is a ring, say of characteristic 10 (characteristic of a ring is not necessarily a prime number), x is a variable in R. Then after providing all necessary information to the tactics, it should transform <code>34 * x^2 - 193 * x + 1720</code> into <code>4 * x^2 + 7 * x</code>.</p>



<a name="235330945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235330945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235330945">(Apr 20 2021 at 12:01)</a>:</h4>
<p>A more advanced implementation also checks whether an integer literal <code>m</code> is a zero divisor, or is invertible, in a ring R whose characteristic is an integer literal <code>n</code>. Example: if R is a ring of characteristic 10, then it should transform <code>7*x=0</code> into <code>x=0</code> since 7 is invertible in R, transform <code>7*x\neq 0</code> into <code>x\neq 0</code>, etc.</p>



<a name="235334480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235334480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235334480">(Apr 20 2021 at 12:28)</a>:</h4>
<p><span class="user-mention" data-user-id="366779">@Jz Pan</span> If you have the number <code>5</code> in Lean, how does Lean handle it? the way it works is that there is a binary system under the hood.<br>
So <code>5 = 2 * (2 * 1) + 1</code>. Now <code>bit0 x = x + x</code> and <code>bit1 x = x + x + 1</code>. So <code>5 = bit1 (bit0 1)</code>.</p>



<a name="235334578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235334578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235334578">(Apr 20 2021 at 12:29)</a>:</h4>
<p>In a specific characteristics, like <code>2</code> or <code>3</code>, we can have special simplification rules, that will turn <code>bit0 x</code> into <code>0</code> (when <code>p = 2</code>), etc...</p>



<a name="235335128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235335128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235335128">(Apr 20 2021 at 12:32)</a>:</h4>
<p>Namely, these rules:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.char_p.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">section</span> <span class="n">char_two</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">R</span> <span class="mi">2</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">char_two_bit0</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">bit0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">two_smul</span> <span class="n">ℕ</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span> <span class="n">char_p.cast_eq_zero</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">char_two_bit1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">bit1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">char_two_bit0</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">end</span> <span class="n">char_two</span>
</code></pre></div>



<a name="235335676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235335676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235335676">(Apr 20 2021 at 12:36)</a>:</h4>
<p>Right, and Damiano gave the rules for <code>p = 3</code>.</p>



<a name="235335714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235335714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235335714">(Apr 20 2021 at 12:36)</a>:</h4>
<p>But I agree with Mario that these lemmas should probably not be <code>@[simp]</code> globally.</p>



<a name="235335768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235335768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235335768">(Apr 20 2021 at 12:37)</a>:</h4>
<p>We can probably enable them with <code>open_locale char2</code></p>



<a name="235335946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235335946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235335946">(Apr 20 2021 at 12:38)</a>:</h4>
<p>The rules for <code>p = 3</code> aren't enough:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">char_three</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">char_p</span> <span class="n">R</span> <span class="mi">3</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">char_three_bit0</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">x</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">bit0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">two_smul</span> <span class="n">ℕ</span> <span class="n">x</span><span class="o">,</span> <span class="n">eq_neg_iff_add_eq_zero</span><span class="o">,</span>
    <span class="n">add_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">succ_nsmul</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span> <span class="n">char_p.cast_eq_zero</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">char_three_bit1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">bit1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">char_three_bit0</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">sub_eq_add_neg</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">34</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>  <span class="c1">-- fails</span>

<span class="kd">end</span> <span class="n">char_three</span>
</code></pre></div>



<a name="235335998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235335998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235335998">(Apr 20 2021 at 12:39)</a>:</h4>
<p>Seems like a job for a norm_num plugin</p>



<a name="235336014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235336014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235336014">(Apr 20 2021 at 12:39)</a>:</h4>
<p>A la norm_fin</p>



<a name="235338194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235338194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235338194">(Apr 20 2021 at 12:53)</a>:</h4>
<p>For <code>p=3</code> you just need more lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">char_three_bit1_zero</span> <span class="o">:</span> <span class="n">bit1</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">bit1</span><span class="o">]</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">char_three_bit1_one</span> <span class="o">:</span> <span class="n">bit1</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">bit1</span><span class="o">]</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">char_three_bit1_two</span> <span class="o">:</span> <span class="n">bit1</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">bit0</span><span class="o">,</span> <span class="n">bit1</span><span class="o">]</span>
</code></pre></div>



<a name="235342595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235342595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235342595">(Apr 20 2021 at 13:24)</a>:</h4>
<p>Just a funny remark.</p>
<p>If you add Gabriel's lemmas <em>after</em> Eric's <code>char_three_bit1</code>, they close the example.<br>
If you add Gabriel's lemmas <em>just before</em> Eric's <code>char_three_bit1</code>, they <em>do not</em> close the example.</p>



<a name="235395641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235395641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235395641">(Apr 20 2021 at 18:52)</a>:</h4>
<p>Thank you for your replies. I'll try these suggestions.</p>
<blockquote>
<p>Seems like a job for a norm_num plugin</p>
</blockquote>
<p>I think this describes my idea best.</p>



<a name="235405082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405082">(Apr 20 2021 at 19:55)</a>:</h4>
<p>My point is that reducing the numerals in a polynomial is not a particularly useful thing to do, unless you combine it with other things. In fact, factoring a polynomial sometimes requires writing the coefficients in an unnormalized way</p>



<a name="235405212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405212">(Apr 20 2021 at 19:56)</a>:</h4>
<p>If you just want the polynomial to look good in the tactic state, then okay, but if you actually want to close the goal (which is what <code>ring</code> is trying to do) then you need to do more</p>



<a name="235405252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405252">(Apr 20 2021 at 19:56)</a>:</h4>
<p>But if you are multiplying by <code>42</code> in a char 2 ring, then there are plenty situations where it helps if there is a cheap tactic that just cancels that term.</p>



<a name="235405331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405331">(Apr 20 2021 at 19:57)</a>:</h4>
<p>maybe, but it still sounds strictly less powerful than this grobner basis approach</p>



<a name="235405402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405402">(Apr 20 2021 at 19:58)</a>:</h4>
<p>which we currently have semi-automatic support for</p>



<a name="235405743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405743">(Apr 20 2021 at 20:00)</a>:</h4>
<p>In particular, I want to point out that in <span class="user-mention silent" data-user-id="366779">Jz Pan</span> 's first version they had to use this number cancelling tactic several times and still had to do some funky algebra afterward, while the factoring approach only requires one application: supply the magical witness coefficient <code>-(E.a6 * (1 + 6 * E.a2 + 24 * E.a2^2 + 32 * E.a2^3 + 216 * E.a6))</code> and then the problem is solved</p>



<a name="235405895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235405895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235405895">(Apr 20 2021 at 20:01)</a>:</h4>
<p>(By the way, I found that coefficient by asking mathematica)</p>



<a name="235406470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235406470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235406470">(Apr 20 2021 at 20:05)</a>:</h4>
<p>[Where is my emoji for cheating <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span> ] /s</p>



<a name="235406670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235406670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235406670">(Apr 20 2021 at 20:07)</a>:</h4>
<p>The role of a true grobner tactic in lean would be to determine that coefficient and then replace itself with <code>ring_rw</code> using the coefficient</p>



<a name="235406758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235406758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235406758">(Apr 20 2021 at 20:07)</a>:</h4>
<p>(<code>ring_rw</code> doesn't exist yet either)</p>



<a name="235596552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235596552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235596552">(Apr 21 2021 at 23:15)</a>:</h4>
<p>OK I have the first working example of char 2 tactics, adapting the codes by <span class="user-mention" data-user-id="310045">@Eric Wieser</span> .</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">char_two_bit0</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">bit0</span><span class="o">,</span>
  <span class="n">transitivity</span> <span class="o">(</span><span class="mi">2</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">bit0</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hchar</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">char_p.cast_eq_zero</span> <span class="n">R</span> <span class="n">_</span> <span class="mi">2</span> <span class="n">hchar</span><span class="o">,</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">char_two_bit1</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">bit1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">char_two_bit1</span> <span class="n">hchar</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">get_local</span> <span class="n">infer_type</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">interactive</span> <span class="o">(</span><span class="n">parse</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">lean.parser</span> <span class="o">(</span><span class="n">ident</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">interactive</span> <span class="o">(</span><span class="n">loc.ns</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">interactive.types</span> <span class="o">(</span><span class="n">texpr</span> <span class="n">location</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.simp_char2</span> <span class="o">(</span><span class="n">hchar_</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">hchar</span> <span class="bp">←</span> <span class="n">tactic.i_to_expr</span> <span class="n">hchar_</span><span class="o">,</span>
  <span class="bp">`</span><span class="o">(</span><span class="n">ring_char</span> <span class="n">_</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">hchar</span><span class="o">,</span>
  <span class="bp">`</span><span class="o">[</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">char_two_bit1</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">pow_zero</span><span class="o">,</span> <span class="n">pow_one</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">]</span> <span class="bp">&lt;|&gt;</span> <span class="n">ring_nf</span> <span class="o">}</span> <span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp_char2</span> <span class="n">hchar</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="235596756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235596756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235596756">(Apr 21 2021 at 23:17)</a>:</h4>
<p>may be good to make a simp-set for this! cf <a href="https://leanprover-community.github.io/extras/simp.html#more-advanced-features">here</a></p>



<a name="235597125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235597125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235597125">(Apr 21 2021 at 23:21)</a>:</h4>
<p>But there are some problems need to be fixed:</p>
<ol>
<li>the char assumption in the tactics is hard-coded as <code>hchar</code>. I tried <code>char_two_bit0 %%hchar, char_two_bit1 %%hchar</code> according to <a href="https://leanprover-community.github.io/extras/tactic_writing.html">this tutorial</a>, but Lean refused to accept my code, complains "kernel failed to type check declaration 'tactic.interactive.simp_char2' this is usually due to a buggy tactic or a bug in the builtin elaborator".</li>
<li>I want it shows a proper error message when <code>(ring_char _ = 2) ← infer_type hchar</code> fails.</li>
</ol>
<p>How to fix them?</p>



<a name="235602618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235602618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235602618">(Apr 22 2021 at 00:28)</a>:</h4>
<p>Unfortunately you can't use antiquotations inside <code>`[...]</code>. You'll need to build the simp set by hand. There are many examples; the last time I did this was <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#elementwise">tactic#elementwise</a>, so if it was me I'd start reconstructing how to do it from there. :-)</p>



<a name="235602655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235602655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235602655">(Apr 22 2021 at 00:29)</a>:</h4>
<p>For 2. just put <code>| fail ":-("</code> at the end of the line (before the comma)</p>



<a name="235602672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235602672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235602672">(Apr 22 2021 at 00:29)</a>:</h4>
<p>(or maybe <code>failed</code>? I can never remember which one is which)</p>



<a name="235623807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235623807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235623807">(Apr 22 2021 at 05:57)</a>:</h4>
<p>Don't forget <code>failure</code></p>



<a name="235763732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235763732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235763732">(Apr 22 2021 at 23:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/ring.20tactics.20for.20characteristic.20p.3F/near/235602618">said</a>:</p>
<blockquote>
<p>Unfortunately you can't use antiquotations inside <code>`[...]</code>. You'll need to build the simp set by hand. There are many examples; the last time I did this was <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#elementwise">tactic#elementwise</a>, so if it was me I'd start reconstructing how to do it from there. :-)</p>
</blockquote>
<p>Thanks for your comments. Now I try to build simp set manually, but I have a new problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.field</span>
<span class="kn">import</span> <span class="n">algebra.char_zero</span>
<span class="kn">import</span> <span class="n">algebra.char_p</span>
<span class="kn">import</span> <span class="n">tactic</span>

  <span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>

  <span class="kd">lemma</span> <span class="n">char_two_bit0</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">bit0</span><span class="o">,</span>
    <span class="n">transitivity</span> <span class="o">(</span><span class="mi">2</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">bit0</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hchar</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">char_p.cast_eq_zero</span> <span class="n">R</span> <span class="n">_</span> <span class="mi">2</span> <span class="n">hchar</span><span class="o">,</span>
    <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">char_two_bit1</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">bit1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="kd">example</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">char_two_bit1</span> <span class="n">hchar</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="kn">open</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">get_local</span> <span class="n">infer_type</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">interactive</span> <span class="o">(</span><span class="n">parse</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">lean.parser</span> <span class="o">(</span><span class="n">ident</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">interactive</span> <span class="o">(</span><span class="n">loc.ns</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">interactive.types</span> <span class="o">(</span><span class="n">texpr</span> <span class="n">location</span><span class="o">)</span>

  <span class="sd">/--</span>
<span class="sd">  Experimental ring tactic for characteristic 2.</span>
<span class="sd">  FIXME: You must provide a `hchar2 : ring_char R = 2` hypothesis.</span>
<span class="sd">  -/</span>
  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.ring_char2</span> <span class="o">(</span><span class="n">loc</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="k">do</span>
    <span class="n">hchar</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">hchar2</span><span class="o">,</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">ring_char</span> <span class="n">_</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">hchar</span> <span class="bp">|</span> <span class="n">tactic.fail</span> <span class="s2">"hchar2 : ring_char R = 2 is expected"</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">simp_lemmas.mk</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add</span> <span class="n">hchar</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">char_two_bit0</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">char_two_bit1</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">pow_zero</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">pow_one</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">zero_mul</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">mul_zero</span><span class="o">,</span>
    <span class="n">ns</span> <span class="bp">←</span> <span class="n">loc.get_locals</span><span class="o">,</span>
    <span class="n">tactic.simp_target</span> <span class="n">s</span><span class="o">,</span>
    <span class="n">tactic.skip</span>
    <span class="c">/-</span><span class="cm"></span>
<span class="cm">    -- tactic.repeat (do</span>
<span class="cm">      ret1 ← tactic.replace_at (</span>
<span class="cm">        λ e, do (a1, a2, a3) ← tactic.simplify s [] e, return (a1, a2)</span>
<span class="cm">      ) ns loc.include_goal,</span>
<span class="cm">      ret2 ← tactic.replace_at (</span>
<span class="cm">        tactic.ring.normalize tactic.transparency.reducible</span>
<span class="cm">      ) ns loc.include_goal,</span>
<span class="cm">      tactic.skip</span>
<span class="cm">    --  if ret1 || ret2 then tactic.skip else tactic.failed</span>
<span class="cm">    -- )</span>
<span class="cm">    -/</span>

  <span class="kd">example</span> <span class="o">(</span><span class="n">hchar2</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">ring_char2</span><span class="o">,</span>
    <span class="c1">-- error here</span>
  <span class="kd">end</span>
</code></pre></div>
<p>It doesn't work and complains that "deep recursion was detected at 'level constraints' (potential solution: increase stack space in your system)". What's the problem?</p>



<a name="235764290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235764290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235764290">(Apr 22 2021 at 23:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="235765367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235765367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235765367">(Apr 22 2021 at 23:42)</a>:</h4>
<p>Sorry, I have added all necessary codes now.</p>



<a name="235765543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235765543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235765543">(Apr 22 2021 at 23:44)</a>:</h4>
<p>I think I have found the problem, but note sure how to fix it: in fact if I replace the first example by <code>simp [hchar, char_two_bit0, char_two_bit1]</code> it will also fall into a deadloop.</p>



<a name="235765927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/235765927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#235765927">(Apr 22 2021 at 23:49)</a>:</h4>
<p>OK I fixed it by myself; replace these 3 lines</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add</span> <span class="n">hchar</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">char_two_bit0</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">char_two_bit1</span><span class="o">,</span>
</code></pre></div>
<p>by</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">char_two_bit0</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_two_bit0</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">),</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add</span> <span class="n">char_two_bit0</span><span class="o">,</span>
    <span class="n">char_two_bit1</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_two_bit1</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">),</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add</span> <span class="n">char_two_bit1</span><span class="o">,</span>
</code></pre></div>
<p>then it works.</p>



<a name="236386205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/ring%20tactics%20for%20characteristic%20p%3F/near/236386205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jz Pan <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/ring.20tactics.20for.20characteristic.20p.3F.html#236386205">(Apr 27 2021 at 18:28)</a>:</h4>
<p>OK, now I'd like to share the <code>ring_charp</code> tactics I write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">algebra.char_zero</span>
<span class="kn">import</span> <span class="n">algebra.char_p</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">dvd_char_is_zero_N</span>
<span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hdvd</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">@</span><span class="n">char_p.cast_eq_zero_iff</span> <span class="n">R</span> <span class="n">_</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hdvd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">cong_char_is_eq_N'</span>
<span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hleq</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hpzero</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="n">hpzero</span> <span class="n">at</span> <span class="n">hdvd</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">sub_eq_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">hdvd</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hdvd</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">replace</span> <span class="n">hpzero</span> <span class="o">:=</span> <span class="n">pos_iff_ne_zero.mpr</span> <span class="n">hpzero</span><span class="o">,</span>
  <span class="n">zify</span> <span class="n">at</span> <span class="n">hpzero</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hdvd</span> <span class="k">with</span> <span class="n">c</span> <span class="n">hdvd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">zify</span> <span class="n">at</span> <span class="n">hleq</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hleq</span> <span class="o">:</span> <span class="o">((</span><span class="n">b</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hdvd</span> <span class="n">at</span> <span class="n">hleq</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hpzero</span><span class="o">]</span> <span class="n">at</span> <span class="n">hleq</span><span class="o">,</span>
  <span class="n">lift</span> <span class="n">c</span> <span class="n">to</span> <span class="n">ℕ</span> <span class="n">using</span> <span class="n">hleq</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hdvd</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">hdvd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hdvd</span><span class="o">,</span>
  <span class="n">push_cast</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[(</span><span class="bp">@</span><span class="n">char_p.cast_eq_zero_iff</span> <span class="n">R</span> <span class="n">_</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">dvd_refl</span> <span class="n">p</span><span class="o">)],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">cong_char_is_eq_N</span>
<span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span>
    <span class="n">exact</span> <span class="n">cong_char_is_eq_N'</span> <span class="n">hp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span> <span class="n">hdvd</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">∣</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">hdvd</span> <span class="k">with</span> <span class="n">c</span> <span class="n">hdvd</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">-</span><span class="n">c</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hdvd</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hdvd</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">hdvd</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">cong_char_is_eq_N'</span> <span class="n">hp</span> <span class="n">b</span> <span class="n">a</span> <span class="n">h</span> <span class="n">hdvd</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kn">section</span> <span class="n">char_specific</span>

  <span class="kd">lemma</span> <span class="n">char_two_bit0</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">bit0</span><span class="o">,</span>
    <span class="n">transitivity</span> <span class="o">(</span><span class="mi">2</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">bit0</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">ring_char.eq_iff</span> <span class="n">at</span> <span class="n">hchar</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">char_p.cast_eq_zero</span> <span class="n">R</span> <span class="n">_</span> <span class="mi">2</span> <span class="n">hchar</span><span class="o">,</span>
    <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">char_two_bit1</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">bit1</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">bit1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">char_two_bit0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">char_two_bit1</span> <span class="n">hchar</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="kn">open</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">get_local</span> <span class="n">infer_type</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">interactive</span> <span class="o">(</span><span class="n">parse</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">lean.parser</span> <span class="o">(</span><span class="n">ident</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">interactive</span> <span class="o">(</span><span class="n">loc.ns</span><span class="o">)</span>
  <span class="kn">open</span> <span class="n">interactive.types</span> <span class="o">(</span><span class="n">texpr</span> <span class="n">location</span><span class="o">)</span>

  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">repeat_at_most</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">tactic.skip</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span> <span class="n">t</span><span class="o">,</span> <span class="n">repeat_at_most</span> <span class="n">n</span> <span class="n">t</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.skip</span>

  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">ring_char_tactic_internal</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">simp_lemmas</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">loc</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="k">do</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">pow_zero</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">pow_one</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">zero_mul</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">s.add_simp</span> <span class="bp">``</span><span class="n">mul_zero</span><span class="o">,</span>
    <span class="n">ns</span> <span class="bp">←</span> <span class="n">loc.get_locals</span><span class="o">,</span>
    <span class="c1">-- FIXME: add a maximal repeat time since sometimes simp will change the goal randomly</span>
    <span class="n">repeat_at_most</span> <span class="mi">4</span> <span class="o">(</span><span class="k">do</span>
      <span class="n">ret1</span> <span class="bp">←</span> <span class="n">tactic.replace_at</span> <span class="o">(</span>
        <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="k">do</span> <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="bp">←</span> <span class="n">tactic.simplify</span> <span class="n">s</span> <span class="n">u</span> <span class="n">e</span><span class="o">,</span> <span class="n">return</span> <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
      <span class="o">)</span> <span class="n">ns</span> <span class="n">loc.include_goal</span><span class="o">,</span>
      <span class="n">ret2</span> <span class="bp">←</span> <span class="n">tactic.replace_at</span> <span class="o">(</span>
        <span class="n">tactic.ring.normalize</span> <span class="n">tactic.transparency.reducible</span>
      <span class="o">)</span> <span class="n">ns</span> <span class="n">loc.include_goal</span><span class="o">,</span>
      <span class="k">if</span> <span class="n">ret1</span> <span class="bp">||</span> <span class="n">ret2</span> <span class="k">then</span> <span class="n">tactic.skip</span> <span class="k">else</span> <span class="n">tactic.failed</span>
    <span class="o">),</span>
    <span class="n">when</span> <span class="n">loc.include_goal</span> <span class="bp">$</span> <span class="n">tactic.try</span> <span class="o">(</span><span class="n">tactic.triv</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.reflexivity</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.contradiction</span><span class="o">)</span>

  <span class="sd">/--</span>
<span class="sd">  Experimental ring tactic for characteristic 2.</span>
<span class="sd">  FIXME: You must provide a `hchar2 : ring_char R = 2` hypothesis.</span>
<span class="sd">  -/</span>
  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.ring_char2</span> <span class="o">(</span><span class="n">loc</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="k">do</span>
    <span class="n">hchar</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">hchar2</span><span class="o">,</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">ring_char</span> <span class="n">_</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">hchar</span> <span class="bp">|</span> <span class="n">tactic.fail</span> <span class="s2">"hchar2 : ring_char R = 2 is expected"</span><span class="o">,</span>
    <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span> <span class="bp">←</span> <span class="n">tactic.mk_simp_set</span> <span class="n">ff</span> <span class="o">[]</span> <span class="o">[],</span> <span class="c1">-- FIXME: this includes all default simp lemmas into it</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_two_bit0</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">s.add</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_two_bit1</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">s.add</span><span class="o">,</span>
    <span class="n">ring_char_tactic_internal</span> <span class="n">s</span> <span class="n">u</span> <span class="n">loc</span>

  <span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar2</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">ring_char2</span><span class="o">,</span>
  <span class="kd">end</span>

  <span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar2</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">35</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">37</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">39</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">ring_char2</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">char_three_3_eq_0</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">3</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">exact_mod_cast</span> <span class="n">dvd_char_is_zero_N</span> <span class="n">hchar</span> <span class="mi">3</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">char_three_4_eq_1</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">exact_mod_cast</span> <span class="n">cong_char_is_eq_N</span> <span class="n">hchar</span> <span class="mi">4</span> <span class="mi">1</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">char_three_5_eq_2</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">5</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">exact_mod_cast</span> <span class="n">cong_char_is_eq_N</span> <span class="n">hchar</span> <span class="mi">5</span> <span class="mi">2</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">),</span>
  <span class="kd">end</span>

  <span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">34</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">char_three_3_eq_0</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">char_three_4_eq_1</span> <span class="n">hchar</span><span class="o">,</span> <span class="n">char_three_5_eq_2</span> <span class="n">hchar</span><span class="o">],</span>
  <span class="kd">end</span>

  <span class="sd">/--</span>
<span class="sd">  Experimental ring tactic for characteristic 3.</span>
<span class="sd">  FIXME: You must provide a `hchar3 : ring_char R = 3` hypothesis.</span>
<span class="sd">  -/</span>
  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.ring_char3</span> <span class="o">(</span><span class="n">loc</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="k">do</span>
    <span class="n">hchar</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">hchar3</span><span class="o">,</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">ring_char</span> <span class="n">_</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">hchar</span> <span class="bp">|</span> <span class="n">tactic.fail</span> <span class="s2">"hchar3 : ring_char R = 3 is expected"</span><span class="o">,</span>
    <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span> <span class="bp">←</span> <span class="n">tactic.mk_simp_set</span> <span class="n">ff</span> <span class="o">[]</span> <span class="o">[],</span> <span class="c1">-- FIXME: this includes all default simp lemmas into it</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_three_3_eq_0</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">s.add</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_three_4_eq_1</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">s.add</span><span class="o">,</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_three_5_eq_2</span> <span class="bp">%%</span><span class="n">hchar</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">s.add</span><span class="o">,</span>
    <span class="n">ring_char_tactic_internal</span> <span class="n">s</span> <span class="n">u</span> <span class="n">loc</span>

  <span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar3</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">34</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">ring_char3</span><span class="o">,</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">char_p_a_plus_p_eq_a</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span><span class="bp">+</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">exact_mod_cast</span> <span class="o">(</span><span class="n">cong_char_is_eq_N</span> <span class="n">hchar</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="kd">end</span>

  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">repeat_n_times</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">T</span><span class="o">)</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">T</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="n">func</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span> <span class="n">return</span> <span class="n">t</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">func</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span> <span class="n">func</span> <span class="n">n</span> <span class="n">t</span> <span class="bp">&gt;&gt;=</span> <span class="n">repeat_n_times</span> <span class="n">n</span> <span class="n">func</span><span class="o">)</span>

  <span class="sd">/--</span>
<span class="sd">  Experimental ring tactic for characteristic p for p an integer literal.</span>
<span class="sd">  FIXME: You must provide a `hchar : ring_char R = p` hypothesis.</span>
<span class="sd">  -/</span>
  <span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.ring_charp</span> <span class="o">(</span><span class="n">loc</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="k">do</span>
    <span class="n">hchar</span> <span class="bp">←</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">hchar</span><span class="o">,</span>
    <span class="bp">`</span><span class="o">(</span><span class="n">ring_char</span> <span class="n">_</span> <span class="bp">=</span> <span class="bp">%%</span><span class="n">pp</span><span class="o">)</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">hchar</span> <span class="bp">|</span> <span class="n">tactic.fail</span> <span class="s2">"hchar : ring_char R = p is expected"</span><span class="o">,</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">pp.to_nat</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.fail</span> <span class="s2">"p must be an integer literal"</span><span class="o">,</span>
    <span class="n">step</span> <span class="bp">←</span> <span class="n">norm_num.get_step</span><span class="o">,</span>
    <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span> <span class="bp">←</span> <span class="n">tactic.mk_simp_set</span> <span class="n">ff</span> <span class="o">[]</span> <span class="o">[],</span> <span class="c1">-- FIXME: this includes all default simp lemmas into it</span>
    <span class="n">s</span> <span class="bp">←</span> <span class="n">repeat_n_times</span> <span class="n">p</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">(</span><span class="n">ss</span> <span class="o">:</span> <span class="n">simp_lemmas</span><span class="o">),</span> <span class="k">do</span>
      <span class="n">char_p_a_plus_p_eq_a</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">char_p_a_plus_p_eq_a</span> <span class="bp">%%</span><span class="n">hchar</span> <span class="bp">%%</span><span class="n">n</span><span class="o">),</span>
      <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">char_p_a_plus_p_eq_a</span> <span class="bp">&gt;&gt;=</span> <span class="n">norm_num.derive'</span> <span class="n">step</span><span class="o">,</span>
      <span class="n">ss</span> <span class="bp">←</span> <span class="n">tactic.mk_eq_mp</span> <span class="n">a2</span> <span class="n">char_p_a_plus_p_eq_a</span> <span class="bp">&gt;&gt;=</span> <span class="n">ss.add</span><span class="o">,</span>
      <span class="n">return</span> <span class="n">ss</span>
    <span class="o">)</span> <span class="n">s</span><span class="o">,</span>
    <span class="n">ring_char_tactic_internal</span> <span class="n">s</span> <span class="n">u</span> <span class="n">loc</span>

  <span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hchar</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="mi">123567</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">51832</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">ring_charp</span><span class="o">,</span>
  <span class="kd">end</span>

<span class="kd">end</span> <span class="n">char_specific</span>
</code></pre></div>
<p>and they magically works, for example, <a href="https://gitee.com/acmepjz/my-lean-test/blob/master/gtm106/weierstrass_equation/models_by_characteristic.lean">here</a><br>
An obvious problem is that <code>ring_charp</code> runs slow if the characteristic is large lol</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
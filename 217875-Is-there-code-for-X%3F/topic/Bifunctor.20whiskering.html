---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html">Bifunctor whiskering</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="289835706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289835706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289835706">(Jul 16 2022 at 16:26)</a>:</h4>
<p>Do we have this bifunctor version of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.whiskering_right">docs#category_theory.whiskering_right</a>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">δ</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">⥤</span> <span class="n">γ</span> <span class="bp">⥤</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>This could probably even be functorial in <code>F</code>, though I don't think I need that for the application I have in mind.</p>



<a name="289836408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289836408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289836408">(Jul 16 2022 at 16:44)</a>:</h4>
<p>If we have the equivalence <code>(α ⥤ β × γ) ≅ ((α ⥤ β) × (α ⥤ γ))</code> then this should follow from uncurrying, applying <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.whiskering_right">docs#category_theory.whiskering_right</a>, applying this equivalence and then currying back.</p>



<a name="289836699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289836699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289836699">(Jul 16 2022 at 16:50)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.prod'">docs#category_theory.functor.prod'</a> , but I don't think we know that it is functorial / is an equivalence.</p>



<a name="289836780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289836780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289836780">(Jul 16 2022 at 16:52)</a>:</h4>
<p>We do have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.nat_trans.prod">docs#category_theory.nat_trans.prod</a> though.</p>



<a name="289846557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289846557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289846557">(Jul 16 2022 at 20:36)</a>:</h4>
<p>I tried doing the equivalence <code>(α ⥤ β × γ) ≅ ((α ⥤ β) × (α ⥤ γ))</code> but I'm stuck at giving <code>unit_iso</code>. Here is my code if someone wants to give it a shot.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.products.basic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u₁</span> <span class="n">u₂</span> <span class="n">u₃</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="n">v₃</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">A</span><span class="o">]</span>
          <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">B</span><span class="o">]</span>
          <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₃</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₃</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">functor_prod_functor_equiv</span> <span class="o">:</span> <span class="o">((</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">C</span><span class="o">))</span> <span class="bp">≌</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">B</span> <span class="bp">×</span> <span class="n">C</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">functor</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span><span class="o">,</span> <span class="n">F.1.prod'</span> <span class="n">F.2</span><span class="o">,</span>
    <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span> <span class="n">G</span> <span class="n">f</span><span class="o">,</span> <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">f.1.app</span> <span class="n">X</span><span class="o">,</span> <span class="n">f.2.app</span> <span class="n">X</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">inverse</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span><span class="o">,</span> <span class="o">⟨</span><span class="n">F</span> <span class="bp">⋙</span> <span class="o">(</span><span class="n">category_theory.prod.fst</span> <span class="n">B</span> <span class="n">C</span><span class="o">),</span> <span class="n">F</span> <span class="bp">⋙</span> <span class="o">(</span><span class="n">category_theory.prod.snd</span> <span class="n">B</span> <span class="n">C</span><span class="o">)⟩,</span>
    <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span> <span class="n">G</span> <span class="n">α</span><span class="o">,</span>
    <span class="o">⟨{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">α.app</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
       <span class="n">naturality'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">functor.comp_map</span><span class="o">,</span> <span class="n">prod.fst_map</span><span class="o">,</span> <span class="bp">←</span><span class="n">prod_comp_fst</span><span class="o">,</span> <span class="n">α.naturality</span><span class="o">]</span> <span class="o">},</span>
     <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">α.app</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
       <span class="n">naturality'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">functor.comp_map</span><span class="o">,</span> <span class="n">prod.snd_map</span><span class="o">,</span> <span class="bp">←</span><span class="n">prod_comp_snd</span><span class="o">,</span> <span class="n">α.naturality</span><span class="o">]</span> <span class="o">}⟩</span> <span class="o">},</span>
  <span class="n">unit_iso</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">counit_iso</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="289846635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289846635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289846635">(Jul 16 2022 at 20:39)</a>:</h4>
<p>I tried doing <code>convert iso.refl (𝟭 ((A ⥤ B) × (A ⥤ C)))</code> for the <code>unit_iso</code> field and then proving equality of functors through <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ext">docs#category_theory.functor.ext</a>,  but I think that's probably a bad approach since the documentation for <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ext">docs#category_theory.functor.ext</a> explicitly says that this isn't something that you usually want to use.</p>



<a name="289847715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289847715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289847715">(Jul 16 2022 at 21:06)</a>:</h4>
<p>I would use <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.nat_iso.of_components">docs#category_theory.nat_iso.of_components</a></p>



<a name="289847788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289847788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289847788">(Jul 16 2022 at 21:08)</a>:</h4>
<p>You (almost) never want to use equality of functors.</p>



<a name="289849863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289849863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289849863">(Jul 16 2022 at 22:06)</a>:</h4>
<p>Is equality of natural transformations OK? Where are these arcane rules written down?</p>



<a name="289849950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289849950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289849950">(Jul 16 2022 at 22:09)</a>:</h4>
<p>Yes those are okay! Because a natural transformation is just a family of morphisms satisfying some prop, and since it's okay to talk about equality of (a family of) morphisms, it's then okay to talk about equality of natural transformations.</p>



<a name="289849963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289849963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289849963">(Jul 16 2022 at 22:09)</a>:</h4>
<p>If a functor didn't have some data related to objects then there would be no issue with equality of functors.</p>



<a name="289850028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289850028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289850028">(Jul 16 2022 at 22:11)</a>:</h4>
<p>I think the general story is that in an n-category you should only talk about equality of n-cells</p>



<a name="289850039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289850039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289850039">(Jul 16 2022 at 22:11)</a>:</h4>
<p>So all bets are off in an infinity category</p>



<a name="289855447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289855447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289855447">(Jul 17 2022 at 00:42)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> How would construct the following equivalence without appealing to equality of functors?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.products.basic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u₁</span> <span class="n">u₂</span> <span class="n">u₃</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="n">v₃</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">A</span><span class="o">]</span>
          <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">B</span><span class="o">]</span>
          <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₃</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₃</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
          <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₄</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₄</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">))</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">F.1</span><span class="o">,</span> <span class="n">F.2</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="289855606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289855606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289855606">(Jul 17 2022 at 00:47)</a>:</h4>
<p>Oh nevermind I can just do <code>{ hom := (𝟙 F.1, 𝟙 F.2), inv := (𝟙 F.1, 𝟙 F.2) }</code></p>



<a name="289855728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289855728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289855728">(Jul 17 2022 at 00:51)</a>:</h4>
<p>Actually I think the following should be added in <code>category_theory.products.basic</code>. What's a good name for it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">X.1</span><span class="o">,</span> <span class="n">X.2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">_</span><span class="o">),</span> <span class="n">inv</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="289857938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289857938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289857938">(Jul 17 2022 at 01:55)</a>:</h4>
<p>I managed to complete this equivalence. <a href="https://github.com/leanprover-community/mathlib/pull/15445">#15445</a></p>



<a name="289860357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289860357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289860357">(Jul 17 2022 at 02:56)</a>:</h4>
<p>(x×y)^z is isomorphic to x^z×y^z in any <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.cartesian_closed">docs#category_theory.cartesian_closed</a> category according to <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category#Equational_theory">Wikipedia</a>; maybe we should do it in this generality? And it would give an isomorphism (involving functor equality), not just an equivalence. However I can't find this fact in category_theory.closed.cartesian, and mathlib doesn't know <code>Cat</code> is an example apparently.</p>



<a name="289872801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289872801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289872801">(Jul 17 2022 at 08:41)</a>:</h4>
<p>Here are two versions of <code>functor_prod_functor_equiv</code> inspired by the adjunction between <code>×</code> and <code>⟶</code> in general cartesian closed categories; one version uses <code>eq_to_iso</code> and another one is closer to <a href="https://github.com/leanprover-community/mathlib/pull/15445">#15445</a>. I'm not sure which one is faster and whether <code>eq_to_iso</code> will cause problems downstream.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.functor.currying</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u₁</span> <span class="n">u₂</span> <span class="n">u₃</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="n">v₃</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">A</span><span class="o">]</span>
          <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">B</span><span class="o">]</span>
          <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₃</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₃</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">prod_functor_to_functor_prod</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="bp">⥤</span> <span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span> <span class="o">:=</span>
<span class="n">curry_obj</span> <span class="bp">$</span> <span class="n">functor.prod'</span>
  <span class="o">(</span><span class="n">uncurry.obj</span> <span class="bp">$</span> <span class="n">category_theory.prod.fst</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
  <span class="o">(</span><span class="n">uncurry.obj</span> <span class="bp">$</span> <span class="n">category_theory.prod.snd</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">functor_prod_to_prod_functor</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">functor.prod'</span>
  <span class="o">(</span><span class="n">curry_obj</span> <span class="bp">$</span> <span class="n">uncurry.obj</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">category_theory.prod.fst</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
  <span class="o">(</span><span class="n">curry_obj</span> <span class="bp">$</span> <span class="n">uncurry.obj</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">category_theory.prod.snd</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">eq_to_hom_fst</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">prod.fst</span> <span class="o">(</span><span class="n">eq_to_hom</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">eq_to_hom</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">prod.fst</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">eq_to_hom_map</span> <span class="o">(</span><span class="n">category_theory.prod.fst</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="n">h</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">eq_to_hom_snd</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">prod.snd</span> <span class="o">(</span><span class="n">eq_to_hom</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">eq_to_hom</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">prod.snd</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">eq_to_hom_map</span> <span class="o">(</span><span class="n">category_theory.prod.snd</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">hom_inv_id'</span> <span class="o">:</span> <span class="n">prod_functor_to_functor_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">⋙</span> <span class="n">functor_prod_to_prod_functor</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">=</span> <span class="mi">𝟭</span> <span class="n">_</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">prod_functor_to_functor_prod</span><span class="o">,</span> <span class="n">functor_prod_to_prod_functor</span><span class="o">,</span> <span class="n">curry_obj</span><span class="o">,</span> <span class="n">uncurry</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">category_theory.functor.ext</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩⟩,</span> <span class="n">simp</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">inv_hom_id'</span> <span class="o">:</span> <span class="n">functor_prod_to_prod_functor</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">⋙</span> <span class="n">prod_functor_to_functor_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">=</span> <span class="mi">𝟭</span> <span class="n">_</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">prod_functor_to_functor_prod</span><span class="o">,</span> <span class="n">functor_prod_to_prod_functor</span><span class="o">,</span> <span class="n">curry_obj</span><span class="o">,</span> <span class="n">uncurry</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">category_theory.functor.ext</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">dsimp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">functor_prod_functor_equiv</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="bp">≌</span> <span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">functor</span> <span class="o">:=</span> <span class="n">prod_functor_to_functor_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">inverse</span> <span class="o">:=</span> <span class="n">functor_prod_to_prod_functor</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">unit_iso</span> <span class="o">:=</span> <span class="n">eq_to_iso</span> <span class="o">(</span><span class="n">hom_inv_id'</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">counit_iso</span> <span class="o">:=</span> <span class="n">eq_to_iso</span> <span class="o">(</span><span class="n">inv_hom_id'</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">prod.eta_iso</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">X.1</span><span class="o">,</span> <span class="n">X.2</span><span class="o">)</span> <span class="bp">≅</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">_</span><span class="o">),</span> <span class="n">inv</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">unit_iso</span> <span class="o">:</span>
  <span class="mi">𝟭</span> <span class="n">_</span> <span class="bp">≅</span> <span class="n">prod_functor_to_functor_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">⋙</span> <span class="n">functor_prod_to_prod_functor</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:=</span>
<span class="n">nat_iso.of_components</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">F</span><span class="o">,</span> <span class="o">(</span><span class="n">prod.eta_iso</span> <span class="n">_</span> <span class="n">_</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">≪≫</span> <span class="n">iso.prod</span>
  <span class="o">(</span><span class="n">nat_iso.of_components</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">iso.refl</span> <span class="n">_</span><span class="o">)</span> <span class="bp">$</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">curry_obj</span><span class="o">],</span> <span class="n">simp</span> <span class="o">})</span>
  <span class="o">(</span><span class="n">nat_iso.of_components</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">iso.refl</span> <span class="n">_</span><span class="o">)</span> <span class="bp">$</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">curry_obj</span><span class="o">],</span> <span class="n">simp</span> <span class="o">}))</span>
  <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">curry_obj</span><span class="o">],</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">})</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">counit_iso</span> <span class="o">:</span>
  <span class="n">functor_prod_to_prod_functor</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">⋙</span> <span class="n">prod_functor_to_functor_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">≅</span> <span class="mi">𝟭</span> <span class="n">_</span> <span class="o">:=</span>
<span class="n">nat_iso.of_components</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">F</span><span class="o">,</span> <span class="n">nat_iso.of_components</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">prod.eta_iso</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="bp">$</span>
    <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">curry_obj</span><span class="o">],</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">})</span>
  <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">curry_obj</span><span class="o">],</span> <span class="n">tidy</span> <span class="o">})</span>

<span class="kd">def</span> <span class="n">functor_prod_functor_equiv'</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="bp">≌</span> <span class="n">A</span> <span class="bp">⥤</span> <span class="n">B</span> <span class="bp">×</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">functor</span> <span class="o">:=</span> <span class="n">prod_functor_to_functor_prod</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">inverse</span> <span class="o">:=</span> <span class="n">functor_prod_to_prod_functor</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">unit_iso</span> <span class="o">:=</span> <span class="n">unit_iso</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">counit_iso</span> <span class="o">:=</span> <span class="n">counit_iso</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span>
  <span class="n">functor_unit_iso_comp'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intro</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">curry_obj</span><span class="o">],</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="289874780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289874780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289874780">(Jul 17 2022 at 09:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Bifunctor.20whiskering/near/289855728">said</a>:</p>
<blockquote>
<p>Actually I think the following should be added in <code>category_theory.products.basic</code>. What's a good name for it?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≅</span> <span class="o">(</span><span class="n">X.1</span><span class="o">,</span> <span class="n">X.2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">_</span><span class="o">),</span> <span class="n">inv</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>The corresponding non-category statement is <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.mk.eta">docs#prod.mk.eta</a>.</p>



<a name="289902154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289902154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289902154">(Jul 17 2022 at 20:10)</a>:</h4>
<p>And the original desired construction can be achieved more directly as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.functor.currying</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">δ</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">⥤</span> <span class="n">γ</span> <span class="bp">⥤</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">curry_obj</span> <span class="bp">$</span> <span class="n">curry_obj</span> <span class="bp">$</span> <span class="n">functor.prod'</span>
  <span class="o">(</span><span class="n">uncurry.obj</span> <span class="bp">$</span> <span class="n">category_theory.prod.fst</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
  <span class="o">(</span><span class="n">uncurry.obj</span> <span class="bp">$</span> <span class="n">category_theory.prod.snd</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">uncurry.obj</span> <span class="n">F</span>
</code></pre></div>



<a name="289912755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/289912755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#289912755">(Jul 18 2022 at 00:45)</a>:</h4>
<p>Nice! It would be great to have the full functorial version though.</p>



<a name="290041392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Bifunctor%20whiskering/near/290041392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Bifunctor.20whiskering.html#290041392">(Jul 19 2022 at 00:47)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/15504">#15504</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
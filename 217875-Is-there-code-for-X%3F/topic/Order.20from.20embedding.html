---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html">Order from embedding</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227139398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227139398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227139398">(Feb 21 2021 at 03:58)</a>:</h4>
<p>I would like to show that the length of a certain list is less than or equal to a certain bound N*N, by showing that there's an injective function from its indices to (fin N × fin N). Unfortunately I haven't found anything useful for, well, any of the steps of that proof; from relating the length of a list to functions on its indices, to relating injective functions and order, to the cardinality of tuples... Is this just the wrong sort of approach?</p>



<a name="227139477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227139477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227139477">(Feb 21 2021 at 04:00)</a>:</h4>
<p>for transferring sizes along injective functions, <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card_le_of_injective">docs#fintype.card_le_of_injective</a> is a good lemma</p>



<a name="227139495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227139495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227139495">(Feb 21 2021 at 04:01)</a>:</h4>
<p>and <a href="https://leanprover-community.github.io/mathlib_docs/find/fintype.card_prod">docs#fintype.card_prod</a> tells you the cardinality of a product</p>



<a name="227140196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140196">(Feb 21 2021 at 04:16)</a>:</h4>
<p>It sounds like this might be more easily proven by inducting on the list itself.</p>



<a name="227140204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140204">(Feb 21 2021 at 04:16)</a>:</h4>
<p>Juggling indexing the list means having to construct the various hypotheses of being in bounds to use <code>list.nth_le</code>.</p>



<a name="227140209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140209">(Feb 21 2021 at 04:17)</a>:</h4>
<p>Do you have an example of your list defn?</p>



<a name="227140364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140364">(Feb 21 2021 at 04:20)</a>:</h4>
<p>I agree with Yakov. Rather than constructing an injective function out of a list, it is easier and more natural to map your list to a <code>list (fin N x fin N)</code> that you can prove is <code>nodup</code>; it's easy to get from this to the claim that the length of the list is at most N^2</p>



<a name="227140367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140367">(Feb 21 2021 at 04:21)</a>:</h4>
<p>and depending on the structure of the function, you might not even need <code>fin N x fin N</code></p>



<a name="227140718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140718">(Feb 21 2021 at 04:29)</a>:</h4>
<p>The idea of mapping + nodup makes sense. I'm still not sure how I can get from mapping to the product to the length of the list being bounded though.</p>
<p>My particular case is proving that unique lattice points drawn from those within N distance of the origin, according to the max norm, are less than <code>4*N*N</code>.</p>



<a name="227140890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140890">(Feb 21 2021 at 04:33)</a>:</h4>
<p>Btw I'm trying to stay away from <code>fintype</code> because I hit a weird bug where even just mentioning a <code>finset</code> in the type of a definition caused lean to hit a deterministic timeout apparently trying to find a normal form for the finset, even though (a) very little progress could actually be made reducing the finset, and (b) reducing the finset was not necessary to type-check the type <em>or</em> the definition... But I could never come up with a reduced failure case for this so I never posted it. It had to do with WF-induction, which is actually why I'm here now trying to get a natural number from of a list instead, to do induction on nat!</p>



<a name="227140962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227140962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227140962">(Feb 21 2021 at 04:35)</a>:</h4>
<blockquote>
<p>My particular case is proving that unique lattice points drawn from those within N distance of the origin, according to the max norm, are less than <code>4*N*N</code>.</p>
</blockquote>
<p>How more precisely is this stated?</p>



<a name="227141084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141084">(Feb 21 2021 at 04:38)</a>:</h4>
<p>It sounds like it might be easier to stay at the level of functions for this, don't bring in lists and instead prove that this set is a subset of <code>Ioo (-N) N x Ioo (-N) N</code></p>



<a name="227141106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141106">(Feb 21 2021 at 04:39)</a>:</h4>
<p>hopefully we have a theorem that says that <code>Ico a b</code> has cardinality <code>b - a</code></p>



<a name="227141207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141207">(Feb 21 2021 at 04:41)</a>:</h4>
<p>hm, this exact theorem isn't there but it shouldn't be hard to prove using <code>int.range</code></p>



<a name="227141213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141213">(Feb 21 2021 at 04:41)</a>:</h4>
<p>Uh, I mean, there's 1000 lines of definitions behind it because I'm actually talking about particular points, not all of them :)<br>
And actually I have a list such that some of its elements can be converted to unique points, and a theorem which says those points have to be within distance N of the origin.<br>
So it's like <code>(list.length $ list.filter my_filter my_list) ≤ 4 * N * N</code>.</p>



<a name="227141269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141269">(Feb 21 2021 at 04:42)</a>:</h4>
<p>Not sure if that's what you meant though. Also FWIW <code>4 * N * N</code> doesn't matter, I literally just need any bound at all for the length of this list.</p>



<a name="227141270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141270">(Feb 21 2021 at 04:42)</a>:</h4>
<p>I mean show the types of things</p>



<a name="227141279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141279">(Feb 21 2021 at 04:43)</a>:</h4>
<p>it doesn't matter if it's only partial, but a complete definition of the term is useful</p>



<a name="227141356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141356">(Feb 21 2021 at 04:44)</a>:</h4>
<p>specifically how is <code>my_list</code> defined</p>



<a name="227141521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141521">(Feb 21 2021 at 04:48)</a>:</h4>
<p>Pasting the whole 1000 lines is also an option (say, in a gist or on a branch) if you don't know how to make <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> of it</p>



<a name="227141522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141522">(Feb 21 2021 at 04:48)</a>:</h4>
<p><del>So I really don't think I can provide a short version of the definition -_-.</del> I have a quite complex type to work around lack of induction-recursion. So what I have is an argument <code>jups : path₂</code>, and <code>my_list</code> is actually <code>jups.updates</code>. <code>path₂</code> is defined like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">path₁</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">update</span>
<span class="kd">structure</span> <span class="n">path₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">updates</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">justified</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">upd</span> <span class="n">ups</span><span class="o">},</span> <span class="n">list.cons</span> <span class="n">upd</span> <span class="n">ups</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">updates</span> <span class="bp">→</span> <span class="n">justified</span> <span class="n">upd</span> <span class="n">ups</span><span class="o">)</span>
</code></pre></div>
<p>The points are actually defined by a partial function from tails of <code>updates</code> to <code>ℤ × ℤ</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">path₁.extension_point</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">point</span>
</code></pre></div>
<p><code>justified</code> is an inductive type giving what I need to show that these points are unique and within distance N of the origin, where <code>N</code> actually comes from a function on <code>path₂.updates</code>.</p>



<a name="227141605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141605">(Feb 21 2021 at 04:50)</a>:</h4>
<p>Just use <code>sorry</code> in all those functions you just described</p>



<a name="227141678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141678">(Feb 21 2021 at 04:52)</a>:</h4>
<blockquote>
<p>what I need to show that these points are unique</p>
</blockquote>
<p>What does this theorem look like?</p>



<a name="227141942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141942">(Feb 21 2021 at 04:59)</a>:</h4>
<p>I think this is more-or-less self contained? :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span>

<span class="kd">inductive</span> <span class="n">update</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>

<span class="kd">def</span> <span class="n">update.is_b</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">update.rec_on</span> <span class="n">upd</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">update.is_b.dec</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span>  <span class="o">:</span> <span class="n">decidable</span> <span class="n">upd.is_b</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path_point_at_time</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path_current_point</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">inductive</span> <span class="n">path₁.is_preleft</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">halfplane</span> <span class="o">:</span> <span class="n">pt.fst</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">path₁.is_preleft</span>
<span class="bp">|</span> <span class="n">extension</span> <span class="o">(</span><span class="n">ups'</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">ups'</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">ups</span> <span class="bp">→</span> <span class="n">path_current_point</span> <span class="n">ups'</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">pt</span> <span class="bp">→</span> <span class="n">path₁.is_preleft</span>

<span class="kd">instance</span> <span class="n">path₁.is_preleft.dec</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">ups.is_preleft</span> <span class="n">pt</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path₁.can_extend_free</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">¬</span><span class="n">ups.is_preleft</span> <span class="o">(</span><span class="n">path_point_at_time</span> <span class="n">ups</span> <span class="n">time</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">justified</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
  <span class="o">:=</span> <span class="n">update.rec_on</span> <span class="n">hd</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">time</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">time</span><span class="o">,</span> <span class="gr">sorry</span> <span class="bp">∧</span> <span class="n">tl.can_extend_free</span> <span class="n">time</span> <span class="bp">∧</span> <span class="gr">sorry</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">eaten</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">path₁.eaten_bound</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span>
  <span class="o">:=</span> <span class="n">option.iget</span> <span class="bp">$</span> <span class="n">list.maximum</span> <span class="bp">$</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">dist</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">$</span> <span class="n">path₁.eaten</span> <span class="n">ups</span>

<span class="kd">def</span> <span class="n">path₂.extend_bound</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path₂</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">(</span><span class="n">list.length</span> <span class="bp">$</span> <span class="n">list.filter</span> <span class="n">update.is_b</span> <span class="n">jups.updates</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">jups.updates.eaten_bound</span> <span class="bp">*</span> <span class="n">jups.updates.eaten_bound</span>
  <span class="o">:=</span> <span class="c1">-- TRYING TO PROVE THIS</span>
</code></pre></div>



<a name="227141966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227141966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227141966">(Feb 21 2021 at 04:59)</a>:</h4>
<p>it's not an mwe yet, <code>point</code> isn't defined</p>



<a name="227142027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142027">(Feb 21 2021 at 05:00)</a>:</h4>
<p>The usual trick is to paste it into a new file</p>



<a name="227142159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142159">(Feb 21 2021 at 05:03)</a>:</h4>
<p>This works, although I made up <code>dist</code> and <code>path1.eaten</code> so I might not get the right idea there</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.min_max</span>

<span class="kd">def</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span>

<span class="kd">inductive</span> <span class="n">update</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>

<span class="kd">def</span> <span class="n">update.is_b</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">update.rec_on</span> <span class="n">upd</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">update.is_b.dec</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span>  <span class="o">:</span> <span class="n">decidable</span> <span class="n">upd.is_b</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path₁</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">update</span>

<span class="kd">def</span> <span class="n">path_point_at_time</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path_current_point</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">inductive</span> <span class="n">path₁.is_preleft</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">halfplane</span> <span class="o">:</span> <span class="n">pt.fst</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">path₁.is_preleft</span>
<span class="bp">|</span> <span class="n">extension</span> <span class="o">(</span><span class="n">ups'</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">ups'</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">ups</span> <span class="bp">→</span> <span class="n">path_current_point</span> <span class="n">ups'</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">pt</span> <span class="bp">→</span> <span class="n">path₁.is_preleft</span>

<span class="kd">instance</span> <span class="n">path₁.is_preleft.dec</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">ups.is_preleft</span> <span class="n">pt</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path₁.can_extend_free</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">¬</span><span class="n">ups.is_preleft</span> <span class="o">(</span><span class="n">path_point_at_time</span> <span class="n">ups</span> <span class="n">time</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">justified</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
  <span class="o">:=</span> <span class="n">update.rec_on</span> <span class="n">hd</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">time</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">time</span><span class="o">,</span> <span class="gr">sorry</span> <span class="bp">∧</span> <span class="n">tl.can_extend_free</span> <span class="n">time</span> <span class="bp">∧</span> <span class="gr">sorry</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">eaten</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">dist</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path₁.eaten</span> <span class="o">:</span> <span class="n">path₁</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path₁.eaten_bound</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span>
  <span class="o">:=</span> <span class="n">option.iget</span> <span class="bp">$</span> <span class="n">list.maximum</span> <span class="bp">$</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">dist</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">$</span> <span class="n">path₁.eaten</span> <span class="n">ups</span>

<span class="kd">structure</span> <span class="n">path₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">updates</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">justified</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">upd</span> <span class="n">ups</span><span class="o">},</span> <span class="n">list.cons</span> <span class="n">upd</span> <span class="n">ups</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">updates</span> <span class="bp">→</span> <span class="n">justified</span> <span class="n">upd</span> <span class="n">ups</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">path₂.extend_bound</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path₂</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">(</span><span class="n">list.length</span> <span class="bp">$</span> <span class="n">list.filter</span> <span class="n">update.is_b</span> <span class="n">jups.updates</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">jups.updates.eaten_bound</span> <span class="bp">*</span> <span class="n">jups.updates.eaten_bound</span> <span class="o">:=</span>
<span class="gr">sorry</span> <span class="c1">-- TRYING TO PROVE THIS</span>
</code></pre></div>



<a name="227142339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142339">(Feb 21 2021 at 05:06)</a>:</h4>
<p>Sorry, didn't realize you were going to try to run it. This actually typechecks:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">init.function</span>
<span class="kn">import</span> <span class="n">data.list.min_max</span>

<span class="kd">def</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span>

<span class="kd">inductive</span> <span class="n">update</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="n">update</span>

<span class="kd">def</span> <span class="n">update.is_b</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">update.rec_on</span> <span class="n">upd</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">update.is_b.dec</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span>  <span class="o">:</span> <span class="n">decidable</span> <span class="n">upd.is_b</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path₁</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">update</span>

<span class="kd">def</span> <span class="n">dist_to_origin</span> <span class="o">:</span> <span class="n">point</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path_point_at_time</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path_current_point</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">more_path_points</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">inductive</span> <span class="n">path₁.is_preleft</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">halfplane</span> <span class="o">:</span> <span class="n">pt.fst</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">path₁.is_preleft</span>
<span class="bp">|</span> <span class="n">extension</span> <span class="o">(</span><span class="n">ups'</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">ups'</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">ups</span> <span class="bp">→</span> <span class="n">path_current_point</span> <span class="n">ups'</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">pt</span> <span class="bp">→</span> <span class="n">path₁.is_preleft</span>

<span class="kd">instance</span> <span class="n">path₁.is_preleft.dec</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">point</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">ups.is_preleft</span> <span class="n">pt</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">path₁.can_extend_free</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">(</span><span class="n">time</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">¬</span><span class="n">ups.is_preleft</span> <span class="o">(</span><span class="n">path_point_at_time</span> <span class="n">ups</span> <span class="n">time</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">justified</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
  <span class="o">:=</span> <span class="n">update.rec_on</span> <span class="n">hd</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">time</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">time</span><span class="o">,</span> <span class="gr">sorry</span> <span class="bp">∧</span> <span class="n">tl.can_extend_free</span> <span class="n">time</span> <span class="bp">∧</span> <span class="gr">sorry</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">λ</span> <span class="n">eaten</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">path₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">updates</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">justified</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">upd</span> <span class="n">ups</span><span class="o">},</span> <span class="n">list.cons</span> <span class="n">upd</span> <span class="n">ups</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">updates</span> <span class="bp">→</span> <span class="n">justified</span> <span class="n">upd</span> <span class="n">ups</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">path₁.bound</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">path₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span>
  <span class="o">:=</span> <span class="n">option.iget</span> <span class="bp">$</span> <span class="n">list.maximum</span> <span class="bp">$</span> <span class="n">list.map</span> <span class="n">dist_to_origin</span> <span class="bp">$</span> <span class="n">more_path_points</span> <span class="n">ups</span>

<span class="kd">def</span> <span class="n">path₂.extend_bound</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path₂</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">(</span><span class="n">list.length</span> <span class="bp">$</span> <span class="n">list.filter</span> <span class="n">update.is_b</span> <span class="n">jups.updates</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">jups.updates.bound</span> <span class="bp">*</span> <span class="n">jups.updates.bound</span>
  <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="227142458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142458">(Feb 21 2021 at 05:09)</a>:</h4>
<p>Not 100% sure this has everything needed for the proof though. <code>is_preleft</code> should suffice for uniqueness. Definitely missing boundedness; let me try to put that back in.</p>



<a name="227142471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142471">(Feb 21 2021 at 05:09)</a>:</h4>
<p>You should add in theorems (with <code>sorry</code> proofs) that you think are necessary for the main theorem, so that people can prove the goal without the setup</p>



<a name="227142540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142540">(Feb 21 2021 at 05:10)</a>:</h4>
<p>You don't need to add more stuff in the inductives or structures, it's fine if the lemmas are not provable because they aren't the focus</p>



<a name="227142598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142598">(Feb 21 2021 at 05:11)</a>:</h4>
<p>like I doubt the definition of <code>justified</code> needs to be provided here, unless you think that unfolding it is an important part of the proof you want help with</p>



<a name="227142691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142691">(Feb 21 2021 at 05:12)</a>:</h4>
<p>Okay, didn't realize we were going full crowd-sourcing on a proof here; I was really just looking for pointers and that's why I was confused about the point of providing a mwe. :) Yeah, a lot of this stuff is pointless. Let me think about it for a while.</p>



<a name="227142731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142731">(Feb 21 2021 at 05:13)</a>:</h4>
<p>Well it's easiest to get pointers starting from a well formed source</p>



<a name="227142797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142797">(Feb 21 2021 at 05:14)</a>:</h4>
<p>I want to use the code to demonstrate some things in context but I want to make sure the advice is applicable to your actual problem</p>



<a name="227142826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142826">(Feb 21 2021 at 05:15)</a>:</h4>
<p>for example I see now that lists are actually kind of integral to your setup, so my earlier suggestion about sets isn't useful</p>



<a name="227142858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142858">(Feb 21 2021 at 05:15)</a>:</h4>
<p>but it's still not clear to me where the uniqueness is coming from here - is <code>jups.updates</code> a nodup list?</p>



<a name="227142919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142919">(Feb 21 2021 at 05:16)</a>:</h4>
<p>remember that the list <code>[(0,0), (0,0), .. ]</code> can be arbitrarily long and still stay within N of the origin</p>



<a name="227142958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227142958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227142958">(Feb 21 2021 at 05:17)</a>:</h4>
<p>Yeah, that's what's missing here; <code>path_point_at_time</code> and <code>path_current_point</code> are obviously related, so that the "unique points" are actually the <code>current_point</code>s which are unique thanks to <code>can_extend_free</code>.</p>



<a name="227143025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227143025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227143025">(Feb 21 2021 at 05:18)</a>:</h4>
<blockquote>
<p>which are unique thanks to can_extend_free.</p>
</blockquote>
<p>is that a lemma that you can give a formal statement to in the language of the mwe?</p>



<a name="227143059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227143059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227143059">(Feb 21 2021 at 05:19)</a>:</h4>
<p>I assume you already have something along these lines proven, it seems like some property that follows from <code>justified</code></p>



<a name="227143151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227143151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227143151">(Feb 21 2021 at 05:20)</a>:</h4>
<p>so you probably don't have to go as far as <code>can_extend_free</code></p>



<a name="227143158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227143158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227143158">(Feb 21 2021 at 05:20)</a>:</h4>
<p>(if you haven't made a lemma about this, you should)</p>



<a name="227144681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227144681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227144681">(Feb 21 2021 at 05:46)</a>:</h4>
<p>Okay, based on my mental model of the problem I expect this to be provable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.min_max</span>

<span class="kd">def</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span>
<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="n">point</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="n">x.nat_abs</span> <span class="n">y.nat_abs</span>

<span class="kd">def</span> <span class="n">path</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">update</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">updates</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">update</span>

<span class="kd">def</span> <span class="n">path.raw_list</span> <span class="o">:</span> <span class="n">path</span> <span class="bp">→</span> <span class="n">updates</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.tail</span> <span class="o">:</span> <span class="n">path</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">path</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.tail_raw_list</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="n">jups.raw_list.tail</span> <span class="bp">=</span> <span class="n">option.iget</span> <span class="o">(</span><span class="n">option.map</span> <span class="n">path.raw_list</span> <span class="n">jups.tail</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>


<span class="kd">def</span> <span class="n">update.new_bound</span> <span class="o">:</span> <span class="n">update</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">update.new_point</span> <span class="o">:</span> <span class="n">update</span> <span class="bp">→</span> <span class="n">updates</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">update.has_new_point</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">update.new_point</span> <span class="n">upd</span> <span class="o">[]</span> <span class="bp">≠</span> <span class="n">none</span>
<span class="kd">instance</span>  <span class="n">update.has_new_point_dec</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">upd.has_new_point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- new_point is none/some depending only upon its `upd` argument:</span>
<span class="kd">def</span> <span class="n">update.has_new_point_correct</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">upds</span> <span class="o">:</span> <span class="n">updates</span><span class="o">)</span> <span class="o">:</span> <span class="n">upd.has_new_point</span> <span class="bp">↔</span> <span class="n">upd.new_point</span> <span class="n">upds</span> <span class="bp">≠</span> <span class="n">none</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">updates.head_point</span> <span class="o">:</span> <span class="n">updates</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">point</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">update.new_point</span> <span class="n">hd</span> <span class="n">tl</span>

<span class="kd">def</span> <span class="n">updates.all_points</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">updates</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ups.tails.filter_map</span> <span class="n">updates.head_point</span>

<span class="kd">def</span> <span class="n">path.max_bound</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">option.iget</span> <span class="bp">$</span> <span class="n">list.maximum</span> <span class="bp">$</span> <span class="n">list.filter_map</span> <span class="n">update.new_bound</span> <span class="n">jups.raw_list</span>
<span class="kd">def</span> <span class="n">path.points_unique</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">hd</span> <span class="n">tl</span><span class="o">,</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">jups.raw_list</span> <span class="bp">→</span> <span class="n">update.new_point</span> <span class="n">hd</span> <span class="n">tl</span> <span class="bp">∉</span> <span class="n">list.map</span> <span class="n">some</span> <span class="o">(</span><span class="n">updates.all_points</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.points_in_bounds</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">pt</span><span class="o">,</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">=</span> <span class="n">jups.raw_list</span> <span class="bp">→</span> <span class="n">hd.new_point</span> <span class="n">tl</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">pt</span> <span class="bp">→</span> <span class="n">norm</span> <span class="n">pt</span> <span class="bp">&lt;</span> <span class="n">jups.max_bound</span> <span class="o">:=</span> <span class="gr">sorry</span>


<span class="kd">def</span> <span class="n">want_to_show</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">list.length</span> <span class="bp">$</span> <span class="n">list.filter</span> <span class="n">update.has_new_point</span> <span class="n">jups.raw_list</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">jups.max_bound</span> <span class="bp">*</span> <span class="n">jups.max_bound</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(Edit: fixed updates.all_points to be a filter_map, but tbh this is not quite how I express it in my code anyways as it gets tangled up in the induction-recursion.)</p>



<a name="227146223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227146223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227146223">(Feb 21 2021 at 06:12)</a>:</h4>
<p>I'm not sure yet how to express a lemma about the relationship between <code>jups.raw_list</code> and the uniqueness of <code>new_point</code>; I guess I was thinking about the bijection between indices of <code>raw_list</code> and tails of <code>raw_list</code>, and the way <code>points_unique</code> is really saying that the non-filtered non-empty tails of <code>raw_list</code> are in bijection with the elements of <code>updates.all_points</code> from the path.</p>
<p>And ultimately <code>want_to_show</code> is helping define a measure on <code>path</code>, which must among other properties must <em>decrease</em> as more points are added. So I need an upper bound on that value:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">path.cons</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> also requires some proofs about `upd` -/</span> <span class="o">:</span> <span class="n">path</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.cons.really_cons</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">jups.cons</span> <span class="n">upd</span><span class="o">)</span><span class="bp">.</span><span class="n">raw_list</span> <span class="bp">=</span> <span class="n">upd</span> <span class="o">::</span> <span class="n">jups.raw_list</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.measure_other_updates</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.measure</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:=</span> <span class="n">jups.measure_other_updates</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">*</span> <span class="n">jups.max_bound</span> <span class="bp">*</span> <span class="n">jups.max_bound</span> <span class="bp">-</span> <span class="o">(</span><span class="n">list.length</span> <span class="bp">$</span> <span class="n">list.filter</span> <span class="n">update.has_new_point</span> <span class="n">jups.raw_list</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">really_want_to_show</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">update</span><span class="o">)</span> <span class="o">(</span><span class="n">jups</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span>
    <span class="k">let</span> <span class="n">jups'</span> <span class="o">:=</span> <span class="n">jups.cons</span> <span class="n">upd</span> <span class="k">in</span>
    <span class="n">jups'.max_bound</span> <span class="bp">=</span> <span class="n">jups.max_bound</span> <span class="bp">→</span>
    <span class="n">jups'.measure_other_updates</span> <span class="bp">&lt;</span> <span class="n">jups.measure_other_updates</span> <span class="bp">+</span> <span class="o">(</span><span class="k">if</span> <span class="n">upd.has_new_point</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">→</span>
    <span class="n">jups'.measure</span> <span class="bp">&lt;</span> <span class="n">jups.measure</span>
  <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Or something like that, I'm really quite set on using a <code>nat</code> measure here due to aforementioned bug, so I don't expect to need or want to change this latter code.</p>



<a name="227151864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227151864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227151864">(Feb 21 2021 at 08:10)</a>:</h4>
<p>Here's a proof modulo the proof that all elements of the list are in the bounds, because I think you stated <code>path.points_in_bounds</code> incorrectly so I didn't try to use it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.min_max</span>
<span class="kn">import</span> <span class="n">data.list.nodup</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">data.int.range</span>
<span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">theorem</span> <span class="n">int.range_nodup</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">int.range</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">int.range</span><span class="o">,</span> <span class="n">list.nodup_map_iff</span><span class="o">],</span> <span class="n">apply</span> <span class="n">list.nodup_range</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">int.coe_nat_inj</span> <span class="o">(</span><span class="n">add_left_cancel</span> <span class="n">h</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">int.length_range</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">int.range</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">int.to_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">int.range</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span>
<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="n">point</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="n">x.nat_abs</span> <span class="n">y.nat_abs</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">path</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">X</span>

<span class="kd">def</span> <span class="n">path.raw_list</span> <span class="o">:</span> <span class="n">path</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">X</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.tail</span> <span class="o">:</span> <span class="n">path</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">path</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">path.tail_raw_list</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">P.raw_list.tail</span> <span class="bp">=</span> <span class="n">option.iget</span> <span class="o">(</span><span class="n">option.map</span> <span class="n">path.raw_list</span> <span class="n">P.tail</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">X.new_bound</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">X.new_point</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">point</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">X.ok</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">X.new_point</span> <span class="n">upd</span> <span class="o">[]</span> <span class="bp">≠</span> <span class="n">none</span>
<span class="kd">instance</span>  <span class="n">X.ok_dec</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="n">upd.ok</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- new_point is none/some depending only upon its `upd` argument:</span>
<span class="kd">def</span> <span class="n">X.ok_correct</span> <span class="o">(</span><span class="n">upd</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">upds</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">upd.ok</span> <span class="bp">↔</span> <span class="n">upd.new_point</span> <span class="n">upds</span> <span class="bp">≠</span> <span class="n">none</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">X.head_point</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">point</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X.new_point</span> <span class="n">hd</span> <span class="n">tl</span>

<span class="kd">def</span> <span class="n">X.all_points</span> <span class="o">(</span><span class="n">ups</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">point</span> <span class="o">:=</span> <span class="n">ups.tails.filter_map</span> <span class="n">X.head_point</span>

<span class="kd">def</span> <span class="n">path.N</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">option.iget</span> <span class="bp">$</span> <span class="n">list.maximum</span> <span class="bp">$</span> <span class="n">list.filter_map</span> <span class="n">X.new_bound</span> <span class="n">P.raw_list</span>

<span class="kd">theorem</span> <span class="n">path.points_unique</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">hd</span> <span class="n">tl</span><span class="o">,</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">P.raw_list</span> <span class="bp">→</span>
  <span class="n">X.new_point</span> <span class="n">hd</span> <span class="n">tl</span> <span class="bp">∉</span> <span class="n">list.map</span> <span class="n">some</span> <span class="o">(</span><span class="n">X.all_points</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">path.points_in_bounds</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">pt</span><span class="o">,</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="bp">=</span> <span class="n">P.raw_list</span> <span class="bp">→</span>
  <span class="n">hd.new_point</span> <span class="n">tl</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">pt</span> <span class="bp">→</span> <span class="n">norm</span> <span class="n">pt</span> <span class="bp">&lt;</span> <span class="n">P.N</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">good_points</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">point</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">X.new_point</span> <span class="n">hd</span> <span class="n">tl</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">good_points</span> <span class="n">tl</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">good_points</span> <span class="n">tl</span>
  <span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">good_points_bound</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">list.filter</span> <span class="n">X.ok</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">good_points</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">le_refl</span> <span class="n">_</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="o">::</span><span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">good_points</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">e</span> <span class="o">:</span> <span class="n">hd.new_point</span> <span class="n">tl</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">good_points</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">list.filter_cons_of_neg</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">good_points_bound</span> <span class="n">tl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">X.ok_correct</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span> <span class="n">e</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">hd.ok</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">list.filter_cons_of_pos</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nat.succ_le_succ</span> <span class="o">(</span><span class="n">good_points_bound</span> <span class="n">tl</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">list.filter_cons_of_neg</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nat.le_succ_of_le</span> <span class="o">(</span><span class="n">good_points_bound</span> <span class="n">tl</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">good_points_all</span> <span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">good_points</span> <span class="n">l</span> <span class="bp">⊆</span> <span class="n">X.all_points</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">X.all_points</span><span class="o">],</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">IH</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">IH</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">good_points</span> <span class="n">tl</span> <span class="bp">→</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="bp">∧</span> <span class="n">X.head_point</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h'</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h'.trans</span> <span class="o">(</span><span class="n">list.suffix_cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="n">e</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">good_points</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">e</span> <span class="o">:</span> <span class="n">hd.new_point</span> <span class="n">tl</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">good_points</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">IH</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">list.suffix_refl</span> <span class="n">_</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">IH</span> <span class="n">h</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">good_points_nodup</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">&lt;</span><span class="o">:</span><span class="bp">+</span> <span class="n">P.raw_list</span> <span class="bp">→</span> <span class="o">(</span><span class="n">good_points</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">nodup</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="o">::</span><span class="n">tl</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">good_points</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">IH</span> <span class="o">:=</span> <span class="n">good_points_nodup</span> <span class="n">tl</span> <span class="o">((</span><span class="n">list.suffix_cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">e</span> <span class="o">:</span> <span class="n">hd.new_point</span> <span class="n">tl</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">good_points</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">IH</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">list.nodup_cons.2</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">IH</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">path.points_unique</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="o">(</span><span class="n">good_points_all</span> <span class="n">_</span> <span class="n">h'</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">want_to_show</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="n">list.length</span> <span class="o">(</span><span class="n">list.filter</span> <span class="n">X.ok</span> <span class="n">P.raw_list</span><span class="o">)</span> <span class="bp">≤</span>
  <span class="mi">4</span> <span class="bp">*</span> <span class="n">P.N</span> <span class="bp">*</span> <span class="n">P.N</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">good_points_bound</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="n">good_points</span> <span class="n">P.raw_list</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">good_points_nodup</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.suffix_refl</span> <span class="n">_</span><span class="o">)⟩,</span>
  <span class="k">let</span> <span class="n">T</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="n">int.range</span> <span class="o">(</span><span class="bp">-</span><span class="n">P.N</span><span class="o">)</span> <span class="n">P.N</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">int.range_nodup</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">change</span> <span class="n">S.card</span> <span class="bp">≤</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T.product</span> <span class="n">T</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">int.mem_range_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">norm</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">P.N</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">norm</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">int.coe_nat_lt</span><span class="o">,</span> <span class="bp">←</span> <span class="n">int.abs_eq_nat_abs</span><span class="o">,</span> <span class="n">abs_lt</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">le_of_lt</span><span class="o">]</span> <span class="o">},</span>
    <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">finset.card_le_of_subset</span> <span class="n">this</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.card_product</span><span class="o">,</span> <span class="k">show</span> <span class="n">T.card</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">int.length_range</span> <span class="n">_</span> <span class="n">_</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">int.coe_nat_add</span><span class="o">],</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227152107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227152107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227152107">(Feb 21 2021 at 08:14)</a>:</h4>
<p>As far as takeaways, the key is the <code>good_points</code> definition, which I think is equal to <code>list.filter ok P.raw_list</code> but is defined in a way which makes the proof of nodup from your lemmas easier.</p>



<a name="227152138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227152138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227152138">(Feb 21 2021 at 08:15)</a>:</h4>
<p>(also I shortened the names a bit to make it easier to see, hope you don't mind)</p>



<a name="227152141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227152141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227152141">(Feb 21 2021 at 08:15)</a>:</h4>
<p><span class="user-mention" data-user-id="310413">@David A</span></p>



<a name="227181304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Order%20from%20embedding/near/227181304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David A <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Order.20from.20embedding.html#227181304">(Feb 21 2021 at 17:21)</a>:</h4>
<p>Thanks, this not only gives me a way forward but also provides some much needed formatting hints ;)</p>
<p><code>path.points_in_bounds</code> is stated the way I intended but it actually only proves the head point is in bounds (and should have just used the new function I added); then I have to use the definition of bounds and the projection of all the proofs <code>path</code> contains onto its own tail to show the result for the tails. So I should probably just make that at a separate lemma...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
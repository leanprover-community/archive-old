---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html">mul_inv_rev for ring_hom.inverse</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="258595902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258595902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258595902">(Oct 21 2021 at 18:34)</a>:</h4>
<p>I couldn't find this statement; is it true?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ring.mul_inverse_rev</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ring.inverse</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ring.inverse</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">ring.inverse</span> <span class="n">a</span> <span class="o">:=</span>
</code></pre></div>
<p>I can work out a proof for <code>comm_ring</code>, but can't find any obvious lemmas to get it for <code>ring</code>.</p>



<a name="258596029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258596029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258596029">(Oct 21 2021 at 18:35)</a>:</h4>
<p>I get stuck at:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ha</span><span class="o">:</span> <span class="bp">¬</span><span class="n">is_unit</span> <span class="n">a</span>
<span class="n">hb</span><span class="o">:</span> <span class="bp">¬</span><span class="n">is_unit</span> <span class="n">b</span>
<span class="n">h</span><span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>
<p>which I suspect isn't provable</p>



<a name="258597081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258597081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258597081">(Oct 21 2021 at 18:43)</a>:</h4>
<p>Yeah I think you're right, it's not provable.</p>



<a name="258598258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258598258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258598258">(Oct 21 2021 at 18:52)</a>:</h4>
<p>Let M be <code>ℕ → ℤ </code> with pointwise addition, and let R be <code>M→+ M</code> with pointwise addition and composition as multiplication (so R is the endomorphism ring of the abelian group M). If <code>f : M</code> then define <code>a.f : M</code> by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a.f(n)=f(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> and <code>b.f : M</code>by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b.f(n+1)=f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b.f(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. I claim that neither a nor b are units in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> because if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> is a unit of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> then the induced map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M\to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> must be a bijection (because it has a two-sided inverse). However <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is not surjective (because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">bf(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> is not injective (because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> sends the function mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and everything else to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, to zero). However the composite <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∘</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\circ b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is the identity function so in particular is a unit.</p>



<a name="258599116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258599116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258599116">(Oct 21 2021 at 18:58)</a>:</h4>
<p>I think this should be true in a Dedekind finite ring (one where <code>a * b = 1 -&gt; b * a = 1</code>), which is the subject of my oldest still open PR <a href="https://github.com/leanprover-community/mathlib/issues/1822">#1822</a>, I did start cleaning it up to get it merged recently, but I can't find the branch now lol. The upshot of that PR is that many nice properties (e.g Noetherian imply Dedekind finite)</p>
<p>EDIT: refreshed branch is at <a href="https://github.com/leanprover-community/mathlib/tree/alexjbest/dedekind-finite">https://github.com/leanprover-community/mathlib/tree/alexjbest/dedekind-finite</a></p>



<a name="258603401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258603401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258603401">(Oct 21 2021 at 19:28)</a>:</h4>
<p>My example is basically the simplest ring I know with elements a,b such that ab=1 and ba!=1</p>



<a name="258603748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258603748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258603748">(Oct 21 2021 at 19:31)</a>:</h4>
<p>One can make a "universal" such ring, i.e. look at polynomials in two non-commuting variables A and B, and then quotient out by the bi-ideal generated by AB-1 to get some quotient ring over which I have very little control. But for this quotient ring (the "universal ring") I don't really see how to prove that BA!=1. The proof I know involves writing down a concrete ring for which the equality doesn't hold and noting that there will be a map from the universal ring to the concrete ring so BA can't have been 1 in the universal ring because then it would have to be 1 in the concrete ring. But then you may as well just use the concrete ring anyway.</p>



<a name="258606433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/258606433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#258606433">(Oct 21 2021 at 19:51)</a>:</h4>
<p>I pr'd the easy version in <a href="https://github.com/leanprover-community/mathlib/issues/9863">#9863</a></p>



<a name="259541671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259541671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259541671">(Oct 29 2021 at 15:34)</a>:</h4>
<p>Does this version look true?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ring.inverse_mul_self</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ring.inverse</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ring.inverse</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">ring.inverse</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">r</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">units.coe_mul</span><span class="o">,</span> <span class="n">ring.inverse_unit</span><span class="o">,</span> <span class="n">ring.inverse_unit</span><span class="o">,</span> <span class="bp">←</span><span class="n">units.coe_mul</span><span class="o">,</span> <span class="n">mul_inv_rev</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ring.inverse_non_unit</span> <span class="n">_</span> <span class="n">hr</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">ring.inverse_non_unit</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hrr</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hr</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>It feels like maybe commutativity isn't relevant if the two argument are the same</p>



<a name="259549276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259549276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259549276">(Oct 29 2021 at 16:25)</a>:</h4>
<p>Yes, because if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">r^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> has an inverse (say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>) then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> has a left inverse <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">wr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> and a right inverse <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">rw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>, which then have to be equal</p>



<a name="259552029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259552029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259552029">(Oct 29 2021 at 16:46)</a>:</h4>
<p>Any golfing ideas?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_unit_mul_self_iff</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">is_unit</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.mul</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">same</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">u</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">u</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">units.inv_mul_eq_iff_eq_mul</span><span class="o">,</span> <span class="bp">←</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">units.eq_mul_inv_iff_mul_eq</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">m</span><span class="o">,</span> <span class="bp">↑</span><span class="n">u</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">same</span><span class="o">,</span> <span class="bp">←</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span><span class="n">hu</span><span class="o">,</span> <span class="n">units.mul_inv</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span><span class="n">hu</span><span class="o">,</span> <span class="n">units.inv_mul</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">ring.inverse_mul_self</span> <span class="o">{</span><span class="n">M₀</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid_with_zero</span> <span class="n">M₀</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">M₀</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ring.inverse</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ring.inverse</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">ring.inverse</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">r</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">units.coe_mul</span><span class="o">,</span> <span class="n">ring.inverse_unit</span><span class="o">,</span> <span class="n">ring.inverse_unit</span><span class="o">,</span> <span class="bp">←</span><span class="n">units.coe_mul</span><span class="o">,</span> <span class="n">mul_inv_rev</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ring.inverse_non_unit</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">,</span>
        <span class="n">ring.inverse_non_unit</span> <span class="n">_</span> <span class="o">(</span><span class="n">mt</span> <span class="n">is_unit_mul_self_iff.mp</span> <span class="n">h</span><span class="o">)],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259553917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259553917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259553917">(Oct 29 2021 at 17:01)</a>:</h4>
<p>Ah, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/is_unit_pos_pow_iff">docs#is_unit_pos_pow_iff</a> but it's not general enough</p>



<a name="259554417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259554417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259554417">(Oct 29 2021 at 17:05)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/10041">#10041</a></p>



<a name="259554908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259554908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259554908">(Oct 29 2021 at 17:09)</a>:</h4>
<p>Thanks for generalizing it, I hadn't been able to use the units api to juggle the terms when I tried it.</p>



<a name="259555683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259555683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259555683">(Oct 29 2021 at 17:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">commute.is_unit_mul</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">commute</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_unit</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">is_unit</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">is_unit</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">H.1.mul</span> <span class="n">H.2</span><span class="o">⟩,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">u</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">commute.refl</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mul_right</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hu</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">this.units_inv_right.right_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">h.eq</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hu</span><span class="o">,</span> <span class="n">u.mul_inv</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="bp">↑</span><span class="n">u</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hu</span><span class="o">,</span> <span class="n">u.mul_inv</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">b</span><span class="o">,</span> <span class="bp">↑</span><span class="n">u</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">rwa</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hu</span><span class="o">,</span> <span class="n">u.inv_mul</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259555766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259555766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259555766">(Oct 29 2021 at 17:16)</a>:</h4>
<p>You can use this to get <code>is_unit_mul_self</code> as well as <code>is_unit_pow</code> in a non-commutative monoid.</p>



<a name="259557223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259557223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259557223">(Oct 29 2021 at 17:28)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/10042">#10042</a></p>



<a name="259558103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259558103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259558103">(Oct 29 2021 at 17:34)</a>:</h4>
<p>Nice! Can you use your PR to generalize <code>is_unit_pos_pow_iff</code> too so that mine can be closed?</p>



<a name="259565012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/mul_inv_rev%20for%20ring_hom.inverse/near/259565012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/mul_inv_rev.20for.20ring_hom.2Einverse.html#259565012">(Oct 29 2021 at 18:26)</a>:</h4>
<p>Done.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html">finsum over product of types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="236801997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236801997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236801997">(Apr 30 2021 at 08:24)</a>:</h4>
<p>I'm using the <code>finsum</code> API for the first time. Do we have this anywhere?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.finprod</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">ab.fst</span> <span class="n">ab.snd</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="236804761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236804761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236804761">(Apr 30 2021 at 08:53)</a>:</h4>
<p>I think it's not true</p>



<a name="236804946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236804946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236804946">(Apr 30 2021 at 08:55)</a>:</h4>
<p>Consider <code>f (x : bool) (y : nat) = if (x and y = 0) or not x then 1 else 0</code></p>



<a name="236805039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236805039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236805039">(Apr 30 2021 at 08:56)</a>:</h4>
<p>I think your example then reduces to  <code>0 = 1</code></p>



<a name="236806449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236806449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236806449">(Apr 30 2021 at 09:09)</a>:</h4>
<p>LOL, thanks.</p>



<a name="236807687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236807687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236807687">(Apr 30 2021 at 09:21)</a>:</h4>
<p>Although proving that was awful:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">),</span> <span class="kd">by</span> <span class="n">exactI</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">ab.fst</span> <span class="n">ab.snd</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="k">if</span> <span class="n">b</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">(</span><span class="k">if</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">),</span> <span class="n">f</span> <span class="n">p.1</span> <span class="n">p.2</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">function.support</span> <span class="n">f'</span><span class="o">)</span><span class="bp">.</span><span class="n">infinite</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">set.infinite_of_injective_forall_mem</span> <span class="o">(</span><span class="n">prod.mk.inj_left</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">function.support</span><span class="o">,</span> <span class="n">f'</span><span class="o">,</span> <span class="n">f</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="n">specialize</span> <span class="n">h</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finsum_of_infinite_support</span> <span class="n">this</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finsum_eq_sum_of_fintype</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fintype.sum_eq_single</span> <span class="n">ff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">f</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">@</span><span class="n">finsum_eq_sum_of_support_subset</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.sum_singleton</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">,},</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">(</span><span class="n">b</span> <span class="bp">|</span> <span class="n">b</span><span class="o">)</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">hb</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">finsum_of_infinite_support</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.infinite_of_injective_forall_mem</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.succ.inj</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">function.support</span><span class="o">,</span><span class="n">f</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="236807800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236807800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236807800">(Apr 30 2021 at 09:22)</a>:</h4>
<p>This is brilliant. Refutation by formal proof <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="236807864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236807864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236807864">(Apr 30 2021 at 09:23)</a>:</h4>
<p>How hard would it be to have a <code>counterexample</code> notation do you think?</p>



<a name="236807884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236807884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236807884">(Apr 30 2021 at 09:23)</a>:</h4>
<p>That handles the <code>¬ </code> and <code>by exactI</code></p>



<a name="236807954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236807954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236807954">(Apr 30 2021 at 09:24)</a>:</h4>
<p>I have no idea but it's an interesting thought.</p>



<a name="236808082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808082">(Apr 30 2021 at 09:25)</a>:</h4>
<p>Vaguely related thought: I have occasionally thought that if the machine learning people really are to have any chance of getting somewhere using Mathlib as a dataset then they would need a wealth of counterexamples.</p>



<a name="236808107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808107">(Apr 30 2021 at 09:25)</a>:</h4>
<p>This does sort of make me worry that the <code>finsum</code> API is awkward, in that "infinities" don't propagate</p>



<a name="236808113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808113">(Apr 30 2021 at 09:25)</a>:</h4>
<p>Like that's probably how we secretly reason about mathematics more than half the time.</p>



<a name="236808204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808204">(Apr 30 2021 at 09:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/finsum.20over.20product.20of.20types/near/236808107">said</a>:</p>
<blockquote>
<p>This does sort of make me worry that the <code>finsum</code> API is awkward</p>
</blockquote>
<p>I'm currently thinking about this too.</p>



<a name="236808258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808258">(Apr 30 2021 at 09:26)</a>:</h4>
<p>For instance, perhaps it should return <code>with_top M</code> instead</p>



<a name="236808270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808270">(Apr 30 2021 at 09:26)</a>:</h4>
<p>Exactly what I'm asking myself!</p>



<a name="236808280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808280">(Apr 30 2021 at 09:27)</a>:</h4>
<p>Although you need something clever somewhere to avoid ending up with <code>with_top (with_top M)</code></p>



<a name="236808417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808417">(Apr 30 2021 at 09:28)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> had a <code>counterexamples</code> branch (but pre the huge changes so it might have rotted by now). I wonder if we could have a directory of counterexamples but not in <code>src</code>?</p>



<a name="236808508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808508">(Apr 30 2021 at 09:29)</a>:</h4>
<p>Maybe it belongs to <code>archive</code>?</p>



<a name="236808586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236808586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236808586">(Apr 30 2021 at 09:30)</a>:</h4>
<p>I'd be in favour of at least experimenting with a <code>counterexamples</code> section of <code>archive</code>.</p>



<a name="236809319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236809319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236809319">(Apr 30 2021 at 09:36)</a>:</h4>
<p>Damiano has a branch with exactly that name (-;<br>
(Edit: I now see that Kevin wrote this 3 posts up <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span>)</p>



<a name="236809560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236809560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236809560">(Apr 30 2021 at 09:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/finsum.20over.20product.20of.20types/near/236808280">said</a>:</p>
<blockquote>
<p>Although you need something clever somewhere to avoid ending up with <code>with_top (with_top M)</code></p>
</blockquote>
<p>This is what the option monad is for</p>



<a name="236809749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236809749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236809749">(Apr 30 2021 at 09:41)</a>:</h4>
<p>I think <code>with_top</code> is just <code>option</code>.</p>



<a name="236809870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236809870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236809870">(Apr 30 2021 at 09:42)</a>:</h4>
<p>Yes, so the monad multiplication takes you from <code>with_top (with_top X)</code> to <code>with_top X</code></p>



<a name="236809925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236809925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236809925">(Apr 30 2021 at 09:42)</a>:</h4>
<p>Agreed. I think this should work.</p>



<a name="236810022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810022">(Apr 30 2021 at 09:44)</a>:</h4>
<p>I don't really see how to apply that here - what would the signature of <code>finsum</code> become?</p>



<a name="236810074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810074">(Apr 30 2021 at 09:44)</a>:</h4>
<p>The first step would be to make its output <code>option M</code></p>



<a name="236810081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810081">(Apr 30 2021 at 09:44)</a>:</h4>
<p>Currently its</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">finsum</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">],</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="n">M</span>
</code></pre></div>



<a name="236810116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810116">(Apr 30 2021 at 09:45)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> <code>with_top := option</code></p>



<a name="236810134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810134">(Apr 30 2021 at 09:45)</a>:</h4>
<p>I think Eric's point is that the input would have to be <code>with_top M</code> also.</p>



<a name="236810136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810136">(Apr 30 2021 at 09:45)</a>:</h4>
<p>If you made it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">finsum</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">],</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">M</span>
</code></pre></div>
<p>then how do you prevent <code>∑ᶠ a b, f a b</code> having type <code>option (option m))</code>?</p>



<a name="236810263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810263">(Apr 30 2021 at 09:46)</a>:</h4>
<p>That's certainly what my point should have been! Indeed,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">finsum</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">],</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">M</span>
</code></pre></div>
<p>would solve the problem</p>



<a name="236810366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810366">(Apr 30 2021 at 09:47)</a>:</h4>
<p>I think we'd want to use <code>def finsum.result M := option M</code> rather than <code>option</code> directly</p>



<a name="236810385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810385">(Apr 30 2021 at 09:47)</a>:</h4>
<p>And then we could add a coercion from <code>finsum.result M</code> to <code>M</code> that sends <code>top</code> to <code>0</code></p>



<a name="236810393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810393">(Apr 30 2021 at 09:48)</a>:</h4>
<p>Which would preserve the current API in some form</p>



<a name="236810475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236810475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236810475">(Apr 30 2021 at 09:48)</a>:</h4>
<p>If that last coercion trick works, it would be really neat. Best of all worlds.</p>



<a name="236812670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236812670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236812670">(Apr 30 2021 at 10:10)</a>:</h4>
<p>You can sort of get the second signature from the first:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.option.basic</span>
<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">def</span> <span class="n">whats_this_called</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">option.get</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span><span class="o">))</span> <span class="k">else</span> <span class="n">none</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">finsum</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">M</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">finsum'</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">whats_this_called</span> <span class="n">f</span> <span class="bp">&gt;&gt;=</span> <span class="n">finsum</span>
</code></pre></div>



<a name="236812850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236812850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236812850">(Apr 30 2021 at 10:12)</a>:</h4>
<p>The option monad is basically a principled way of making sure undefined values propagate. But mathlib generally prefers to use <code>0</code> for undefined values</p>



<a name="236831522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236831522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236831522">(Apr 30 2021 at 13:11)</a>:</h4>
<p>For undefined values of add_monoid, 1 for monoid for finprod, of course</p>



<a name="236832245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236832245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236832245">(Apr 30 2021 at 13:17)</a>:</h4>
<p>What's this called is ((&gt;&gt;= f) o pure) I think</p>



<a name="236832909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236832909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236832909">(Apr 30 2021 at 13:22)</a>:</h4>
<p>The whole point of this function is that it doesn't have undefinedness handling</p>



<a name="236832936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236832936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236832936">(Apr 30 2021 at 13:22)</a>:</h4>
<p>because that handling is exactly what causes all the pain</p>



<a name="236833235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833235">(Apr 30 2021 at 13:24)</a>:</h4>
<p>But we still have all that handling as obligations in the lemmas anyway</p>



<a name="236833286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833286">(Apr 30 2021 at 13:25)</a>:</h4>
<p>And the compromise finsum makes seems to make a bunch of "obvious" statements not true without annoying side conditions</p>



<a name="236833346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833346">(Apr 30 2021 at 13:25)</a>:</h4>
<p>The statements are true as long as you ignore the fact that <code>finsum</code> is defined on useless inputs</p>



<a name="236833361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833361">(Apr 30 2021 at 13:25)</a>:</h4>
<p>just assume everything is reasonable in the lemmas</p>



<a name="236833439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833439">(Apr 30 2021 at 13:26)</a>:</h4>
<p><code>finsum</code> is not actually any different from <code>finset.sum</code> in terms of assumptions</p>



<a name="236833496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833496">(Apr 30 2021 at 13:26)</a>:</h4>
<p>it's just possible to state theorems that lie outside those assumptions now</p>



<a name="236833568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833568">(Apr 30 2021 at 13:27)</a>:</h4>
<p>your first response to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">ab.fst</span> <span class="n">ab.snd</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>should be "that doesn't typecheck, let me add assumptions so I don't have to deal with places where the function is crazy"</p>



<a name="236833665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833665">(Apr 30 2021 at 13:28)</a>:</h4>
<p>for example <code>[fintype α] [fintype β]</code></p>



<a name="236833825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833825">(Apr 30 2021 at 13:29)</a>:</h4>
<p>Oh, I guess an argument for why <code>option</code> wouldn't really help is the sum over <code>f (z : units int \times int) := z.1 * z.2</code></p>



<a name="236833844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833844">(Apr 30 2021 at 13:29)</a>:</h4>
<p>this is a little bit overconstrained, but the nice thing about <code>finsum</code> is that it is defined whenever it can possibly be defined so you can later revisit and generalize the theorem to any context where it remains reasonable. But the fully general statement is probably not the first thing you want</p>



<a name="236833921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833921">(Apr 30 2021 at 13:30)</a>:</h4>
<p>You will need monads everywhere with the <code>option</code> approach</p>



<a name="236833988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236833988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236833988">(Apr 30 2021 at 13:30)</a>:</h4>
<p>plus it's not even computable, you need to use <code>whats_this_called</code> which is more naturally stated on <code>roption</code></p>



<a name="236834189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236834189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236834189">(Apr 30 2021 at 13:32)</a>:</h4>
<p>If you want to propagate a well definedness condition through multiple operations, I would suggest <code>roption</code> instead of <code>option</code>. The latter is better when the function itself can tell you whether or not it is defined</p>



<a name="236834333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236834333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236834333">(Apr 30 2021 at 13:33)</a>:</h4>
<p>But at a certain point this starts to look like the situation with integrals and derivatives where you have to do everything twice, first prove that the value is defined and then prove it is equal to something (and neither implies the other)</p>



<a name="236834528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236834528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236834528">(Apr 30 2021 at 13:34)</a>:</h4>
<p>The nice thing about <code>finset.sum</code> is that it is always defined, so the first part is absent. It's still possible to have this with <code>finsum</code> provided the definedness proof is "easy" or typeclassable</p>



<a name="236834656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236834656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236834656">(Apr 30 2021 at 13:35)</a>:</h4>
<p>Presumably having <code>finsum</code> match the design of integrals makes a lot of sense?</p>



<a name="236834748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236834748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236834748">(Apr 30 2021 at 13:36)</a>:</h4>
<p>not if it makes the easy case harder</p>



<a name="236834850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236834850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236834850">(Apr 30 2021 at 13:36)</a>:</h4>
<p>because the whole reason it exists is to make dealing with finite sums easier than the existing method using <code>finset.sum</code></p>



<a name="236835800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236835800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236835800">(Apr 30 2021 at 13:43)</a>:</h4>
<p>It is a bit funny to me that <code>finsum</code> is converging on the design of finite sums that I did in metamath, <a href="http://us.metamath.org/mpeuni/df-gsum.html">df-gsum</a>. The idea behind it is that it is defined to be the sum if it is at all reasonable to call a unique thing "the sum" of a function. It's still a bit more crazy than <code>finsum</code> since it also special cases when the summing set is a sequence of integers, in which case it is the left-associative ordered sum; otherwise it is the sum of the nonzero values up to associativity and commutativity</p>



<a name="236835883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236835883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236835883">(Apr 30 2021 at 13:43)</a>:</h4>
<p>doing something like that would be harder in lean since type equality tests don't work very well</p>



<a name="236841170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236841170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236841170">(Apr 30 2021 at 14:19)</a>:</h4>
<p>My armchair understanding is that using <code>roption / option</code> for partial values like these could be really nice, if only we had some nice way of dealing with all the monad stuff (as well as <code>whats_this_called</code>, which I guess can't be defined in terms of monad operations since it's noncomputable). For example the false theorem at the start of this thread is a true unconditional equality in <code>roption M</code>. A lot of other lemmas, like <code>finsum (f + g) = finsum f + finsum g</code> aren't equalities since the LHS can be defined even when the RHS isn't. Here there's a directedness to the lemma: if you know the values of<code>finsum f</code> and <code>finsum g</code>, then you also know the value of <code>finsum (f + g)</code>. Of course this is still easy to express with <code>roption</code>. Fubini's theorem for infinite sums is worse: knowing that <code>some x = ∑ a b, f a b</code> doesn't tell you that <code>∑ ab, f ab.fst ab.snd</code> exists. Still the way you compute the latter sum in practice is that you compute the former sum, and during these computations observe that <code>∑ a b, |f a b|</code> is finite...</p>



<a name="236841528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236841528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236841528">(Apr 30 2021 at 14:21)</a>:</h4>
<p>If you go too far in this direction you end up at <a href="https://leanprover-community.github.io/mathlib_docs/find/tsum">docs#tsum</a></p>



<a name="236842818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236842818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236842818">(Apr 30 2021 at 14:29)</a>:</h4>
<blockquote>
<p>and during these computations observe that ∑ a b, |f a b| is finite...</p>
</blockquote>
<p>This of course assumes that <code>|f a b|</code> is a thing</p>



<a name="236843005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236843005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236843005">(Apr 30 2021 at 14:30)</a>:</h4>
<p>If the target type is canonically ordered, then I think you do have Fubini's theorem (with suitable undefinedness preserving sum operations)</p>



<a name="236843059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236843059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236843059">(Apr 30 2021 at 14:30)</a>:</h4>
<p>Yes, the problem is with negative terms</p>



<a name="236843179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236843179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236843179">(Apr 30 2021 at 14:31)</a>:</h4>
<p>But eric is right that if you want to handle convergence of absolute values that's what <code>tsum</code> does</p>



<a name="236843304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236843304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236843304">(Apr 30 2021 at 14:32)</a>:</h4>
<p>Personally, I think the lemmas should just assume the indexing set is finite because that's the easy case where all the lemmas go through</p>



<a name="236843346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236843346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236843346">(Apr 30 2021 at 14:32)</a>:</h4>
<p>There will be a second series of lemmas with more subtle conditions when you only have finite support</p>



<a name="236844611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236844611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236844611">(Apr 30 2021 at 14:41)</a>:</h4>
<p>This sounds like a reasonable pragmatic approach</p>



<a name="236844649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236844649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236844649">(Apr 30 2021 at 14:41)</a>:</h4>
<p>BTW, a sum where some term is ill-defined should be thought of as ill-defined. This is why you should be able to factor the sum of <code>f : A -&gt; roption B</code> through <code>whats_this_called</code> as sketched above. This is not true of integrals: the integral of <code>f : A -&gt; roption B</code> should only require <code>f</code> to be a.e. well-defined.</p>



<a name="236844847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236844847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236844847">(Apr 30 2021 at 14:42)</a>:</h4>
<p>You should be able to do so, since I think <code>roption A</code> is a comm monoid if <code>A</code> is</p>



<a name="236844878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236844878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236844878">(Apr 30 2021 at 14:43)</a>:</h4>
<p>maybe that instance doesn't exist</p>



<a name="236845059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236845059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236845059">(Apr 30 2021 at 14:44)</a>:</h4>
<p>I guess that's what <code>with_top</code> will do for you</p>



<a name="236845125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236845125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236845125">(Apr 30 2021 at 14:44)</a>:</h4>
<p>Aha, that's nice!</p>



<a name="236845175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236845175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236845175">(Apr 30 2021 at 14:45)</a>:</h4>
<p>Oh, actually if there are infinitely many tops then you will get 0 instead of top</p>



<a name="236845236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236845236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236845236">(Apr 30 2021 at 14:45)</a>:</h4>
<p>so the <code>finsum</code> implementation has to be aware of the top element</p>



<a name="236845576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236845576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236845576">(Apr 30 2021 at 14:47)</a>:</h4>
<p>BTW here's the roption version of <code>whats_this_called</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pfun</span>

<span class="kd">def</span> <span class="n">pfun.totalize</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">roption</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span><span class="o">)⟩</span>
</code></pre></div>



<a name="236845938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236845938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236845938">(Apr 30 2021 at 14:50)</a>:</h4>
<p>But <code>pfun.totalize</code> isn't in mathlib yet right?</p>



<a name="236846016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236846016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236846016">(Apr 30 2021 at 14:51)</a>:</h4>
<p>no, I just made it up</p>



<a name="236873734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236873734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236873734">(Apr 30 2021 at 17:40)</a>:</h4>
<p>Dear All,</p>
<p>I have not followed the discussion yet, but indeed there is a <code>counterexamples</code> branch to mathlib.  I have maintained it by merging master into it every once in a whole, but have not done so after the two big <code>nat/int</code> refactors.</p>
<p>The branch might break now, but I would still love to have more counterexamples!  Feel free to push something onto it: in the branch counterexamples, there is a counterexamples folder in src.</p>



<a name="236873804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236873804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236873804">(Apr 30 2021 at 17:41)</a>:</h4>
<p>I am on holidays for a week, so I will not have a chance to update master soon, but will do so as soon as I can!</p>



<a name="236888423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236888423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236888423">(Apr 30 2021 at 19:25)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="321459">@Damiano Testa</span> Enjoy your holidays. I will keep the <code>counterexamples</code> branch in mind.</p>



<a name="236922804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236922804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236922804">(May 01 2021 at 01:01)</a>:</h4>
<p>I’ve also wanted a Fubini for <code>finsum</code> for my work on Hahn series, and an analog of <code>finset.sum_sigma</code>. An option version would be great because you could use <code>simp</code> and only have to check finiteness at the beginning and end, but it would also be awful because yet. another. API.</p>



<a name="236961309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236961309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236961309">(May 01 2021 at 11:54)</a>:</h4>
<p>I don't have time right now but I might at least try to prove this version (which would suffice for my purposes) this evening:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.finprod</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑ᶠ</span> <span class="n">ab</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ab</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">ab</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="236996369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/236996369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#236996369">(May 01 2021 at 20:30)</a>:</h4>
<p>(On the off chance some good citizen was going to work on <span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span>  I now have a proof of this which I will PR tomorrow)</p>



<a name="237052797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/finsum%20over%20product%20of%20types/near/237052797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/finsum.20over.20product.20of.20types.html#237052797">(May 02 2021 at 13:26)</a>:</h4>
<p>Just pushed up my attempt as <a href="https://github.com/leanprover-community/mathlib/issues/7439">#7439</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
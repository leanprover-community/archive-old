---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html">Multiset to set</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209111610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209111610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209111610">(Sep 04 2020 at 16:01)</a>:</h4>
<p>What is the canonical way to get a <code>set α</code> containing the elements of <code>s : multiset α</code>? <code>(∈ s)</code>, <code>↑s.to_finset</code>, something else?</p>



<a name="209113049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113049">(Sep 04 2020 at 16:16)</a>:</h4>
<p>You can always abuse the <code>has_mem</code> instance :)</p>



<a name="209113121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113121">(Sep 04 2020 at 16:16)</a>:</h4>
<p>I don't know how canonical that is.</p>



<a name="209113692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113692">(Sep 04 2020 at 16:21)</a>:</h4>
<p>From some experimenting, <code>to_finset</code> has better support for <code>rw</code> and <code>simp</code> than <code>(∈ s)</code>, but either way is not very nice.</p>



<a name="209113775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113775">(Sep 04 2020 at 16:22)</a>:</h4>
<p>Ah I see, that's exactly what you meant by <code>(\in S)</code>.</p>



<a name="209113971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113971">(Sep 04 2020 at 16:24)</a>:</h4>
<p>Indeed.</p>



<a name="209113974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113974">(Sep 04 2020 at 16:24)</a>:</h4>
<p>I guess less inscrutability is another argument for <code>to_finset</code>.</p>



<a name="209113981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209113981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209113981">(Sep 04 2020 at 16:24)</a>:</h4>
<p>This is completely a personal opinion (and clearly does not agree with what's done in mathlib), but I think the canonical way to produce a set from anything should always be via <code>has_mem</code>. This would at least provide some consistency.</p>



<a name="209114188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209114188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209114188">(Sep 04 2020 at 16:26)</a>:</h4>
<p>I agree. In fact, I think there was a suggestion floating around that <code>has_mem</code> should only exist for <code>set</code>, and to access the syntax for other types, you should just provide the coercion to <code>set</code>.</p>



<a name="209114276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209114276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209114276">(Sep 04 2020 at 16:27)</a>:</h4>
<p><code>has_mem</code> should not even exist. It should just be notation for sets.</p>



<a name="209114609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209114609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209114609">(Sep 04 2020 at 16:31)</a>:</h4>
<p>I wrote thousands of lines of group theory over the summer and I would have gone completely nuts if I couldn't write <code>x \in H</code> for <code>H : subgroup G</code>.</p>



<a name="209114645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209114645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209114645">(Sep 04 2020 at 16:32)</a>:</h4>
<p>But you already introduced the coercion to <code>set G</code> as <code>carrier</code> right?</p>



<a name="209114689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209114689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209114689">(Sep 04 2020 at 16:32)</a>:</h4>
<p>So why not use it?</p>



<a name="209115080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209115080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209115080">(Sep 04 2020 at 16:36)</a>:</h4>
<p>This way you would never have to prove that <code>{x : G | x \in H} = (H : set G)</code>.</p>



<a name="209115234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209115234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209115234">(Sep 04 2020 at 16:38)</a>:</h4>
<p>I tried making this change in core Lean once but things failed horribly <span aria-label="frown" class="emoji emoji-1f641" role="img" title="frown">:frown:</span> <br>
I think mainly what broke were things like (made up example) <code>∀ l, (∀ x, x ∉ l) ↔ list.length l = 0</code> where current Lean keeps an open mind about <code>l</code> until it sees <code>list.length l</code>, but with the change <code>x ∉ l</code> already makes Lean think <code>l</code> is a <code>set</code> and when it gets to <code>list.length l</code> it's too late.</p>



<a name="209115390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209115390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209115390">(Sep 04 2020 at 16:40)</a>:</h4>
<p>I gave up at that point but it's possible a more cunning approach would have worked.</p>



<a name="209115512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209115512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209115512">(Sep 04 2020 at 16:41)</a>:</h4>
<p>In this case, wouldn't this be okay? <code>∀ l, list.length l = 0 ↔  (∀ x, x ∉ l) </code></p>



<a name="209115580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209115580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209115580">(Sep 04 2020 at 16:42)</a>:</h4>
<p>Probably, but there were many examples of this kind of thing</p>



<a name="209121297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209121297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209121297">(Sep 04 2020 at 17:37)</a>:</h4>
<p>I wonder what it would be like if there were a mechanism to make every theorem and definition about <code>set</code> be automatically generalized to anything with a <code>has_mem</code> instance, since <code>has_mem</code> is basically a coercion to a <code>set</code> already:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">has_mem_to_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">set_of</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>


<p>(It seems like it's more convenient proving things about <code>set</code>s rather than about types with <code>has_mem</code> instances, so that's why I'm suggesting the idea of automatic generalization.  This is something an attribute could do, right?)</p>



<a name="209121500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209121500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209121500">(Sep 04 2020 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Multiset.20to.20set/near/209114689">said</a>:</p>
<blockquote>
<p>So why not use it?</p>
</blockquote>
<p>Because then I get random up-arrows everywhere, which makes the code look more confusing to mathematicians?</p>



<a name="209121977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209121977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209121977">(Sep 04 2020 at 17:44)</a>:</h4>
<p>I guess it wouldn't work to generalize <em>every</em> theorem/definition, because some rely on sets forming a lattice.</p>
<p>There are some big problems with this proposal, but I'm still curious about whether an attribute is able to do this kind of metaprogramming.</p>



<a name="209122313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209122313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209122313">(Sep 04 2020 at 17:48)</a>:</h4>
<p>I've also wondered whether there really needs to be a type class, or whether we could do some even more ad hoc thing like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span><span class="err">∈</span><span class="bp">`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span><span class="bp">.</span><span class="n">has</span> <span class="n">a</span>
</code></pre></div>


<p>and then rely on <code>.</code> notation to get what we want</p>



<a name="209122392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209122392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209122392">(Sep 04 2020 at 17:49)</a>:</h4>
<p>Would that be like how <code>::</code> is notation defined by vectors, multisets, lists, and others?</p>



<a name="209122488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209122488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209122488">(Sep 04 2020 at 17:50)</a>:</h4>
<p>How does Lean disambiguate notation?  It seems to do a reasonably good job at it, whatever it's doing.</p>



<a name="209123627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209123627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209123627">(Sep 04 2020 at 18:01)</a>:</h4>
<p>This is a different suggestion. More like duck typing.<br>
The disadvantage is you could never abstract over a <code>has_mem</code> instance. But I could only find one such occurrence in the core library and mathlib, and it just relates <code>∈</code> and <code>∉</code>, which you could achieve anyways.</p>



<a name="209123639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209123639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209123639">(Sep 04 2020 at 18:01)</a>:</h4>
<p>I understand that this opinion is controversial, but here is a related observation/question. Whenever we have two types <code>X</code> and <code>Y</code> with a <code>has_mem X Y</code>, you get a natural map from <code>Y</code> to <code>set X</code> given by sending <code>y</code> to <code>{x : X | x \in y}</code>. Is there any reasonable example where there is also a coercion from <code>Y</code> to <code>set X</code>where these two are not defeq?</p>



<a name="209123708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209123708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209123708">(Sep 04 2020 at 18:02)</a>:</h4>
<p>I don't really understand how notation overloading works--it may appear to work well because the <code>::</code> for multiset is used mostly in <code>multiset.lean</code> or whatever, which also defines it.</p>



<a name="209124159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209124159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209124159">(Sep 04 2020 at 18:06)</a>:</h4>
<p>I think that Patrick fought hard to get the exact opposite behaviour for filters: he wanted <code>s \in F</code> because he felt it looked much more natural than <code>s \in F.sets</code>. IIRC his argument was the same as mine -- it just looks more like what a mathematician would write. I don't know any examples where there's a coercion which isn't defeq.</p>



<a name="209124373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209124373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209124373">(Sep 04 2020 at 18:08)</a>:</h4>
<p>Kevin, everyone wants to write <code>s \in F</code> and <code>g \in H</code>, I think. The question is how to implement it so that Lean isn't so frequently baffled by the relationship between the type of a set and the type of its elements, and maybe also to be able to apply lemmas about <code>\forall x \in s, ...</code> for sets to things that are not sets, etc.</p>



<a name="209124647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209124647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209124647">(Sep 04 2020 at 18:11)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">subring</span>

<span class="kn">notation</span> <span class="n">a</span> <span class="bp">`</span><span class="err">∈₁</span><span class="bp">`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span> <span class="err">∈</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">r</span> <span class="err">∈₁</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div>


<p>Unfortunately the uparrow appears in the goal window.</p>



<a name="209124705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209124705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209124705">(Sep 04 2020 at 18:12)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> That natural map is the <code>has_mem_to_set</code> that I wrote, though I used <code>set_of</code> rather than set builder notation for some reason.  (The answer to your question ought to be "no," I'd hope!)</p>



<a name="209124844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209124844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209124844">(Sep 04 2020 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Multiset.20to.20set/near/209123708">said</a>:</p>
<blockquote>
<p>I don't really understand how notation overloading works--it may appear to work well because the <code>::</code> for multiset is used mostly in <code>multiset.lean</code> or whatever, which also defines it.</p>
</blockquote>
<p>I was adding <code>::</code> to <code>data.sym</code>, and some theorems involved <code>::</code> for multisets, vectors, and lists, so I was impressed the overloading just worked.</p>



<a name="209125038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209125038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209125038">(Sep 04 2020 at 18:15)</a>:</h4>
<p>For example Lean doesn't understand what it should do with <code>lemma h (s : set ℕ) : ∀ x ∈ s, x ∈ set.univ := sorry</code>, but it works if you add <code>local notation x ` ∈ ` s := @has_mem.mem _ _ set.has_mem x s</code>. It's pretty frustrating because attaching a predicate <code>_ ∈ t</code> to some object <code>t</code> is exactly what it means to coerce <code>t</code> to a set!</p>



<a name="209126061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209126061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209126061">(Sep 04 2020 at 18:25)</a>:</h4>
<p>Regarding <span class="user-mention" data-user-id="243562">@Adam Topaz</span>'s point, would it break anything to remove all <code>has_coe _ (set _)</code> instances and replace them all with the following single instance?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">}</span><span class="bp">⟩</span>
</code></pre></div>


<p>Then to define a coercion, you implement <code>has_mem</code>.</p>



<a name="209126154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209126154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209126154">(Sep 04 2020 at 18:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Multiset.20to.20set/near/209126061">said</a>:</p>
<blockquote>
<p>Regarding <span class="user-mention silent" data-user-id="243562">Adam Topaz</span>'s point, would it break anything to remove all <code>has_coe _ (set _)</code> instances and replace them all with the following single instance?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">}</span><span class="bp">⟩</span>
</code></pre></div>


<p>Then to define a coercion, you implement <code>has_mem</code>.</p>
</blockquote>
<p>I'm fine with that too. I'm mostly asking for consistency.</p>



<a name="209126387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209126387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209126387">(Sep 04 2020 at 18:28)</a>:</h4>
<p>Oh right, I forgot you were suggesting the other way.  Here's that one, too, for completeness:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">has_mem_from_coe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">↑</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">⟩</span>
</code></pre></div>



<a name="209126683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209126683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209126683">(Sep 04 2020 at 18:31)</a>:</h4>
<p>Though at that point, it may as well be something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem</span>

<span class="kn">abbreviation</span> <span class="n">mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">↑</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∈</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">mem</span>
</code></pre></div>


<p>removing <code>has_mem</code> entirely.</p>



<a name="209138309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209138309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209138309">(Sep 04 2020 at 20:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Multiset.20to.20set/near/209126061">said</a>:</p>
<blockquote>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">}</span><span class="bp">⟩</span>
</code></pre></div>


</blockquote>
<p>This must be <code>has_coe_t</code>, or otherwise it would loop.</p>



<a name="209961351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209961351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209961351">(Sep 14 2020 at 02:59)</a>:</h4>
<p>I spent a little while investigation dropping <code>has_mem</code> in favour of the coercion. Unfortunately the place it fails down is when you want to write <code>a \mem s ++ t</code>, say for <code>s t : list X</code>. Then Lean coerces the RHS to a <code>set</code>, and can no longer find <code>++</code>.</p>



<a name="209972317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209972317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209972317">(Sep 14 2020 at 07:27)</a>:</h4>
<p>Is there a way to "lock" a typeclass so only a fixed set of instances are allowed?  (Community agreement counts <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>)  If so, then this could work to effectively drop <code>has_mem</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">namespace</span> <span class="n">new_has_mem</span>

<span class="n">class</span> <span class="n">has_mem</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="err">∈</span>        <span class="o">:=</span> <span class="n">has_mem</span><span class="bp">.</span><span class="n">mem</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">α</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">set</span><span class="bp">.</span><span class="n">mem</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="n">coe_has_mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">s</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem</span> <span class="n">x</span> <span class="err">↑</span><span class="n">s</span><span class="bp">⟩</span>

<span class="c1">-- then no other instances to has_mem ever!</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">mem_coe_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe</span> <span class="n">β</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">↑</span><span class="n">y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">l</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">l</span><span class="bp">.</span><span class="n">mem</span> <span class="n">x</span><span class="o">}</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="bp">.</span><span class="n">empty</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">new_has_mem</span>
</code></pre></div>


<p>It turns out what I'd tried with <code>infix</code> before didn't work at all.  I'd hoped it would make Lean prefer <code>set.mem</code> for sets, but it just caused it to not be able to disambiguate the notation.  The above does effectively the same thing, but actually works. <code>set.mem</code> should have higher priority than the coercion (and if it's only working right now because there's no coersion from a set to a set, the priority could be set explicitly).</p>



<a name="209972420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209972420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209972420">(Sep 14 2020 at 07:28)</a>:</h4>
<p>I'm not saying I'm in favor of dropping <code>has_mem</code>.  It seems a bit nicer to me to keep <code>has_mem</code> but then replace all coercions to set with a single coercion that uses <code>has_mem</code> to implement it.</p>



<a name="209983546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Multiset%20to%20set/near/209983546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Multiset.20to.20set.html#209983546">(Sep 14 2020 at 09:49)</a>:</h4>
<p>That is an interesting approach! It does not infer <code>{y, z} : set ℕ</code> in <code>example (x y z : ℕ) : x ∈ {y, z} := sorry</code>, which ideally I was hoping for. The current <code>has_mem</code> has the same issue though. So it looks like the <code>coe_has_mem</code> approach works at least as well as the current <code>has_mem</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html">by symmetry</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="234081177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234081177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234081177">(Apr 11 2021 at 22:25)</a>:</h4>
<p>I have a proof that I'd like to be able to write in a shape like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.opens</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">S</span> <span class="n">T</span> <span class="o">(</span><span class="n">hST</span> <span class="o">:</span> <span class="n">f</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">T</span><span class="o">),</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">symmetry''</span><span class="o">,</span> <span class="c1">-- hypothetical tactic</span>
  <span class="k">show</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="gr">sorry</span> <span class="c1">-- some longish proof</span>
<span class="kd">end</span>
</code></pre></div>
<p>That is, I have a goal of the form <code>p S ↔ p T</code>, and all my hypotheses are symmetrical on swapping S and T. I'd like to reduce the goal to just proving one direction <code>p S → p T</code>, "because obviously it's all symmetric."</p>
<p>Is there a tactic that can do this for me?</p>



<a name="234081407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234081407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234081407">(Apr 11 2021 at 22:30)</a>:</h4>
<p>wlog can do this for inequalities. In your case, you have S \le T and T \le S, if you do apply le_antisymm instead of ext x</p>



<a name="234081542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234081542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234081542">(Apr 11 2021 at 22:32)</a>:</h4>
<p>Hmm interesting! I'll try that</p>



<a name="234081684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234081684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234081684">(Apr 11 2021 at 22:34)</a>:</h4>
<p>Here's what I get from one attempt at using <code>wlog</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">S</span> <span class="n">T</span> <span class="o">(</span><span class="n">hST</span> <span class="o">:</span> <span class="n">f</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">T</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="n">wlog</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">≤</span> <span class="n">S</span> <span class="n">using</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  3 goals</span>
<span class="cm">  case cases</span>
<span class="cm">  α β : Type,</span>
<span class="cm">  f : set α → β,</span>
<span class="cm">  S T : set α,</span>
<span class="cm">  hST : f S = f T</span>
<span class="cm">  ⊢ T ≤ S ∨ S ≤ T</span>

<span class="cm">  case main</span>
<span class="cm">  α β : Type,</span>
<span class="cm">  f : set α → β,</span>
<span class="cm">  S T : set α,</span>
<span class="cm">  case : T ≤ S,</span>
<span class="cm">  hST : f S = f T</span>
<span class="cm">  ⊢ S ≤ T</span>

<span class="cm">  α β : Type,</span>
<span class="cm">  f : set α → β,</span>
<span class="cm">  S T : set α,</span>
<span class="cm">  hST : f S = f T</span>
<span class="cm">  ⊢ T ≤ S</span>
<span class="cm">  -/</span>
</code></pre></div>



<a name="234081715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234081715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234081715">(Apr 11 2021 at 22:35)</a>:</h4>
<p>I'm clearly doing something wrong there because the first goal isn't even true a priori (not without basically proving the original goal)</p>



<a name="234081971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234081971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234081971">(Apr 11 2021 at 22:40)</a>:</h4>
<p>I guess another version of the question is, if I just <code>apply le_antisymm</code> instead of the <code>ext x</code>, then I have these two goals:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>αβ: Type
f: set α → β
ST: set α
hST: f S = f T
⊢ S ≤ T

αβ: Type
f: set α → β
ST: set α
hST: f S = f T
⊢ T ≤ S
</code></pre></div>
<p>And the thing I want to do is provide a proof of one of them, and somehow use that to discharge the other. Which will be by somehow using the fact that if you swap the variable names and apply symmetry to <code>hST</code>, that turns the one goal into the other one.</p>
<p>But I'm not seeing the match between that and what <code>wlog</code> does -- it seems to want to split the goal into more goals, not coalesce symmetrical goals.</p>



<a name="234082805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234082805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234082805">(Apr 11 2021 at 22:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">S</span> <span class="n">T</span> <span class="o">(</span><span class="n">hST</span> <span class="o">:</span> <span class="n">f</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">T</span><span class="o">),</span>
  <span class="n">wlog</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">≤</span> <span class="n">S</span> <span class="n">using</span> <span class="n">T</span> <span class="n">S</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- pick one of the directions of `T ≤ S` or `S ≤ T` to prove here</span>
    <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- now knowing that `T ≤ S`, use that to prove `T = S` using your "longish proof"</span>
    <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234082865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234082865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234082865">(Apr 11 2021 at 22:58)</a>:</h4>
<p>Hmm -- but how does that avoid repeating the main proof twice?</p>



<a name="234082908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234082908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234082908">(Apr 11 2021 at 22:59)</a>:</h4>
<p>Once for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>≤</mo><mi>S</mi></mrow><annotation encoding="application/x-tex"> T \leq S </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and once for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>≤</mo><mi>T</mi></mrow><annotation encoding="application/x-tex"> S \leq T </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></p>



<a name="234082976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234082976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234082976">(Apr 11 2021 at 23:00)</a>:</h4>
<p>maybe it'll be easier to understand if you have the actual mathematical setup</p>



<a name="234083009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234083009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234083009">(Apr 11 2021 at 23:00)</a>:</h4>
<p>Sure, one moment</p>



<a name="234083188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234083188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234083188">(Apr 11 2021 at 23:03)</a>:</h4>
<p>The details of the proof are rather messy at present, but here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.instances.real</span>
<span class="kn">import</span> <span class="n">topology.opens</span>

<span class="kn">open</span> <span class="n">function</span>
<span class="kn">open</span> <span class="n">metric</span>
<span class="kn">open</span> <span class="n">topological_space</span>
<span class="n">open_locale</span> <span class="n">cardinal</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kn">namespace</span> <span class="n">cardinal</span>

<span class="kd">lemma</span> <span class="n">mk_opens_R_aux</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">#</span><span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">:=</span>
<span class="c1">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>
<span class="c1">-- (Any dense set would do just as well in place of ℚ.)</span>
<span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="bp">|</span> <span class="n">ball</span> <span class="o">(</span><span class="n">p.1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">p.2</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">}</span> <span class="k">in</span>
<span class="n">mk_le_of_injective</span> <span class="o">(</span><span class="k">show</span> <span class="n">injective</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">assume</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="o">{</span>
    <span class="k">assume</span> <span class="n">hxS</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">S</span> <span class="bp">∈</span> <span class="bp">𝓝</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mem_nhds_sets</span> <span class="n">S.property</span> <span class="n">hxS</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">mem_nhds_iff.mp</span> <span class="n">this</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">ε</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hεpos</span><span class="o">,</span> <span class="n">hball</span><span class="o">⟩⟩,</span>
    <span class="n">rcases</span> <span class="n">exists_pos_rat_lt</span> <span class="o">(</span><span class="n">half_pos</span> <span class="n">hεpos</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">εQ</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h0εQ</span><span class="o">,</span> <span class="n">hεQ</span><span class="o">⟩⟩,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">ball</span> <span class="n">x</span> <span class="o">(</span><span class="n">εQ</span><span class="o">)</span> <span class="bp">∈</span> <span class="bp">𝓝</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">ball_mem_nhds</span> <span class="n">x</span> <span class="o">(</span><span class="n">rat.cast_pos.mpr</span> <span class="n">h0εQ</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">exists.elim</span> <span class="o">(</span><span class="n">dense_embedding_of_rat.dense.inter_nhds_nonempty</span> <span class="n">this</span><span class="o">),</span>
    <span class="n">rintro</span> <span class="n">yR</span> <span class="o">⟨⟨</span><span class="n">yQ</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="n">hyballx</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">dist</span> <span class="n">yR</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">εQ</span><span class="o">,</span> <span class="k">from</span> <span class="n">set.mem_def.mp</span> <span class="n">hyballx</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">ball</span> <span class="o">(</span><span class="n">yQ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">εQ</span> <span class="bp">⊆</span> <span class="n">ball</span> <span class="n">x</span> <span class="n">ε</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">ball_subset</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hy</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">ball</span> <span class="o">(</span><span class="n">yQ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">εQ</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="k">from</span> <span class="n">set.subset.trans</span> <span class="n">this</span> <span class="n">hball</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">yQ</span><span class="o">,</span> <span class="n">εQ</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">S</span><span class="o">,</span> <span class="k">from</span> <span class="n">set.mem_def.mpr</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">yQ</span><span class="o">,</span> <span class="n">εQ</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">T</span><span class="o">,</span> <span class="k">from</span> <span class="n">hST</span> <span class="bp">▸</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">ball</span> <span class="o">(</span><span class="n">yQ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">εQ</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">,</span> <span class="k">from</span> <span class="n">set.mem_def.mp</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hyballT</span> <span class="o">:</span> <span class="n">ball</span> <span class="n">yR</span> <span class="n">εQ</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">,</span> <span class="k">from</span> <span class="n">hy</span> <span class="bp">▸</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">set.mem_of_subset_of_mem</span> <span class="n">hyballT</span> <span class="o">(</span><span class="n">mem_ball_comm.mp</span> <span class="n">hyballx</span><span class="o">),</span>
  <span class="o">},</span>

  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- "by symmetry"</span>
<span class="o">})</span>
</code></pre></div>



<a name="234083350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234083350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234083350">(Apr 11 2021 at 23:05)</a>:</h4>
<p>(I think all the details in that block after <code>split</code> don't matter, except to see why I don't want to just say it twice with S and T swapped)</p>



<a name="234287517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234287517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234287517">(Apr 13 2021 at 08:28)</a>:</h4>
<p>Another trick would be to prove the implication for general variables (X, Y) first, and then apply it twice: once on (S, T) and once on (T, S).</p>
<div class="codehilite" data-code-language="import"><pre><span></span><code>open function

example (α β : Type) (f : set α → β) : injective f :=
begin
  assume S T (hST : f S = f T),
  have aux_lemma : ∀ X Y : whatever_S_and_T_are, any_condition_on_S_and_T → S ⊆ T := sorry,
  have : S = T := subset.antisymm (aux_lemma S T conditions_on_S conditions_on_T) (aux_lemma T S conditions_on_T conditions_on_S),
end```
It would be great if a tactic could figure out how to change the goal on its own, but I slightly doubt it's feasible.
</code></pre></div>



<a name="234446381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234446381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234446381">(Apr 14 2021 at 06:13)</a>:</h4>
<p>Thanks! Yeah, that's the best existing solution I've found.</p>



<a name="234446969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234446969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234446969">(Apr 14 2021 at 06:20)</a>:</h4>
<p>For my example above, it might look like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mk_opens_R_aux</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">#</span><span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">:=</span>
<span class="c1">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>
<span class="c1">-- (Any dense set would do just as well in place of ℚ.)</span>
<span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">p</span> <span class="bp">|</span> <span class="n">ball</span> <span class="o">(</span><span class="n">p.1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">p.2</span> <span class="bp">⊆</span> <span class="n">S</span> <span class="o">}</span> <span class="k">in</span>
<span class="n">mk_le_of_injective</span> <span class="o">(</span><span class="k">show</span> <span class="n">injective</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span>
<span class="k">suffices</span> <span class="bp">∀</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="n">f</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">T</span><span class="o">,</span>
  <span class="k">from</span> <span class="k">assume</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">,</span> <span class="n">opens.ext</span> <span class="bp">$</span> <span class="n">set.subset.antisymm</span> <span class="o">(</span><span class="n">this</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="n">T</span> <span class="n">S</span> <span class="n">hST.symm</span><span class="o">),</span>
<span class="kd">by</span> <span class="o">{</span>
  <span class="k">assume</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="n">hxS</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">S</span> <span class="bp">∈</span> <span class="bp">𝓝</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mem_nhds_sets</span> <span class="n">S.property</span> <span class="n">hxS</span><span class="o">,</span>
  <span class="c1">-- … same long detailed proof as before …</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="o">})</span>
</code></pre></div>



<a name="234447412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234447412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234447412">(Apr 14 2021 at 06:26)</a>:</h4>
<p>I don't find that totally satisfying, because it feels like a fair bit of fuss for what in a paper/blackboard proof would be done almost without comment, and it feels like something that <em>should</em> in principle be totally possible for a computer to see.</p>
<p>But I guess there isn't currently code around that can do it. Maybe I'll see if if I can figure out how to make a tactic that does. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="234447704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234447704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234447704">(Apr 14 2021 at 06:31)</a>:</h4>
<p>Yeah, <code>wlog</code> doesn't handle "by symmetry" proofs of this form. It can case split on <code>S &lt;= T \/ T &lt;= S</code> but that doesn't make sense here because <code>opens real</code> is not totally ordered.</p>



<a name="234447723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234447723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234447723">(Apr 14 2021 at 06:31)</a>:</h4>
<p>Yeah, that makes sense</p>



<a name="234448308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448308">(Apr 14 2021 at 06:37)</a>:</h4>
<p>FWIW I would set up your proof like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mk_opens_R_aux</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">#</span><span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>
  <span class="c1">-- (Any dense set would do just as well in place of ℚ.)</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">ℝ</span><span class="o">),</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="n">ball</span> <span class="o">(</span><span class="n">p.1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">p.2</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">},</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span><span class="o">},</span> <span class="n">f</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">T</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">mk_le_of_injective</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">,</span> <span class="o">(</span><span class="n">this</span> <span class="n">hST</span><span class="o">)</span><span class="bp">.</span><span class="n">antisymm</span> <span class="o">(</span><span class="n">this</span> <span class="n">hST.symm</span><span class="o">))</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span> <span class="n">x</span> <span class="n">hxS</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">S</span> <span class="bp">∈</span> <span class="bp">𝓝</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">mem_nhds_sets</span> <span class="n">S.property</span> <span class="n">hxS</span><span class="o">,</span>
  <span class="bp">...</span> <span class="c1">-- as before</span>
<span class="kd">end</span>
</code></pre></div>



<a name="234448551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448551">(Apr 14 2021 at 06:39)</a>:</h4>
<p>Thanks. Ah, yeah, the <code>{S T}</code> trick simplifies that next line. And using \le instead of \sub means skipping the <code>opens.ext</code> translation.</p>



<a name="234448584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448584">(Apr 14 2021 at 06:39)</a>:</h4>
<p>Presumably the commented fact "An open set in ℝ is uniquely determined by the [any dense set] balls included in it." is itself a mathlib worthy lemma, separated from any cardinality facts.</p>



<a name="234448683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448683">(Apr 14 2021 at 06:40)</a>:</h4>
<p>I'd be happy to PR it! I will certainly clean up the proof first (most of all in the parts that come after the part this question is about.)</p>



<a name="234448741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448741">(Apr 14 2021 at 06:41)</a>:</h4>
<p>the statement can also be stated in terms of <code>2^omega</code></p>



<a name="234448849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448849">(Apr 14 2021 at 06:42)</a>:</h4>
<p>I was writing it up as the main part of another fun fact about the open sets in ℝ:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The open sets in ℝ have the same cardinality as ℝ. -/</span>
<span class="c1">-- Probably the right level of generality for this is a separable... uniform space?</span>
<span class="c1">-- At least any separable metric space.</span>
<span class="kd">lemma</span> <span class="n">mk_opens_R</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">#</span><span class="n">ℝ</span> <span class="o">:=</span>
</code></pre></div>
<p>which I think likely also belongs in mathlib. Though it's possible the main work needed for that is already present -- I looked in places specific to ℝ but haven't tried to find it in the places where the main lemma at the right level of generality would live.</p>



<a name="234448923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234448923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234448923">(Apr 14 2021 at 06:43)</a>:</h4>
<p>(And as the comment says, I haven't even worked out yet at a mathematical level what level of generality that is.)</p>



<a name="234452446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234452446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234452446">(Apr 14 2021 at 07:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/by.20symmetry/near/234448308">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">{</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">mk_le_of_injective</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">,</span> <span class="o">(</span><span class="n">this</span> <span class="n">hST</span><span class="o">)</span><span class="bp">.</span><span class="n">antisymm</span> <span class="o">(</span><span class="n">this</span> <span class="n">hST.symm</span><span class="o">))</span> <span class="o">},</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Ah, and the reason you're using <code>@mk_le_of_injective</code> there is to specify <code>f</code>, which is the same effect my version above was getting with <code>show injective f,</code>.</p>
<p>I do like <code>show</code> when it makes things clearer, but here it really isn't adding anything beyond specifying <code>f</code>.</p>



<a name="234462279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/by%20symmetry/near/234462279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/by.20symmetry.html#234462279">(Apr 14 2021 at 08:40)</a>:</h4>
<p><span class="user-mention" data-user-id="397997">@Greg Price</span> Here's a golf of the remainder of your proof, without fundamentally changing the proof approach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mk_opens_R_aux</span> <span class="o">:</span> <span class="bp">#</span><span class="o">(</span><span class="n">opens</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">#</span><span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>
  <span class="c1">-- (Any dense set would do just as well in place of ℚ.)</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">ℝ</span><span class="o">),</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">×</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="n">ball</span> <span class="o">(</span><span class="n">p.1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="n">p.2</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">},</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">S</span> <span class="n">T</span><span class="o">},</span> <span class="n">f</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">T</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">mk_le_of_injective</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span><span class="o">,</span> <span class="o">(</span><span class="n">this</span> <span class="n">hST</span><span class="o">)</span><span class="bp">.</span><span class="n">antisymm</span> <span class="o">(</span><span class="n">this</span> <span class="n">hST.symm</span><span class="o">))</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">S</span> <span class="n">T</span> <span class="n">hST</span> <span class="n">x</span> <span class="o">(</span><span class="n">hxS</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">),</span> <span class="k">show</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ε</span><span class="o">,</span> <span class="n">hεpos</span><span class="o">,</span> <span class="n">hball</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_nhds_iff.1</span> <span class="o">(</span><span class="n">mem_nhds_sets</span> <span class="n">S.2</span> <span class="n">hxS</span><span class="o">),</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">εQ</span><span class="o">,</span> <span class="n">h0εQ</span><span class="o">,</span> <span class="n">hεQ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_pos_rat_lt</span> <span class="o">(</span><span class="n">half_pos</span> <span class="n">hεpos</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">ball_mem_nhds</span> <span class="n">x</span> <span class="o">(</span><span class="n">rat.cast_pos.2</span> <span class="n">h0εQ</span><span class="o">),</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">yR</span><span class="o">,</span> <span class="o">⟨</span><span class="n">yQ</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">hyballx</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">dense_embedding_of_rat.dense.inter_nhds_nonempty</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">set.subset.trans</span> <span class="o">(</span><span class="n">ball_half_subset</span> <span class="n">_</span> <span class="o">(</span><span class="n">ball_subset_ball</span> <span class="n">hεQ.le</span> <span class="n">hyballx</span><span class="o">))</span> <span class="n">hball</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">yQ</span><span class="o">,</span> <span class="n">εQ</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">set.subset.trans</span> <span class="o">(</span><span class="n">ball_subset_ball</span> <span class="n">hεQ.le</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hST</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="o">(</span><span class="n">mem_ball_comm.mp</span> <span class="n">hyballx</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>It's possible that you can do more by generalizing to dense embeddings or something</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
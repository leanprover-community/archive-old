---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html">prefunctor?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209886466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886466">(Sep 12 2020 at 15:41)</a>:</h4>
<p>I don't know what this is actually called....</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">prefunctor</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_hom</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_hom</span> <span class="n">D</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span>
<span class="o">(</span><span class="n">map</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">obj</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">obj</span> <span class="n">Y</span><span class="o">))</span>
</code></pre></div>


<p>Does this exist somewhere in mathlib?</p>



<a name="209886531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886531">(Sep 12 2020 at 15:42)</a>:</h4>
<p>it's like <code>functor</code> (the <code>_root_</code> one)</p>



<a name="209886547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886547">(Sep 12 2020 at 15:42)</a>:</h4>
<p>Right, I know that. But I would like to use it with <code>has_hom</code>, as above.</p>



<a name="209886570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886570">(Sep 12 2020 at 15:43)</a>:</h4>
<p>I'm building the free category associated to a type <code>C</code> with a <code>has_hom</code> instance, and this is what is needed to state its universal property.</p>



<a name="209886778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886778">(Sep 12 2020 at 15:48)</a>:</h4>
<p>it probably doesn't exist (otherwise <code>functor</code> would have depended on it)</p>



<a name="209886800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886800">(Sep 12 2020 at 15:49)</a>:</h4>
<p>I was at one point meaning to give this the perhaps controversial name of "diagram"</p>



<a name="209886860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886860">(Sep 12 2020 at 15:50)</a>:</h4>
<p>These things do actually show up in math. One thing I know about specifically is in defining Nori's version of the motivic Galois group, and he does indeed call them "diagrams"</p>



<a name="209886951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886951">(Sep 12 2020 at 15:52)</a>:</h4>
<p>"pregraph" also makes sense for a name.</p>



<a name="209886976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886976">(Sep 12 2020 at 15:53)</a>:</h4>
<p>Anyway, in case anyone is interested:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/free_cat/src/category_theory/category/free.lean">https://github.com/leanprover-community/mathlib/blob/free_cat/src/category_theory/category/free.lean</a></p>



<a name="209886985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886985">(Sep 12 2020 at 15:53)</a>:</h4>
<p>You can also define what it means to be the (co)limit of one of these things--having a functor and, in particular, a domain <em>category</em> isn't necessary, and not always convenient. (I guess this is to some extent related to wanting to use these things to talk about free categories.)</p>



<a name="209887027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887027">(Sep 12 2020 at 15:54)</a>:</h4>
<p>Right.</p>



<a name="209887042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887042">(Sep 12 2020 at 15:54)</a>:</h4>
<p>e.g. a pushout is a colimit of a diagram indexed on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo><mo>←</mo><mo>⋅</mo><mo>→</mo><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot \leftarrow \cdot \to \cdot</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span></span></span></span>, with no category structure implied &amp; therefore no identity morphisms</p>



<a name="209887053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887053">(Sep 12 2020 at 15:55)</a>:</h4>
<p>so in that context, the name diagram makes some sense.</p>



<a name="209887255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887255">(Sep 12 2020 at 15:57)</a>:</h4>
<p>Yeah I agree. A guess a lot of the stuff in the <code>shapes</code> dir can be made into diagrams (or free categories associated with a diagram).</p>



<a name="209889547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889547">(Sep 12 2020 at 16:46)</a>:</h4>
<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class="user-mention" data-user-id="110032">@Reid Barton</span></p>



<a name="209889556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889556">(Sep 12 2020 at 16:47)</a>:</h4>
<p>nope</p>



<a name="209889842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889842">(Sep 12 2020 at 16:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209889547">said</a>:</p>
<blockquote>
<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class="user-mention silent" data-user-id="110032">Reid Barton</span></p>
</blockquote>
<p>On the "unrelated" topic -- I recently did something with those given I wanted to keep using vim for lean -- the most straightforward way for all the unicode stuff without getting too far inside the lean LSP was I basically used the translations.json file from the lean vscode extension and autogenerated snippets from it for vim to use, which I put here: <a href="https://github.com/Julian/lean-unicode.vim/blob/main/Ultisnips/lean.snippets">https://github.com/Julian/lean-unicode.vim/blob/main/Ultisnips/lean.snippets</a> -- presuming emacs has a way to load ultisnips formatted snippets that may already be usable exactly as is)</p>



<a name="209889897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889897">(Sep 12 2020 at 16:54)</a>:</h4>
<p>Yeah I guess I can do something with <code>yasnippet</code> (the canonocal(?) snippet package in emacs)</p>



<a name="209890071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209890071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209890071">(Sep 12 2020 at 16:58)</a>:</h4>
<p>Okay, that works. I just made a snippet file for <code>yasnippet</code> that looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span> <span class="n">key</span><span class="o">:</span> <span class="n">funct</span>
<span class="bp">#</span> <span class="n">name</span><span class="o">:</span> <span class="n">func_symb</span>
<span class="bp">#</span> <span class="c1">--</span>
<span class="err">⥤$</span><span class="mi">0</span>
</code></pre></div>



<a name="209896928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209896928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209896928">(Sep 12 2020 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209889547">said</a>:</p>
<blockquote>
<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class="user-mention silent" data-user-id="110032">Reid Barton</span></p>
</blockquote>
<p>I think we might be allowed to add it to <code>lean-mode</code>.  All the input translations are defined by <code>lean-input-translations</code> in <a href="https://github.com/leanprover/lean-mode/blob/master/lean-input.el">https://github.com/leanprover/lean-mode/blob/master/lean-input.el</a>  (though if you want to experiment locally, you can customize <code>lean-input-user-translations</code>)</p>
<p>Does VSCode already have a way to input the category theory functor symbol?  If not, maybe <code>\Functor</code> (vs <code>\functor</code>)?</p>



<a name="209897607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Peattie <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897607">(Sep 12 2020 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209896928">said</a>:</p>
<blockquote>
<p>Does VSCode already have a way to input the category theory functor symbol?  If not, maybe <code>\Functor</code> (vs <code>\functor</code>)?</p>
</blockquote>
<p>Yeah it's <code>\functor</code> currently (<a href="https://github.com/leanprover/vscode-lean/blob/v0.16.13/translations.json#L1075">source</a>)</p>



<a name="209897659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Peattie <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897659">(Sep 12 2020 at 20:06)</a>:</h4>
<p>oh sorry, I misunderstood <code>\functor</code> is mapped to ⥤</p>



<a name="209897852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897852">(Sep 12 2020 at 20:11)</a>:</h4>
<p>I think \func suffices in vscode.</p>



<a name="209897896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897896">(Sep 12 2020 at 20:12)</a>:</h4>
<p>Actually, that's useful to know.  It seems like <code>\functor</code> in VSCode is <code>⥤</code> and <code>\Rightarrow</code> is <code>⇒</code>, where in emacs <code>\functor</code> and various other options give only <code>⇒</code>.</p>



<a name="209897902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897902">(Sep 12 2020 at 20:12)</a>:</h4>
<p>I wouldn't mind if <code>\functor</code> in emacs were <code>⥤</code></p>



<a name="209898224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898224">(Sep 12 2020 at 20:21)</a>:</h4>
<p>Ok, here's a PR: <a href="https://github.com/leanprover/lean-mode/pull/29">https://github.com/leanprover/lean-mode/pull/29</a></p>



<a name="209898298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898298">(Sep 12 2020 at 20:23)</a>:</h4>
<p>Does the melpa package mirror this?</p>



<a name="209898385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898385">(Sep 12 2020 at 20:25)</a>:</h4>
<p>I don't know how it works, other than changes I've made in the past eventually appear in melpa</p>



<a name="209898393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898393">(Sep 12 2020 at 20:25)</a>:</h4>
<p>Ok cool</p>



<a name="209898407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898407">(Sep 12 2020 at 20:26)</a>:</h4>
<p>I look forward to this getting merged!</p>



<a name="209898462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898462">(Sep 12 2020 at 20:26)</a>:</h4>
<p>If there are other missing symbols, this might be a good time to add them</p>



<a name="209898527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898527">(Sep 12 2020 at 20:28)</a>:</h4>
<p>That's the main one I've been frustrated with. Maybe <span class="user-mention" data-user-id="110032">@Reid Barton</span> has others he would like to see?</p>



<a name="209898532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898532">(Sep 12 2020 at 20:28)</a>:</h4>
<p>Nothing else comes to mind</p>



<a name="209903664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209903664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209903664">(Sep 12 2020 at 23:01)</a>:</h4>
<p>Refactoring <code>functor</code> to use <code>prefunctor</code> (I like <code>diagram</code>!) sounds like a great idea.</p>



<a name="209905117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209905117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209905117">(Sep 12 2020 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209903664">said</a>:</p>
<blockquote>
<p>Refactoring <code>functor</code> to use <code>prefunctor</code> (I like <code>diagram</code>!) sounds like a great idea.</p>
</blockquote>
<p>I agree. The question is how to do it. Note that to define a sufficiently nontrivial notion of a morphism between <code>prefunctor</code>s, you need to make some sort of <code>has_comp</code> class (in order to state the naturality condition).</p>



<a name="209905932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209905932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209905932">(Sep 13 2020 at 00:06)</a>:</h4>
<p>Isn't <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.category_struct/src">src#category_theory.category_struct</a> all that we need?</p>



<a name="209906341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209906341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209906341">(Sep 13 2020 at 00:19)</a>:</h4>
<p>Oh right. And that also allows us to define an "indentity" morphism.</p>



<a name="209955189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209955189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209955189">(Sep 13 2020 at 23:54)</a>:</h4>
<p>you guys can use <code>func</code> for <code>⥤</code> in Emacs by adding the following snippet as part of your <code>lean-mode-hook</code>:</p>
<div class="codehilite"><pre><span></span><code>  <span class="p">(</span><span class="nv">lean-input-incorporate-changed-setting</span>
   <span class="ss">&#39;lean-input-user-translations</span>
   <span class="o">`</span><span class="p">(</span> <span class="p">(</span><span class="s">&quot;func&quot;</span> <span class="s">&quot;⥤&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="s">&quot;tf&quot;</span> <span class="s">&quot;⟨╯°□°⟩╯︵┻━┻&quot;</span><span class="p">)</span>
<span class="p">))</span>
</code></pre></div>



<a name="209955981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209955981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209955981">(Sep 14 2020 at 00:18)</a>:</h4>
<p>tf?</p>



<a name="209956372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209956372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209956372">(Sep 14 2020 at 00:28)</a>:</h4>
<p>It must be the little-used principle of <em>tabula furorem</em></p>



<a name="211927329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927329">(Oct 01 2020 at 15:23)</a>:</h4>
<p>Did you make any progress on <code>prefunctor</code> / <code>diagram</code>, <span class="user-mention" data-user-id="243562">@Adam Topaz</span>? We'll soon have three copies of the <code>lift</code>/ <code>ι</code> relationship ((<code>free</code>|<code>exterior</code>|<code>universal_enveloping</code>) <code>_algebra</code>), and I was looking at adding <code>clifford_algebra</code> too...</p>



<a name="211927376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927376">(Oct 01 2020 at 15:23)</a>:</h4>
<p>Sorry, I've been busy with teaching :(</p>



<a name="211927569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927569">(Oct 01 2020 at 15:24)</a>:</h4>
<p>But I'm not sure the <code>lift</code> / <code>\iota</code> stuff really relates to this.</p>



<a name="211927801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927801">(Oct 01 2020 at 15:26)</a>:</h4>
<p>How would you like to use these <code>diagram</code>s in this context?</p>



<a name="211928281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211928281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211928281">(Oct 01 2020 at 15:29)</a>:</h4>
<p>You said yourself you wanted to use it to state the universal property, and I think somehow I saw a connection - but I can't see it any more.</p>



<a name="211928526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211928526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211928526">(Oct 01 2020 at 15:31)</a>:</h4>
<p>Oh, I was referring to the universal property specifically for the free category associated to a <code>diagram</code>.</p>



<a name="211928555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211928555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211928555">(Oct 01 2020 at 15:31)</a>:</h4>
<p>the analogue of <code>\iota</code> in that case is a <code>prefunctor</code>.</p>



<a name="211929072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211929072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211929072">(Oct 01 2020 at 15:34)</a>:</h4>
<p>I think I was hoping for a bundling of <code>lift</code> and  <code>ι</code>, so that we can state the theorems about the bundle in just one place rather than repeating them</p>



<a name="211952981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211952981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211952981">(Oct 01 2020 at 18:24)</a>:</h4>
<p>The bundle of <code>lift</code> and <code>\iota</code> in this case just means that you have an initial object in some category, and initial objects are in mathlib already. But I don't necessarily think that's a more useful description than just keeping <code>lift</code> and <code>\iota</code> around as is.</p>



<a name="211955224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211955224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211955224">(Oct 01 2020 at 18:40)</a>:</h4>
<p>(deleted)</p>



<a name="211990000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211990000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211990000">(Oct 01 2020 at 23:50)</a>:</h4>
<p>My preference would be for adding <em>in addition</em> to the existing <code>lift</code> and <code>\iota</code> the formulation as an initial object.</p>



<a name="211990031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211990031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211990031">(Oct 01 2020 at 23:51)</a>:</h4>
<p>In practice one is usually happy to use the explicit <code>lift</code> and <code>\iota</code> in most places. But it is a nice verification that we've really stated the right properties to have the initial object formulation.</p>



<a name="211992673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211992673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211992673">(Oct 02 2020 at 00:33)</a>:</h4>
<p>I agree with this. But the examples <span class="user-mention" data-user-id="310045">@Eric Wieser</span> mentioned are all left adjoints. I presume a better route would be to prove the adjunction <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="211993171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993171">(Oct 02 2020 at 00:41)</a>:</h4>
<p>Some other category libraries have a notion like "something determined by a universal property", generally an initial/terminal object of a comma category, I think. Then this can be used to define limits and maybe adjunctions and so on.</p>



<a name="211993226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993226">(Oct 02 2020 at 00:42)</a>:</h4>
<p>I think it's the kind of concept that in informal mathematics we can recognize but don't really have a name for.</p>



<a name="211993234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993234">(Oct 02 2020 at 00:42)</a>:</h4>
<p>Because it is too basic/central somehow.</p>



<a name="211993241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993241">(Oct 02 2020 at 00:43)</a>:</h4>
<p>Do you have an example of such a library in mind?</p>



<a name="211993274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993274">(Oct 02 2020 at 00:43)</a>:</h4>
<p>Could this be a replacement for, e.g.  the localization stuff?</p>



<a name="211993322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993322">(Oct 02 2020 at 00:44)</a>:</h4>
<p>e.g. <a href="https://github.com/HoTT/HoTT/blob/master/theories/Categories/KanExtensions/Core.v#L167-L168">https://github.com/HoTT/HoTT/blob/master/theories/Categories/KanExtensions/Core.v#L167-L168</a></p>



<a name="211993346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993346">(Oct 02 2020 at 00:45)</a>:</h4>
<p><a href="https://github.com/HoTT/HoTT/blob/master/theories/Categories/UniversalProperties.v#L68-L69">https://github.com/HoTT/HoTT/blob/master/theories/Categories/UniversalProperties.v#L68-L69</a></p>



<a name="211993383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993383">(Oct 02 2020 at 00:46)</a>:</h4>
<p><a href="https://github.com/HoTT/HoTT/blob/092ebba509710c6e3eadbe03bc68049dd0b4ea0c/theories/Categories/Category/Objects.v#L36-L37">https://github.com/HoTT/HoTT/blob/092ebba509710c6e3eadbe03bc68049dd0b4ea0c/theories/Categories/Category/Objects.v#L36-L37</a></p>



<a name="211993440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993440">(Oct 02 2020 at 00:46)</a>:</h4>
<p><a href="https://github.com/HoTT/HoTT/blob/master/theories/Categories/Limits/Core.v#L107-L108">https://github.com/HoTT/HoTT/blob/master/theories/Categories/Limits/Core.v#L107-L108</a></p>



<a name="211993613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993613">(Oct 02 2020 at 00:50)</a>:</h4>
<p>Is this definition of initial objects correct? is the empty type contractible (in HoTT)?</p>



<a name="211993639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993639">(Oct 02 2020 at 00:51)</a>:</h4>
<p>It's the homsets out that are contractible</p>



<a name="211993648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993648">(Oct 02 2020 at 00:51)</a>:</h4>
<p>Oh right</p>



<a name="211993727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993727">(Oct 02 2020 at 00:53)</a>:</h4>
<p>wait I mean what happens if there are no morphisms from x to x'?</p>



<a name="211993741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993741">(Oct 02 2020 at 00:53)</a>:</h4>
<p>The empty type is not contractible</p>



<a name="211993782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993782">(Oct 02 2020 at 00:54)</a>:</h4>
<p>(whoops internet is flaky in that room)</p>



<a name="211993900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993900">(Oct 02 2020 at 00:57)</a>:</h4>
<p>I think one version of this concept is as follows. Sometimes, you have a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">U : D \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> which doesn't necessarily have a left adjoint but for some particular <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X \in C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, you can still find an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>X</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">FX \in D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> such that for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> there's an iso <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>F</mi><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>U</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Hom}(FX, Y) = \mathrm{Hom}(X, UY)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>.</p>



<a name="211993960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993960">(Oct 02 2020 at 00:58)</a>:</h4>
<p>for example, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mi>I</mi></msup></mrow><annotation encoding="application/x-tex">U : C \to C^I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span></span></span></span></span></span></span> could be the diagonal functor and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">FX</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> the colimit of a specific diagram <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X : I \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p>



<a name="211994066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994066">(Oct 02 2020 at 01:00)</a>:</h4>
<p>We have the notion of a colimit of a specific diagram, and we know (I guess, or could easily add) that the whole colimit <em>functor</em> is adjoint to the diagonal functor when it exists, but AFAIK we don't have a way to say how an individual colimit is related to the diagonal functor.</p>



<a name="211994109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994109">(Oct 02 2020 at 01:01)</a>:</h4>
<p>You can probably do something with cones</p>



<a name="211994191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994191">(Oct 02 2020 at 01:03)</a>:</h4>
<p>The cone category we have is basically a one-off construction of the comma category of the diagonal functor.</p>



<a name="211994285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994285">(Oct 02 2020 at 01:04)</a>:</h4>
<p>whereas those HoTT library snippets I linked to build it up incrementally</p>



<a name="211994290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994290">(Oct 02 2020 at 01:04)</a>:</h4>
<p>I have no idea how well that works for usability, of course</p>



<a name="211994417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994417">(Oct 02 2020 at 01:07)</a>:</h4>
<p>For localization (of a ring, say, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[S^{-1}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>) you could look for an initial object of the full subcategory of the slice category consisting of the guys where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> gets sent to invertible elements. But I don't know if it's the most convenient way to say it.</p>



<a name="211995032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211995032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211995032">(Oct 02 2020 at 01:19)</a>:</h4>
<p>I imagine there are a few styles that might possibly work, such as "every concept is an initial/terminal object in some auxiliary category", or "every concept is a Kan extension", or to do everything with profunctors and the coend calculus.</p>



<a name="211995753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211995753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211995753">(Oct 02 2020 at 01:33)</a>:</h4>
<p>None of these approaches (if implemented in lean) would solve the issue of universes when defining the universal properties, would they?</p>



<a name="211997278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211997278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211997278">(Oct 02 2020 at 02:06)</a>:</h4>
<p>I don't think so, and moreover I think this is actually a real math issue that we usually ignore (generally it's obvious once you've constructed the object that satisfies the universal property, but a priori the object could depend on the ambient universe).</p>



<a name="214778481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214778481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214778481">(Oct 27 2020 at 23:39)</a>:</h4>
<p>I was just looking up a result in Makkai and Paré's book on accessible categories and I notice that they define the notions of (co)limit (co)cone in the generality being discussed here. They call a <code>has_hom</code> a "graph* (actually I don't think they ever define the term "graph", but it's clear this must be what they mean) and a <code>prefunctor</code> a "diagram".</p>



<a name="214778592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214778592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214778592">(Oct 27 2020 at 23:40)</a>:</h4>
<p>Also, I think in Higher Topos Theory (co)limits can be indexed on any simplicial set, which are basically the higher equivalent of graphs in this context.</p>



<a name="214783351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214783351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214783351">(Oct 28 2020 at 00:43)</a>:</h4>
<p>Sounds good to me! (I wonder what the people in the secret graph theory stream think about this <span class="user-mention" data-user-id="306601">@Kyle Miller</span> <span class="user-mention" data-user-id="252300">@Jalex Stark</span> ?)</p>



<a name="214783441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214783441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214783441">(Oct 28 2020 at 00:44)</a>:</h4>
<p>It's public now!</p>



<a name="214783478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214783478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214783478">(Oct 28 2020 at 00:45)</a>:</h4>
<p>I think the graphs in mathlib are not so great at carrying data for other structures yet, but I bet Kyle would have useful opinions.</p>



<a name="214783644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214783644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214783644">(Oct 28 2020 at 00:47)</a>:</h4>
<p>I guess this was meant to lend weight more to the term "diagram" than the term "graph", which might mean other things elsewhere (though <code>category_theory.graph</code> seems okay, for a renaming of <code>category_theory.has_hom</code>?)</p>



<a name="214783722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214783722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214783722">(Oct 28 2020 at 00:48)</a>:</h4>
<p>Maybe <code>has_arrow</code> instead of <code>has_hom</code>?</p>



<a name="214783820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214783820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214783820">(Oct 28 2020 at 00:49)</a>:</h4>
<p>Or more precisely <code>has_arrow</code> (in the root namespace) instead of <code>category_theory.has_hom</code>?</p>



<a name="214799371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214799371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214799371">(Oct 28 2020 at 06:17)</a>:</h4>
<p>This notion of a graph sounds like a quiver to me (and quivers evoke category theory, which is a nice perk, compared to "directed graph").  Calling it a <code>quiver</code> might be too restrictive, though, if you want to study different collections of arrows on the same objects type, but I can't immediately think of a case where you'd want to do this.</p>
<p>I like <span class="user-mention" data-user-id="243562">@Adam Topaz</span>'s suggestion, but maybe plural as <code>has_arrows</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">class</span> <span class="n">has_arrows</span> <span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">arrows</span> <span class="o">:</span> <span class="n">obj</span> <span class="bp">→</span> <span class="n">obj</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>



<a name="214829321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214829321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214829321">(Oct 28 2020 at 12:33)</a>:</h4>
<p>To me (as someone working on representation theory of finite dimensional algebras and quivers), quiver sounds like the correct notion for that kind of object. It means precisely directed graph (with multiple arrows and loops allowed, and typically also has no finiteness restrictions). I definitely know use-cases where one would like to study different collections of arrows on the same object type. As discussed in some other graph theory thread previously, a typical other way to encode a quiver is via a collection of vertices (objects), a collection of arrows (homs) and two functions (in my area called either s and t or t and h, indicating the start and terminal vertex).</p>



<a name="214843257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214843257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214843257">(Oct 28 2020 at 14:25)</a>:</h4>
<p>The nlab agrees: <a href="https://ncatlab.org/nlab/show/quiver">https://ncatlab.org/nlab/show/quiver</a></p>



<a name="214843563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214843563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214843563">(Oct 28 2020 at 14:27)</a>:</h4>
<p>Although my brain associates the term <code>quiver</code> specifically to a <code>diagram</code> with values in the category of <code>k</code>-vector spaces.</p>



<a name="214843655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214843655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214843655">(Oct 28 2020 at 14:27)</a>:</h4>
<p>Presumably this object is still going to underlie every category, though. I don't think it's really normal to say that the category of groups has an underlying "quiver" (<a href="https://ncatlab.org/nlab/show/concept+with+an+attitude#quivers">https://ncatlab.org/nlab/show/concept+with+an+attitude#quivers</a>)</p>



<a name="214843820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214843820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214843820">(Oct 28 2020 at 14:28)</a>:</h4>
<p>I agree. That's why I think <code>has_arrow(s)</code> is a good compromise between category theory and graph theory.</p>



<a name="214843936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214843936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214843936">(Oct 28 2020 at 14:29)</a>:</h4>
<p>It still means we would change the name <code>hom</code> for the homsets of a category. Would we change the field name for the action of a functor too?</p>



<a name="214844207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214844207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214844207">(Oct 28 2020 at 14:31)</a>:</h4>
<p>We could keep the name <code>hom X Y</code> for <code>has_arrow.arrow X Y</code> in the case where <code>X Y : C</code> and <code>C</code> is a category.</p>



<a name="214844346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214844346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214844346">(Oct 28 2020 at 14:32)</a>:</h4>
<p>How would we do that?</p>



<a name="214844370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214844370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214844370">(Oct 28 2020 at 14:32)</a>:</h4>
<p>Or just make <code>hom</code> an alias for <code>has_arrow.arrow</code>.</p>



<a name="214844372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214844372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214844372">(Oct 28 2020 at 14:32)</a>:</h4>
<p>Like as an abbreviation?</p>



<a name="214844492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214844492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214844492">(Oct 28 2020 at 14:33)</a>:</h4>
<p>It's used in so many places in record constructor syntax, and as a component in other names, that it just feels like stirring up trouble to think about changing it...</p>



<a name="214845059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214845059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214845059">(Oct 28 2020 at 14:38)</a>:</h4>
<p>Will this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category</span>

<span class="kd">class</span> <span class="n">has_arrow</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">category_theory.has_hom</span> <span class="n">α</span>
</code></pre></div>



<a name="214880606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214880606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214880606">(Oct 28 2020 at 18:41)</a>:</h4>
<p>It seems like the easiest thing is to call it a "hom-graph" in the docstring and then do nothing <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A "hom-graph" is a directed graph attached to a vertex type.  The</span>
<span class="sd">set of directed edges ("arrows") from vertex `a` to vertex `b` is</span>
<span class="sd">given by `hom a b`, for which this module provides the notation `a ⟶ b` -/</span>
<span class="kd">class</span> <span class="n">has_hom</span> <span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="n">obj</span> <span class="bp">→</span> <span class="n">obj</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>

<p>Then we can say a quiver "is" a hom-graph, in the sense that a quiver's vertex type can be given a <code>has_hom</code> instance.  With one possible definition of a quiver:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">quiver</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">homs</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">homs</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">quiver.has_hom</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">quiver</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_hom</span> <span class="n">Q.V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">subtype</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">Q.homs</span> <span class="bp">|</span> <span class="n">Q.s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">Q.t</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">w</span><span class="o">}</span> <span class="o">}</span>
</code></pre></div>

<p>With this setup, it would be nice if prefunctors (or preprefunctors?) would apply to <code>has_hom</code> to be able to study quiver representations.</p>



<a name="214883599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214883599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214883599">(Oct 28 2020 at 19:04)</a>:</h4>
<p>(I've wondered about the duality between defining directed graphs in terms of directed edge sets (<code>has_hom</code>) or as spans (<code>quiver</code>).  Is there a category theoretic name for the kind of object <code>has_hom</code> is?)</p>



<a name="214905554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214905554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214905554">(Oct 28 2020 at 22:29)</a>:</h4>
<p>In the case of graphs (without composition/category structure) this is the equivalence of categories between, for a fixed set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, the category of sets with a map to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and the category of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-indexed families of sets. I think this one is too basic to really have a name, but fancier versions of it go by names like the Grothendieck construction or straightening/unstraightening.</p>



<a name="214905562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214905562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214905562">(Oct 28 2020 at 22:29)</a>:</h4>
<p>For graphs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> would be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V \times V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>.</p>



<a name="214905693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214905693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214905693">(Oct 28 2020 at 22:31)</a>:</h4>
<p>For categories, the presentation in terms of <code>s</code> and <code>t</code> is as the models of an <a href="https://ncatlab.org/nlab/show/essentially+algebraic+theory">essentially algebraic theory</a> while the one in terms of a family of sets indexed by two objects is as the modules of a <a href="https://ncatlab.org/nlab/show/generalized+algebraic+theory">generalized algebraic theory</a>.</p>



<a name="214905923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214905923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214905923">(Oct 28 2020 at 22:33)</a>:</h4>
<p>I also like to think of the first one as "categories internal to Set" and the second as "categories enriched in Set" although those phrases are likely to be confusing.</p>



<a name="214929604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/214929604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#214929604">(Oct 29 2020 at 06:07)</a>:</h4>
<p>Another applications of quivers and diagrams that I dream of leanifying is the category of Nori motives, which built as quiver representation on a quiver of schemes.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
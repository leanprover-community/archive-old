---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html">generators smul generators generate</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="229107944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229107944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229107944">(Mar 06 2021 at 15:55)</a>:</h4>
<p>Dear All,</p>
<p>let <code>S</code> be an  <code>R</code>-algebra and <code>M</code> an <code>S</code>-module.  Suppose that <code>gs : set S</code> is a set of generators of <code>S</code>as an <code>R</code>-module and <code>gm : set M</code> is a set of generators of <code>M</code> as an <code>S</code>-module.  Is it already in Lean the statement that the products <code>s • m</code>, for <code>s ∈ gs</code> and <code>m ∈ gm</code>generate <code>M</code> as an <code>R</code>-module?</p>
<p>Thank you!</p>



<a name="229107962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229107962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229107962">(Mar 06 2021 at 15:55)</a>:</h4>
<p>(deleted)</p>



<a name="229108027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108027">(Mar 06 2021 at 15:56)</a>:</h4>
<p>Fixed!</p>



<a name="229108197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108197">(Mar 06 2021 at 15:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">span_smul</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">span</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">•</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">span</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict_scalars</span> <span class="n">R</span> <span class="o">:=</span>
</code></pre></div>



<a name="229108200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108200">(Mar 06 2021 at 15:59)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/b04aeb5e19faa21c2ae76158fc8454bb236f5f4f/src/algebra/algebra/tower.lean#L266">https://github.com/leanprover-community/mathlib/blob/b04aeb5e19faa21c2ae76158fc8454bb236f5f4f/src/algebra/algebra/tower.lean#L266</a></p>



<a name="229108211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108211">(Mar 06 2021 at 15:59)</a>:</h4>
<p>Great, thanks Kenny!</p>



<a name="229108313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108313">(Mar 06 2021 at 16:00)</a>:</h4>
<p>Is your statement something like <code>[algebra R S] [module S M] (hs : subalgebra.adjoin gs = \top) (hm : submodule.span S gm =\top) : submodule.span R {...} = \top</code>?</p>



<a name="229108351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108351">(Mar 06 2021 at 16:00)</a>:</h4>
<p>Eric, yes, with some <code>is_scalar_tower</code> scattered around as well.</p>



<a name="229108407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108407">(Mar 06 2021 at 16:01)</a>:</h4>
<p>I will try to see if what Kenny sent works, but it looks like it is exactly what I need!</p>



<a name="229108554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229108554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229108554">(Mar 06 2021 at 16:03)</a>:</h4>
<p>Unrelatedly, the <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.smul_mem_span_smul'">docs#submodule.smul_mem_span_smul'</a> next to Kenny's lemma looks like a special case of <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.smul_mem">docs#submodule.smul_mem</a>?</p>



<a name="229118831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229118831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229118831">(Mar 06 2021 at 18:34)</a>:</h4>
<p>Continuing in this thread, I like the \smul notation for multiplying <code>set ??</code>, but it seems that I cannot smultiply <code>finset ??</code> by <code>finset ??</code>. </p>
<p>Since I am a little worried of <code>finset</code>, before embarking in proving that the smultiplication of finsets is a finset, I wanted to make sure that this is really not in mathlib yet.</p>
<p>So...  are finsets smultiplicable in mathlib?</p>



<a name="229118926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229118926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229118926">(Mar 06 2021 at 18:35)</a>:</h4>
<p>(For those who are curious about why I care about this, I am trying to prove that in the "generator tower" mentioned at the beginning of the thread, if I start with finite generating sets for the two parts, then I get a finite generating set over the whole tower.)</p>



<a name="229120434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229120434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229120434">(Mar 06 2021 at 18:59)</a>:</h4>
<p>Why not just use sets with a <code>finite</code> hypothesis? I think this makes things easier.</p>



<a name="229124215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229124215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229124215">(Mar 06 2021 at 19:56)</a>:</h4>
<p>Ok, I will try!</p>



<a name="229124961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229124961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229124961">(Mar 06 2021 at 20:06)</a>:</h4>
<p>Kevin, your suggestion reduces my problem to the lemma below.  If you have any suggestions of what I can try to remove the sorry, I will be happy to hear it!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.tower</span>

<span class="kd">lemma</span> <span class="n">finite.smul_of_finite</span> <span class="o">{</span><span class="n">S</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229125168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229125168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229125168">(Mar 06 2021 at 20:09)</a>:</h4>
<p>The library will know that the product of G and v (a subset of S x M) is finite, and that the image of a finite set is finite.</p>



<a name="229125759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229125759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229125759">(Mar 06 2021 at 20:18)</a>:</h4>
<p>So, I should first prove that <code>(G • v)</code> is a fintype?  Sorry about the silly questions, but I am not really able to make much progress on this.</p>



<a name="229126903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229126903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229126903">(Mar 06 2021 at 20:34)</a>:</h4>
<p>I managed to construct a function from the cartesian product to the smul-product, but even assuming a fintype instance on the product, Lean would not allow me to prove fintype from a surjection:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finite.smul_of_finite</span> <span class="o">{</span><span class="n">S</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gG</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">vM</span><span class="o">⟩⟩,</span> <span class="o">⟨</span><span class="n">g</span> <span class="bp">•</span> <span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">vM</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">v</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">fintype.of_surjective</span> <span class="n">f</span> <span class="n">_</span><span class="o">,</span>
<span class="c1">--- here is the error:</span>
<span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">S</span><span class="o">,</span>
<span class="n">_inst_3</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">,</span>
<span class="n">_inst_4</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span>
<span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">,</span>
<span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">,</span>
<span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span><span class="o">),</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_a</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span><span class="o">),</span>
       <span class="n">_a.cases_on</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">fst</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">snd</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">v</span><span class="o">),</span>
            <span class="n">subtype.cases_on</span> <span class="n">fst</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">fst_val</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">fst_property</span> <span class="o">:</span> <span class="n">fst_val</span> <span class="bp">∈</span> <span class="n">G</span><span class="o">),</span>
                 <span class="n">subtype.cases_on</span> <span class="n">snd</span>
                   <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">snd_val</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">snd_property</span> <span class="o">:</span> <span class="n">snd_val</span> <span class="bp">∈</span> <span class="n">v</span><span class="o">),</span>
                      <span class="n">id_rhs</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">}</span> <span class="o">⟨</span><span class="n">fst_val</span> <span class="bp">•</span> <span class="n">snd_val</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩))))</span>
      <span class="n">_x</span><span class="o">,</span>
<span class="n">_inst</span> <span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span>
<span class="bp">⊢</span> <span class="n">fintype</span> <span class="o">(</span><span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span><span class="o">)</span>

<span class="kd">end</span>
</code></pre></div>



<a name="229127644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229127644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229127644">(Mar 06 2021 at 20:45)</a>:</h4>
<p>Does <code>letI</code> work better than haveI?</p>



<a name="229127706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229127706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229127706">(Mar 06 2021 at 20:46)</a>:</h4>
<p>Eric, I got it down to just the product instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finite.smul_of_finite</span> <span class="o">{</span><span class="n">S</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gG</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">vM</span><span class="o">⟩⟩,</span> <span class="o">⟨</span><span class="n">g</span> <span class="bp">•</span> <span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">vM</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="o">{</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">fintype.of_surjective</span> <span class="n">f</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">j_val</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">g</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">gG</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">mv</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">subtype.mk_eq_mk.mpr</span> <span class="n">rfl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">finite.smul_of_finite</span> <span class="n">fG</span> <span class="n">fv</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229127905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229127905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229127905">(Mar 06 2021 at 20:48)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/prod.fintype">docs#prod.fintype</a>?</p>



<a name="229128074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128074">(Mar 06 2021 at 20:50)</a>:</h4>
<p>I think that the issue is that when I write <code>G</code>, it is no longer a set, but a weird type and Lean does not seem to know that G.fintype means that this weird type is also a fintype...</p>



<a name="229128107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128107">(Mar 06 2021 at 20:51)</a>:</h4>
<p>so when I apply prod.fintype, Lean tells me that there is no fintype instance on <code>G</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">S</span><span class="o">,</span>
<span class="n">_inst_3</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">,</span>
<span class="n">_inst_4</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">,</span>
<span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">,</span>
<span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">,</span>
<span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span><span class="o">),</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_a</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span> <span class="bp">×</span> <span class="bp">↥</span><span class="n">v</span><span class="o">),</span>
       <span class="n">_a.cases_on</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">fst</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">snd</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">v</span><span class="o">),</span>
            <span class="n">subtype.cases_on</span> <span class="n">fst</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">fst_val</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">fst_property</span> <span class="o">:</span> <span class="n">fst_val</span> <span class="bp">∈</span> <span class="n">G</span><span class="o">),</span>
                 <span class="n">subtype.cases_on</span> <span class="n">snd</span>
                   <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">snd_val</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">snd_property</span> <span class="o">:</span> <span class="n">snd_val</span> <span class="bp">∈</span> <span class="n">v</span><span class="o">),</span>
                      <span class="n">id_rhs</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">}</span> <span class="o">⟨</span><span class="n">fst_val</span> <span class="bp">•</span> <span class="n">snd_val</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩))))</span>
      <span class="n">_x</span>
<span class="bp">⊢</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="n">G</span>
</code></pre></div>



<a name="229128207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128207">(Mar 06 2021 at 20:52)</a>:</h4>
<p>Well add two new haveIs for those instances then!</p>



<a name="229128219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128219">(Mar 06 2021 at 20:52)</a>:</h4>
<p>Indeed!  This is where I am now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finite.smul_of_finite</span> <span class="o">{</span><span class="n">S</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gG</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">vM</span><span class="o">⟩⟩,</span> <span class="o">⟨</span><span class="n">g</span> <span class="bp">•</span> <span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">vM</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">G</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">v</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prod.fintype</span> <span class="n">G</span> <span class="n">v</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">fintype.of_surjective</span> <span class="n">f</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">j_val</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">g</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">gG</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">mv</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">subtype.mk_eq_mk.mpr</span> <span class="n">rfl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">finite.smul_of_finite</span> <span class="n">fG</span> <span class="n">fv</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229128240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128240">(Mar 06 2021 at 20:53)</a>:</h4>
<p>library_search: <code>haveI : fintype G := set.finite.fintype fG</code>!</p>



<a name="229128281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128281">(Mar 06 2021 at 20:53)</a>:</h4>
<p>This works!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finite.smul_of_finite</span> <span class="o">{</span><span class="n">S</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">⟨⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">gG</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">vM</span><span class="o">⟩⟩,</span> <span class="o">⟨</span><span class="n">g</span> <span class="bp">•</span> <span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">vM</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">set.finite.fintype</span> <span class="n">fG</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">set.finite.fintype</span> <span class="n">fv</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">prod.fintype</span> <span class="n">G</span> <span class="n">v</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">fintype.of_surjective</span> <span class="n">f</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">j_val</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">gG</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">g</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">gG</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">mv</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">subtype.mk_eq_mk.mpr</span> <span class="n">rfl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">finite.smul_of_finite</span> <span class="n">fG</span> <span class="n">fv</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229128292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128292">(Mar 06 2021 at 20:53)</a>:</h4>
<p>It feels unnecessarily complicated, but I am happy to have it now!</p>



<a name="229128725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128725">(Mar 06 2021 at 21:00)</a>:</h4>
<p>The whole point is to avoid finset and fintype completely</p>



<a name="229128826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229128826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229128826">(Mar 06 2021 at 21:00)</a>:</h4>
<p>You do everything with sets and then show that everything is finite.</p>



<a name="229129143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229129143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229129143">(Mar 06 2021 at 21:05)</a>:</h4>
<p>I tried to use sets, but when I write <code>G × v</code>, Lean converts this to something that is not a set.  Is there a way of getting the cartesian product without making it into a strange type?</p>



<a name="229129395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229129395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229129395">(Mar 06 2021 at 21:09)</a>:</h4>
<p><code>set.finite.fintype fg</code> is <code>fg.fintype</code> I think</p>



<a name="229129415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229129415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229129415">(Mar 06 2021 at 21:09)</a>:</h4>
<p>And you should be able to get away without the third haveI</p>



<a name="229129680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229129680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229129680">(Mar 06 2021 at 21:13)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/set.prod">docs#set.prod</a>?</p>



<a name="229131267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229131267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229131267">(Mar 06 2021 at 21:38)</a>:</h4>
<p>Well, I give up for today.</p>
<p>I also realized that my "proof" above does not actually work!</p>
<p>Hopefully it will all seem simpler when I get back to this!</p>



<a name="229140547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229140547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229140547">(Mar 07 2021 at 00:10)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.tower</span>

<span class="kd">lemma</span> <span class="n">finite.smul_of_finite</span> <span class="o">{</span><span class="n">S</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">fG</span> <span class="o">:</span> <span class="n">G.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">fv</span> <span class="o">:</span> <span class="n">v.finite</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">•</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="n">fG.image2</span> <span class="o">(</span><span class="bp">•</span><span class="o">)</span> <span class="n">fv</span>
</code></pre></div>
<p>Sorry I didn't get to this earlier -- I was having family time. The <code>set.finite</code> API should be, IMNSHO, the go-to way for mathematicians to deal with finiteness. <code>finset</code> and <code>fintype</code> are these type-valued finiteness things which experts seem to be able to use and can't see what the fuss is all about when us regular people whinge about instance problems because they understand all the details of what's going on. The advantage of <code>finset</code> over <code>finite</code> is that it's computable, but computability is worth absolutely nothing to me, and I find Prop-valued finiteness much easier to use.</p>



<a name="229160695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229160695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229160695">(Mar 07 2021 at 06:04)</a>:</h4>
<p>Kevin, thank you so much for the proof and also for the information about <code>finset</code> vs <code>finite</code>.  I did not realize that one of them was easier to work with and was using <code>finset</code> simply because that was what I had seen in mathlib.</p>
<p>Even though I had problems working with <code>finite</code>, it did appear easier to navigate than <code>finset</code>.</p>
<p>I certainly tried <code>library_search</code> on the lemma above.  Why did it fail?  Is it because of the fact that one of the inputs is a function?</p>



<a name="229167545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229167545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229167545">(Mar 07 2021 at 08:04)</a>:</h4>
<p>I don't know. I just looked at the definition of G bub v, saw it used set.image2, so knew that the answer was going to be set.finite.image2 . I agree that <code>library_search</code> could have found this.</p>



<a name="229168386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168386">(Mar 07 2021 at 08:17)</a>:</h4>
<p>I tried looking at the definition of the \smul, but what I clicked took me to <code>has_scalar</code>, which was probably not what you found.</p>



<a name="229168438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168438">(Mar 07 2021 at 08:18)</a>:</h4>
<p>But this is the pattern in general, eg in my sketch above I went via <a href="http://set.prod">set.prod</a> and the proof that a product of two finite sets is finite is <a href="http://set.finite.prod">set.finite.prod</a> . The "weird type" you're talking about above is just the coercion to Type. This is what happens when you bundle subobjects. Because things like <code>set X</code> and <code>subgroup G</code> ( if G is a group) are types, this means that things like <code>H : subgroup G</code> are terms, which is not how we mathematicians usually think about them -- we would usually think of a subgroup as being a group itself. This is why we have the notation g \in H, to remind us that the type of g is still G and the relationship between g and H is something else. This is fine sometimes, but if you actually want to think about H as a type itself rather than a term (eg if you really want to define a function with source H and cannot or will not think about it as the restriction of a function defined on G, or you want to talk about a subgroup of H and cannot or will not think of it as a subgroup of G contained in H) then you need to have a way to promote H to a type. This is done via <code>has_coe_to_sort</code> and as I've implied it's often something I try to avoid because it looks a bit inelegant, but it's not hard to understand: the promotion of the subset <code>{x | p x}</code> is the subtype <code>{x // p x}</code> and a term of this type is just a pair consisting of x : G and a proof that <code>x \in H</code> so you can do <code>cases</code> on it and use pointy bracket notation etc.</p>



<a name="229168451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168451">(Mar 07 2021 at 08:18)</a>:</h4>
<p>I just assumed that it was set up in such a way that once you set up <code>smul</code> for types, then it automatically picks up what to do with subsets of those types.</p>



<a name="229168546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168546">(Mar 07 2021 at 08:20)</a>:</h4>
<p>Re definition: you need to use the infoview correctly. You looked at the definition of the notation in general. If you inspect the bub in G bub v you can see it's something like set.has_scalar (I think -- not at lean right now) and this is where you can see it's <code>image2</code>.</p>



<a name="229168811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168811">(Mar 07 2021 at 08:24)</a>:</h4>
<p>Thanks, Kevin!  The stuff on coercions is very helpful!  It is something that I am starting to understand, but I still struggle with.  For instance, I would like to avoid these coercions, but sometimes I feel that Lean corners me into using them and I am rarely able to exit the resulting mess.  However, it is not always clear to me what it is that I did wrong that took me to such an undesirable place!</p>



<a name="229168884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168884">(Mar 07 2021 at 08:25)</a>:</h4>
<p>I indeed Ctrl-clicked the bullet in the code side, and did not think of clicking on the infoview and then specializing to the correct bullet to go to the correct definition!  <em>Now</em> I found it!  Thanks again!</p>



<a name="229168986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229168986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229168986">(Mar 07 2021 at 08:27)</a>:</h4>
<p>You treated a term as a type, that's what makes <code>has_coe_to_sort</code> kick in. We're taught that everything is a term and some terms are types but this is a bad way of thinking about things. If you think of everything as precisely one of a term, a type and a universe then you get a much better model of how type theory is used in mathematics in general.</p>



<a name="229169042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169042">(Mar 07 2021 at 08:28)</a>:</h4>
<p>well, some terms <em>are</em> types: <code>nat</code> is a type and also a term of type <code>Type</code></p>



<a name="229169099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169099">(Mar 07 2021 at 08:29)</a>:</h4>
<p>of course when we talk about terms used as types we usually mean terms whose type is not <code>Type</code> or <code>Prop</code> but something like <code>finset A</code>, in which case you need a coercion</p>



<a name="229169101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169101">(Mar 07 2021 at 08:29)</a>:</h4>
<p>&lt;/pedantic&gt;</p>



<a name="229169339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169339">(Mar 07 2021 at 08:33)</a>:</h4>
<p>The fact that nat is a term is for me deemed harmful. I don't see any use of this and I would accept a model of type theory where there were two different colons, one of the form term : type and one of the form type :: universe.</p>



<a name="229169497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169497">(Mar 07 2021 at 08:35)</a>:</h4>
<p>Ok, while I knew this, I am glad that Kevin also finds it a little bit of a coincidence that <code>nat</code> is a term!</p>
<p>I view this as the type-theory analogue of the fact that you <em>can</em> wonder about whether ℕ is an <em>element</em> of π in set-theory, but you really shouldn't!</p>



<a name="229169564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169564">(Mar 07 2021 at 08:36)</a>:</h4>
<p>I remember as a beginner trying to draw a map of Lean's type theory and starting with Prop : Type which is in some sense the most harmful of all the "random" term : type relations. It took me a long time to realise that Prop and Type were the same kind of thing and that this relation between them was of no use. We have a system where we can ask if nat = Prop and for me this is embarrassing, it's a junk question. I have constantly emphasised this universe/type/term viewpoint in my teaching and I think it makes it clearer to mathematicians</p>



<a name="229169835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229169835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229169835">(Mar 07 2021 at 08:41)</a>:</h4>
<p>I certainly find it closer to my intuition to separate Props from non-Props.  In fact, I sometimes have troubles applying inductions (Edit: in Lean!) and I think that the issue is often related to the fact that there is a blur between whether you are doing it on Prop or Type (or something like that).</p>
<p>Yet, I find it interesting that this distinction is not so strong and you can talk about Props on a similar footing as "usual mathematical objects".  I guess that this is something that is no news to logicians, but I find charming these concepts!</p>



<a name="229170500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229170500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229170500">(Mar 07 2021 at 08:51)</a>:</h4>
<p><code>Prop : Type</code> and <code>nat : Type</code> make sense in the context of <code>list Prop</code> and <code>list nat</code>, respectively a list of statements and a list of integers</p>



<a name="229171026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229171026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229171026">(Mar 07 2021 at 09:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/generators.20smul.20generators.20generate/near/229169339">said</a>:</p>
<blockquote>
<p>The fact that nat is a term is for me deemed harmful. I don't see any use of this and I would accept a model of type theory where there were two different colons, one of the form term : type and one of the form type :: universe.</p>
</blockquote>
<p>This kind of type theory exists; it's actually quite common outside DTT circles. For example Haskell's type theory distinguishes between "terms", "types" and "kinds"; so for example <code>1 : int</code> and <code>int : *</code> where <code>*</code> is the kind of all types (what we would call <code>Type</code>). This is useful when talking about "higher kinded types" like <code>list : * -&gt; *</code>, where <code>* -&gt; *</code> is another "kind". (Of course this is no biggie for a DTT user, but if you are used to dealing with just types then these "types of types" are a little mind blowing.)</p>



<a name="229171198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229171198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229171198">(Mar 07 2021 at 09:02)</a>:</h4>
<p>I guess the DTT crowd saw this and said "well you're duplicating all the work now with a typehood relation that looks just like the other one. What if you need kinds of kinds? So let's make an infinite hierarchy of kinds of kinds of kinds and call them universes"</p>



<a name="229171337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229171337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229171337">(Mar 07 2021 at 09:05)</a>:</h4>
<p>This solves the problem of having many kinds of typehood judgment, at the cost of universe hierarchy management. Lean uses a little nat-like algebra of levels, while Coq uses a partial order of globally coherent universe constraints, and I think they are both lotsa complicated when we only really care about somewhere between 0 and 1 universes</p>



<a name="229172917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229172917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229172917">(Mar 07 2021 at 09:31)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I would be surprised if there were any lists of Props occurring anywhere in mathlib other than in meta code. I can fully believe that this is an important concept in tactic-writing but this is an abstraction layer i never go into in my teaching.</p>



<a name="229173086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173086">(Mar 07 2021 at 09:34)</a>:</h4>
<p>Perhaps <a href="https://leanprover-community.github.io/mathlib_docs/find/tfae">docs#tfae</a> uses it?</p>



<a name="229173203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173203">(Mar 07 2021 at 09:35)</a>:</h4>
<p>Or whatever the full name is...</p>



<a name="229173304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173304">(Mar 07 2021 at 09:36)</a>:</h4>
<p>I think that's a secret def that doc-gen doesn't want to tell me about?</p>



<a name="229173307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173307">(Mar 07 2021 at 09:37)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.tfae">docs#list.tfae</a> ?</p>



<a name="229173333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173333">(Mar 07 2021 at 09:37)</a>:</h4>
<p>Ironic how <code>list</code> was in the name!  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="229173401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173401">(Mar 07 2021 at 09:38)</a>:</h4>
<p>I did not know about <code>tfae</code>.</p>



<a name="229173755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173755">(Mar 07 2021 at 09:44)</a>:</h4>
<p>tfae is the only example I know</p>



<a name="229173760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173760">(Mar 07 2021 at 09:44)</a>:</h4>
<p>In fact <code>list Prop</code> is useless in meta code because <code>Prop</code> has no computational content</p>



<a name="229173762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173762">(Mar 07 2021 at 09:44)</a>:</h4>
<p>it may as well be <code>list unit</code></p>



<a name="229173870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173870">(Mar 07 2021 at 09:46)</a>:</h4>
<p>I think a much more important use of types as terms is in things like <code>ring A</code> where the application of <code>A</code> to <code>ring</code> is the same as the application of <code>f</code> to <code>x</code> in any function application <code>f x</code></p>



<a name="229173988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229173988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229173988">(Mar 07 2021 at 09:48)</a>:</h4>
<p>It's possible to get by with this being two different kinds of application but it's at best a notational headache</p>



<a name="229187625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229187625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229187625">(Mar 07 2021 at 13:28)</a>:</h4>
<p>In the current definition of simple graphs in mathlib, edges are given by <code>V -&gt; V -&gt; Prop</code>, so a list of statements whether an edge is in the graph would also be <code>list Prop</code></p>



<a name="229187762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229187762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229187762">(Mar 07 2021 at 13:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/generators.20smul.20generators.20generate/near/229169339">said</a>:</p>
<blockquote>
<p>The fact that nat is a term is for me deemed harmful. I don't see any use of this</p>
</blockquote>
<p>How would you then phrase statements like "the naturals are countable", "the reals are uncountable"?</p>



<a name="229187767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229187767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229187767">(Mar 07 2021 at 13:30)</a>:</h4>
<p>Surely it would be <code>list (sym2 V)</code>?</p>



<a name="229187815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229187815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229187815">(Mar 07 2021 at 13:31)</a>:</h4>
<p>You're right, I mean a list of <code>edge \in graph</code></p>



<a name="229187938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229187938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229187938">(Mar 07 2021 at 13:33)</a>:</h4>
<p>I think one of the smarter things that is in Lean syntax is differentiating cartesian products from the type level to the term level: <code>term : (⬝,⬝) vs type (⬝ × ⬝)</code>, unlike Haskell which uses <code>(,)</code> for both.</p>



<a name="229194133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229194133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229194133">(Mar 07 2021 at 15:06)</a>:</h4>
<p>Well, in haskell you don't need to since types and terms are different</p>



<a name="229194165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229194165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229194165">(Mar 07 2021 at 15:07)</a>:</h4>
<p>You wouldn't really be able to unify them in lean because they have different (incompatible) types</p>



<a name="229194243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/generators%20smul%20generators%20generate/near/229194243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/generators.20smul.20generators.20generate.html#229194243">(Mar 07 2021 at 15:08)</a>:</h4>
<p>I once played around with unifying lambda and pi, which is just about doable (you just treat lambda as pi when it is used as a type)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
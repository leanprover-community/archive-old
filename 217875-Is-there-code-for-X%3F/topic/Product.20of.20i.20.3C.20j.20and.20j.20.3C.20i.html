---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html">Product of i < j and j < i</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260406273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260406273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260406273">(Nov 05 2021 at 13:42)</a>:</h4>
<p>This was nonsense.<br>
<del>Does someone see a quick way of proving the following?</del></p>



<a name="260407174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260407174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260407174">(Nov 05 2021 at 13:49)</a>:</h4>
<p>Is this true as stated? Why can't the set of i larger than a be empty say and the other one not be?</p>



<a name="260407312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260407312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260407312">(Nov 05 2021 at 13:50)</a>:</h4>
<p>Because I am stupid.</p>



<a name="260407328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260407328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260407328">(Nov 05 2021 at 13:50)</a>:</h4>
<p>Time for  coffee</p>



<a name="260411320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260411320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260411320">(Nov 05 2021 at 14:21)</a>:</h4>
<p>Ok, the real question is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.interval</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">j</span><span class="o">))</span> <span class="bp">=</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I am not asking to do my work, but suggestions are welcome :)</p>



<a name="260411614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260411614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260411614">(Nov 05 2021 at 14:24)</a>:</h4>
<p>I think the RHS is <code>∏ i in (finset.univ : finset ℕ).off_diag, f i.2 - f i.1</code>?</p>



<a name="260412018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260412018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260412018">(Nov 05 2021 at 14:27)</a>:</h4>
<p>You can move multiplication out of the LHS, swap the products on the right factor, then split the prod on the RHS as the <code>i &lt; j</code> and <code>j &lt; i</code> bits.</p>



<a name="260412358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260412358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260412358">(Nov 05 2021 at 14:29)</a>:</h4>
<p>Do we have something like <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.filter_or">docs#finset.filter_or</a></p>



<a name="260412380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260412380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260412380">(Nov 05 2021 at 14:29)</a>:</h4>
<p>It's the "swap the product" part that is causing me troubles.</p>



<a name="260412486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260412486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260412486">(Nov 05 2021 at 14:30)</a>:</h4>
<p>Ah, <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.filter_or">docs#finset.filter_or</a> seems relevant</p>



<a name="260413028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260413028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260413028">(Nov 05 2021 at 14:35)</a>:</h4>
<p>Yeah, <code>simp_rw [ne_iff_lt_or_gt, finset.filter_or],</code> is a good start</p>



<a name="260413196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260413196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260413196">(Nov 05 2021 at 14:36)</a>:</h4>
<p>You might need to turn the double sum in a single one using <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.product">docs#finset.product</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_product">docs#finset.prod_product</a>.</p>



<a name="260413266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260413266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260413266">(Nov 05 2021 at 14:37)</a>:</h4>
<p>And once again Eric, <code>finset.prod_product_right</code> would come in handy!</p>



<a name="260413602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260413602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260413602">(Nov 05 2021 at 14:39)</a>:</h4>
<p>Well, no more handy than <code>rw [prod_product, prod_comm]</code></p>



<a name="260414737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260414737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260414737">(Nov 05 2021 at 14:48)</a>:</h4>
<p>This gets through some of the pain:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">j</span><span class="o">))</span> <span class="bp">=</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ne_iff_lt_or_gt</span><span class="o">,</span> <span class="n">finset.filter_or</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">eq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="o">(</span><span class="n">finset.prod</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.prod_union</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hl</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.mem_inter.1</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">imp</span> <span class="n">finset.mem_filter.1</span> <span class="n">finset.mem_filter.1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">lt_asymm</span> <span class="n">hl</span> <span class="n">hg</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260423004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260423004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260423004">(Nov 05 2021 at 15:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">j</span><span class="o">))</span> <span class="bp">=</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ne_iff_lt_or_gt</span><span class="o">,</span> <span class="n">finset.filter_or</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">eq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="o">(</span><span class="n">finset.prod</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.prod_union</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">conv_rhs</span> <span class="o">{</span>
      <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span>
      <span class="n">conv</span> <span class="o">{</span>
        <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">neg_sub</span><span class="o">,</span> <span class="n">neg_eq_neg_one_mul</span><span class="o">]</span> <span class="o">},</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">,</span> <span class="n">finset.prod_const</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hl</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.mem_inter.1</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">imp</span> <span class="n">finset.mem_filter.1</span> <span class="n">finset.mem_filter.1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">lt_asymm</span> <span class="n">hl</span> <span class="n">hg</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Takes care of one half of the product, the easy part...</p>



<a name="260429878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260429878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260429878">(Nov 05 2021 at 16:34)</a>:</h4>
<p>And let's <code>simp</code> for the win.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod_filter_lt_mul_neg_eq_prod_off_diag</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">j</span><span class="o">))</span> <span class="bp">=</span>
  <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ne_iff_lt_or_gt</span><span class="o">,</span> <span class="n">finset.filter_or</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">eq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="o">(</span><span class="n">finset.prod</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.prod_union</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)),</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">conv_rhs</span> <span class="o">{</span>
      <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span>
      <span class="n">conv</span> <span class="o">{</span>
        <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">neg_sub</span><span class="o">,</span> <span class="n">neg_eq_neg_one_mul</span><span class="o">]</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">,</span> <span class="n">finset.prod_const</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">conv_lhs</span> <span class="o">{</span>
      <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span>
      <span class="n">conv</span> <span class="o">{</span>
        <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">neg_sub</span><span class="o">,</span> <span class="n">neg_eq_neg_one_mul</span><span class="o">]</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">,</span> <span class="n">finset.prod_const</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finset.prod_mul_distrib</span><span class="o">,</span> <span class="n">filter_gt_card</span><span class="o">],</span>
    <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">],</span>
    <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.prod_sigma'</span><span class="o">,</span> <span class="n">finset.prod_sigma'</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">finset.prod_bij'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="o">⟨</span><span class="n">i.2</span><span class="o">,</span> <span class="n">i.1</span><span class="o">⟩)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="o">⟨</span><span class="n">i.2</span><span class="o">,</span> <span class="n">i.1</span><span class="o">⟩)</span>
      <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hl</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset.mem_inter.1</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">imp</span> <span class="n">finset.mem_filter.1</span> <span class="n">finset.mem_filter.1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">lt_asymm</span> <span class="n">hl</span> <span class="n">hg</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260432589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260432589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260432589">(Nov 05 2021 at 16:53)</a>:</h4>
<p>Does this lemma generalize to <code>g i j = f i - f j</code>?</p>



<a name="260435289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260435289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260435289">(Nov 05 2021 at 17:11)</a>:</h4>
<p>Probably, as long as <code>g i j = - g j i</code>.</p>



<a name="260435420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260435420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260435420">(Nov 05 2021 at 17:12)</a>:</h4>
<p>Oh, or maybe that condition is not even needed</p>



<a name="260435738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260435738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260435738">(Nov 05 2021 at 17:14)</a>:</h4>
<p><del>It can probably be further generalized by replacing ...</del><br>
edit: nevermind</p>



<a name="260436092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Product%20of%20i%20%3C%20j%20and%20j%20%3C%20i/near/260436092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Product.20of.20i.20.3C.20j.20and.20j.20.3C.20i.html#260436092">(Nov 05 2021 at 17:16)</a>:</h4>
<p>Yes, it should be generalized and golfed</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html">linear order on finsupps</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="292692975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292692975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292692975">(Aug 10 2022 at 04:46)</a>:</h4>
<p>Dear All,</p>
<p>is there code already for defining a linear order on finsupps with source and target that are linearly ordered?</p>
<p>Specifically, I would like to have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finsupp.lex</span> <span class="o">{</span><span class="n">α</span> <span class="n">N</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>where <code>f &lt; g</code> if <code>f ≠ g</code> and</p>
<ul>
<li>either <code>f = 0</code>, or</li>
<li>the smallest <code>a : α</code> where <code>f a ≠ g a</code> satisfies <code>f a &lt; g a</code>.</li>
</ul>
<p>This is essentially a lex-order, but I was not able to find it in the <code>lex</code> files.</p>
<p>Thanks!</p>



<a name="292693518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693518">(Aug 10 2022 at 04:56)</a>:</h4>
<p>One observation: it might be convenient to define this as the pullback of the lex order on functions under the embedding of funsupps into functions</p>



<a name="292693531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693531">(Aug 10 2022 at 04:56)</a>:</h4>
<p>I don't see why you need the <code>f = 0</code> case.</p>



<a name="292693548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693548">(Aug 10 2022 at 04:57)</a>:</h4>
<p>The <code>0</code> case was only to be able to talk about the "smallest ...".</p>



<a name="292693578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693578">(Aug 10 2022 at 04:57)</a>:</h4>
<p>Anyway, I have tried getting the functions to work, but I might be missing some imports.</p>



<a name="292693661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693661">(Aug 10 2022 at 04:58)</a>:</h4>
<p>Still it doesn't seem like you need it. If <code>f</code> is minimal, then the smallest <code>a</code> will respect <code>f a &lt; g a</code> (because <code>g a &lt; f a</code> would be contradictory.</p>



<a name="292693681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693681">(Aug 10 2022 at 04:59)</a>:</h4>
<p>Also, you will need <code>N</code> to be well-ordered for the minimal <code>a</code> to even exist.</p>



<a name="292693689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693689">(Aug 10 2022 at 04:59)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pi.lex.linear_order">docs#pi.lex.linear_order</a></p>



<a name="292693702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693702">(Aug 10 2022 at 05:00)</a>:</h4>
<p>If you do not need to split that case, that is fine as well.  I was just worried that applying <code>f</code> to <code>a</code> would cause problems is <code>a</code> was the bottom of <code>with_bot α</code>.</p>



<a name="292693780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693780">(Aug 10 2022 at 05:00)</a>:</h4>
<p>Is well-ordering necessary, since I am always dealing with <code>fin</code>supps?</p>



<a name="292693823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693823">(Aug 10 2022 at 05:01)</a>:</h4>
<p>What I mean is that the minimal <code>a</code> can be chosen in the union of the supports of <code>f</code> and <code>g</code>.</p>



<a name="292693923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693923">(Aug 10 2022 at 05:02)</a>:</h4>
<p>I'll try with <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.lex.linear_order">docs#pi.lex.linear_order</a> and see how far I get, thanks!</p>



<a name="292693954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292693954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292693954">(Aug 10 2022 at 05:03)</a>:</h4>
<p>Oh yeah, maybe not. In that case you can pull back the order from <code>pi.lex</code>, but not its linearity, so you will need to prove that separately.</p>



<a name="292694013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292694013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292694013">(Aug 10 2022 at 05:04)</a>:</h4>
<p>This brings up a lot of memory, so I wonder whether I didn't try implementing this for Shing and his Gröbner bases somewhere.</p>



<a name="292694027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292694027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292694027">(Aug 10 2022 at 05:04)</a>:</h4>
<p>I think I didn't, so please go ahead</p>



<a name="292694061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292694061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292694061">(Aug 10 2022 at 05:05)</a>:</h4>
<p>Ok, so <code>pi.lex</code> will give me an order once I have orders on source and target, right?  And you are saying that this order is linear, but this final fact is not proven?</p>



<a name="292694094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292694094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292694094">(Aug 10 2022 at 05:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/linear.20order.20on.20finsupps/near/292694013">said</a>:</p>
<blockquote>
<p>This brings up a lot of memory, so I wonder whether I didn't try implementing this for Shing and his Gröbner bases somewhere.</p>
</blockquote>
<p>This makes lots of sense to me, since I am thinking about this in the context of <code>add_monoid_algebra</code>s.</p>



<a name="292694499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292694499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292694499">(Aug 10 2022 at 05:11)</a>:</h4>
<p>Yaël, you are suggesting this, correct?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finsupp.lex</span> <span class="o">{</span><span class="n">α</span> <span class="n">N</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">pi.lex</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">lt</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">lt_iff_le_not_le</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">le_total</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">decidable_le</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">decidable_eq</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">decidable_lt</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">max</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">max_def</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">min</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">min_def</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="292695914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292695914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292695914">(Aug 10 2022 at 05:31)</a>:</h4>
<p>You can get at least <code>partial_order</code> for free: <a href="https://leanprover-community.github.io/mathlib_docs/find/partial_order.lift">docs#partial_order.lift</a></p>



<a name="292696064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696064">(Aug 10 2022 at 05:33)</a>:</h4>
<p>Ah, great!  I was having problems proving reflexivity!  With your suggestion, I can probably make it to the end!</p>
<p>I'll let you know if I need more help, but I will get back to this in an hour or so.</p>
<p>Thanks!</p>



<a name="292696113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696113">(Aug 10 2022 at 05:34)</a>:</h4>
<p>You can get <code>lattice</code> from defining <code>sup</code> and <code>inf</code> and then using <a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective.lattice">docs#function.injective.lattice</a>.</p>



<a name="292696132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696132">(Aug 10 2022 at 05:34)</a>:</h4>
<p>So you'll only to prove totality afterwards</p>



<a name="292696176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696176">(Aug 10 2022 at 05:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pi.lex</span>
<span class="kn">import</span> <span class="n">order.synonym</span>
<span class="kn">import</span> <span class="n">data.finsupp.order</span>
<span class="bp">.</span>

<span class="kd">noncomputable</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">N</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">is_well_order</span> <span class="n">α</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">linear_order</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">linear_order.lift'</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="n">function.injective</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)))</span> <span class="n">finsupp.coe_fn_injective</span><span class="o">)</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">to_lex</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="mi">1</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">to_lex</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="mi">1</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292696251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696251">(Aug 10 2022 at 05:36)</a>:</h4>
<p>And now try getting rid of <code>is_well_order</code> <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>



<a name="292696306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696306">(Aug 10 2022 at 05:37)</a>:</h4>
<p>For Damiano I would imagine alpha is <code>fin n</code> or something anyways</p>



<a name="292696345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696345">(Aug 10 2022 at 05:37)</a>:</h4>
<p>I suspect it might be <code>int</code></p>



<a name="292696593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696593">(Aug 10 2022 at 05:41)</a>:</h4>
<p>Alex, I would prefer to leave α arbitrary, but <code>fin n</code> is one of the main players.</p>
<p>Yaël, <code>N</code> is likely to be ℕ or ℤ, depending on whether I'm thinking of polynomials or Laurent polynomials.</p>



<a name="292696645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292696645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292696645">(Aug 10 2022 at 05:42)</a>:</h4>
<p>Anyway, thank you both!  I'll see what I can do with the well-order wrinkle!</p>



<a name="292710940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292710940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292710940">(Aug 10 2022 at 08:11)</a>:</h4>
<p>Can you tell that I do not know my way around the <code>lex</code> API?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pi.lex</span>
<span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">N</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">partial_order</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">partial_order.lift</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="n">function.injective</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">)</span> <span class="bp">→</span> <span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)))</span>
  <span class="n">finsupp.coe_fn_injective</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">ne_or_ne_of_ne</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">ac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inr</span> <span class="o">(</span><span class="n">ne_of_ne_of_eq</span> <span class="n">ab.symm</span> <span class="n">ac</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">ac</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">finsupp.lex</span> <span class="o">{</span><span class="n">α</span> <span class="n">N</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">add_zero_class</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">linear_order</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le_total</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="k">let</span> <span class="n">dfug</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f.support</span> <span class="bp">∪</span> <span class="n">g.support</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">of_lex</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">of_lex</span> <span class="n">g</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">by_cases</span> <span class="n">de</span> <span class="o">:</span> <span class="n">dfug</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">or.inl</span> <span class="o">(</span><span class="n">le_of_eq</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">not_ne_iff.mp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">not_ne_iff.mpr</span> <span class="n">de</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">refine</span> <span class="n">finset.ne_empty_of_mem</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">,</span> <span class="n">finset.mem_union</span><span class="o">,</span> <span class="n">finsupp.mem_support_iff</span><span class="o">],</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">ne_or_ne_of_ne</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">ne.def</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.nonempty_iff_ne_empty</span><span class="o">]</span> <span class="n">at</span> <span class="n">de</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">min</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">dfug.min'</span> <span class="n">de</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">mf</span> <span class="o">:</span> <span class="n">of_lex</span> <span class="n">f</span> <span class="n">min</span> <span class="bp">≤</span> <span class="n">of_lex</span> <span class="n">g</span> <span class="n">min</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">or.inl</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">rcases</span> <span class="n">finset.mem_filter.mp</span> <span class="o">(</span><span class="n">finset.min'_mem</span> <span class="n">_</span> <span class="n">de</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="bp">-</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">min</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">lt_of_le_of_ne</span> <span class="n">mf</span> <span class="n">h</span><span class="o">⟩,</span>
      <span class="n">by_cases</span> <span class="n">js</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">∈</span> <span class="n">f.support</span> <span class="bp">∪</span> <span class="n">g.support</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hj</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">finset.min'_le</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">finset.mem_filter.mpr</span> <span class="o">⟨</span><span class="n">js</span><span class="o">,</span> <span class="n">hj</span><span class="o">⟩)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_union</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">finsupp.mem_support_iff</span><span class="o">,</span> <span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">js</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">js</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">or.inr</span> <span class="o">(</span><span class="n">or.inr</span> <span class="o">⟨</span><span class="n">min</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">not_le.mp</span> <span class="n">mf</span><span class="o">⟩),</span>
      <span class="n">by_cases</span> <span class="n">js</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">∈</span> <span class="n">f.support</span> <span class="bp">∪</span> <span class="n">g.support</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hj</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">finset.min'_le</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">finset.mem_filter.mpr</span> <span class="o">⟨</span><span class="n">js</span><span class="o">,</span> <span class="n">hj.symm</span><span class="o">⟩)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_union</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">finsupp.mem_support_iff</span><span class="o">,</span> <span class="n">not_not</span><span class="o">]</span> <span class="n">at</span> <span class="n">js</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">js</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="n">decidable_le</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">decidable_eq</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">decidable_lt</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">lex</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">)))</span> <span class="o">}</span>
</code></pre></div>



<a name="292714145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292714145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292714145">(Aug 10 2022 at 08:36)</a>:</h4>
<p>I will have a go at it myself when I have access to a computer</p>



<a name="292768986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292768986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292768986">(Aug 10 2022 at 14:45)</a>:</h4>
<p>Should I make a PR about this or is it too niche?  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="292784465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292784465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> FR <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292784465">(Aug 10 2022 at 16:02)</a>:</h4>
<p>It may be helpful to prove <code>is_domain (add_monoid_algebra R (σ → ₀ G))</code>, which can be used in the proof of the Lindemann-Weierstrass theorem. Otherwise it needs a copy of <code>mv_polynomial.is_domain</code>.</p>



<a name="292789635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292789635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292789635">(Aug 10 2022 at 16:32)</a>:</h4>
<p>Yes, my goal is to prove <code>no_zero_divisors</code> on <code>add_monoid_algebra</code>s in as much a generality as I can.</p>



<a name="292790750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292790750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292790750">(Aug 10 2022 at 16:38)</a>:</h4>
<p>I already have a proof with enough covariant assumptions on the grading type.  Now I'd like to make sure that these assumptions are unneeded!</p>



<a name="292809129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/linear%20order%20on%20finsupps/near/292809129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/linear.20order.20on.20finsupps.html#292809129">(Aug 10 2022 at 18:29)</a>:</h4>
<p>I opened two PRs:</p>
<ul>
<li><a href="https://github.com/leanprover-community/mathlib/pull/15983">#15983</a>, where there are results about non-zero divisors in <code>add_monoid_algebra</code>s,</li>
<li><a href="https://github.com/leanprover-community/mathlib/pull/15984">#15984</a>, where there is the proof above that <code>finsupp</code>s can be linearly ordered.</li>
</ul>
<p>Any comments on these PRs are very welcome!  In particular, if you have a use-case in mind for either the linear extensions or the non-existence of zero-divisors, I would be happy to hear about them and try to improve/generalize as needed!</p>
<p>Thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
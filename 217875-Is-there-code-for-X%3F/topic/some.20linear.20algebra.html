---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html">some linear algebra</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291876462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291876462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291876462">(Aug 03 2022 at 16:33)</a>:</h4>
<p>Can someone please let me know if there is a slick way to prove this? I have an <code>n</code> by <code>n</code> matrix <code>Q</code> (which is really a bilinear form on an <code>n</code>-dimensional real vector space <code>F</code>), and a basis <code>vs</code> for <code>F</code> having gram matrix <code>G</code>, that is, the matrix of <code>Q</code> inner products of the <code>vs</code>. Then <code>Q</code> can be expressed as claimed below:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.matrix.bilinear_form</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">linear_algebra_thing</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">bilin_form</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span>
<span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hdim</span> <span class="o">:</span> <span class="n">finite_dimensional.finrank</span> <span class="n">ℝ</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">hvG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">Q</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">w₁</span> <span class="n">w₂</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
<span class="n">Q</span> <span class="n">w₁</span> <span class="n">w₂</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="291878416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291878416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291878416">(Aug 03 2022 at 16:47)</a>:</h4>
<p>before looking at the code more closely (I just came home) : please avoid <code>bilin_form</code>, we have <a href="https://leanprover-community.github.io/mathlib_docs/linear_algebra/sesquilinear_form.html">https://leanprover-community.github.io/mathlib_docs/linear_algebra/sesquilinear_form.html</a> which is way better</p>



<a name="291878682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291878682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291878682">(Aug 03 2022 at 16:49)</a>:</h4>
<p>in your case it would be <code>Q : F →ₗ[ℝ] F →ₗ[ℝ] ℝ</code></p>



<a name="291881256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291881256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291881256">(Aug 03 2022 at 17:07)</a>:</h4>
<p>my first point would be that what you wrote in the text does not match the statement, since <code>vs</code> is not necessarily a basis, so I am not sure whether your claim is actually correct as stated.</p>



<a name="291881528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291881528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291881528">(Aug 03 2022 at 17:08)</a>:</h4>
<p>so I guess you want rather something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.sesquilinear_form</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix.default</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">linear_algebra_thing</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>  <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">hvG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">Q</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">w₁</span> <span class="n">w₂</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
<span class="n">Q</span> <span class="n">w₁</span> <span class="n">w₂</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="291881875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291881875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291881875">(Aug 03 2022 at 17:11)</a>:</h4>
<p>Thanks for your comments! Well, the fact that the gram matrix is invertible and the cardinality of <code>vs</code> is the rank of <code>F</code> means (to a human) that it's a basis. For my application, I'd rather not assume that it's a basis, but sure, I'd be delighted if there was a slick Lean proof of your version of the statement.</p>



<a name="291884573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291884573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291884573">(Aug 03 2022 at 17:32)</a>:</h4>
<p>I think I have to rephrase your problem a little more..</p>



<a name="291885299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291885299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291885299">(Aug 03 2022 at 17:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">coord_bilin_form</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">linear_map.mk₂</span> <span class="n">ℝ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w₁</span> <span class="n">w₂</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span>
  <span class="gr">sorry</span> <span class="gr">sorry</span> <span class="gr">sorry</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">coord_bilin_form_apply</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">w₁</span> <span class="n">w₂</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">coord_bilin_form</span> <span class="n">Q</span> <span class="n">vs</span> <span class="n">G</span> <span class="n">w₁</span> <span class="n">w₂</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">linear_algebra_thing</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">hvG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">Q</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
<span class="n">Q</span> <span class="bp">=</span> <span class="n">coord_bilin_form</span> <span class="n">Q</span> <span class="n">vs</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">linear_map.ext_basis</span> <span class="n">vs</span> <span class="n">vs</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">hvG</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">coord_bilin_form_apply</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hvG</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>So now it is at least reduced to a calculation of matrices.</p>



<a name="291885459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291885459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291885459">(Aug 03 2022 at 17:39)</a>:</h4>
<p>Ah great, thanks! The human proof of this is completely trivial, by the way. If <code>Q</code> is a matrix and <code>V</code> is a matrix of basis vectors for <code>F</code> with gram matrix <code>G=V^t*Q*V</code>, then taking inverses and moving the <code>V</code>'s to the other side, we get <code>Q⁻¹ = V * G⁻¹ * V^t</code>, which is equivalent to the claim...</p>



<a name="291885975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291885975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291885975">(Aug 03 2022 at 17:43)</a>:</h4>
<p>Depending on what you want to use this for it might be easier to express everything in terms of matrices and matrix multiplication first.</p>



<a name="291886207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291886207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291886207">(Aug 03 2022 at 17:44)</a>:</h4>
<p>inverting and transposing matrices works quite well in Lean</p>



<a name="291886315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291886315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291886315">(Aug 03 2022 at 17:45)</a>:</h4>
<p>my idea was to go the exact opposite road and state your lemma in a rather weird invariant way</p>



<a name="291888573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291888573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291888573">(Aug 03 2022 at 18:02)</a>:</h4>
<p>The proof is really not nice:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.sesquilinear_form</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix.default</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">]</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">coord_bilin_form</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">linear_map.mk₂</span> <span class="n">ℝ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w₁</span> <span class="n">w₂</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span>
  <span class="gr">sorry</span> <span class="gr">sorry</span> <span class="gr">sorry</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">coord_bilin_form_apply</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">w₁</span> <span class="n">w₂</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">coord_bilin_form</span> <span class="n">Q</span> <span class="n">vs</span> <span class="n">G</span> <span class="n">w₁</span> <span class="n">w₂</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">linear_algebra_thing</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">hvG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">Q</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">))</span> <span class="o">:</span>
<span class="n">Q.flip</span> <span class="bp">=</span> <span class="n">coord_bilin_form</span> <span class="n">Q</span> <span class="n">vs</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">linear_map.ext_basis</span> <span class="n">vs</span> <span class="n">vs</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">linear_map.flip_apply</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">hvG</span> <span class="n">j</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">coord_bilin_form_apply</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hvG</span><span class="o">],</span>
  <span class="n">simp_rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">G</span> <span class="n">i</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">simp_rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.sum_comm</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="bp">←</span><span class="n">finset.mul_sum</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="bp">←</span><span class="n">matrix.mul_apply</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">matrix.mul_inv_of_invertible</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">matrix.one_apply</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="291889319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291889319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291889319">(Aug 03 2022 at 18:07)</a>:</h4>
<p>it would be ok if there is a lemma that calculates <code>(A.mul (B.mul C)) x y</code> as the <code>finsum</code>, but I haven't found anything in that direction</p>



<a name="291889561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/291889561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#291889561">(Aug 03 2022 at 18:08)</a>:</h4>
<p>but note the <code>flip</code>, it seems that I forgot one transposition when first rewriting your lemma</p>



<a name="292008304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292008304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292008304">(Aug 04 2022 at 13:38)</a>:</h4>
<p>Great, thanks!</p>



<a name="292010177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292010177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292010177">(Aug 04 2022 at 13:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz Doll</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/some.20linear.20algebra/near/291888573">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coord_bilin_form</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">vs</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">linear_map.mk₂</span> <span class="n">ℝ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w₁</span> <span class="n">w₂</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">j</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">G</span><span class="bp">⁻¹</span> <span class="n">i</span> <span class="n">j</span><span class="o">))</span>
  <span class="gr">sorry</span> <span class="gr">sorry</span> <span class="gr">sorry</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>It is rarely necessary to prove linearity conditions like this, there is usually some abstract nonsense.  In this case you could first construct each individual function</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="n">w₁</span> <span class="n">w₂</span><span class="o">,</span> <span class="n">Q</span> <span class="n">w₁</span> <span class="o">(</span><span class="n">vs</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">Q</span> <span class="n">w₂</span> <span class="o">(</span><span class="n">vs</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div>
<p>as a bilinear map using <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map">docs#linear_map</a>.compl₂ and <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.mul">docs#linear_map.mul</a> (if we don't have that construction already) and then add the appropriate scalar multiples of these together.</p>



<a name="292011075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292011075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292011075">(Aug 04 2022 at 13:57)</a>:</h4>
<p>This is a very good point, thanks Heather. I was just lazy and wanted to get the bundled version as fast as possible.</p>



<a name="292011418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292011418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292011418">(Aug 04 2022 at 13:59)</a>:</h4>
<p>There might be also a point to commute the factors (and the summations) in the definition so that the proof gets less annoying</p>



<a name="292011634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292011634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292011634">(Aug 04 2022 at 14:01)</a>:</h4>
<p>but depending on how you replace the naive definition with a bundled one this might actually happen automatically</p>



<a name="292519361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292519361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292519361">(Aug 09 2022 at 02:03)</a>:</h4>
<p>May I ask another stupid question in a similar vein? How would one prove something like this? I have an <code>n</code> by <code>n</code> matrix with <code>-1</code>s on the diagonal and <code>1</code>s off the diagonal. I claim that its inverse matrix has something on the diagonal and something else off the diagonal. What's an efficient (?) way to verify this with a calculation? Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span><span class="bp">=</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Ginv</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hGinv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">Ginv</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">((</span><span class="mi">1</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">)))</span>
  <span class="o">:</span> <span class="n">Ginv.mul</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.mul</span><span class="o">,</span> <span class="n">matrix.dot_product</span><span class="o">,</span> <span class="n">hGinv</span><span class="o">,</span> <span class="n">hG</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292519631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292519631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292519631">(Aug 09 2022 at 02:09)</a>:</h4>
<p>Some progress:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kn">import</span> <span class="n">data.matrix.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span><span class="bp">=</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Ginv</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hGinv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">Ginv</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">((</span><span class="mi">1</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">)))</span>
  <span class="o">:</span> <span class="n">Ginv.mul</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.mul</span><span class="o">,</span> <span class="n">matrix.dot_product</span><span class="o">,</span> <span class="n">hGinv</span><span class="o">,</span> <span class="n">hG</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292521063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292521063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292521063">(Aug 09 2022 at 02:41)</a>:</h4>
<p>I don't think this is correct? The matrix product has (n-1)/n on diagonal and -1/n off diagonal according to my calculation. And when n=2, the matrix G has rank 1 so it doesn't have an inverse.</p>



<a name="292522414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292522414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292522414">(Aug 09 2022 at 03:10)</a>:</h4>
<p>Here's "proof" of it being incorrect, given how it's phrased right now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kn">import</span> <span class="n">data.matrix.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">else</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_singleton'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">else</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">ne</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_singleton'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span><span class="bp">;</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ne.symm</span> <span class="n">h</span><span class="o">]</span>  <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ_erase'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span>  <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">ne</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">,</span> <span class="n">and.comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ_erase'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">,</span> <span class="n">and.comm</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span><span class="bp">=</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Ginv</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hGinv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">Ginv</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">((</span><span class="mi">1</span><span class="bp">-</span><span class="n">n</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">)))</span>
  <span class="o">:</span> <span class="n">Ginv.mul</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.mul</span><span class="o">,</span> <span class="n">matrix.dot_product</span><span class="o">,</span> <span class="n">hGinv</span><span class="o">,</span> <span class="n">hG</span><span class="o">],</span>
  <span class="n">ext</span> <span class="n">i</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">eq_or_ne</span> <span class="n">k</span> <span class="n">i</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">matrix.one_apply</span><span class="o">],</span>
    <span class="n">field_simp</span><span class="o">,</span>
    <span class="n">ring_nf</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">,</span> <span class="n">hn</span><span class="o">],</span>
    <span class="c1">-- false</span>
    <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">matrix.one_apply</span><span class="o">,</span> <span class="n">ne.symm</span> <span class="n">h</span><span class="o">],</span>
    <span class="n">field_simp</span> <span class="o">[</span><span class="n">hn</span><span class="o">],</span>
    <span class="n">ring_nf</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hn</span><span class="o">],</span>
    <span class="c1">-- false</span>
    <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292522488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292522488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292522488">(Aug 09 2022 at 03:13)</a>:</h4>
<p>That's great, thanks! I think I can take it from here...</p>



<a name="292523308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292523308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292523308">(Aug 09 2022 at 03:32)</a>:</h4>
<p>Here's something very bizarre that's happening. This works perfectly well:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>
<span class="kn">import</span> <span class="n">data.matrix.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">else</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_singleton'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">else</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_singleton</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">ne</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_singleton'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">eq</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span><span class="bp">;</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ne.symm</span> <span class="n">h</span><span class="o">]</span>  <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_eq_univ_erase'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span>  <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="bp">∅</span> <span class="k">else</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="n">ne</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">,</span> <span class="n">and.comm</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">finset.filter_ne_univ_erase'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">k</span><span class="o">})</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="bp">\</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">k</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">not_or_distrib</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">,</span> <span class="n">and.comm</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="bp">≥</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span><span class="bp">=</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">Ginv</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hGinv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">Ginv</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="k">then</span> <span class="o">(</span><span class="bp">-</span><span class="o">((</span><span class="bp">-</span><span class="mi">3</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">-</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))))</span>
    <span class="k">else</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">-</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))))</span> <span class="o">:</span>
  <span class="n">Ginv.mul</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">-</span><span class="mi">2</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hh</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.mul</span><span class="o">,</span> <span class="n">matrix.dot_product</span><span class="o">,</span> <span class="n">hGinv</span><span class="o">,</span> <span class="n">hG</span><span class="o">,</span> <span class="n">hh</span><span class="o">,</span> <span class="n">one_div</span><span class="o">,</span> <span class="n">mul_inv_rev</span><span class="o">,</span> <span class="n">mul_ite</span><span class="o">,</span>
      <span class="n">mul_neg</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">matrix.one_apply_eq</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">],</span> <span class="c1">-- squeeze_simp doesn't give full simp!!!???</span>
    <span class="n">field_simp</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.mul</span><span class="o">,</span> <span class="n">matrix.dot_product</span><span class="o">,</span> <span class="n">hGinv</span><span class="o">,</span> <span class="n">hG</span><span class="o">,</span> <span class="n">hh</span><span class="o">,</span> <span class="n">one_div</span><span class="o">,</span> <span class="n">mul_inv_rev</span><span class="o">,</span> <span class="n">mul_ite</span><span class="o">,</span>
      <span class="n">mul_neg</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">matrix.one_apply_ne</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">,</span> <span class="n">hh</span><span class="o">],</span>
    <span class="n">field_simp</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>But if I replace those inner <code>simp</code>s with <code>squeeze_simp</code>s, then it tells me to use this long line:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">,</span> <span class="n">finset.filter_eq_univ'</span><span class="o">,</span> <span class="n">finset.sum_neg_distrib</span><span class="o">,</span> <span class="n">finset.filter_eq_singleton</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">if_true</span><span class="o">,</span>
  <span class="n">finset.sum_const</span><span class="o">,</span> <span class="n">finset.card_singleton</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span> <span class="n">nat.cast_one</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">finset.filter_ne_singleton</span><span class="o">,</span>
  <span class="n">finset.card_empty</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">neg_neg</span><span class="o">,</span> <span class="n">finset.filter_ne_univ</span><span class="o">,</span> <span class="n">finset.filter_eq_univ_erase</span><span class="o">,</span> <span class="n">neg_zero'</span><span class="o">,</span>
  <span class="n">finset.filter_ne_univ_erase</span><span class="o">,</span> <span class="n">finset.pair_self_eq</span><span class="o">,</span> <span class="n">finset.sum_sdiff_eq_sub</span><span class="o">,</span> <span class="n">finset.subset_univ</span><span class="o">,</span> <span class="n">finset.card_fin</span><span class="o">,</span>
  <span class="n">zero_add</span><span class="o">],</span>
</code></pre></div>
<p>which does <em>not</em> simplify to the same amount?!?!?</p>
<p>Thanks again for all your help!!</p>



<a name="292524824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292524824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292524824">(Aug 09 2022 at 04:10)</a>:</h4>
<p>In cases like this, I extract the goal after the simp that works, clean it of coercion arrows, and make that goal into a suffices</p>



<a name="292529393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/some%20linear%20algebra/near/292529393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/some.20linear.20algebra.html#292529393">(Aug 09 2022 at 05:54)</a>:</h4>
<p>Note we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.filter_ne">docs#finset.filter_ne</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.filter_eq">docs#finset.filter_eq</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
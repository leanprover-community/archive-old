---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html">Concrete fraction ring of int</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264745311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264745311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264745311">(Dec 13 2021 at 17:57)</a>:</h4>
<p>Do we have this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">≃+*</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I am building it up manually, juggling all sorts of <code>gcd</code> and <code>dvd</code> proofs. Perhaps we have this equivalence explicitly?</p>



<a name="264745976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264745976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264745976">(Dec 13 2021 at 18:00)</a>:</h4>
<p>This should already be there, maybe the other way round. I'm quite sure.</p>



<a name="264746024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264746024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264746024">(Dec 13 2021 at 18:01)</a>:</h4>
<p>grep gave me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">src</span><span class="bp">/</span><span class="n">ring_theory</span><span class="bp">/</span><span class="n">localization.lean</span>
<span class="mi">1747</span><span class="o">:</span><span class="kd">instance</span> <span class="n">rat.is_fraction_ring</span> <span class="o">:</span> <span class="n">is_fraction_ring</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="o">:=</span>
</code></pre></div>



<a name="264747142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264747142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264747142">(Dec 13 2021 at 18:08)</a>:</h4>
<p>Yes, but that is a Prop. But that does not give the "canonical" iso, right? Also, the API is a little missing here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">is_fraction_ring</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="n">rat.is_fraction_ring</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">is_fraction_ring</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">localization.is_localization</span> <span class="c1">-- library_search or suggest don't solve this</span>
</code></pre></div>



<a name="264757736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264757736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264757736">(Dec 13 2021 at 19:30)</a>:</h4>
<p>Maybe you can use  <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/localization.html#is_localization.ring_equiv_of_ring_equiv">https://leanprover-community.github.io/mathlib_docs/ring_theory/localization.html#is_localization.ring_equiv_of_ring_equiv</a> to get the iso?</p>



<a name="264757761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264757761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264757761">(Dec 13 2021 at 19:30)</a>:</h4>
<p>What do you call the "canonical" iso? When working on Dedekind domain, we somewhat convinced ourselves that having <em>one</em> proof of the iso was enough.</p>



<a name="264758185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264758185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264758185">(Dec 13 2021 at 19:34)</a>:</h4>
<p>Here's what I have so far. It's a WIP, could be I stated something wrong:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="kd">lemma</span> <span class="n">int.nat_abs_sign</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">z.sign.nat_abs</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rcases</span> <span class="n">z</span> <span class="k">with</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">_</span><span class="o">)</span> <span class="bp">|</span> <span class="n">_</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kd">lemma</span> <span class="n">int.nat_abs_sign_of_nonzero</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">z.sign.nat_abs</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">int.nat_abs_sign</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">hz</span><span class="o">]</span>

<span class="c1">-- field of fractions ℚ</span>
<span class="kd">def</span> <span class="n">fwd</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">→</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.mk</span> <span class="n">q.num</span>
    <span class="o">⟨</span><span class="n">q.denom</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">q.pos.ne'</span><span class="o">)⟩</span>

<span class="kd">def</span> <span class="n">rev</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">d</span><span class="o">,</span> <span class="o">⟨</span><span class="n">int.sign</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">/</span> <span class="n">n.gcd</span> <span class="n">d</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">int.nat_abs</span> <span class="n">d</span> <span class="bp">/</span> <span class="n">n.gcd</span> <span class="n">d</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hn</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">zero_lt_one</span> <span class="o">},</span>
    <span class="n">cases</span> <span class="n">d</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">set_like.coe_mk</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">_</span> <span class="bp">|</span> <span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">n.gcd</span> <span class="n">d</span> <span class="bp">∣</span> <span class="n">d.nat_abs</span> <span class="o">:=</span>
      <span class="o">(</span><span class="n">int.nat_abs</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">gcd_dvd_right</span> <span class="o">(</span><span class="n">int.nat_abs</span> <span class="n">d</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">hd</span><span class="o">]</span> <span class="n">using</span> <span class="n">hk</span> <span class="o">},</span>
    <span class="n">replace</span> <span class="n">hd</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d.nat_abs</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hd</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="n">using</span> <span class="n">hd</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">hpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n.gcd</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">int.gcd_pos_of_non_zero_left</span> <span class="n">d</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hk</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">nat.mul_div_assoc</span> <span class="n">_</span> <span class="o">(</span><span class="n">dvd_refl</span> <span class="n">_</span><span class="o">),</span> <span class="n">hpos</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hn</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="n">cases</span> <span class="n">d</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n.gcd</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">int.gcd_pos_of_non_zero_left</span> <span class="n">d</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span> <span class="n">at</span> <span class="n">hd</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">set_like.coe_mk</span><span class="o">,</span> <span class="n">int.nat_abs_div</span> <span class="n">_</span> <span class="n">_</span> <span class="o">((</span><span class="n">n.gcd_dvd_left</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">mul_left</span> <span class="n">d.sign</span><span class="o">),</span>
        <span class="n">int.nat_abs_mul</span><span class="o">,</span> <span class="n">int.nat_abs_sign_of_nonzero</span> <span class="n">hd</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat.coprime_div_gcd_div_gcd</span> <span class="n">hpos</span>
  <span class="kd">end</span><span class="o">⟩)</span>
  <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">a</span> <span class="n">c</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">⟩</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_rec_constant</span><span class="o">,</span> <span class="n">set_like.coe_mk</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">localization.r_iff_exists</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span> <span class="n">at</span> <span class="n">hb</span> <span class="n">hd</span> <span class="n">hk</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set_like.coe_mk</span><span class="o">,</span> <span class="n">mul_eq_mul_right_iff</span><span class="o">,</span> <span class="n">hk</span><span class="o">,</span> <span class="n">or_false</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hc</span> <span class="n">hc</span> <span class="n">ha</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hb</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">hd</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">hc'</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">/</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">int.mul_div_assoc</span> <span class="n">_</span> <span class="o">(</span><span class="n">dvd_refl</span> <span class="n">_</span><span class="o">),</span> <span class="n">int.div_self</span> <span class="n">hb</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">subst</span> <span class="n">hc'</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">int.div_eq_div_of_mul_eq_mul</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">int.gcd_dvd_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mul_left</span> <span class="n">_</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">int.gcd_eq_zero_iff</span><span class="o">,</span> <span class="n">ha</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">int.gcd_eq_zero_iff</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span> <span class="o">},</span>
      <span class="gr">sorry</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="kd">end</span>
  <span class="n">q</span>
</code></pre></div>



<a name="264758203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264758203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264758203">(Dec 13 2021 at 19:34)</a>:</h4>
<p><code>is_fraction_ring</code> asserts that the algebra map <code>ℤ → ℚ</code> is an iso. I'm sure that there is something in mathlib that lets you turn this assertion + <code>algebra_map ℤ ℚ</code> into a <code>ring_equiv</code>.</p>



<a name="264759889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264759889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264759889">(Dec 13 2021 at 19:47)</a>:</h4>
<p>Is this what you are looking for?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">iso</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">≃+*</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="n">is_localization.ring_equiv_of_ring_equiv</span> <span class="n">ℚ</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_equiv.refl</span> <span class="n">ℤ</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">:</span> <span class="n">submonoid.map</span> <span class="o">(</span><span class="n">ring_equiv.refl</span> <span class="n">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">to_monoid_hom</span> <span class="o">(</span><span class="n">non_zero_divisors</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">non_zero_divisors</span> <span class="n">ℤ</span><span class="o">))</span>

<span class="k">#check</span> <span class="n">iso</span>
</code></pre></div>



<a name="264771712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264771712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264771712">(Dec 13 2021 at 21:22)</a>:</h4>
<p><del>Isn't there</del>There is also <a href="https://leanprover-community.github.io/mathlib_docs/find/is_localization.alg_equiv">docs#is_localization.alg_equiv</a> which doesn't need the <code>_of_ring_equiv</code> parameters</p>



<a name="264771909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264771909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264771909">(Dec 13 2021 at 21:24)</a>:</h4>
<p>In particular its specialization <a href="https://leanprover-community.github.io/mathlib_docs/find/fraction_ring.alg_equiv">docs#fraction_ring.alg_equiv</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.to_ring_equiv</span>
</code></pre></div>



<a name="264790554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264790554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264790554">(Dec 14 2021 at 00:25)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> now ask him to do Dedekind reals = Cauchy reals = uniform completion reals = Eudoxus reals!</p>



<a name="264791109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264791109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264791109">(Dec 14 2021 at 00:33)</a>:</h4>
<p>You joke, but I think that the fact that this statement isn't easily proven is helping me identify some API holes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fwd</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">→</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.mk</span> <span class="n">q.num</span>
    <span class="o">⟨</span><span class="n">q.denom</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">q.pos.ne'</span><span class="o">)⟩</span>

<span class="kd">def</span> <span class="n">rev</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.lift_on</span> <span class="n">q</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">d</span><span class="o">,</span> <span class="n">rat.mk</span> <span class="n">n</span> <span class="n">d</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">myiso</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">≃</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">fwd</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">rev</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">myiso.symm</span> <span class="bp">=</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="o">:=</span>
</code></pre></div>



<a name="264791145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264791145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264791145">(Dec 14 2021 at 00:33)</a>:</h4>
<p>Specifically, API in dealing with <code>int.sign</code>, a missing <code>rat.ext</code>, and linking <code>localization</code> and <code>is_localization</code>.</p>



<a name="264791186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264791186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264791186">(Dec 14 2021 at 00:34)</a>:</h4>
<p>I think <code>n / d</code> is the API, not <code>rat.mk</code></p>



<a name="264791312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264791312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264791312">(Dec 14 2021 at 00:35)</a>:</h4>
<p>Right, but that requires me to actually juggle the gcd or lcm, no?</p>



<a name="264792127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264792127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264792127">(Dec 14 2021 at 00:47)</a>:</h4>
<p>Definitely something went wrong if you're talking about gcds</p>



<a name="264796003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264796003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264796003">(Dec 14 2021 at 01:40)</a>:</h4>
<p>It does seem annoying though, this is what I came up with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="kd">def</span> <span class="n">fwd</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">→</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.mk</span> <span class="n">q.num</span>
     <span class="o">⟨</span><span class="n">q.denom</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">q.pos.ne'</span><span class="o">)⟩</span>

<span class="kd">def</span> <span class="n">rev</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.lift_on</span> <span class="n">q</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">d</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">/</span> <span class="n">d</span><span class="o">)</span> <span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">a</span> <span class="n">c</span> <span class="n">b</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">localization.r_iff_exists</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">div_eq_div_iff</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact_mod_cast</span> <span class="n">int.eq_of_mul_eq_mul_right</span> <span class="o">(</span><span class="n">non_zero_divisors.ne_zero</span> <span class="n">k.2</span><span class="o">)</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="o">(</span><span class="n">non_zero_divisors.ne_zero</span> <span class="n">b.2</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="o">(</span><span class="n">non_zero_divisors.ne_zero</span> <span class="n">d.2</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>


<span class="kd">def</span> <span class="n">myiso</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">≃</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">fwd</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">rev</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">rat.num_div_denom</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">apply</span> <span class="n">localization.ind</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩,</span>
    <span class="n">change</span> <span class="n">fwd</span> <span class="o">(</span><span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">localization.mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">localization.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">/</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">localization.mk_eq_mk_iff</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">localization.r_of_eq</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set_like.coe_mk</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">submonoid.coe_one</span><span class="o">],</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">r.denom</span> <span class="bp">=</span> <span class="n">r.num</span> <span class="bp">*</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact_mod_cast</span> <span class="n">this</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">div_eq_div_iff</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">apply</span> <span class="n">rat.num_div_denom</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="o">(</span><span class="n">non_zero_divisors.ne_zero</span> <span class="n">b.2</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact_mod_cast</span> <span class="n">r.denom_ne_zero</span> <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="264796035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264796035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264796035">(Dec 14 2021 at 01:40)</a>:</h4>
<p>I think you're really not supposed to use it this way, and it would be easier to prove that the <code>iso</code> from above equals these functions if you really want that</p>



<a name="264816820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264816820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264816820">(Dec 14 2021 at 06:15)</a>:</h4>
<p>I tried to follow your suggestion, but I'm having trouble with one of the directions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="c1">-- field of fractions ℚ</span>
<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">≃+*</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.to_ring_equiv</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="n">fraction_ring.alg_equiv</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">=</span>
  <span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.lift_on</span> <span class="n">q</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">d</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">))</span>
    <span class="kd">begin</span>
      <span class="n">rintro</span> <span class="n">a</span> <span class="n">c</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">⟩,</span>
      <span class="n">rw</span> <span class="n">localization.r_iff_exists</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩,</span>
      <span class="n">rw</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span> <span class="n">at</span> <span class="n">hb</span> <span class="n">hd</span> <span class="n">hk</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set_like.coe_mk</span><span class="o">,</span> <span class="n">coe_coe</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">div_eq_div_iff</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="bp">←</span><span class="n">int.cast_mul</span><span class="o">,</span> <span class="n">hk</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">int.cast_eq_zero</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">coe_coe</span><span class="o">]</span> <span class="n">using</span> <span class="n">hb</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">int.cast_eq_zero</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">coe_coe</span><span class="o">]</span> <span class="n">using</span> <span class="n">hd</span> <span class="o">},</span>
    <span class="kd">end</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span> <span class="n">n</span> <span class="n">d</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fraction_ring.alg_equiv_apply</span><span class="o">,</span> <span class="n">localization.lift_on_mk</span><span class="o">,</span> <span class="n">localization.mk_eq_mk'</span><span class="o">,</span>
      <span class="n">is_localization.map_mk'</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="c1">-- the equivalence between the two fields is what we expect</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">→</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span>
  <span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.mk</span> <span class="n">q.num</span>
    <span class="o">⟨</span><span class="n">q.denom</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">q.pos.ne'</span><span class="o">)⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">int.cast_coe_nat</span><span class="o">,</span> <span class="n">set_like.coe_mk</span><span class="o">,</span> <span class="n">ring_hom.eq_int_cast</span><span class="o">,</span>
             <span class="n">fraction_ring.alg_equiv_symm_apply</span><span class="o">,</span> <span class="n">localization.mk_eq_mk'</span><span class="o">],</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="264816980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264816980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264816980">(Dec 14 2021 at 06:18)</a>:</h4>
<p>Ehhh I guess I can just use the "forward" result and cheat :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">→</span> <span class="n">fraction_ring</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span>
  <span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">localization.mk</span> <span class="n">q.num</span>
    <span class="o">⟨</span><span class="n">q.denom</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">q.pos.ne'</span><span class="o">)⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">alg_equiv.apply_symm_apply</span><span class="o">,</span> <span class="n">fraction_ring.alg_equiv_apply</span><span class="o">,</span> <span class="n">localization.mk_eq_mk'</span><span class="o">,</span>
      <span class="n">is_localization.map_mk'</span><span class="o">],</span>
  <span class="n">simp</span>
<span class="kd">end</span>
</code></pre></div>



<a name="264960028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264960028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264960028">(Dec 15 2021 at 03:13)</a>:</h4>
<p>This proof is coming into use to verify that the localization action is <code>c • ⟨a, b⟩ = ⟨c • a, b⟩</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">localization.smul</span> <span class="n">z</span> <span class="o">((</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">q</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">z</span> <span class="bp">•</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">q</span> <span class="bp">=</span>
    <span class="n">localization.mk</span> <span class="n">q.num</span>
    <span class="o">⟨</span><span class="n">q.denom</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">q.pos.ne'</span><span class="o">)⟩,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">alg_equiv.apply_symm_apply</span><span class="o">,</span> <span class="n">fraction_ring.alg_equiv_apply</span><span class="o">,</span> <span class="n">localization.mk_eq_mk'</span><span class="o">,</span>
        <span class="n">is_localization.map_mk'</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">fraction_ring.alg_equiv</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">localization.smul_mk</span><span class="o">,</span> <span class="n">alg_equiv.apply_symm_apply</span><span class="o">,</span> <span class="n">fraction_ring.alg_equiv_apply</span><span class="o">,</span>
      <span class="n">localization.mk_eq_mk'</span><span class="o">,</span> <span class="n">is_localization.map_mk'</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mul_div_assoc</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="264960043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264960043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264960043">(Dec 15 2021 at 03:13)</a>:</h4>
<p>Am I misusing the API here? I feel like there are some simp lemmas that I have to avoid because otherwise I get into a difficult-to-wrangle goal.</p>



<a name="264960140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264960140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264960140">(Dec 15 2021 at 03:15)</a>:</h4>
<p>The docstring for <a href="https://leanprover-community.github.io/mathlib_docs/find/localization.smul">docs#localization.smul</a> says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Scalar multiplication in a ring localization is defined as `c • ⟨a, b⟩ = ⟨c • a, c • b⟩`. -/</span>
</code></pre></div>
<p>but for "rat ~ fraction_ring int" it seems like it is the <code>z • q.num / q.denom</code> as I would expect. Am I misunderstanding the constructor syntax in the docstring, or something more broadly about how scalar actions on localizations work?</p>



<a name="264960790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264960790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264960790">(Dec 15 2021 at 03:26)</a>:</h4>
<p>I think the docstring is wrong, judging from the next lemma...</p>



<a name="264960842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264960842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264960842">(Dec 15 2021 at 03:27)</a>:</h4>
<p>Right. I wanted to make sure that I understood the definition correctly and how <code>localization.mk</code> works by proving an example I thought would differentiate.</p>



<a name="264961022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/264961022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#264961022">(Dec 15 2021 at 03:30)</a>:</h4>
<p>Is there a good textbook / outside-of-mathlib reference for the "canonical" choice? A cursory search only found <a href="https://math.stackexchange.com/q/2965345">https://math.stackexchange.com/q/2965345</a>, which indicated to me that the choice might have been what the docstring wrote. That's why I was checking.</p>



<a name="265051669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/265051669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#265051669">(Dec 15 2021 at 18:15)</a>:</h4>
<p>Right, this is something that Eric and I keep talking about. There are two different situations. If a group (or monoid) acts on a ring, then that means <code>g . (a * b) = (g . a) * (g . b)</code>. In that case, in the localization you should also have <code>g . (a / b) = (g . a) / (g . b)</code>. The other situation is when considering a localization of an R-algebra. In that case you have <code>r . (a * b) = (r . a) * b</code> and so <code>r . (a / b) = (r . a) / b</code>.<br>
In Lean we write both of these with <code>•</code> and call it <code>mul_action</code> but only the first one is "an action on a ring". (The second one is an action on the underlying set of a ring.)</p>



<a name="265068329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/265068329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#265068329">(Dec 15 2021 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, I think part of the problem is that we don't really have many instances of the type of action you're referring to, according to <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_distrib_mul_action">docs#mul_distrib_mul_action</a>; pretty much the only interesting actions in that list are <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_aut.apply_mul_distrib_mul_action">docs#mul_aut.apply_mul_distrib_mul_action</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/conj_act.mul_distrib_mul_action">docs#conj_act.mul_distrib_mul_action</a>, all the rest are inherited actions.</p>



<a name="265084450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/265084450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#265084450">(Dec 15 2021 at 22:21)</a>:</h4>
<p>Maybe we should just use new notation for (the rarer) one of these?</p>



<a name="265084813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Concrete%20fraction%20ring%20of%20int/near/265084813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Concrete.20fraction.20ring.20of.20int.html#265084813">(Dec 15 2021 at 22:24)</a>:</h4>
<p>Mathematical notation is a bit of an art. We know <code>a * (b + c) = a * b + a * c</code> and choose notation wisely to make this sort of thing happen ("times distributes over plus" is indicated with notation and is probably the reason for BIDMAS/PEMDAS). We also know <code>a * (b * c) = (a * b) * c</code> ("times associates with times")-- Turns out that <code>•</code> definitely distributes over <code>+</code>, and definitely associates with itself, but it can't work out whether it distributes over or associates with <code>*</code>. So maybe it's two notations.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
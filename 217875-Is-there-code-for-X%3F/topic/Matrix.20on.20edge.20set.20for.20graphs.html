---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html">Matrix on edge set for graphs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="228939597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228939597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228939597">(Mar 05 2021 at 11:44)</a>:</h4>
<p>Hello!<br>
I am trying to define the incidence matrix of a graph, but currently fail to do so using the edge set of the graph. Is there any code for that i.e. where the edge set of the graph is used as a fintype for the matrix?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>  <span class="o">[</span><span class="n">preorder</span> <span class="n">V</span><span class="o">]</span>

<span class="c1">-- Some attempts, unsuccessful</span>
<span class="c1">--variables (E : finset (sym2 V))</span>
<span class="c1">--def E := G.edge_set.to_finset</span>

<span class="kd">def</span> <span class="n">incidence_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">E</span> <span class="n">ℤ</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">e</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">G.incidence_finset</span> <span class="n">i</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>
<p>What I am currently struggling is creating E such that E is a fintype, and also E is the edge set of V so that I can define the incidence matrix of G properly.</p>



<a name="228940154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228940154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228940154">(Mar 05 2021 at 11:50)</a>:</h4>
<p><span class="user-mention" data-user-id="303889">@Alena Gusakov</span> <span class="user-mention" data-user-id="306601">@Kyle Miller</span> will probably know. But I think the adjacency matrix is already defined somewhere.</p>



<a name="228940221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228940221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228940221">(Mar 05 2021 at 11:50)</a>:</h4>
<p>Yes, but the adjancency matrix is defined on the set of vertices V, what I am looking for is a matrix defined on the edge set, if that makes sense.</p>



<a name="228940295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228940295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228940295">(Mar 05 2021 at 11:51)</a>:</h4>
<p>Ooh, sorry. I don't know much about graphs</p>



<a name="228940416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228940416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228940416">(Mar 05 2021 at 11:52)</a>:</h4>
<p>Can you use <code>{e // e \in G.edge_set}</code>?</p>



<a name="228940452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228940452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228940452">(Mar 05 2021 at 11:52)</a>:</h4>
<p>That should give you a type, and hopefully Lean figures out automatically that it is finite if <code>V</code> is finite.</p>



<a name="228941035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228941035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228941035">(Mar 05 2021 at 11:57)</a>:</h4>
<p>So, although we have from the simple_graph file that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">edge_set</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sym2.from_rel</span> <span class="n">G.sym</span>
</code></pre></div>
<p>When I define my set E as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">E</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="bp">//</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span><span class="o">}</span> <span class="c1">-- btw what does // mean? is it like the mathematical notation {x | x \in \N, x &lt; 3} or something like that?</span>
</code></pre></div>
<p>I get the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="o">{</span><span class="n">e</span> <span class="bp">//</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span><span class="o">}</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
</code></pre></div>



<a name="228942280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228942280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228942280">(Mar 05 2021 at 12:07)</a>:</h4>
<p><code>matrix</code> expects a type <code>n</code> with an instance <code>fintype n</code>. you are trying to feed it a <code>set</code>.</p>



<a name="228942355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228942355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228942355">(Mar 05 2021 at 12:08)</a>:</h4>
<p><code>{x // condition on x}</code> creates a <code>Type*</code> which you can then use for <code>matrix</code>.</p>



<a name="228942373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228942373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228942373">(Mar 05 2021 at 12:08)</a>:</h4>
<p>But it still needs the <code>fintype</code> instance.</p>



<a name="228943081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228943081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228943081">(Mar 05 2021 at 12:14)</a>:</h4>
<p>Oh, now I see. Ok, so after the fixes, the thing that is left is this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">E</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="bp">//</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_finset</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">E</span> <span class="n">ℤ</span>
</code></pre></div>
<p>which gives the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">matrix</span> <span class="n">V</span> <span class="n">E</span>
<span class="n">term</span>
  <span class="n">E</span>
<span class="n">has</span> <span class="n">type</span>
    <span class="kt">Type</span> <span class="bp">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">?+</span><span class="mi">1</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="bp">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="bp">?+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>Can you please explain what the error means? I often come across error messages like this, but can't see what they precisely mean.</p>



<a name="228943404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228943404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228943404">(Mar 05 2021 at 12:17)</a>:</h4>
<p>Lean definitely can't find <code>fintype E</code> there, as you hid it behind a def</p>



<a name="228965846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228965846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228965846">(Mar 05 2021 at 14:53)</a>:</h4>
<p>I wonder if you might be able to just have <code>[fintype G.edge_set]</code> for this?</p>



<a name="228965900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228965900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228965900">(Mar 05 2021 at 14:53)</a>:</h4>
<p>I know fintype/finset stuff is really annoying</p>



<a name="228968362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228968362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228968362">(Mar 05 2021 at 15:07)</a>:</h4>
<p>Can't seem to make it work with that idea, this is how I managed to do it for now, I know it's ugly, but I will improve it when I myself improve at Lean probably <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="bp">//</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">edges_fintype'</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">fintype</span> <span class="n">G.E</span> <span class="o">:=</span> <span class="n">subtype.fintype</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">V</span> <span class="n">G.E</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">e</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e.val</span> <span class="o">}</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.E</span> <span class="n">ℤ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">e</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>
<p>Oh, and I don't seem to find any library containing directed graphs, since I might need them to define the directed incidence matrix. Is there some work in progress towards that? (this is just for learning purposes towards my project, don't want to copy anybody <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>



<a name="228991329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228991329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228991329">(Mar 05 2021 at 17:24)</a>:</h4>
<p>I'd suggest not defining <code>E</code> and instead use Lean's auto-coercion feature:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℤ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">e.val</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>
<p>(By the way, there's also <code>e.val ∈ G.incidence_set i</code> for indicating that an edge and a vertex are incident.  It means exactly the same thing as <code>i ∈ e.val</code> but potentially has more useful lemmas about it.)</p>



<a name="228992531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/228992531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#228992531">(Mar 05 2021 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="366674">Gabriel Moise</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/228968362">said</a>:</p>
<blockquote>
<p>Oh, and I don't seem to find any library containing directed graphs, since I might need them to define the directed incidence matrix. Is there some work in progress towards that? (this is just for learning purposes towards my project, don't want to copy anybody <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>
</blockquote>
<p>There's nothing about directed graphs yet.  For directed incidence matrices, I've thought it would be nice if there were a type of directed simple graphs, a function to <code>simple_graph</code> that forgets orientations, and a function to prove/calculate things about simple graphs by giving a proof/calculation for directed graphs and a proof that changing the orientation of an edge doesn't change the result.  This could be how you'd use directed incidence matrices for a simple graph.  (One example: calculate the graph Laplacian from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>I</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">II^T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> a directed incidence matrix of a directed version of a given simple graph.)</p>



<a name="229056067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229056067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229056067">(Mar 06 2021 at 02:23)</a>:</h4>
<p>By the time you are talking about an incidence matrix, it will get increasingly cumbersome to think of edges as certain pairs of vertices. Instead, you can model a graph as an incidence structure on a  vertex type <code>V</code> and an edge type <code>E</code> together with some some incidence information (such as <code>inc : V \to E \to \nat</code> or <code>head : E \to V</code>,  <code>tail : E \to V</code>), the flavour of which could capture simple graphs, multigraphs, digraphs, hypergraphs, etc etc.  Defining an incidence matrix is easy if you set things up this way. For directed graphs, I personally like <code>inc : V \to E \to int</code> which takes values <code>1</code> and <code>-1</code>.</p>
<p>In some areas of graph theory, such as when you're thinking about induced subgraphs and complements, an edge really 'is' a pair of vertices. However, in other cases, you really want to think of edges as their own entities that are not syntactically bound to vertices. If you want an incidence matrix, this strongly suggests to me that you're in the latter situation.</p>



<a name="229188091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229188091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229188091">(Mar 07 2021 at 13:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/228991329">said</a>:</p>
<blockquote>
<p>I'd suggest not defining <code>E</code> and instead use Lean's auto-coercion feature:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℤ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">e.val</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>
<p>(By the way, there's also <code>e.val ∈ G.incidence_set i</code> for indicating that an edge and a vertex are incident.  It means exactly the same thing as <code>i ∈ e.val</code> but potentially has more useful lemmas about it.)</p>
</blockquote>
<p>Following this approach, I get into some trouble with type coercions, for example, here I want to prove something quite simple :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">degree_equals_sum_of_incidence_row</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.degree</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">inc_matrix</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">],</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">card_incidence_set_eq_degree</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>which is very similar to what is already done in the simple_graph module, however I stumble upon the following thing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">fintype.card</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.incidence_set</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)),</span> <span class="bp">↑</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span><span class="o">)</span> <span class="n">univ</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>
</code></pre></div>
<p>which is what is left to be proven, but I can't seem to get it done, as I am not very experienced with coercions. My fear is that I will encounter this a lot and it would make code look messy.</p>



<a name="229188343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229188343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229188343">(Mar 07 2021 at 13:39)</a>:</h4>
<p>Can you give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="229188350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229188350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229188350">(Mar 07 2021 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329425">Peter Nelson</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/229056067">said</a>:</p>
<blockquote>
<p>By the time you are talking about an incidence matrix, it will get increasingly cumbersome to think of edges as certain pairs of vertices. Instead, you can model a graph as an incidence structure on a  vertex type <code>V</code> and an edge type <code>E</code> together with some some incidence information (such as <code>inc : V \to E \to \nat</code> or <code>head : E \to V</code>,  <code>tail : E \to V</code>), the flavour of which could capture simple graphs, multigraphs, digraphs, hypergraphs, etc etc.  Defining an incidence matrix is easy if you set things up this way. For directed graphs, I personally like <code>inc : V \to E \to int</code> which takes values <code>1</code> and <code>-1</code>.</p>
<p>In some areas of graph theory, such as when you're thinking about induced subgraphs and complements, an edge really 'is' a pair of vertices. However, in other cases, you really want to think of edges as their own entities that are not syntactically bound to vertices. If you want an incidence matrix, this strongly suggests to me that you're in the latter situation.</p>
</blockquote>
<p>With this approach, I see that I can do something like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">incidence</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span>
</code></pre></div>
<p>However, if I want to define a simple_graph as a special case for the more general graph (I am not sure it is necessary for me to do that though, just felt it might be needed), I thought this would work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">incidence</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="bp">∈</span> <span class="n">e</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">sym2.is_diag</span> <span class="n">e</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">}</span>
</code></pre></div>
<p>However, this looks much more "unfriendly" than the usual structure of a simple_graph from the library and it doesn't look like I can do much with it right away.</p>



<a name="229189037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229189037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229189037">(Mar 07 2021 at 13:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/229188343">said</a>:</p>
<blockquote>
<p>Can you give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">matrix</span>
<span class="kn">open</span> <span class="n">finset</span> <span class="n">matrix</span> <span class="n">simple_graph</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">e.val</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">degree_equals_sum_of_incidence_row</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.degree</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">inc_matrix</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">],</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">card_incidence_set_eq_degree</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="229191322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229191322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229191322">(Mar 07 2021 at 14:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">e.val</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">inc_matrix_def</span> <span class="o">:</span> <span class="n">G.inc_matrix</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">∈</span> <span class="n">e.val</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">mem_edge_set_of_incidence</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span> <span class="o">:=</span>
<span class="n">set.mem_of_mem_inter_left</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">degree_equals_sum_of_incidence_row</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.degree</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">inc_matrix_def</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.sum_ite</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">nat.cast_id</span><span class="o">,</span> <span class="n">finset.sum_const</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span> <span class="n">finset.sum_const_zero</span><span class="o">,</span>
  <span class="n">subtype.val_eq_coe</span><span class="o">],</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">card_incidence_set_eq_degree</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">G.incidence_finset</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">fintype.card_coe</span> <span class="o">(</span><span class="n">G.incidence_finset</span> <span class="n">i</span><span class="o">),</span>
  <span class="n">convert</span> <span class="n">this</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">finset.card_congr</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">e</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="o">[</span><span class="n">incidence_finset</span><span class="o">,</span> <span class="n">incidence_set</span><span class="o">]</span> <span class="n">using</span> <span class="n">he</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">he1</span> <span class="n">he2</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">ext</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_incidence_finset</span> <span class="n">at</span> <span class="n">he</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">[</span><span class="n">e</span><span class="o">,</span> <span class="n">mem_edge_set_of_incidence</span> <span class="n">he</span><span class="o">],</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">incidence_set</span><span class="o">]</span> <span class="n">using</span> <span class="n">he.right</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="229191341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229191341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229191341">(Mar 07 2021 at 14:23)</a>:</h4>
<p>That's solving your current problem. I had to provide two tiny pieces of API.</p>



<a name="229191367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229191367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229191367">(Mar 07 2021 at 14:23)</a>:</h4>
<p>In general, I think there are likely better ways to phrase it such that you don't have to juggle between fintype, finsets, and various coercions.</p>



<a name="229192200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229192200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229192200">(Mar 07 2021 at 14:35)</a>:</h4>
<p>Here's another version, pick your poison.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">inc_matrix_def</span> <span class="o">:</span> <span class="n">G.inc_matrix</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="n">ite</span> <span class="o">((</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">mem_edge_set_of_incidence</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span> <span class="o">:=</span>
<span class="n">set.mem_of_mem_inter_left</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">degree_equals_sum_of_incidence_row</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.degree</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">inc_matrix_def</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">card_incidence_set_eq_degree</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.sum_boole</span><span class="o">,</span> <span class="n">nat.cast_id</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">finset.card_congr</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">mem_edge_set_of_incidence</span> <span class="n">he</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">he</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e1</span><span class="o">,</span> <span class="n">he1</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">e2</span><span class="o">,</span> <span class="n">he2</span><span class="o">⟩</span> <span class="n">he1'</span> <span class="n">he2'</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.mk_eq_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">e</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">he'</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="229192462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229192462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229192462">(Mar 07 2021 at 14:39)</a>:</h4>
<p>Woah, thank you very much! I will try to use a different approach, cause this is actually a lot of work for such a result, so I guess I need a change.</p>



<a name="229192737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229192737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229192737">(Mar 07 2021 at 14:43)</a>:</h4>
<p>If you check the <code>simp</code>s, you'll see absolutely no content about graphs</p>



<a name="229192790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229192790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229192790">(Mar 07 2021 at 14:44)</a>:</h4>
<p>So that just means some finset/fintype API is missing</p>



<a name="229192799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229192799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229192799">(Mar 07 2021 at 14:44)</a>:</h4>
<p>One minute</p>



<a name="229192981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229192981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229192981">(Mar 07 2021 at 14:47)</a>:</h4>
<p>Like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">fintype.card_coe_filter</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">t</span><span class="o">]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">finset.card</span> <span class="o">(</span><span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="n">finset.univ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">finset.card_congr</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">h</span> <span class="n">he</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">]</span> <span class="n">using</span> <span class="n">he</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e1</span><span class="o">,</span> <span class="n">he1</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">e2</span><span class="o">,</span> <span class="n">he2</span><span class="o">⟩</span> <span class="n">he1'</span> <span class="n">he2'</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.mk_eq_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hr</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">e</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">]</span> <span class="n">using</span> <span class="n">he'</span><span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">exists_prop_of_true</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">inc_matrix_def</span> <span class="o">:</span> <span class="n">G.inc_matrix</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="n">ite</span> <span class="o">((</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">mem_edge_set_of_incidence</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span> <span class="o">:=</span>
<span class="n">set.mem_of_mem_inter_left</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">incidence_subset_edge_set</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.incidence_set</span> <span class="n">v</span> <span class="bp">⊆</span> <span class="n">G.edge_set</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">set.mem_of_mem_inter_left</span>

<span class="kd">lemma</span> <span class="n">degree_equals_sum_of_incidence_row</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.degree</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">inc_matrix_def</span><span class="o">,</span> <span class="bp">←</span><span class="n">card_incidence_set_eq_degree</span><span class="o">],</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">fintype.card_coe_filter</span> <span class="o">(</span><span class="n">G.incidence_subset_edge_set</span> <span class="n">i</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="229193066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229193066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229193066">(Mar 07 2021 at 14:48)</a>:</h4>
<p>Now you can see that your statement is very simple, and is just the result of the simple implication that any <code>incidence_set</code> is definitionally a subset of the <code>edge_set</code>.</p>



<a name="229193612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229193612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229193612">(Mar 07 2021 at 14:58)</a>:</h4>
<p>Oh, I see what you mean. So, I should either get used to working with finsets and fintypes to continue with this model, or choose a different model.</p>



<a name="229193766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229193766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229193766">(Mar 07 2021 at 15:00)</a>:</h4>
<p>I see this as just part of the formalization. You have to identify which pieces of what you're working on are the "mathematical content" and which is the "fomalization plumbing". Separating out the two is the skill I've had to gain to be able to do the formalizations I am interested in</p>



<a name="229193937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229193937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229193937">(Mar 07 2021 at 15:03)</a>:</h4>
<p>In addition, graphs might be some of the more frustrating things in formalization because of the constant jumps between objects, subobjects, choice, finite vs infinite, many different "induction principles"</p>



<a name="229193942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229193942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229193942">(Mar 07 2021 at 15:03)</a>:</h4>
<p>And working with concrete objects too.</p>



<a name="229194139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229194139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229194139">(Mar 07 2021 at 15:06)</a>:</h4>
<p>Well, I guess I will become good at them with experience and I will see what tools I need to formalize what I want. I will see what I can do to progress with what you proved for me! Thank you again! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="229251502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229251502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229251502">(Mar 08 2021 at 05:55)</a>:</h4>
<p>By the way, <code>incidence_subset_edge_set</code> already exists as <code>simple_graph.incidence_set_subset</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="kd">lemma</span> <span class="n">fintype.card_coe_filter</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">t</span><span class="o">]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">t</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="n">finset.univ</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">finset.card_congr</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">h</span> <span class="n">he</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">]</span> <span class="n">using</span> <span class="n">he</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e1</span><span class="o">,</span> <span class="n">he1</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">e2</span><span class="o">,</span> <span class="n">he2</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.mk_eq_mk</span><span class="o">]</span> <span class="n">using</span> <span class="n">hr</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="n">he'</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">set_coe.exists</span><span class="o">,</span>
      <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">exists_eq_right</span><span class="o">,</span> <span class="n">finset.mem_filter</span><span class="o">]</span> <span class="n">using</span> <span class="n">he'</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">degree_equals_sum_of_incidence_row</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">G.degree</span> <span class="n">i</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">inc_matrix</span><span class="o">,</span> <span class="n">finset.sum_boole</span><span class="o">,</span> <span class="n">nat.cast_id</span><span class="o">,</span>
       <span class="bp">←</span><span class="n">fintype.card_coe_filter</span> <span class="o">(</span><span class="n">G.incidence_set_subset</span> <span class="n">i</span><span class="o">),</span> <span class="n">card_incidence_set_eq_degree</span><span class="o">]</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="229465411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229465411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229465411">(Mar 09 2021 at 12:03)</a>:</h4>
<p>Can I get some help with this, I encounter this situation very often, when I have to prove stuff about the sum of elements from a type, but I struggle with splitting the sum into two parts based on some property: in the following case, I know that the sum can be split into the sum where x is not the edge between i and j (in which case the sum is 0) and the sum (consisting of one element) when x is the edge (therefore the sum will be 1) and altogether the sum will equal 1 as I need. Can you give me a direction regarding this kind of problems? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">inc_matrix_def</span> <span class="o">:</span> <span class="n">G.inc_matrix</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="n">ite</span> <span class="o">((</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">adj_sum_of_prod_inc_one</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
<span class="n">G.adj</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">G.inc_matrix</span> <span class="n">j</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="c1">-- If x is the edge between i and j, then the product is 1, else it is 0, and since there is only</span>
  <span class="c1">-- one edge between i and j, the sum will be 1</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="229465770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229465770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229465770">(Mar 09 2021 at 12:06)</a>:</h4>
<p>There is <code>finset.sum_filter</code> that might be helpful for that</p>



<a name="229466321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229466321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229466321">(Mar 09 2021 at 12:11)</a>:</h4>
<p>Your statement is probably easier to prove as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="c1">-- maybe use ℕ instead of ℤ?</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="k">if</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">inc_matrix_def</span> <span class="o">:</span> <span class="n">G.inc_matrix</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="n">ite</span> <span class="o">((</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">adj_sum_of_prod_inc_one</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
<span class="n">G.adj</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">G.edge_finset</span><span class="o">,</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">G.inc_matrix</span> <span class="n">j</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
</code></pre></div>
<p>The subtype and coercion stuff is a distraction</p>



<a name="229466928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229466928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229466928">(Mar 09 2021 at 12:17)</a>:</h4>
<p>This is a good start:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">adj_sum_of_prod_inc_one</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
<span class="n">G.adj</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">G.edge_finset</span><span class="o">,</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">G.inc_matrix</span> <span class="n">j</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">G.edge_finset</span> <span class="o">:=</span> <span class="o">(</span><span class="n">G.mem_edge_finset</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">finset.insert_erase</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.sum_insert</span> <span class="o">(</span><span class="n">finset.not_mem_erase</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">convert</span> <span class="n">add_zero</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">finset.sum_eq_zero</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.mem_erase</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="229471672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229471672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229471672">(Mar 09 2021 at 12:56)</a>:</h4>
<p>Wouldn't it be a mistake to define the incidence matrix on the whole sym2 V type? Like it's definition is on the edge set of the graph from what I know.</p>



<a name="229475829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229475829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229475829">(Mar 09 2021 at 13:28)</a>:</h4>
<p>When defined over the whole sym2 V type, you'll just have all zero columns</p>



<a name="229477943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229477943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229477943">(Mar 09 2021 at 13:42)</a>:</h4>
<p>Yes, I see that, but I thought it would have been better to follow the mathematical definition of the incidence matrix, but I guess that this solves me a lot of coercion problems since I don't have the G.edge_set type anymore.</p>



<a name="229478905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229478905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229478905">(Mar 09 2021 at 13:48)</a>:</h4>
<p>You're always free to have separate <code>inc_matrix'</code> and <code>inc_matrix</code> definitions, where one is the mathetmatically "clean" one, while the other is the one that is easy to prove things about</p>



<a name="229478937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229478937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229478937">(Mar 09 2021 at 13:49)</a>:</h4>
<p>Then all you need is a lemma saying how they relate to each other</p>



<a name="229612875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/229612875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#229612875">(Mar 10 2021 at 07:12)</a>:</h4>
<p><span class="user-mention" data-user-id="366674">@Gabriel Moise</span> There's a missing graph theory lemma that makes this easier.  After that, the main (non-math) complexity is to get things into the right form for <code>finset.filter_eq</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="sd">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>
<span class="sd">` | M i e = 1` if `i` is endpoint of `e`</span>
<span class="sd">` | M i e = 0` otherwise -/</span>
<span class="kd">def</span> <span class="n">inc_matrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">V</span> <span class="n">G.edge_set</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">inc_matrix_apply</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="bp">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">mem_incidence_sets_iff_eq_of_adj</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">i</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">j</span> <span class="bp">↔</span> <span class="n">e</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">quotient.rec_on_subsingleton</span> <span class="n">e</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rcases</span> <span class="n">p</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="n">sym2.eq_iff</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">incidence_set</span><span class="o">],</span>
  <span class="n">tidy</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">adj_sum_of_prod_inc_one</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">),</span> <span class="n">G.inc_matrix</span> <span class="n">i</span> <span class="n">e</span> <span class="bp">*</span> <span class="n">G.inc_matrix</span> <span class="n">j</span> <span class="n">e</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">inc_matrix_apply</span><span class="o">,</span> <span class="bp">←</span><span class="n">ite_and</span><span class="o">,</span> <span class="n">G.mem_incidence_sets_iff_eq_of_adj</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">finset.sum_boole</span><span class="o">,</span> <span class="n">nat.cast_id</span><span class="o">,</span> <span class="n">boole_mul</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">finset.card</span> <span class="o">(</span><span class="n">finset.filter_eq</span> <span class="n">finset.univ</span> <span class="o">(⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">G.edge_set</span><span class="o">)),</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">if_true</span><span class="o">,</span> <span class="n">finset.card_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.coe_mk</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">eq_comm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="230082356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/230082356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#230082356">(Mar 12 2021 at 19:12)</a>:</h4>
<p>There is also one thing that always appears in my proofs and I always improvise with lemma's that I create specifically for the current thing I am solving, but I was wondering if there is a simple proof for this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.matrix</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">sum_simplification</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">-&gt;</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℤ</span> <span class="bp">-&gt;</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">[</span><span class="n">decidable_pred</span> <span class="n">P</span><span class="o">]</span> <span class="o">:</span>
<span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">))</span> <span class="bp">=</span>
<span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">ite</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>It is close to the lemma "sum_apply_ite", however there the function h that is applied is independent of x. I apologize for the narrowing to \Z, but this will perfectly do for my work. I don't need a full solution, some hints are more than welcomed as well <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="230085268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/230085268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#230085268">(Mar 12 2021 at 19:35)</a>:</h4>
<p>I think you want <a href="https://leanprover-community.github.io/mathlib_docs/find/apply_ite">docs#apply_ite</a>?</p>



<a name="230086527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Matrix%20on%20edge%20set%20for%20graphs/near/230086527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Moise <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Matrix.20on.20edge.20set.20for.20graphs.html#230086527">(Mar 12 2021 at 19:45)</a>:</h4>
<p>Oh I forgot about working on the internal elements, thank you so much! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
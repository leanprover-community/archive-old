---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/invertible.20modules.20are.20f.2Eg.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/invertible.20modules.20are.20f.2Eg.2E.html">invertible modules are f.g.</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206372552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/invertible%20modules%20are%20f.g./near/206372552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/invertible.20modules.20are.20f.2Eg.2E.html#206372552">(Aug 09 2020 at 01:16)</a>:</h4>
<p>Picard groups are really intereting.</p>
<p>I think this is a theorem. Do we have this in Lean?</p>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a commutative ring, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>==-modules such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi><mo>≅</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">N\otimes_RN\cong R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is finitely-generated. Furthermore <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is projective.</p>
<p>Handwavy maths proof: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">;</mo><mi>R</mi><mo>→</mo><mi>M</mi><mo>⊗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">i;R\to M\otimes N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is the iso and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><mi>F</mi></mrow></msub><msup><mi>m</mi><mi>i</mi></msup><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">i(1)=\sum_{i:F} m^in_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.124374em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then the map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>F</mi></msup></mrow><annotation encoding="application/x-tex">R^F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> defined by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mi>i</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> canonically induces a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>F</mi></msup><mo>→</mo><mi>M</mi><mo>⊗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N^F\to M\otimes N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> which is surjective because it sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n_i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> to a generator. This morphism then splits. Because the transition from the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>F</mi></msup><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R^F,M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> world to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>F</mi></msup><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">N^F,R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> world was in some sense canonical we deduce that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>F</mi></msup><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R^F\to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> splits and hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is projective and finitely generated. Checking that the diagrams commute is what I would call an "exercise for the reader".</p>
<p>The reason this theorem is interesting is that I think it implies that you can do universe bumping. Mathematicians work in ZFC. All the prizes are for ZFC stuff. Brian Conrad told me that Fermat's Last Theorem can be proved in ZFC and I believe him, Deligne went out of his way with SGA4.5 to prove that Grothendieck's zany topos proof of the Weil conjectures could be done in ZFC, and Scholze explicitly takes time out in his etale cohomology of diamonds paper to show that his results can be formalised in ZFC. Who knows how long the resistance will last though.</p>
<p>I'd be really interested in seeing a Lean proof of this invertible module thing. I will see if I can make any sense of my universe-bumping assertion.</p>



<a name="206379160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/invertible%20modules%20are%20f.g./near/206379160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/invertible.20modules.20are.20f.2Eg.2E.html#206379160">(Aug 09 2020 at 04:58)</a>:</h4>
<p>Here's what I was thinking about. You end up with two groups, one in Type (a quotient) and one in Type 1 (a much bigger quotient) but they're isomorphic by the first isomorphism theorem.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">tensor_product</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">noetherian</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">Module</span><span class="bp">.</span><span class="n">abelian</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">Module</span><span class="bp">.</span><span class="n">monoidal</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">isomorphism_classes</span>


<span class="c1">--open_locale tensor_product</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
<span class="o">[</span><span class="n">add_comm_group</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>

<span class="c1">-- sketchy proof in the chat</span>
<span class="kn">theorem</span> <span class="n">fg_of_pseudoinvertible</span> <span class="o">:</span>
  <span class="n">nonempty</span> <span class="o">(</span><span class="n">linear_equiv</span> <span class="n">R</span> <span class="o">(</span><span class="n">tensor_product</span> <span class="n">R</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">fg</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">is_pseudoinvertible</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Module</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">B</span><span class="o">,</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">A</span> <span class="err">⊗</span> <span class="n">B</span> <span class="err">≅</span> <span class="mi">𝟙</span><span class="bp">_</span> <span class="o">(</span><span class="n">Module</span> <span class="n">R</span><span class="o">))</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">Module</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="err">⊗</span> <span class="n">B</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Module</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">Module</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">is_isomorphic_setoid</span>

<span class="n">def</span> <span class="n">isom_con</span> <span class="o">:</span> <span class="n">con</span> <span class="o">(</span><span class="n">Module</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">hAB</span> <span class="n">hCD</span><span class="o">,</span>
  <span class="bp">⟨</span><span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">Module</span><span class="bp">.</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="n">tensor_hom</span>
    <span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">iso</span><span class="bp">.</span><span class="n">hom</span> <span class="o">(</span><span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="o">(</span><span class="n">A</span> <span class="err">≅</span> <span class="n">B</span><span class="o">)</span> <span class="n">hAB</span><span class="o">))</span>
    <span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">iso</span><span class="bp">.</span><span class="n">hom</span> <span class="o">(</span><span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="o">(</span><span class="n">C</span> <span class="err">≅</span> <span class="n">D</span><span class="o">)</span> <span class="n">hCD</span><span class="o">)),</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="n">Module</span><span class="bp">.</span><span class="n">monoidal_category</span><span class="bp">.</span><span class="n">tensor_hom</span>
    <span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">iso</span><span class="bp">.</span><span class="n">inv</span> <span class="o">(</span><span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="o">(</span><span class="n">A</span> <span class="err">≅</span> <span class="n">B</span><span class="o">)</span> <span class="n">hAB</span><span class="o">))</span>
    <span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">iso</span><span class="bp">.</span><span class="n">inv</span> <span class="o">(</span><span class="bp">@</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="o">(</span><span class="n">C</span> <span class="err">≅</span> <span class="n">D</span><span class="o">)</span> <span class="n">hCD</span><span class="o">)),</span>
  <span class="c1">-- left as an exercise for the reader</span>
  <span class="n">hom_inv_id&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">inv_hom_id&#39;</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span><span class="bp">⟩</span><span class="o">,</span>
 <span class="bp">..</span><span class="o">(</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">is_isomorphic_setoid</span> <span class="o">(</span><span class="n">Module</span> <span class="n">R</span><span class="o">))</span>
<span class="o">}</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="err">$</span> <span class="o">(</span><span class="n">isom_con</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="c1">-- (category_theory.is_isomorphic_setoid (Module R)) :=</span>
<span class="k">by</span> <span class="n">apply_instance</span>

<span class="n">def</span> <span class="n">Isom_classes</span> <span class="o">:=</span> <span class="o">(</span><span class="n">isom_con</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">Isom_classes</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">Isom_classes</span><span class="bp">;</span> <span class="n">apply_instance</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">Isom_classes</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="err">⟦</span><span class="mi">𝟙</span><span class="bp">_</span> <span class="o">(</span><span class="n">Module</span> <span class="n">R</span><span class="o">)</span><span class="err">⟧</span><span class="bp">⟩</span>

<span class="c1">-- possibly all tricky theorems in category theory</span>
<span class="kn">instance</span> <span class="n">Picard_Monoid</span> <span class="o">:</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">Isom_classes</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">Picard_Group</span> <span class="o">:=</span> <span class="n">units</span> <span class="o">(</span><span class="n">Isom_classes</span> <span class="n">R</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">Picard_Group</span> <span class="n">ℚ</span> <span class="c1">-- Type 1!!</span>

<span class="c1">-- set of quotients of R^n</span>
<span class="kn">structure</span> <span class="n">finitely_generated_module</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">quotient_by_me</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">((</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span><span class="o">))</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">finitely_generated_module</span> <span class="n">R</span> <span class="c1">-- still in Type!</span>

<span class="c1">-- surjects onto the pseudoinvertible ones</span>
<span class="n">def</span> <span class="n">forget</span> <span class="o">:</span> <span class="n">finitely_generated_module</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">Module</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">nQ</span><span class="o">,</span> <span class="n">Module</span><span class="bp">.</span><span class="n">of</span> <span class="n">R</span> <span class="n">nQ</span><span class="bp">.</span><span class="n">quotient_by_me</span><span class="bp">.</span><span class="n">quotient</span>

<span class="n">def</span> <span class="n">fgmod_equiv</span> <span class="o">(</span><span class="n">L</span> <span class="n">M</span> <span class="o">:</span> <span class="n">finitely_generated_module</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">L</span><span class="bp">.</span><span class="n">quotient_by_me</span><span class="bp">.</span><span class="n">quotient</span> <span class="err">≅</span>
<span class="n">M</span><span class="bp">.</span><span class="n">quotient_by_me</span><span class="bp">.</span><span class="n">quotient</span><span class="o">)</span>

<span class="n">def</span> <span class="n">Picard_Group2</span> <span class="o">:=</span> <span class="n">quot</span> <span class="o">(</span><span class="n">fgmod_equiv</span> <span class="n">R</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">Picard_Group2</span> <span class="c1">-- still in Type</span>

<span class="c1">-- now define the forgetful morphism from this category</span>
<span class="c1">-- to Module R, observe that is maximally well-behaved</span>
<span class="c1">-- with respect to isomorphisms and hence gives us</span>
<span class="c1">-- a map from the quotient of `finitely_generated_module R`</span>
<span class="c1">-- by the isomorphism equivalence relation to the Picard Group.</span>
<span class="c1">-- It&#39;s a surjection by the ring theory theorem, so</span>
<span class="c1">-- by the first isomorphism theorem we have an isomorphism</span>
<span class="c1">-- between a Picard Group in Type (invertible fractional ideals</span>
<span class="c1">-- modulo principal ones) to a Picard Group in Type 1 (iso</span>
<span class="c1">-- classes of invertible modules). We want the one in Type</span>
<span class="c1">-- because its existence is a stronger statement but note</span>
<span class="c1">-- that we will have to make the Type 1 quotient property</span>
<span class="c1">-- even though there is a lot of AC about here</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
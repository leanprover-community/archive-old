---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html">Simpler proof of injectivity {0,1,-1} --> R?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281721591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281721591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281721591">(May 09 2022 at 17:54)</a>:</h4>
<p>I need the fact that when <code>a b : ℤ</code> are both in <code>{0, 1, -1}</code> and <code>(a : R) = (b : R)</code> in a nontrivial ring <code>R</code> of characteristic <code>≠ 2</code>, then <code>a = b</code>. I'm wondering if the following proof can be simplified.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>
<span class="kn">import</span> <span class="n">algebra.char_p.basic</span>

<span class="sd">/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/</span>
<span class="kd">lemma</span> <span class="n">ring.two_ne_zero</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="bp">¬</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)),</span> <span class="n">char_p.int_cast_eq_zero_iff</span> <span class="n">R</span> <span class="o">(</span><span class="n">ring_char</span> <span class="n">R</span><span class="o">)</span> <span class="mi">2</span><span class="o">,</span>
      <span class="o">(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)),</span> <span class="n">int.coe_nat_dvd</span><span class="o">,</span> <span class="n">nat.dvd_prime</span> <span class="n">nat.prime_two</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">mt</span> <span class="o">(</span><span class="n">or_iff_left</span> <span class="n">hR</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">char_p.ring_char_ne_one</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/-- If two integers from `{0, 1, -1}` result in equal elements in a ring `R`</span>
<span class="sd">that is nontrivial and of characteristic not `2`, then they are equal. -/</span>
<span class="kd">lemma</span> <span class="n">ring.int_sign_eq_of_coe_eq</span>
 <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span>
 <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">eq_of_sub_eq_zero</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">hf</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hh</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">ha</span> <span class="bp">|</span> <span class="n">ha</span> <span class="bp">|</span> <span class="n">ha</span><span class="bp">;</span> <span class="n">rcases</span> <span class="n">hb</span> <span class="k">with</span> <span class="n">hb</span> <span class="bp">|</span> <span class="n">hb</span> <span class="bp">|</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">swap</span> <span class="mi">5</span><span class="o">,</span> <span class="n">swap</span> <span class="mi">9</span><span class="o">,</span> <span class="c1">-- move goals with `a = b` to the front</span>
    <span class="n">iterate</span> <span class="mi">3</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">]</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- 6 goals remain</span>
    <span class="n">all_goals</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">],</span> <span class="n">norm_num</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">sub_eq_zero_of_eq</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h''</span> <span class="o">:</span> <span class="o">((</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">sub_eq_zero_of_eq</span> <span class="n">h.symm</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hh</span> <span class="k">with</span> <span class="n">hh</span> <span class="bp">|</span> <span class="n">hh</span> <span class="bp">|</span> <span class="n">hh</span> <span class="bp">|</span> <span class="n">hh</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hh</span><span class="o">,</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span> <span class="n">exact</span> <span class="n">one_ne_zero</span> <span class="n">h'</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hh</span><span class="o">,</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h''</span><span class="o">,</span> <span class="n">exact</span> <span class="n">one_ne_zero</span> <span class="n">h''</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hh</span><span class="o">,</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ring.two_ne_zero</span> <span class="n">hR</span> <span class="n">h'</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hh</span><span class="o">,</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h''</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ring.two_ne_zero</span> <span class="n">hR</span> <span class="n">h''</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>(Fiddling with casts of numerals is especially annoying...)</p>



<a name="281721843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281721843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281721843">(May 09 2022 at 17:56)</a>:</h4>
<p>Somehow I had the feeling that the proof of <code>hh</code> in the above should just be <code>dec_trivial</code>, but that does not seem to work.</p>



<a name="281732709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281732709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281732709">(May 09 2022 at 19:19)</a>:</h4>
<p>Here's a minor golf for two_ne_zero, plus two more lemmas which I thought would be useful but turned out not to be because you can go straight from R to nat. I don't really see any way of dealing with all 9 cases in the big theorem; I mean, that's how we'd do it in our heads, right? I guess a more general approach would be to have a and b in <code>set.Icc (-N) N</code> and the assumption that the characteristic is 0 or bigger than 2N; that would force you to "do it properly" as it were.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coe_eq_zero_iff_nat_abs</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x.nat_abs</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">int.nat_abs_eq</span> <span class="n">x</span> <span class="k">with</span> <span class="n">hx</span> <span class="n">hx</span><span class="bp">;</span>
  <span class="o">{</span> <span class="n">conv_lhs</span> <span class="o">{</span><span class="n">rw</span> <span class="o">[</span><span class="n">hx</span><span class="o">]</span> <span class="o">},</span> <span class="n">simp</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">ring_char.zspec</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">ring_char</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">∣</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">coe_eq_zero_iff_nat_abs</span><span class="o">,</span> <span class="n">int.coe_nat_dvd_left</span><span class="o">,</span> <span class="n">ring_char.spec</span><span class="o">]</span>

<span class="sd">/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/</span>
<span class="kd">lemma</span> <span class="n">ring.two_ne_zero</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="bp">¬</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[(</span><span class="kd">by</span> <span class="n">norm_cast</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)),</span> <span class="n">ring_char.spec</span><span class="o">,</span> <span class="n">nat.dvd_prime</span> <span class="n">nat.prime_two</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">mt</span> <span class="o">(</span><span class="n">or_iff_left</span> <span class="n">hR</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">char_p.ring_char_ne_one</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281733251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281733251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281733251">(May 09 2022 at 19:24)</a>:</h4>
<p>Thanks!</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F/near/281732709">said</a>:</p>
<blockquote>
<p>I don't really see any way of dealing with all 9 cases in the big theorem; I mean, that's how we'd do it in our heads, right? I guess a more general approach would be to have a and b in <code>set.Icc (-N) N</code> and the assumption that the characteristic is 0 or bigger than 2N; that would force you to "do it properly" as it were.</p>
</blockquote>
<p>Well, but that would make the handling of the assumption on the characteristic much more unpleasant in my use case...</p>



<a name="281735071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281735071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281735071">(May 09 2022 at 19:36)</a>:</h4>
<p>Here's a slightly shorter proof using the <code>rintro rfl</code> trick many times:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ring.int_sign_eq_of_coe_eq</span>
 <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span>
 <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">eq_of_sub_eq_zero</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">hf</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hh</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span><span class="bp">;</span>
    <span class="n">rcases</span> <span class="n">hb</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span><span class="bp">;</span>
    <span class="n">norm_num</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hf</span><span class="bp">;</span> <span class="n">norm_num</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">hh</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">ring.two_ne_zero</span> <span class="n">hR</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">ring.two_ne_zero</span> <span class="n">hR</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281740962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281740962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281740962">(May 09 2022 at 20:24)</a>:</h4>
<p>Any reason you're not using <a href="https://leanprover-community.github.io/mathlib_docs/find/sign_type">docs#sign_type</a>?</p>



<a name="281741262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281741262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281741262">(May 09 2022 at 20:26)</a>:</h4>
<p>This translates into "The canonical map from <code>sign_type</code> is injective"</p>



<a name="281742660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281742660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281742660">(May 09 2022 at 20:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F/near/281740962">said</a>:</p>
<blockquote>
<p>Any reason you're not using <a href="https://leanprover-community.github.io/mathlib_docs/find/sign_type">docs#sign_type</a>?</p>
</blockquote>
<p>Yes: I want to add values.<br>
How much simpler would the proof be when <code>a b : sign_type</code>? You still have nine cases to deal with...</p>



<a name="281743029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281743029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281743029">(May 09 2022 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F/near/281735071">said</a>:</p>
<blockquote>
<p>Here's a slightly shorter proof using the <code>rintro rfl</code> trick many times: (...)</p>
</blockquote>
<p>It is shorter, but a bit less efficient (although not by much).</p>



<a name="281747149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281747149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281747149">(May 09 2022 at 21:17)</a>:</h4>
<p>The point of sign_type is basically to be coerced into the correct structure</p>



<a name="281801552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281801552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281801552">(May 10 2022 at 09:57)</a>:</h4>
<p>The proof of <code>ring.two_ne_zero</code> can also be golfed to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ring.two_ne_zero</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">hR</span> <span class="bp">$</span> <span class="n">char_p.ring_char_of_prime_eq_zero</span> <span class="n">nat.prime_two</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>if you really want to obscure it.</p>



<a name="281801714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281801714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281801714">(May 10 2022 at 09:59)</a>:</h4>
<p>Also, in the spirit of <code>ring.int_sign_eq_of_coe_eq</code>, this lemma seems potentially useful:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">window</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">de</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">char_p</span> <span class="n">R</span> <span class="n">e</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.inj_on</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">set.Ico</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">a</span> <span class="o">⟨</span><span class="n">a0</span><span class="o">,</span> <span class="n">ad</span><span class="o">⟩</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">b0</span><span class="o">,</span> <span class="n">bd</span><span class="o">⟩</span> <span class="n">ab</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">char_p.int_coe_eq_int_coe_iff</span> <span class="n">R</span> <span class="n">e</span><span class="o">,</span> <span class="n">int.modeq_iff_dvd</span><span class="o">]</span> <span class="n">at</span> <span class="n">ab</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ab</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">c0</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">int.lt_add_one_iff.mp</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">neg_nonpos.mp</span> <span class="o">(</span><span class="n">int.lt_add_one_iff.mp</span> <span class="n">_</span><span class="o">))</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_add</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_lt_iff_lt_one_right</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">e</span><span class="o">),</span> <span class="bp">←</span> <span class="n">hc</span><span class="o">]</span><span class="bp">;</span>
    <span class="n">linarith</span> <span class="o">},</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">c0</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">sub_eq_zero</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281803258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281803258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281803258">(May 10 2022 at 10:15)</a>:</h4>
<p>In fact, using <code>window</code>, you can prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ring.int_sign_eq_of_coe_eq_Ico</span>
 <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR0</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span>
 <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">set.Ico</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">set.Ico</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">window</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">ring_char</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_char.of_eq</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">nat.succ_le_iff.mpr</span> <span class="o">(</span><span class="n">lt_of_le_of_ne</span> <span class="n">_</span> <span class="o">(</span><span class="n">ne.symm</span> <span class="n">_</span><span class="o">))</span> <span class="o">},</span>
  <span class="n">exacts</span> <span class="o">[</span><span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">,</span> <span class="n">hR0</span><span class="o">,</span> <span class="n">char_p.ring_char_ne_one</span><span class="o">,</span> <span class="n">hR</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281803543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281803543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281803543">(May 10 2022 at 10:18)</a>:</h4>
<p>Note that, besides replacing the explicit equalities of <code>a, b</code> I am using intervals.  Still, the main reason this feels simpler is the extra assumption <code>ring_char R ≠ 0</code>.  There was a discussion recently about the fact that <code>char_p R 0</code> is <em>not</em> an equivalent of <code>char_zero</code>.</p>
<p>To me, your example seems to be further indication that <code>ring_char R = 0</code> should be mean <code>char_zero R</code> and not <code>char_p R 0</code>.</p>



<a name="281803594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Simpler%20proof%20of%20injectivity%20%7B0%2C1%2C-1%7D%20--%3E%20R%3F/near/281803594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Simpler.20proof.20of.20injectivity.20.7B0.2C1.2C-1.7D.20--.3E.20R.3F.html#281803594">(May 10 2022 at 10:19)</a>:</h4>
<p>This is a proof that in your case, the <code>ring_char</code> assumption also implies <code>char_zero R</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ch0</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_assoc_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">hR0</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">char_zero</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">char_p.char_p_to_char_zero</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">ring_char.of_eq</span> <span class="n">hR0</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
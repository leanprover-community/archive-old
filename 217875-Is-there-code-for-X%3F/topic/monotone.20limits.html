---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html">monotone limits</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="239909048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239909048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239909048">(May 22 2021 at 23:49)</a>:</h4>
<p>To my surprise, I failed to <code>library_search</code> a statement that the limit of an increasing sequence is at least any member of the sequence. I needed that for <code>ennreal</code>-valued sequences, but could not find it even for <code>â„</code>-valued sequences. I suspect I am doing something wrong in my search. E.g., the following fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.instances.real</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr_R</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span> <span class="c1">-- fails</span>
</code></pre></div>
<p>I guess the right generality should cover at least both of the above (I'm guessing <code>{Ï„ : Type*} [linear_order Ï„] [topological_space Ï„] [order_topology Ï„]</code>), and also not just sequences. For sequences I have the following clumsy proof (which covers the <code>â„</code>, <code>nnreal</code>, and <code>ennreal</code> that I most care about), but what is the right way? And what should I have done to find it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ord</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topo</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">ord_topo</span> <span class="o">:</span> <span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">mâ‚€</span> <span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">over_lim</span> <span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">over_lim</span> <span class="o">,</span>
  <span class="n">set</span> <span class="n">U</span> <span class="o">:=</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="n">mâ‚€</span><span class="o">))</span> <span class="k">with</span> <span class="n">hU</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">hU_nbhd</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">âˆˆ</span> <span class="bp">ğ“</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">Iio_mem_nhds</span> <span class="n">over_lim</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">too_high</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">â„•</span><span class="o">)</span> <span class="o">,</span> <span class="n">n</span> <span class="bp">â‰¥</span> <span class="n">mâ‚€</span> <span class="bp">â†’</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">âˆ‰</span> <span class="n">U</span> <span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span> <span class="o">,</span>
    <span class="n">simp</span> <span class="o">,</span>
    <span class="n">exact</span> <span class="n">h_incr</span> <span class="n">hn</span> <span class="o">,</span> <span class="o">}</span> <span class="o">,</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">filter.tendsto_at_top'.mp</span> <span class="n">h_lim</span> <span class="n">U</span> <span class="n">hU_nbhd</span> <span class="o">,</span>
  <span class="n">cases</span> <span class="n">key</span> <span class="k">with</span> <span class="n">nâ‚€</span> <span class="n">hnâ‚€</span> <span class="o">,</span>
  <span class="n">set</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="n">nâ‚€</span> <span class="n">mâ‚€</span> <span class="k">with</span> <span class="n">hk</span> <span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hnâ‚€</span> <span class="n">k</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="n">nâ‚€</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">,</span>
  <span class="n">specialize</span> <span class="n">too_high</span> <span class="n">k</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="n">nâ‚€</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">,</span>
  <span class="n">contradiction</span> <span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="239911848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239911848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239911848">(May 23 2021 at 00:42)</a>:</h4>
<p>To continue a bit, my first instinct was in fact to look for the completeness axiom of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span> formulated along the lines of "all increasing upper bounded sequences have a limit". This is stronger than I asked for above (for the special case of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span>). I couldn't find this formulation of the completeness axiom. I suspected the failure might be because of my clumsy phrasing of the hypotheses. Perhaps boundedness in the form <code>âˆƒ (b : â„) , âˆ€ n , s(n) â‰¤ b</code> is not the right way, or perhaps one should not state the existence of the limit but instead be explicit about the limit being <code>Sup (range s)</code>, or something more clever. Anyway, I could not find it in the docs or even by my favorites <code>library_search</code>, <code>tidy</code>, or <code>simp</code>.</p>
<p>So I guess another question I have is: does the above formulation of the completeness axiom of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">R</span></span></span></span> exist?</p>



<a name="239940485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239940485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239940485">(May 23 2021 at 10:20)</a>:</h4>
<p>The completeness axiom is formalised as all non-empty bounded-above subsets have a Sup. I don't know if we have this sequence version. A lot of things which one would regard as standard 1st year UG mathematics are proved quite conceptually in Lean, e.g. you probably won't find directly the assertion that the limit of the sum of two sequences of real numbers is the sum of the limits, this will just follow from some general lemma about continuous operators commuting with limits in some huge generality and then we leave it to the type class inference system to insert the proof that addition is continuous on the reals. I don't know my way around the library or the tricks that are used here, but it looks like you're thinking about things in the right way and this lemma might not be there -- you'll have to wait for an analyst to chime in.</p>



<a name="239941090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239941090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239941090">(May 23 2021 at 10:30)</a>:</h4>
<p>The completeness axioms you're describing sound like those of <a href="https://leanprover-community.github.io/mathlib_docs/find/conditionally_complete_lattice">docs#conditionally_complete_lattice</a> to me</p>



<a name="239941130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239941130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239941130">(May 23 2021 at 10:31)</a>:</h4>
<p>For which <a href="https://leanprover-community.github.io/mathlib_docs/find/real.conditionally_complete_linear_order">docs#real.conditionally_complete_linear_order</a> provides the instance</p>



<a name="239941182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239941182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239941182">(May 23 2021 at 10:32)</a>:</h4>
<p>There's a theorem of the form "limit = Sup" for monotone sequences, where "limit" is using the order topology and "Sup" is using the lattice structure.</p>



<a name="239941187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239941187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239941187">(May 23 2021 at 10:32)</a>:</h4>
<p>The question is whether this is missing.</p>



<a name="239941386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239941386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239941386">(May 23 2021 at 10:35)</a>:</h4>
<p>more generally you could have an order-preserving function from a total order to a lattice and the claim is that if the sup of the range of the function exists and is L then the function sends at_top to nhds(L) in the sense of <code>filter.tendsto</code></p>



<a name="239962074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239962074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239962074">(May 23 2021 at 16:26)</a>:</h4>
<p>The lemma about monotone sequences converging to their sup is <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_at_top_csupr">docs#tendsto_at_top_csupr</a></p>



<a name="239962483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239962483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239962483">(May 23 2021 at 16:34)</a>:</h4>
<p>I compressed your proof a bit.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">filter.not_eventually_false</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Â¬</span> <span class="o">(</span><span class="bp">âˆ€á¶ </span> <span class="n">x</span> <span class="k">in</span> <span class="n">f</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">Î»</span> <span class="n">h</span><span class="o">,</span> <span class="n">ne_bot.ne'</span> <span class="o">(</span><span class="n">eventually_false_iff_eq_bot.mp</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span> <span class="n">n</span>  <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">mâ‚€</span> <span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">over_lim</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">yes</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆˆ</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
    <span class="k">from</span> <span class="n">h_lim</span> <span class="o">(</span><span class="n">Iio_mem_nhds</span> <span class="bp">$</span> <span class="n">not_le.1</span> <span class="n">over_lim</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">no</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">âˆ€</span> <span class="n">n</span> <span class="bp">â‰¥</span> <span class="n">a</span><span class="o">,</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">,</span> <span class="bp">Î»</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h_incr</span> <span class="n">hb</span><span class="o">âŸ©</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_not_self</span><span class="o">,</span> <span class="n">not_eventually_false</span><span class="o">]</span> <span class="n">using</span> <span class="n">yes.and</span> <span class="n">no</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="239962552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239962552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239962552">(May 23 2021 at 16:35)</a>:</h4>
<p>The main point is that filters also allow to abstract away the <code>max nâ‚€ mâ‚€</code> thing.</p>



<a name="239977811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239977811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239977811">(May 23 2021 at 21:01)</a>:</h4>
<p>Thanks a lot everyone!</p>
<p>Kevin's answer about the generality that could be used instead of sequences (functions on <code>â„•</code>) sounded good to me. I had no idea what a total order is in Lean though... I tried <code>{Ïƒ: Type*} [preorder Ïƒ] [is_trichotomous Ïƒ (_inst_1.lt)] [ne_bot (@at_top Ïƒ _inst_1)]</code>. A modification of Patrick's improved proof works in this generality, although the first of the two <code>simpa</code>s broke, and I had to resort again to what I am able to write, which of course compromised Patrick's elegance. Anyway, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.instances.real</span>
<span class="kn">import</span> <span class="n">topology.instances.ennreal</span>
<span class="kn">import</span> <span class="n">init.algebra.classes</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">filter.not_eventually_false</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Â¬</span> <span class="o">(</span><span class="bp">âˆ€á¶ </span> <span class="n">x</span> <span class="k">in</span> <span class="n">f</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">Î»</span> <span class="n">h</span><span class="o">,</span> <span class="n">ne_bot.ne'</span> <span class="o">(</span><span class="n">eventually_false_iff_eq_bot.mp</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">is_trichotomous</span> <span class="n">Ïƒ</span> <span class="o">(</span><span class="n">_inst_1.lt</span><span class="o">)]</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="o">(</span><span class="bp">@</span><span class="n">at_top</span> <span class="n">Ïƒ</span> <span class="n">_inst_1</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">mâ‚€</span> <span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">over_lim</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">yes</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆˆ</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
    <span class="k">from</span> <span class="n">h_lim</span> <span class="o">(</span><span class="n">Iio_mem_nhds</span> <span class="bp">$</span> <span class="n">not_le.1</span> <span class="n">over_lim</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">no</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">âˆ€</span> <span class="n">n</span> <span class="bp">â‰¥</span> <span class="n">a</span><span class="o">,</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span>
        <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_Iio</span><span class="o">,</span> <span class="n">not_lt</span><span class="o">]</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">at_least</span> <span class="o">:</span> <span class="n">Ici</span> <span class="n">a</span> <span class="bp">âŠ†</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="bp">â†</span> <span class="n">eq</span> <span class="o">,</span>
      <span class="n">exact</span> <span class="n">at_top.sets_of_superset</span> <span class="o">(</span><span class="n">mem_at_top</span> <span class="n">a</span><span class="o">)</span> <span class="n">at_least</span> <span class="o">,</span> <span class="o">}</span> <span class="o">,</span>
    <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">,</span> <span class="bp">Î»</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h_incr</span> <span class="n">hb</span><span class="o">âŸ©</span> <span class="o">,</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_not_self</span><span class="o">,</span> <span class="n">not_eventually_false</span><span class="o">]</span> <span class="n">using</span> <span class="n">yes.and</span> <span class="n">no</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>In this generality both of the two cases I actually cared about do indeed work:</p>
<ul>
<li>increasing <em>sequences</em> with values in <em>reals</em></li>
<li>increasing <em>sequences</em> with values in <em>ennreals</em>.</li>
</ul>
<p>That much is good (although of course these did already work with my initial pedestrian formulation, too...).</p>
<p>However, only the first of the two seems to be found by <code>library_search</code>, the other one is not found! (Although it works). Here are the specific cases I tried:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr_R'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">tendsto_ge_of_incr</span> <span class="n">incr</span> <span class="n">lim</span>
    <span class="c1">-- works and is found by `library_search`</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr_ennreal'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">tendsto_ge_of_incr</span> <span class="n">incr</span> <span class="n">lim</span>
    <span class="c1">-- works but is not found by `library_search` ?!?</span>
</code></pre></div>
<p>Does anyone understand why the first is found and the second is not?</p>



<a name="239978425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239978425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239978425">(May 23 2021 at 21:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20limits/near/239940485">said</a>:</p>
<blockquote>
<p>A lot of things which one would regard as standard 1st year UG mathematics are proved quite conceptually in Lean, ...</p>
</blockquote>
<p>Yes! I've noticed, and I (sort of) understand why. For me, what often works in practice is to write the undergrad statement in the cleanest possible form, and then apply <code>library_search</code> <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span> (or a <code>tidy</code> or a <code>simp</code>). This experimental observation of mine is probably a corollary to what you said in "...and then we leave it to the type class inference system to insert the proof". I have been extremely impressed with how well this method works, btw!</p>
<p>And because this is what I almost always do in Lean, I think the working of <code>library_search</code> in the above two cases is sort of important...</p>



<a name="239979752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239979752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239979752">(May 23 2021 at 21:36)</a>:</h4>
<p>One (or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>â‰ˆ</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">â‰ˆ</span></span></span></span> one) more question <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span>...</p>
<p>My original use-case was in fact about decreasing sequences, but because I did not want to write <code>(decr : @monotone â„• (order_dual Ï„) _ _ s)</code> I phrased the question here about increasing sequences.</p>
<p>I am of course able to prove the decreasing analogue by changing a few <code>Iio</code>s to <code>Ioi</code>s and a few <code>â‰¤</code>s to <code>â‰¥</code>s. But shouldn't there now be some quick shortcut (using <code>order_dual</code>)? Specifically, what would be a <em>good</em> proof of the following, given the proof we already had above?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">tendsto_le_of_decr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">is_trichotomous</span> <span class="n">Ïƒ</span> <span class="o">(</span><span class="n">_inst_1.lt</span><span class="o">)]</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="o">(</span><span class="bp">@</span><span class="n">at_top</span> <span class="n">Ïƒ</span> <span class="n">_inst_1</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_decr</span> <span class="o">:</span> <span class="bp">@</span><span class="n">monotone</span> <span class="n">Ïƒ</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">Ï„</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">l</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span>  <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Maybe already writing the decreasingness assumption as <code>@monotone Ïƒ (order_dual Ï„) _ _ s</code> is a bit clumsy... Is there a better way?</p>



<a name="239980558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/239980558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#239980558">(May 23 2021 at 21:51)</a>:</h4>
<p>Ah, sorry --- I now got the first part of my own question about reducing the decreasing case to the increasing case. I clearly should have had more faith in Kevin's advice to "leave it to the type class inference system to insert the proof".</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">tendsto_le_of_decr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">is_trichotomous</span> <span class="n">Ïƒ</span> <span class="o">(</span><span class="n">_inst_1.lt</span><span class="o">)]</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="o">(</span><span class="bp">@</span><span class="n">at_top</span> <span class="n">Ïƒ</span> <span class="n">_inst_1</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_decr</span> <span class="o">:</span> <span class="bp">@</span><span class="n">monotone</span> <span class="n">Ïƒ</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">Ï„</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">l</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">Ï„'</span> <span class="o">:=</span> <span class="n">order_dual</span> <span class="n">Ï„</span> <span class="k">with</span> <span class="n">hÏ„'</span> <span class="o">,</span>
  <span class="n">exact</span> <span class="bp">@</span><span class="n">tendsto_ge_of_incr</span> <span class="n">Ïƒ</span> <span class="n">Ï„'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span> <span class="n">l</span> <span class="n">h_decr</span> <span class="n">h_lim</span> <span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>This still leaves the question of is there a better phrasing of <code>(h_decr : @monotone Ïƒ (order_dual Ï„) _ _ s)</code>, though.</p>



<a name="240009121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240009121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240009121">(May 24 2021 at 05:51)</a>:</h4>
<p>I also noticed that the <code>[is_trichotomous Ïƒ (_inst_1.lt)]</code> is an unnecessary assumption. The Bourbaki assumption <code>[ne_bot (@at_top Ïƒ _inst_1)]</code> for the <code>at_top</code>-filter is enough:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">init.algebra.classes</span>
<span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">filter.not_eventually_false</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Â¬</span> <span class="o">(</span><span class="bp">âˆ€á¶ </span> <span class="n">x</span> <span class="k">in</span> <span class="n">f</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">Î»</span> <span class="n">h</span><span class="o">,</span> <span class="n">ne_bot.ne'</span> <span class="o">(</span><span class="n">eventually_false_iff_eq_bot.mp</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="o">(</span><span class="bp">@</span><span class="n">at_top</span> <span class="n">Ïƒ</span> <span class="n">_inst_1</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">mâ‚€</span> <span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">over_lim</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">yes</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆˆ</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
    <span class="k">from</span> <span class="n">h_lim</span> <span class="o">(</span><span class="n">Iio_mem_nhds</span> <span class="bp">$</span> <span class="n">not_le.1</span> <span class="n">over_lim</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">no</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">âˆ€</span> <span class="n">n</span> <span class="bp">â‰¥</span> <span class="n">a</span><span class="o">,</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span>
        <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_Iio</span><span class="o">,</span> <span class="n">not_lt</span><span class="o">]</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">at_least</span> <span class="o">:</span> <span class="n">Ici</span> <span class="n">a</span> <span class="bp">âŠ†</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="bp">â†</span> <span class="n">eq</span> <span class="o">,</span>
      <span class="n">exact</span> <span class="n">at_top.sets_of_superset</span> <span class="o">(</span><span class="n">mem_at_top</span> <span class="n">a</span><span class="o">)</span> <span class="n">at_least</span> <span class="o">,</span> <span class="o">}</span> <span class="o">,</span>
    <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">,</span> <span class="bp">Î»</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h_incr</span> <span class="n">hb</span><span class="o">âŸ©</span> <span class="o">,</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_not_self</span><span class="o">,</span> <span class="n">not_eventually_false</span><span class="o">]</span> <span class="n">using</span> <span class="n">yes.and</span> <span class="n">no</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="240009136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240009136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240009136">(May 24 2021 at 05:52)</a>:</h4>
<p>What I originally wanted to ask regarding this lemma is whether it was (1) missing deliberately, (2) missing not deliberately, or (3) deliberately not missing. I'm still slightly unsure about the conclusion...</p>
<p>(In my own level of the game I can use an arbitrarily pedestrian version of this, but I of course greatly appreciate the improvements of Kevin and Patrick.)</p>



<a name="240012382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YaÃ«l Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012382">(May 24 2021 at 06:42)</a>:</h4>
<p>Random note: it's cleaner to call instances using <code>\fl the type of the instance \fr</code> than by its name <code>_inst_1</code> which is susceptible to change. In general French quotes allow you to make Lean fetch assumptions (or hypotheses, however you want to call them) from the local context without having to name them. It's mostly useful for instances as they are basically the only hypotheses you don't get to name.</p>



<a name="240012416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012416">(May 24 2021 at 06:42)</a>:</h4>
<p>you can also name them when you need to reference them (which is almost never)</p>



<a name="240012501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012501">(May 24 2021 at 06:44)</a>:</h4>
<p>In particular in this case you should write <code>is_trichotomous Ïƒ (&lt;)</code> instead of using <code>_inst_1</code></p>



<a name="240012523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012523">(May 24 2021 at 06:44)</a>:</h4>
<p>and <code>ne_bot (@at_top Ïƒ _)</code></p>



<a name="240012525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YaÃ«l Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012525">(May 24 2021 at 06:44)</a>:</h4>
<p>Isn't also <code>ne_bot (@at_top \sigma \fl  preorder \alpha\fr)</code> the same as <code>non_trivial \alpha</code>?</p>



<a name="240012587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012587">(May 24 2021 at 06:45)</a>:</h4>
<p>No, the at_top filter is nontrivial iff there is no top element</p>



<a name="240012640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240012640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240012640">(May 24 2021 at 06:46)</a>:</h4>
<p>that is <code>no_top_order</code></p>



<a name="240078399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240078399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240078399">(May 24 2021 at 16:51)</a>:</h4>
<p>Kalle, is the following sufficient for your purposes?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span>
   <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">mâ‚€</span> <span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">over_lim</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">yes</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆˆ</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
    <span class="k">from</span> <span class="n">h_lim</span> <span class="o">(</span><span class="n">Iio_mem_nhds</span> <span class="bp">$</span> <span class="n">not_le.1</span> <span class="n">over_lim</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">no</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">âˆ€</span> <span class="n">n</span> <span class="bp">â‰¥</span> <span class="n">a</span><span class="o">,</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span>
        <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_Iio</span><span class="o">,</span> <span class="n">not_lt</span><span class="o">]</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">at_least</span> <span class="o">:</span> <span class="n">Ici</span> <span class="n">a</span> <span class="bp">âŠ†</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="bp">â†</span> <span class="n">eq</span> <span class="o">,</span>
      <span class="n">exact</span> <span class="n">at_top.sets_of_superset</span> <span class="o">(</span><span class="n">mem_at_top</span> <span class="n">a</span><span class="o">)</span> <span class="n">at_least</span> <span class="o">,</span> <span class="o">}</span> <span class="o">,</span>
    <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">,</span> <span class="bp">Î»</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h_incr</span> <span class="n">hb</span><span class="o">âŸ©</span> <span class="o">,</span> <span class="o">},</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">Ïƒ</span> <span class="o">:=</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">âŸ©,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">at_top</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Ïƒ</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_not_self</span><span class="o">,</span> <span class="n">not_eventually_false</span><span class="o">]</span> <span class="n">using</span> <span class="n">yes.and</span> <span class="n">no</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="240083696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/240083696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#240083696">(May 24 2021 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20limits/near/240078399">said</a>:</p>
<blockquote>
<p>Kalle, is the following sufficient for your purposes?</p>
</blockquote>
<p>It certainly is enough to cover the cases I had in mind!</p>
<p>But even with this, <code>library_search</code> only finds the real increasing case but not the ennreal case or the real decreasing case. All of these of course work with any of the proposed versions so far. But I can imagine a user wanting to find the statement by a tactic (instead of the docs, where the typeclass inference is left to the user), and I don't understand why it is found in one case and not the other(s), although the generality is enough for all... Could it be that I don't have enough <code>import</code>s for the searches below?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.instances.real</span>
<span class="kn">import</span> <span class="n">topology.instances.ennreal</span>
<span class="kn">import</span> <span class="n">init.algebra.classes</span>
<span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">filter.not_eventually_false</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">[</span><span class="n">ne_bot</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Â¬</span> <span class="o">(</span><span class="bp">âˆ€á¶ </span> <span class="n">x</span> <span class="k">in</span> <span class="n">f</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">Î»</span> <span class="n">h</span><span class="o">,</span> <span class="n">ne_bot.ne'</span> <span class="o">(</span><span class="n">eventually_false_iff_eq_bot.mp</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">filter</span>
<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span>
   <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">mâ‚€</span> <span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">over_lim</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">yes</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆˆ</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
    <span class="k">from</span> <span class="n">h_lim</span> <span class="o">(</span><span class="n">Iio_mem_nhds</span> <span class="bp">$</span> <span class="n">not_le.1</span> <span class="n">over_lim</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">no</span> <span class="o">:</span> <span class="bp">âˆ€á¶ </span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">âˆ€</span> <span class="n">n</span> <span class="bp">â‰¥</span> <span class="n">a</span><span class="o">,</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">eq</span> <span class="o">:</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">mâ‚€</span> <span class="bp">â‰¤</span> <span class="n">s</span> <span class="n">n</span> <span class="o">}</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span>
        <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_Iio</span><span class="o">,</span> <span class="n">not_lt</span><span class="o">]</span> <span class="o">,</span>
      <span class="k">have</span> <span class="n">at_least</span> <span class="o">:</span> <span class="n">Ici</span> <span class="n">a</span> <span class="bp">âŠ†</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">âˆ‰</span> <span class="n">Iio</span> <span class="o">(</span><span class="n">s</span> <span class="n">mâ‚€</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="bp">â†</span> <span class="n">eq</span> <span class="o">,</span>
      <span class="n">exact</span> <span class="n">at_top.sets_of_superset</span> <span class="o">(</span><span class="n">mem_at_top</span> <span class="n">a</span><span class="o">)</span> <span class="n">at_least</span> <span class="o">,</span> <span class="o">}</span> <span class="o">,</span>
    <span class="n">exact</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">,</span> <span class="bp">Î»</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h_incr</span> <span class="n">hb</span><span class="o">âŸ©</span> <span class="o">,</span> <span class="o">},</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">Ïƒ</span> <span class="o">:=</span> <span class="o">âŸ¨</span><span class="n">mâ‚€</span><span class="o">âŸ©,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">at_top</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Ïƒ</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_not_self</span><span class="o">,</span> <span class="n">not_eventually_false</span><span class="o">]</span> <span class="n">using</span> <span class="n">yes.and</span> <span class="n">no</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr_R'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span> <span class="c1">--works</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_decr_R'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">â„</span><span class="o">)</span> <span class="o">(</span><span class="n">decr</span> <span class="o">:</span> <span class="bp">@</span><span class="n">monotone</span> <span class="n">â„•</span> <span class="o">(</span><span class="n">order_dual</span> <span class="n">â„</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">l</span> <span class="bp">â‰¤</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span> <span class="c1">--does not work</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr_ennreal'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">âˆ€</span> <span class="n">n</span> <span class="o">,</span> <span class="n">s</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">library_search</span> <span class="c1">--does not work</span>
</code></pre></div>
<p>In any case this (and other) formulation(s) close the goals when inserted above. So in that sense they work.</p>



<a name="243117303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/243117303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#243117303">(Jun 18 2021 at 05:13)</a>:</h4>
<p><span class="user-mention" data-user-id="373986">@Kalle KytÃ¶lÃ¤</span>, I noticed the same gap today (and searching back in Zulip I found this previous discussion).  I also was surprised that it was missing!</p>
<p>I have just PR'd it, <a href="https://github.com/leanprover-community/mathlib/issues/7983">#7983</a>.  The lemma <code>monotone.ge_of_tendsto</code> is my version of your <code>tendsto_ge_of_incr</code>.  But the proof is a bit shorter ;-).  Here it is in your notation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.ordered.basic</span>

<span class="kn">open</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kd">lemma</span> <span class="n">tendsto_ge_of_incr</span> <span class="o">{</span><span class="n">Ïƒ</span> <span class="n">Ï„</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">Ïƒ</span><span class="o">]</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">Ïƒ</span><span class="o">]</span>
  <span class="o">[</span><span class="n">linear_order</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Ï„</span><span class="o">]</span> <span class="o">[</span><span class="n">order_topology</span> <span class="n">Ï„</span><span class="o">]</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ïƒ</span> <span class="bp">â†’</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ï„</span><span class="o">}</span> <span class="o">(</span><span class="n">h_incr</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lim</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">s</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">ğ“</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">âˆ€</span> <span class="n">n</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">â‰¤</span> <span class="n">l</span> <span class="o">:=</span>
<span class="bp">Î»</span> <span class="n">n</span><span class="o">,</span> <span class="n">ge_of_tendsto</span> <span class="n">h_lim</span> <span class="o">((</span><span class="n">eventually_ge_at_top</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">mono</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">_</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">h_incr</span> <span class="n">hxy</span><span class="o">))</span>
</code></pre></div>



<a name="243138139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/monotone%20limits/near/243138139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/monotone.20limits.html#243138139">(Jun 18 2021 at 09:42)</a>:</h4>
<p>A <em>bit</em> shorter? Wow!</p>
<p>Thanks a lot <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>! I tended to believe it would be useful in mathlib, and if your PR lands there before I finish my current exercise, I will be able to use it <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
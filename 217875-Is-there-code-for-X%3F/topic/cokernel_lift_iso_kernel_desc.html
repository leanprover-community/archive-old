---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html">cokernel_lift_iso_kernel_desc</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272582840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272582840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272582840">(Feb 20 2022 at 10:32)</a>:</h4>
<p>Do we have this canonical iso somewhere? Or that this is simply not true?<br>
I don't have a good way to construct the inverse map though.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">cokernel_lift_iso_kernel_desc</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">abelian</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⟶</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">cokernel</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="bp">≅</span> <span class="n">kernel</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="272582922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272582922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272582922">(Feb 20 2022 at 10:33)</a>:</h4>
<p>This looks <em>very similar</em> to what I've been doing for derived functors. Let me check if it is actually identical.</p>



<a name="272582928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272582928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272582928">(Feb 20 2022 at 10:33)</a>:</h4>
<p>What are you working on?</p>



<a name="272582992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272582992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272582992">(Feb 20 2022 at 10:34)</a>:</h4>
<p>I'm constructing projective replacements of bounded cochain complexes.</p>



<a name="272583391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272583391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272583391">(Feb 20 2022 at 10:43)</a>:</h4>
<p>I didn't prove this one, but you can have a look <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/derived_functor_zero.lean">here</a>.</p>



<a name="272583397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272583397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272583397">(Feb 20 2022 at 10:43)</a>:</h4>
<p>I think you can do it using pseudoelements</p>



<a name="272583412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272583412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272583412">(Feb 20 2022 at 10:43)</a>:</h4>
<p>You have the morphism in one direction, right?</p>



<a name="272583728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272583728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272583728">(Feb 20 2022 at 10:50)</a>:</h4>
<p>(My file is a mess, I know. I will clean it once it's sorry free)</p>



<a name="272583777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272583777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272583777">(Feb 20 2022 at 10:51)</a>:</h4>
<p>The morphism is just<br>
<code>cokernel.desc _ (kernel.lift _ (kernel.ι _ ≫ cokernel.π _) (by simp)) (by { ext, simp })</code>.<br>
Yeah, I'm also fiddling with pseudoelements. Not sure if there is a cleaner proof though.</p>



<a name="272583890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272583890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272583890">(Feb 20 2022 at 10:53)</a>:</h4>
<p>The morphism is also equal to <code>kernel.lift _ (cokernel.desc _ (kernel.ι g ≫ cokernel.π _) (by simp)) (by { ext, simp })</code>, and I think using one way you can show that it is mono, and with the other way that it is epi.</p>



<a name="272585696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272585696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272585696">(Feb 20 2022 at 11:24)</a>:</h4>
<p>(deleted)</p>



<a name="272587107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272587107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272587107">(Feb 20 2022 at 11:49)</a>:</h4>
<p>Here's a full proof without pseudoelements:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.abelian.basic</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kn">open</span> <span class="n">category_theory.limits</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">abelian</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⟶</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">cokernel_lift_to_kernel_desc₁</span> <span class="o">:</span> <span class="n">cokernel</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">kernel</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">kernel.lift</span> <span class="n">_</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">_</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">cokernel.π</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">))</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">})</span>

<span class="kd">def</span> <span class="n">cokernel_lift_to_kernel_desc₂</span> <span class="o">:</span> <span class="n">cokernel</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">kernel</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">cokernel.desc</span> <span class="n">_</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">_</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">cokernel.π</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">))</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">})</span>

<span class="kd">lemma</span> <span class="n">cokernel_lift_to_kernel_desc_eq</span> <span class="o">:</span>
  <span class="n">cokernel_lift_to_kernel_desc₁</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">cokernel_lift_to_kernel_desc₂</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">cokernel_lift_to_kernel_desc₁</span><span class="o">,</span> <span class="n">cokernel_lift_to_kernel_desc₂</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mono</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">cokernel.π</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">cokernel.π</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)),</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">is_colimit</span> <span class="o">(</span><span class="n">pushout_cocone.mk</span> <span class="n">t</span> <span class="o">(</span><span class="n">cokernel.π</span> <span class="n">f</span><span class="o">)</span> <span class="n">_</span> <span class="o">:</span> <span class="n">pushout_cocone</span> <span class="o">(</span><span class="n">cokernel.π</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">abelian.mono_inl_of_is_colimit</span> <span class="n">_</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">pushout_cocone.is_colimit_aux'</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">s.inr</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">w</span> <span class="n">w'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">kernel.lift_ι</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">,</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">s.condition</span><span class="o">,</span> <span class="bp">←</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="n">cokernel.condition</span><span class="o">,</span>
      <span class="n">zero_comp</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="o">(</span><span class="n">cancel_epi</span> <span class="o">(</span><span class="n">cokernel.π</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">s.condition</span><span class="o">,</span> <span class="n">cokernel.π_desc</span><span class="o">,</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="n">pushout_cocone.mk_inl</span><span class="o">,</span>
      <span class="n">cokernel.π_desc_assoc</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">cokernel.π_desc</span><span class="o">,</span> <span class="n">pushout_cocone.mk_inr</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="o">(</span><span class="n">cancel_epi</span> <span class="o">(</span><span class="n">cokernel.π</span> <span class="n">f</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">cokernel.π_desc</span><span class="o">]</span> <span class="n">using</span> <span class="n">w'</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">epi</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">cokernel.π</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">cokernel.π</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category.assoc</span><span class="o">,</span> <span class="n">cokernel.π_desc</span><span class="o">,</span> <span class="n">kernel.condition</span><span class="o">])),</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">is_limit</span> <span class="o">(</span><span class="n">pullback_cone.mk</span> <span class="n">t</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span><span class="o">)</span> <span class="n">_</span> <span class="o">:</span> <span class="n">pullback_cone</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">cokernel.π</span> <span class="n">f</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">abelian.epi_fst_of_is_limit</span> <span class="n">_</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">kernel.lift_ι</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">pullback_cone.is_limit_aux'</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">s.snd</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">w</span> <span class="n">w'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">cokernel.π_desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">,</span> <span class="bp">←</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">s.condition</span><span class="o">,</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="n">kernel.condition</span><span class="o">,</span>
      <span class="n">comp_zero</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="o">(</span><span class="n">cancel_mono</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">s.condition</span><span class="o">,</span> <span class="n">kernel.lift_ι</span><span class="o">,</span> <span class="n">category.assoc</span><span class="o">,</span> <span class="n">pullback_cone.mk_fst</span><span class="o">,</span>
      <span class="n">kernel.lift_ι_assoc</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">kernel.lift_ι</span><span class="o">,</span> <span class="n">pullback_cone.mk_snd</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="o">(</span><span class="n">cancel_mono</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">g</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">kernel.lift_ι</span><span class="o">]</span> <span class="n">using</span> <span class="n">w'</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">mono_cokernel_lift_to_kernel_desc₁</span> <span class="o">:</span> <span class="n">mono</span> <span class="o">(</span><span class="n">cokernel_lift_to_kernel_desc₁</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">kernel.lift_mono</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="n">epi_cokernel_lift_to_kernel_desc₁</span> <span class="o">:</span> <span class="n">epi</span> <span class="o">(</span><span class="n">cokernel_lift_to_kernel_desc₁</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">cokernel_lift_to_kernel_desc_eq</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">cokernel.desc_epi</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_iso</span> <span class="o">(</span><span class="n">cokernel_lift_to_kernel_desc₁</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_iso_of_mono_of_epi</span> <span class="n">_</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">cokernel_lift_iso_kernel_desc</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">abelian</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">⟶</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">cokernel</span> <span class="o">(</span><span class="n">kernel.lift</span> <span class="n">g</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="bp">≅</span> <span class="n">kernel</span> <span class="o">(</span><span class="n">cokernel.desc</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">as_iso</span> <span class="o">(</span><span class="n">cokernel_lift_to_kernel_desc₁</span> <span class="n">f</span> <span class="n">g</span> <span class="n">w</span><span class="o">)</span>
</code></pre></div>



<a name="272595489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272595489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272595489">(Feb 20 2022 at 14:25)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> <a href="#narrow/stream/267928-condensed-mathematics/topic/LES.20for.20Ext/near/272419447">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/LES.20for.20Ext/near/272419447</a></p>



<a name="272598295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272598295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272598295">(Feb 20 2022 at 15:20)</a>:</h4>
<p>So is everyone ready to change the definition of <code>homology</code> now?</p>



<a name="272599746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272599746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272599746">(Feb 20 2022 at 15:49)</a>:</h4>
<p>I am in favor of changing it, but we already use quite a lot in the LTE. I don't know how much work a refactor would be</p>



<a name="272600103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272600103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272600103">(Feb 20 2022 at 15:55)</a>:</h4>
<p>We should at least add the API obtained by identifying it with a cokernel or kernel, similarly to the lemmas in the code under the link I posted</p>



<a name="272600116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272600116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272600116">(Feb 20 2022 at 15:55)</a>:</h4>
<p>That would make it much more pleasant to work with IMO</p>



<a name="272615053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272615053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272615053">(Feb 20 2022 at 20:42)</a>:</h4>
<p>This should help: <a href="https://github.com/leanprover-community/mathlib/pull/12171">#12171</a></p>



<a name="272616724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272616724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272616724">(Feb 20 2022 at 21:10)</a>:</h4>
<p>I am adding the file to the LTE (shamelessly of course, but you're listed as the author).</p>



<a name="272617920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272617920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272617920">(Feb 20 2022 at 21:32)</a>:</h4>
<p>I am already lost trying to use your constructions :D Do you see an easy way of providing the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">left_derived.zero_to_self_obj_hom</span> <span class="o">[</span><span class="n">enough_projectives</span> <span class="n">C</span><span class="o">]</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ProjectiveResolution</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">F.left_derived</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">X</span>
</code></pre></div>



<a name="272619909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272619909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272619909">(Feb 20 2022 at 22:07)</a>:</h4>
<p>Perhaps using <code>homology.desc'</code>? I'm away from my computer, so I can't check</p>



<a name="272620027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272620027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272620027">(Feb 20 2022 at 22:09)</a>:</h4>
<p>I mean, I already have it with the current API, it's just to play with what you did</p>



<a name="272620054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272620054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272620054">(Feb 20 2022 at 22:09)</a>:</h4>
<p>If you want to map out of homology, you can use <code>homology.desc'</code> and if you want to map into it, use <code>homology.lift</code></p>



<a name="272625889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272625889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272625889">(Feb 21 2022 at 00:00)</a>:</h4>
<p>Something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">left_derived.zero_to_self_obj_hom</span> <span class="o">[</span><span class="n">enough_projectives</span> <span class="n">C</span><span class="o">]</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ProjectiveResolution</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">F.left_derived</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left_derived_obj_iso</span> <span class="n">F</span> <span class="mi">0</span> <span class="n">P</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">≫</span> <span class="n">homology.desc'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">kernel.ι</span> <span class="n">_</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">F.map</span> <span class="o">(</span><span class="n">P.π.f</span> <span class="mi">0</span><span class="o">)))</span>
<span class="kd">begin</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">complex_shape.down</span> <span class="n">ℕ</span><span class="o">)</span><span class="bp">.</span><span class="n">rel</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">kernel.lift_ι_assoc</span><span class="o">,</span> <span class="n">homological_complex.d_to_eq</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span> <span class="n">map_homological_complex_obj_d</span><span class="o">,</span>
      <span class="n">category.assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">functor.map_comp</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">},</span>
<span class="kd">end</span>
<span class="bp">≫</span> <span class="n">F.map</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>works (I don't know if using <code>P</code> is a good idea or not). In any case naturality of this morphism seems a pain. I will have a closer look tomorrow.</p>



<a name="272717671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272717671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272717671">(Feb 21 2022 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span>  I added the lemmas you asked for in <a href="https://github.com/leanprover-community/mathlib/pull/12171">#12171</a> . <br>
<code>homology.map</code> is pretty clunky to work with. Maybe we should think about (eventually) redefining <code>homology.map</code> to be, e.g. <br>
<code>homology.desc' _ _ _ (homology.lift _ _ _ (kernel.ι _ ≫ β.left ≫ cokernel.π _) _) _</code>.</p>



<a name="272717853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272717853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272717853">(Feb 21 2022 at 17:43)</a>:</h4>
<p>Note that the proofs that switch between <code>homology.desc' ... (homology.lift ...)</code> and <code>homology.lift ... (homology.desc' ...)</code> are now just a simple <code>ext, simp</code> game.</p>



<a name="272717976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272717976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272717976">(Feb 21 2022 at 17:44)</a>:</h4>
<p>This should make the naturality of your map pretty simple to prove I think.</p>



<a name="272718678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272718678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272718678">(Feb 21 2022 at 17:52)</a>:</h4>
<p>Thanks!!</p>



<a name="272718853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272718853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272718853">(Feb 21 2022 at 17:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/cokernel_lift_iso_kernel_desc/near/272717976">said</a>:</p>
<blockquote>
<p>This should make the naturality of your map pretty simple to prove I think.</p>
</blockquote>
<p>Assuming you define it using <code>homology.desc'</code>, of course!</p>



<a name="272719055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272719055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272719055">(Feb 21 2022 at 17:56)</a>:</h4>
<p>I will do it later, but I agree it should be easy now.</p>



<a name="272735247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/cokernel_lift_iso_kernel_desc/near/272735247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/cokernel_lift_iso_kernel_desc.html#272735247">(Feb 21 2022 at 21:08)</a>:</h4>
<p>I confirm it's now easy</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
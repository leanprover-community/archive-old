---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html">𝔽₄</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="320946805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320946805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320946805">(Jan 12 2023 at 14:09)</a>:</h4>
<p>Do we have any computable way to build <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>? I can build the data quite easily with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive [add_comm_group, fintype]</span><span class="o">]</span>
<span class="kd">def</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="n">zmod</span> <span class="mi">2</span> <span class="bp">×</span> <span class="n">zmod</span> <span class="mi">2</span>
<span class="kn">namespace</span> <span class="bp">𝔽₄</span>

  <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)⟩</span>
  <span class="kd">def</span> <span class="n">α</span> <span class="o">:</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="bp">𝔽₄</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="s2">"0"</span><span class="o">,</span> <span class="s2">"α"</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="s2">"1"</span><span class="o">,</span> <span class="s2">"1 + α"</span><span class="o">]]</span> <span class="n">f.1</span> <span class="n">f.2</span><span class="o">⟩</span>

  <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span>     <span class="mi">0</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span>    <span class="mi">0</span><span class="o">,</span>     <span class="mi">0</span><span class="o">]],</span>
        <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span>     <span class="mi">1</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span>    <span class="n">α</span><span class="o">,</span> <span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">]]],</span>
      <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span>     <span class="n">α</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>     <span class="mi">1</span><span class="o">]],</span>
        <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span>    <span class="mi">1</span><span class="o">,</span>     <span class="n">x</span><span class="o">]]]]</span> <span class="n">x.1</span> <span class="n">x.2</span> <span class="n">y.1</span> <span class="n">y.2</span><span class="o">⟩</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="n">α</span>
<span class="kd">end</span> <span class="bp">𝔽₄</span>
</code></pre></div>
<p>but I'm left with a nasty case bash to prove it's a field</p>



<a name="320947052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320947052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320947052">(Jan 12 2023 at 14:10)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/galois_field">docs#galois_field</a><code> 2 2</code>?</p>



<a name="320947129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320947129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320947129">(Jan 12 2023 at 14:11)</a>:</h4>
<p>Or is that not computable enough?</p>



<a name="320947269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320947269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320947269">(Jan 12 2023 at 14:11)</a>:</h4>
<p>That's not computable at all unfortunately, due to <code>polynomial.X</code> being noncomputable</p>



<a name="320947335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320947335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320947335">(Jan 12 2023 at 14:11)</a>:</h4>
<p>But I guess I could get the field structure for my example via isomorhism with it</p>



<a name="320953114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320953114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320953114">(Jan 12 2023 at 14:36)</a>:</h4>
<p>Can you set it up in such a way that <code>dec_trivial</code> works for all the Prop fields?</p>



<a name="320955107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320955107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320955107">(Jan 12 2023 at 14:44)</a>:</h4>
<p><del>Unfortunately that doesn't work for <code>mul_inv_cancel</code>, but it does work for every other field!</del></p>



<a name="320955694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320955694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320955694">(Jan 12 2023 at 14:46)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The finite field with four elements.</span>

<span class="sd">As an implementation detail, this is implemented as the additive group</span>
<span class="sd">`zmod 2 × zmod 2` with a different multiplication. -/</span>
<span class="kd">@[derive [add_comm_group, fintype, decidable_eq, nontrivial]</span><span class="o">]</span>
<span class="kd">def</span> <span class="bp">𝔽₄</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">zmod</span> <span class="mi">2</span> <span class="bp">×</span> <span class="n">zmod</span> <span class="mi">2</span>
<span class="kn">namespace</span> <span class="bp">𝔽₄</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)⟩</span>
<span class="kd">def</span> <span class="n">α</span> <span class="o">:</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="bp">𝔽₄</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="s2">"0"</span><span class="o">,</span> <span class="s2">"1"</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="s2">"α"</span><span class="o">,</span> <span class="s2">"1 + α"</span><span class="o">]]</span> <span class="n">f.2</span> <span class="n">f.1</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span>     <span class="mi">0</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span>    <span class="mi">0</span><span class="o">,</span>     <span class="mi">0</span><span class="o">]],</span>
      <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span>     <span class="mi">1</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span>    <span class="n">α</span><span class="o">,</span> <span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">]]],</span>
    <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span>     <span class="n">α</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>     <span class="mi">1</span><span class="o">]],</span>
      <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span>    <span class="mi">1</span><span class="o">,</span>     <span class="n">α</span><span class="o">]]]]</span> <span class="n">x.2</span> <span class="n">x.1</span> <span class="n">y.2</span> <span class="n">y.1</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="bp">𝔽₄</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">α</span><span class="o">]]</span> <span class="n">x.2</span> <span class="n">x.1</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">field</span> <span class="bp">𝔽₄</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">zero</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">+</span><span class="o">),</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">nat_cast</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
  <span class="n">nat_cast_zero</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">nat_cast_succ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">prod.ext</span> <span class="o">(</span><span class="n">nat.cast_succ</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">add_zero</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="n">has_inv.inv</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">mul_inv_cancel</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">inv_zero</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="bp">..𝔽₄.</span><span class="n">add_comm_group</span><span class="o">,</span>
  <span class="bp">..𝔽₄.</span><span class="n">nontrivial</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">char_two</span> <span class="o">:</span> <span class="n">char_p</span> <span class="bp">𝔽₄</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">prod.ext_iff.trans</span> <span class="bp">$</span> <span class="o">(</span><span class="n">and_iff_left</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="n">char_p.cast_eq_zero_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="bp">𝔽₄</span>
</code></pre></div>



<a name="320955817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320955817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320955817">(Jan 12 2023 at 14:47)</a>:</h4>
<p><code>dec_trivial</code> failed initially because my implementation was wrong!</p>



<a name="320955964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320955964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320955964">(Jan 12 2023 at 14:47)</a>:</h4>
<p>My follow-up question would be whether this is suitable for inclusion in mathlib given that <code>galois_field 2 2</code> exists</p>



<a name="320964422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320964422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320964422">(Jan 12 2023 at 15:22)</a>:</h4>
<p>That <code>def 𝔽₄ := zmod 2 × zmod 2</code> line really hurts the eye.</p>



<a name="320968464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/320968464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#320968464">(Jan 12 2023 at 15:38)</a>:</h4>
<p>Yes, it if were in mathlib rather than a sloppy zulip post that would need a comment explaining what is going on</p>



<a name="321044849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/321044849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#321044849">(Jan 12 2023 at 22:17)</a>:</h4>
<p>I understand that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> is the only (good) even prime number (or is it <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>?). But presumably mathlib should have a computable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2655em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, right?</p>



<a name="321047061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/321047061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#321047061">(Jan 12 2023 at 22:33)</a>:</h4>
<p>I think that in programs like magma, which have very fast finite fields, they cache the multiplication tables etc. The problem with F_p^n is that there's no canonical model because of the automorphisms, so you'll have to choose your favourite irreducible degree n polynomial over F_p i.e. a random one</p>



<a name="321047870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/321047870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#321047870">(Jan 12 2023 at 22:38)</a>:</h4>
<p><a href="http://www.seanerikoconnor.freeservers.com/Mathematics/AbstractAlgebra/PrimitivePolynomials/theory.html">This article</a> looks like a nice summary of algorithms for finding primitive polynomials. (You can skip to the section <em>Definition of Primitive Polynomial</em>). Assuming you have a primitive polynomial ready, here is some code that defines multiplication and inverse Lean-computably:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.basic</span>
<span class="kn">import</span> <span class="n">data.fin.vec_notation</span>
<span class="kn">import</span> <span class="n">data.zmod.basic</span>

<span class="n">open_locale</span> <span class="n">polynomial</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">section</span> <span class="n">adjoin_root</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">mp</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">to_poly</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">X</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">C</span> <span class="o">(</span><span class="n">mp</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">^</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kd">@[nolint unused_arguments, derive add_comm_group]</span>
<span class="c">/-</span><span class="cm"> A computable representation of `adjoin_root (to_poly mp)`.</span>
<span class="cm">  Finite fields of order p^n can be obtained by choosing an</span>
<span class="cm">  irreducible polynomial of degree n over `zmod p` as `to_poly mp`.</span>
<span class="cm">  Using `array` may be faster, but it's a structure so isn't defeq to `fin n → R`,</span>
<span class="cm">  and it doesn't have an add_group instance. -/</span>
<span class="kd">def</span> <span class="n">adjoin_root</span> <span class="o">(</span><span class="n">mp</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_smul</span> <span class="n">R</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pi.has_smul</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">has_repr</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pi_fin.has_repr</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pi.fintype</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fintype.decidable_pi_fintype</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">mp</span><span class="o">}</span>

<span class="sd">/-- multiply by the generator. -/</span>
<span class="kd">def</span> <span class="n">mul_gen</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:</span> <span class="n">adjoin_root</span> <span class="n">mp</span> <span class="o">:=</span>
<span class="n">a</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">•</span> <span class="n">mp</span> <span class="bp">+</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span> <span class="o">(</span><span class="n">i</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mul_aux</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">adjoin_root</span> <span class="n">mp</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">•</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mul_gen</span> <span class="o">(</span><span class="n">mul_aux</span> <span class="n">k</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">(</span><span class="n">fin.rev</span> <span class="bp">↑</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">•</span> <span class="n">b</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">mul_aux</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">pi.single</span> <span class="mi">0</span> <span class="mi">1</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">n</span><span class="o">,</span> <span class="n">npow_rec</span> <span class="n">n</span> <span class="n">a</span><span class="o">⟩</span>

<span class="c">/-</span><span class="cm"> Inverse requires `[field R]` and `irreducible (to_poly mp)`, and could be implemented using</span>
<span class="cm">  Euclidean algorithm, like how `zmod.inv` is defined. For finite fields (`R = zmod p` with `p`</span>
<span class="cm">  prime), it can be obtained by raising to the `p^(n+1)-2`th power.</span>
<span class="cm">  TODO: show `adjoin_root mp` is a comm_ring using the equivalence with `adjoin (to_poly mp)`;</span>
<span class="cm">    show it's a field when `R` is a field and `to_poly mp` is irreducible. -/</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">Qi</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="bp">-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">ℚ</span><span class="o">)</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="bp">*</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="bp">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">Qi</span><span class="o">)</span> <span class="c1">--![2, 0]</span>

<span class="kd">end</span> <span class="n">adjoin_root</span>

<span class="kn">section</span> <span class="n">finite_field</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mp</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">mp</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="bp">^</span> <span class="o">(</span><span class="n">p</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">2</span><span class="o">))⟩</span>
<span class="c">/-</span><span class="cm"> Warning: gives 0⁻¹ = 1 when p = 2, n = 0 -/</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">F4</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="bp">*</span> <span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">F4</span><span class="o">)</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">F4</span><span class="o">)</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="c1">-- profiler says elaboration takes 4~5s but actually takes 37s</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">field</span> <span class="n">F4</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="n">has_inv.inv</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">mul_inv_cancel</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="n">inv_zero</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">adjoin_root.add_comm_group</span> <span class="n">_</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">pi.nontrivial</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">finite_field</span>
</code></pre></div>



<a name="321048656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/321048656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#321048656">(Jan 12 2023 at 22:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.F0.9D.94.BD.E2.82.84/near/321047061">said</a>:</p>
<blockquote>
<p>... because of the automorphisms...</p>
</blockquote>
<p>in principle we can have all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2655em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>'s.</p>



<a name="321052006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%F0%9D%94%BD%E2%82%84/near/321052006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.F0.9D.94.BD.E2.82.84.html#321052006">(Jan 12 2023 at 23:08)</a>:</h4>
<p>I'm afraid there are <code>φ(p^n-1)/n</code> primitive polynomials, i.e. monic polynomials <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \in \mathbb{F}_p[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub><mo>≅</mo><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">⟨</mo><mi>f</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n} \cong  \mathbb{F}_p[X]/ \langle f\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.975em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2655em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">⟩</span></span></span></span> and all nonzero elements are powers of the class of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. My code only requires an irreducible polynomial (i.e. without the last condition), but primitive polynomials are commonly used, probably because it's easier to make a exp-log table from it?</p>
<ul>
<li><a href="https://reference.wolfram.com/language/FiniteFields/tutorial/FiniteFields.html">Mathematica</a> provides a default IrreduciblePolynomial but doesn't say what algorithm it uses, and also let you specify your own. </li>
<li>MATLAB has <a href="https://www.mathworks.com/help/comm/ref/gfprimfd.html">this</a>.</li>
<li><a href="https://doc.sagemath.org/html/en/reference/finite_rings/sage/rings/finite_rings/finite_field_constructor.html">Sage</a> chooses Conway polynomials.</li>
</ul>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
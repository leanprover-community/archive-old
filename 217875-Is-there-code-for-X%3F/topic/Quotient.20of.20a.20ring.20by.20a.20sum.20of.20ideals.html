---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html">Quotient of a ring by a sum of ideals</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246947751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246947751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246947751">(Jul 23 2021 at 07:26)</a>:</h4>
<p>Hi ! </p>
<p>Say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex"> R </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a commutative ring, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo separator="true">,</mo><mi>J</mi></mrow><annotation encoding="application/x-tex"> I,J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> are ideals of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex"> R </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>J</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex"> J&#x27; </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is the ideal corresponding to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex"> J </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex"> R/I </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>.<br>
Does anyone know of results of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>I</mi><mo>+</mo><mi>J</mi><mo stretchy="false">)</mo><mo>≅</mo><mo stretchy="false">(</mo><mi>R</mi><mi mathvariant="normal">/</mi><mi>I</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mi>J</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex"> R/(I+J) \cong (R/I)/J&#x27; </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> in matlib ? (I couldn't find any when browsing through the files I thought might contain something like that).</p>
<p>The context is I am trying to show that for an integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex"> p </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> (of course later I will be taking <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> to be prime, hence the choice of notation <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>)  and a polynomial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex"> f </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> with integer coefficients,  there is an isomorphism <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>p</mi><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mover accent="true"><mi>f</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathbb{Z}[x] / (p, f(x) ) \cong \mathbb{Z}/p\mathbb{Z}[x] / ( \overline{f}(x) ) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.14444em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.81444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> that sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>+</mo><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> g + (p , f(x) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mo>+</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mover accent="true"><mi>f</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g +( p )) + (\overline{f}(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.14444em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.81444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>f</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{f}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.08888em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.81444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> is the reduction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> mod <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>.</p>
<p>Many thanks in advance !</p>



<a name="246953302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246953302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246953302">(Jul 23 2021 at 08:40)</a>:</h4>
<p>I also can't find this exact result (or anything much approaching it) in mathlib. Here's the definitions, but I've not filled in any of the proofs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">ring_theory.ideal.operations</span>

<span class="c1">-- let R be a commutative ring and let I,J be ideals of R</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="c1">-- define f₁ to be the obvious ring hom R/I → R/(I+J)</span>
<span class="kd">def</span> <span class="n">f₁</span> <span class="o">:</span> <span class="n">I.quotient</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span> <span class="n">ideal.quotient.lift</span> <span class="n">I</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="gr">sorry</span>

<span class="c1">-- define f₂ to be the induced ring hom (R/I)/J' -&gt;R/(I+J), where J' is the image of J in R/I</span>
<span class="kd">def</span> <span class="n">f₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ideal.quotient.lift</span> <span class="o">(</span><span class="n">ideal.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="c1">-- Then f₂ is an isomorphism</span>
<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">≃+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ring_equiv.of_bijective</span> <span class="o">(</span><span class="n">f₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="gr">sorry</span>
</code></pre></div>
<p>To me this indicates that we're missing some API for this sort of thing.</p>



<a name="246953749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246953749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246953749">(Jul 23 2021 at 08:45)</a>:</h4>
<p>Actually I think I'm being overly pessimistic making it noncomputable...</p>



<a name="246954185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246954185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246954185">(Jul 23 2021 at 08:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">ring_theory.ideal.operations</span>

<span class="c1">-- let R be a commutative ring and let I,J be ideals of R</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="c1">-- define f₁ to be the obvious ring hom R/I → R/(I+J)</span>
<span class="kd">def</span> <span class="n">f₁</span> <span class="o">:</span> <span class="n">I.quotient</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span> <span class="n">ideal.quotient.lift</span> <span class="n">I</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="gr">sorry</span>

<span class="c1">-- define f₂ to be the induced ring hom (R/I)/J' -&gt;R/(I+J), where J' is the image of J in R/I</span>
<span class="kd">def</span> <span class="n">f₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ideal.quotient.lift</span> <span class="o">(</span><span class="n">ideal.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="c1">-- define g₁ to be the composite of the maps R → (R/I) and (R/I) → (R/I)/J'</span>
<span class="kd">def</span> <span class="n">g₁</span> <span class="o">:=</span> <span class="n">ring_hom.comp</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)))</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span>

<span class="c1">-- define g₂ to be the induced map R/(I+J) → (R/I)/J'</span>
<span class="kd">def</span> <span class="n">g₂</span> <span class="o">:=</span> <span class="n">ideal.quotient.lift</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">g₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="gr">sorry</span>

<span class="c1">-- Then f₂ and g₂ are inverse isomorphisms</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">≃+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">g₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">ring_hom.map_mul</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">ring_hom.map_add</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="246954572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246954572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246954572">(Jul 23 2021 at 08:56)</a>:</h4>
<p>Thanks a lot ! I'd started to try and write some code towards a proof, but had some trouble understanding how Lean works with defining maps on quotients. I'd be happy to work on a bit of API for this sort of thing, since it seems I'll be needing it for the stuff I'm working on at the minute <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="246964781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246964781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246964781">(Jul 23 2021 at 11:11)</a>:</h4>
<p>I found quotients In lean hard to understand so I <a href="https://wp.me/p9bxpM-LQ">wrote a workshop on them</a> as part of my formalising mathematics course. The main thing to know is that quotients are defined by their universal property and what Lean calls <code>lift</code> is what a mathematician would think of as descent (<code>lift</code> is the function you use to get a map from the quotient given a map from the original ring and a proof that the ideal is in the kernel)</p>



<a name="246964896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246964896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246964896">(Jul 23 2021 at 11:13)</a>:</h4>
<p>Some of those sorries might be a little tricky by the way, I suspect they'll all have pretty slick solutions in Lean which will only be a few lines long but they might be hard to find!</p>



<a name="246971458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246971458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246971458">(Jul 23 2021 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/246964781">said</a>:</p>
<blockquote>
<p>I found quotients In lean hard to understand so I <a href="https://wp.me/p9bxpM-LQ">wrote a workshop on them</a> as part of my formalising mathematics course. The main thing to know is that quotients are defined by their universal property and what Lean calls <code>lift</code> is what a mathematician would think of as descent (<code>lift</code> is the function you use to get a map from the quotient given a map from the original ring and a proof that the ideal is in the kernel)</p>
</blockquote>
<p>I've just read through the workshop, it makes a lot more sense now. I quite like the universal property approach !</p>



<a name="246971596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/246971596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#246971596">(Jul 23 2021 at 12:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/246964896">said</a>:</p>
<blockquote>
<p>Some of those sorries might be a little tricky by the way, I suspect they'll all have pretty slick solutions in Lean which will only be a few lines long but they might be hard to find!</p>
</blockquote>
<p>Good to know ! My initial attempt had around 50 lines of code, and I wasn't even half way through, so I'll probably have to do some rewriting !</p>



<a name="247310079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247310079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247310079">(Jul 27 2021 at 09:10)</a>:</h4>
<p>I've been able to spell out the proofs fully, but my code is still somewhat long-ish. Do you have any tips for making it more concise ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.ideal.operations</span>
<span class="kn">import</span> <span class="n">ring_theory.ideal.basic</span>
<span class="kn">open</span> <span class="n">ideal</span>

<span class="kn">namespace</span> <span class="n">ideal_quot</span>

<span class="c1">-- let R be a commutative ring and let I,J be ideals of R</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="n">J</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">add_comm</span> <span class="o">:</span> <span class="n">I</span><span class="bp">+</span><span class="n">J</span> <span class="bp">=</span> <span class="n">J</span><span class="bp">+</span><span class="n">I</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="o">[</span><span class="n">ideal.add_eq_sup</span><span class="o">,</span> <span class="n">sup_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">ideal.add_eq_sup</span><span class="o">]}</span>


<span class="c1">-- a few lemmas to help shorten the proofs later</span>
<span class="kd">def</span> <span class="n">left_proj_quot_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span> <span class="bp">→</span>  <span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">hx</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ideal.quotient.eq_zero_iff_mem.2</span> <span class="o">(</span><span class="n">ideal.mem_sup_left</span> <span class="n">hx</span><span class="o">)}</span>

<span class="kd">def</span> <span class="n">right_proj_quot_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">):</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span> <span class="bp">→</span>  <span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">hx</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ideal.quotient.eq_zero_iff_mem.2</span> <span class="o">(</span><span class="n">ideal.mem_sup_right</span> <span class="n">hx</span><span class="o">)}</span>

<span class="kd">lemma</span> <span class="n">in_ker_proj_to_sum_left</span> <span class="o">:</span> <span class="n">I.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span><span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ideal.map</span><span class="o">,</span><span class="n">ideal.span_eq_bot</span><span class="o">],</span>
  <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">set.mem_image</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hy</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">hx.2</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">left_proj_quot_sum</span> <span class="n">I</span> <span class="n">J</span> <span class="n">x</span> <span class="n">hx.1</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">in_ker_proj_to_sum_right</span> <span class="o">:</span> <span class="n">J.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span><span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">apply</span> <span class="n">in_ker_proj_to_sum_left</span><span class="o">}</span>

<span class="c1">-- define f₁ to be the obvious ring hom R/I → R/(I+J)</span>
<span class="kd">def</span> <span class="n">f₁</span> <span class="o">:</span> <span class="n">I.quotient</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ideal.quotient.lift</span> <span class="n">I</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="o">(</span><span class="n">left_proj_quot_sum</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span>

<span class="c1">-- one of the longer proofs. This will be used to lift f₁ to a map (R/I)/J' → R/(I+J)</span>
<span class="kd">def</span> <span class="n">H_proj_J</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">I.quotient</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hx</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hIJmap</span><span class="o">:</span> <span class="o">((</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="bp">''</span> <span class="n">J</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="bp">''</span> <span class="n">J</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">set.ext</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>

    <span class="o">{</span><span class="n">intro</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span><span class="n">hz</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">set.mem_image</span> <span class="o">((</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span> <span class="n">J</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">f₁</span> <span class="n">at</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ring_hom.comp_apply</span><span class="o">,</span><span class="n">ideal.quotient.lift_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hz.right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">set.mem_image_of_mem</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="n">hz.left</span><span class="o">},</span>

    <span class="o">{</span><span class="n">intro</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span><span class="n">hz</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">set.mem_image</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="n">J</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">f₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.mem_image_eq</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">ring_hom.comp_apply</span><span class="o">,</span><span class="n">ideal.quotient.lift_mk</span><span class="o">]},</span>

  <span class="k">have</span> <span class="n">hJ</span><span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="bp">=</span> <span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span>
    <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ideal.map_map</span><span class="o">,</span><span class="n">ideal.map</span><span class="o">,</span><span class="n">hIJmap</span><span class="o">,</span><span class="bp">←</span> <span class="n">ideal.map</span><span class="o">],</span>

  <span class="k">have</span> <span class="n">hf₁a</span> <span class="o">:</span> <span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">ideal.map</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">set.mem_of_subset_of_mem</span> <span class="o">(</span><span class="n">ideal.subset_span</span><span class="o">),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">set.mem_image_of_mem</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="n">hx</span><span class="o">),</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">hJ</span><span class="o">,</span> <span class="n">in_ker_proj_to_sum_right</span> <span class="n">I</span> <span class="n">J</span><span class="o">]</span> <span class="n">at</span> <span class="n">hf₁a</span><span class="o">,</span>
<span class="kd">end</span>


<span class="c1">-- define f₂ to be the induced ring hom (R/I)/J' -&gt;R/(I+J), where J' is the image of J in R/I</span>
<span class="kd">def</span> <span class="n">f₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ideal.quotient.lift</span> <span class="o">(</span><span class="n">ideal.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">H_proj_J</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span>

<span class="c1">-- define g₁ to be the composite of the maps R → (R/I) and (R/I) → (R/I)/J'</span>
<span class="kd">def</span> <span class="n">g₁</span> <span class="o">:=</span> <span class="n">ring_hom.comp</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)))</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span>

<span class="c1">-- Another short result for lifting map g₁ to a map R/(I+J) → (R/I)/J'</span>
<span class="kd">def</span> <span class="n">H_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">):</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="bp">+</span><span class="n">J</span> <span class="bp">→</span> <span class="n">g₁</span> <span class="n">I</span> <span class="n">J</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hx</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hIJtoJ</span> <span class="o">:</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">J.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ideal.add_eq_sup</span><span class="o">,</span> <span class="n">ideal.map_sup</span><span class="o">,</span><span class="n">map_quotient_self</span><span class="o">],</span>
    <span class="n">simp</span><span class="o">},</span>
  <span class="k">have</span> <span class="n">hJto0</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span><span class="o">(</span><span class="n">J.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)))</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
    <span class="kd">by</span> <span class="n">rw</span> <span class="n">map_quotient_self</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">((</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span>
    <span class="o">(</span><span class="n">J.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)))</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hIJtoJ</span><span class="o">,</span> <span class="n">hJto0</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">g₁</span><span class="o">,</span> <span class="bp">←</span> <span class="n">ideal.mem_bot</span><span class="o">,</span> <span class="bp">←</span> <span class="n">this</span><span class="o">,</span> <span class="n">ring_hom.comp_apply</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">ideal.mem_map_of_mem</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ideal.mem_map_of_mem</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
<span class="c1">-- define g₂ to be the induced map R/(I+J) → (R/I)/J'</span>
<span class="kd">def</span> <span class="n">g₂</span> <span class="o">:=</span> <span class="n">ideal.quotient.lift</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">g₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">H_sum</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span>

<span class="c1">-- Then f₂ and g₂ are inverse isomorphisms</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">≃+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">g₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">function.left_inverse</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">ideal.quotient.mk_surjective</span> <span class="n">z</span><span class="o">)</span> <span class="k">with</span> <span class="n">u</span> <span class="n">hu</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">f₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hu</span><span class="o">,</span><span class="n">ideal.quotient.lift_mk</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">H_proj_J</span> <span class="n">I</span> <span class="n">J</span><span class="o">)],</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">ideal.quotient.mk_surjective</span> <span class="n">u</span><span class="o">)</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">f₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hv</span><span class="o">,</span><span class="n">ideal.quotient.lift_mk</span> <span class="n">I</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="o">(</span><span class="n">left_proj_quot_sum</span> <span class="n">I</span> <span class="n">J</span><span class="o">)],</span>
    <span class="n">unfold</span> <span class="n">g₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ideal.quotient.lift_mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">g₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">H_sum</span> <span class="n">I</span> <span class="n">J</span><span class="o">),</span>
    <span class="n">unfold</span> <span class="n">g₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ring_hom.comp_apply</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">function.right_inverse</span> <span class="n">function.left_inverse</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">ideal.quotient.mk_surjective</span> <span class="n">z</span><span class="o">)</span> <span class="k">with</span> <span class="n">u</span> <span class="n">hu</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hu</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">g₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ideal.quotient.lift_mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">g₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">H_sum</span> <span class="n">I</span> <span class="n">J</span><span class="o">),</span>
    <span class="n">unfold</span> <span class="n">g₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ring_hom.comp_apply</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">f₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ideal.quotient.lift_mk</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">H_proj_J</span> <span class="n">I</span> <span class="n">J</span><span class="o">),</span>
    <span class="n">unfold</span> <span class="n">f₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ideal.quotient.lift_mk</span> <span class="n">I</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span>  <span class="o">(</span><span class="n">left_proj_quot_sum</span> <span class="n">I</span> <span class="n">J</span><span class="o">),</span>
  <span class="kd">end</span>
  <span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">ring_hom.map_mul</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">ring_hom.map_add</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="247310469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247310469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247310469">(Jul 27 2021 at 09:16)</a>:</h4>
<p>A general comment: in mathlib <code>sum</code> in a lemma name refers to an n-ary sum, not the binary addition you use there which mathlib calls <code>add</code>.</p>



<a name="247310686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247310686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247310686">(Jul 27 2021 at 09:18)</a>:</h4>
<p>Ah thanks that's good to know, I'll edit the names of the lemmas !</p>



<a name="247311238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247311238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247311238">(Jul 27 2021 at 09:25)</a>:</h4>
<p>Here's a much shorter way to close your last example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- this should maybe be in mathlib</span>
<span class="sd">/-- Any two ring homs out of a quotient are equal if their composition with quotient.mk is equal -/</span>
<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">ideal.quotient.ring_hom_ext</span> <span class="o">{</span><span class="n">S</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">I.quotient</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f.comp</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g.comp</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ideal.quotient.mk_surjective</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">ring_hom.congr_fun</span> <span class="n">h</span> <span class="n">u</span> <span class="o">:</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>

<span class="c1">-- Then f₂ and g₂ are inverse isomorphisms</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">≃+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ring_equiv.of_hom_inv</span> <span class="o">(</span><span class="n">f₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">g₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">z</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">z</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span>
</code></pre></div>



<a name="247311622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247311622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247311622">(Jul 27 2021 at 09:30)</a>:</h4>
<p>Your first two lemmas can be golfed slightly be removing the <code>intro</code> - if your goal state has a <code>→</code> in it, and the first line of your proof is an <code>intro</code>, then you should have used a <code>:</code> instead of a <code>→</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- as mentioned above these should have `add` not `sum` in their names.</span>
<span class="kd">def</span> <span class="n">left_proj_quot_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">ideal.quotient.eq_zero_iff_mem.2</span> <span class="o">(</span><span class="n">ideal.mem_sup_left</span> <span class="n">hx</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">right_proj_quot_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">ideal.quotient.eq_zero_iff_mem.2</span> <span class="o">(</span><span class="n">ideal.mem_sup_right</span> <span class="n">hx</span><span class="o">)</span>
</code></pre></div>



<a name="247313746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247313746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247313746">(Jul 27 2021 at 09:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/247311238">said</a>:</p>
<blockquote>
<p>Here's a much shorter way to close your last example:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- this should maybe be in mathlib</span>
<span class="sd">/-- Any two ring homs out of a quotient are equal if their composition with quotient.mk is equal -/</span>
<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">ideal.quotient.ring_hom_ext</span> <span class="o">{</span><span class="n">S</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">I.quotient</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f.comp</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g.comp</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ideal.quotient.mk_surjective</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">ring_hom.congr_fun</span> <span class="n">h</span> <span class="n">u</span> <span class="o">:</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>

<span class="c1">-- Then f₂ and g₂ are inverse isomorphisms</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">J.map</span> <span class="o">(</span><span class="n">ideal.quotient.mk</span> <span class="n">I</span><span class="o">))</span><span class="bp">.</span><span class="n">quotient</span> <span class="bp">≃+*</span> <span class="o">(</span><span class="n">I</span> <span class="bp">+</span> <span class="n">J</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">ring_equiv.of_hom_inv</span> <span class="o">(</span><span class="n">f₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">g₂</span> <span class="n">I</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">z</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">z</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Ah, I didn't know about the ext tactic, thanks a lot for showing me that !</p>



<a name="247313793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247313793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247313793">(Jul 27 2021 at 09:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/247311622">said</a>:</p>
<blockquote>
<p>Your first two lemmas can be golfed slightly be removing the <code>intro</code> - if your goal state has a <code>→</code> in it, and the first line of your proof is an <code>intro</code>, then you should have used a <code>:</code> instead of a <code>→</code>:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- as mentioned above these should have `add` not `sum` in their names.</span>
<span class="kd">def</span> <span class="n">left_proj_quot_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">ideal.quotient.eq_zero_iff_mem.2</span> <span class="o">(</span><span class="n">ideal.mem_sup_left</span> <span class="n">hx</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">right_proj_quot_sum</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span><span class="o">)</span> <span class="o">:</span> <span class="n">ideal.quotient.mk</span> <span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">ideal.quotient.eq_zero_iff_mem.2</span> <span class="o">(</span><span class="n">ideal.mem_sup_right</span> <span class="n">hx</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I've noticed a few other of my lemmas have a similar issue, I'll make the relevant modifications</p>



<a name="247354939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247354939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247354939">(Jul 27 2021 at 16:10)</a>:</h4>
<p>Unfold's are quite often not necessary in a proof, while they are useful to see what's going on and what you want to do next of course, it can make proofs more readable / short by removing them after, so I'd recommend trying to see which ones can be removed. Doing this you can combine some rewrites onto one line too when they are only small steps.<br>
Also the tactics <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases">tactic#rcases</a> and <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rintros">tactic#rintros</a> can be very helpful when you just want to introduce something and then split it up immediately, definitely worth looking at examples of how they are used in mathlib to see some of the tricks <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.</p>



<a name="247355960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247355960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247355960">(Jul 27 2021 at 16:19)</a>:</h4>
<p>For example <code>in_ker_proj_to_sum_left</code> can be proved with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">in_ker_proj_to_sum_left</span> <span class="o">:</span> <span class="n">I.map</span><span class="o">(</span><span class="n">ideal.quotient.mk</span><span class="o">(</span><span class="n">I</span><span class="bp">+</span><span class="n">J</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ideal.map</span><span class="o">,</span> <span class="n">ideal.span_eq_bot</span><span class="o">,</span> <span class="n">set.mem_image</span><span class="o">],</span>
  <span class="n">rintros</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">left_proj_quot_sum</span> <span class="n">I</span> <span class="n">J</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="247360554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247360554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247360554">(Jul 27 2021 at 16:57)</a>:</h4>
<p><code>rintro</code> is a synonym of <code>rintros</code> and <code>obtain</code> makes more semantical sense than <code>rcases</code> when you <em>obtain</em> an object and its property from an <code>exists</code> for example.</p>



<a name="247432867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247432867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247432867">(Jul 28 2021 at 08:17)</a>:</h4>
<p>Thanks a lot for the advice ! I've been trying to expand the repertoire of tactics I know how to use so I'll try and have a go at using those !</p>



<a name="247434270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247434270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247434270">(Jul 28 2021 at 08:35)</a>:</h4>
<p>On a slightly unrelated issue I've encountered when playing around with the code, say we have two rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex"> R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex"> S </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> which we can prove are equal (although they aren't equal by definition - in my case, this is the quotients <code>(I+J).quotient</code> and <code>(J+I).quotient</code> ). Is there :</p>
<ol>
<li>An easy way of defining the identity isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \to S </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> ? </li>
<li>Given another type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex"> T </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, can we get Lean to understand <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex"> f : R \to T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> as a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex"> f : S \to T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> ?</li>
</ol>
<p>For the first question, the case I am interested in seems to be approachable using <code>quot_equiv_of_eq</code> in <code>ring_theory.ideals.basic</code>, but is there a way to get an explicit description of the isomorphism ? (if possible, I would need to show that the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>I</mi><mo>+</mo><mi>J</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>J</mi><mo>+</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x + (I+J) \mapsto x + (J+I) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span> is an isomorphism. This could be done by lifting the canonical map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>J</mi><mo>+</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> R \to R/(J+I) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span> to a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>I</mi><mo>+</mo><mi>J</mi><mo stretchy="false">)</mo><mo>→</mo><mi>R</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>J</mi><mo>+</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> R/(I+J) \to R/(J+I) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span>, but I'm sure there's a slicker approach !)</p>



<a name="247434430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247434430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247434430">(Jul 28 2021 at 08:37)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ideal.quot_equiv_of_eq">docs#ideal.quot_equiv_of_eq</a> is indeed what you want</p>



<a name="247434696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247434696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247434696">(Jul 28 2021 at 08:40)</a>:</h4>
<p>It looks like it (along with <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.congr">docs#quotient.congr</a> which it builds upon) is missing the lemmas about how it applies</p>



<a name="247436010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247436010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247436010">(Jul 28 2021 at 08:57)</a>:</h4>
<p>Fair enough, thanks ! <br>
 Out of curiosity, how would we do this for the general case of equal rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex"> R </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex"> S </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> ?</p>



<a name="247437027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247437027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247437027">(Jul 28 2021 at 09:09)</a>:</h4>
<p>You mean when you can prove <code>R = S</code>?</p>



<a name="247437121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247437121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247437121">(Jul 28 2021 at 09:10)</a>:</h4>
<p>That's not enough, to make a ring_equiv you have to prove the ring structures agree too</p>



<a name="247437795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247437795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247437795">(Jul 28 2021 at 09:19)</a>:</h4>
<p>Oh right, of course ! Thanks !<br>
I should be more careful when I use the equal sign, I was getting confused between equality of types and equivalence of ring structures <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="247438393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247438393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247438393">(Jul 28 2021 at 09:26)</a>:</h4>
<p>For the case of the quotients you know that the two ring structures are equal by construction</p>



<a name="247439162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247439162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247439162">(Jul 28 2021 at 09:35)</a>:</h4>
<p>Oh I had never realised that!</p>



<a name="247439248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Quotient%20of%20a%20ring%20by%20a%20sum%20of%20ideals/near/247439248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals.html#247439248">(Jul 28 2021 at 09:36)</a>:</h4>
<p>The quotient only depends on the underlying equivalence relation which are equal for the two quotients.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html">`list.take_while_coe`?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="316702774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316702774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316702774">(Dec 19 2022 at 09:55)</a>:</h4>
<p>Hey!</p>
<p>I'm given <code>l : list X</code> with <code>l.pairwise (≤)</code> and <code>x : X</code>.<br>
What's the best way to get two lists <code>l₁ : list {y | y ≤ x}</code> and <code>l₂ : list {y | x ≤ y}</code> corresponding to <code>take_while</code> and <code>drop_while</code> ?<br>
I'd need associated lemmas telling me that coercing the lists back and appending gives me exactly <code>l</code> too.</p>
<p>I can't even find something like <code>list.filter_subtype</code> that would work for filter. <br>
Thanks!</p>



<a name="316732911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316732911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316732911">(Dec 19 2022 at 12:51)</a>:</h4>
<p>I would assume that <a href="https://leanprover-community.github.io/mathlib_docs/find/list.attach">docs#list.attach</a> on the result of <code>take_while</code> and <code>drop_while</code> is almost sufficient</p>



<a name="316733009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316733009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316733009">(Dec 19 2022 at 12:51)</a>:</h4>
<p>Your three properties aren't simultaneously true unless <code>linear_order X</code></p>



<a name="316734668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316734668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316734668">(Dec 19 2022 at 13:00)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise">docs#list.pairwise</a></p>



<a name="316734747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316734747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316734747">(Dec 19 2022 at 13:01)</a>:</h4>
<p>I doubt even that's enough, because l1 and l2 will both contain <code>x</code> if it's in the list.</p>



<a name="316742607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316742607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316742607">(Dec 19 2022 at 13:27)</a>:</h4>
<p>I only care about linear order, so that's no matter: It's for my experiments with rectifiable functions, and this list decomposition is about splitting a partition of a set into partitions of two sides of the set.</p>



<a name="316743553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316743553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316743553">(Dec 19 2022 at 13:32)</a>:</h4>
<p>Kevin's point still stands, one list should be <code>&lt;</code> not <code>≤</code> otherwise they share the element <code>x</code></p>



<a name="316744572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316744572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316744572">(Dec 19 2022 at 13:37)</a>:</h4>
<p>(I had the notion that <code>drop_while</code> was by definition returning the complement of <code>take_while</code>)</p>



<a name="316744891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316744891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316744891">(Dec 19 2022 at 13:38)</a>:</h4>
<p>Oh nevermind, Kevin's comment is a distraction; the list still satisfies <code>x ≤ y</code>, it just also satisfies <code>x &lt; y</code></p>



<a name="316745008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316745008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316745008">(Dec 19 2022 at 13:39)</a>:</h4>
<p>Note that even if your lists weren't ordered you could use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.partition">docs#list.partition</a></p>



<a name="316745422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316745422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316745422">(Dec 19 2022 at 13:41)</a>:</h4>
<p>Does this help?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">{</span><span class="n">y</span> <span class="bp">//</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l.take_while</span> <span class="o">(</span><span class="bp">≤</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">attach.map</span> <span class="bp">$</span> <span class="n">subtype.map</span> <span class="n">id</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">list.mem_take_while_imp</span>
</code></pre></div>



<a name="316748315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316748315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316748315">(Dec 19 2022 at 13:54)</a>:</h4>
<p>The other direction is harder because we don't seem to have <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise.drop_while">docs#list.pairwise.drop_while</a></p>



<a name="316749377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316749377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316749377">(Dec 19 2022 at 13:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">{</span><span class="n">y</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l.drop_while</span> <span class="o">(</span><span class="bp">≤</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">attach.map</span> <span class="bp">$</span> <span class="n">subtype.map</span> <span class="n">id</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">list.drop_while_nth_le_zero_not</span> <span class="n">_</span> <span class="n">l</span> <span class="o">(</span><span class="n">list.length_pos_of_mem</span> <span class="n">hy</span><span class="o">),</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_le</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">this.trans_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">_</span> <span class="bp">|</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">list.nth_le_of_mem</span> <span class="n">hy</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">l.drop_while</span> <span class="o">(</span><span class="bp">≤</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">list.pairwise_iff_nth_le</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat.succ_pos'</span><span class="o">,</span> <span class="o">},</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="316751518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316751518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316751518">(Dec 19 2022 at 14:08)</a>:</h4>
<p>Thanks, it might help! But the answer to <code>is there code for …</code> is "no" in this case, right?</p>



<a name="316752984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316752984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316752984">(Dec 19 2022 at 14:14)</a>:</h4>
<p>Why not just (l.filter (le x)).attach?</p>



<a name="316753016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316753016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316753016">(Dec 19 2022 at 14:14)</a>:</h4>
<p>Doesn't require l to be sorted</p>



<a name="316753408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316753408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316753408">(Dec 19 2022 at 14:16)</a>:</h4>
<p>Yeah, I think there's an <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> problem hiding here</p>



<a name="316753463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316753463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316753463">(Dec 19 2022 at 14:16)</a>:</h4>
<p>Although mathlib should certainly have <code>list.pairwise.drop_while</code>and the <code>take_while</code> version too</p>



<a name="316753499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316753499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316753499">(Dec 19 2022 at 14:16)</a>:</h4>
<p>And then you have a theorem that a sorted l as input would give the same as (l.take_while ...).filter</p>



<a name="316753819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316753819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316753819">(Dec 19 2022 at 14:18)</a>:</h4>
<p><code>(l.filter (le x)).attach : list (l.filter (le x))</code>, and then I need to use something else saying that <code>l.filter (le x) \subset (le x)</code> ?</p>



<a name="316756147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316756147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316756147">(Dec 19 2022 at 14:28)</a>:</h4>
<p>That's what the <code>.map $ subtype.map id $ λ</code> is from my message above</p>



<a name="316757358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316757358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316757358">(Dec 19 2022 at 14:33)</a>:</h4>
<p>But I'm still not sure what you'll be doing with these two lists, because since they're lists of two different subtypes, you'll have difficulty working with them</p>



<a name="316757627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316757627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316757627">(Dec 19 2022 at 14:34)</a>:</h4>
<p>Instead, I'm imagining a filter partition function that takes a list and a predicate, and gives you back a tuple of lists. Then your downstream functions take this tuple. And it's a theorem that you propagate some property, not encoded as a subtype straight up</p>



<a name="316758635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316758635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316758635">(Dec 19 2022 at 14:39)</a>:</h4>
<p><a href="https://github.com/bottine/mathlib/blob/d70be72b4b96cd0e229b563358c3c8baf38ec534/src/topology/metric_space/path.lean#L372">https://github.com/bottine/mathlib/blob/d70be72b4b96cd0e229b563358c3c8baf38ec534/src/topology/metric_space/path.lean#L372</a></p>



<a name="316758700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316758700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316758700">(Dec 19 2022 at 14:39)</a>:</h4>
<p>I think I really need those two sublist as living in different sets.</p>



<a name="316759590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316759590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316759590">(Dec 19 2022 at 14:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60list.2Etake_while_coe.60.3F/near/316757627">said</a>:</p>
<blockquote>
<p>Instead, I'm imagining a filter partition function that takes a list and a predicate, and gives you back a tuple of lists.</p>
</blockquote>
<p>No need to imagine,</p>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60list.2Etake_while_coe.60.3F/near/316745008">said</a>:</p>
<blockquote>
<p>Note that even if your lists weren't ordered you could use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.partition">docs#list.partition</a></p>
</blockquote>



<a name="316759742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/316759742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#316759742">(Dec 19 2022 at 14:44)</a>:</h4>
<blockquote>
<p>I think I really need those two sublist as living in different sets.</p>
</blockquote>
<p>Remember that they don't live in sets, they live in types. Indeed, <code>list {y | y ≤ x}</code>, is better written <code>list {y // y ≤ x}</code> to eliminate a <code>coe_sort</code></p>



<a name="317112598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317112598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317112598">(Dec 21 2022 at 09:14)</a>:</h4>
<p>Any idea why <code>refl</code> doesn't work at the last line?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kd">noncomputable theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">set</span>


<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">subtype.map_id_comp_id</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">t</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">subtype.map</span> <span class="n">id</span> <span class="n">st</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">subtype.map</span> <span class="n">id</span> <span class="n">rs</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">subtype.map</span> <span class="n">id</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">st</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">rs</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">subtype.coe_comp_map_id</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">coe</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">subtype.map</span> <span class="n">id</span> <span class="n">rs</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">list.take_while_subtype</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">subtype</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l.take_while</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">attach.map</span> <span class="bp">$</span> <span class="n">subtype.map</span> <span class="n">id</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">list.mem_take_while_imp</span>

<span class="kd">lemma</span> <span class="n">list.take_while_subtype_map_coe</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.take_while_subtype</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subtype</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l.take_while</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.take_while_subtype</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.map_map</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">list.attach_map_coe</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">list.pairwise_le_drop_while_le_not_le</span>  <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">l.drop_while</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.drop_while</span><span class="o">,</span> <span class="n">list.not_mem_nil</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hy.elim</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">h</span> <span class="n">y</span> <span class="n">hy</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.drop_while</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.pairwise_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">hy</span> <span class="k">with</span> <span class="n">ax</span> <span class="n">nax</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">list.pairwise_le_drop_while_le_not_le</span> <span class="n">l</span> <span class="n">h.right</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">hy</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">hy</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ax</span><span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">yx</span><span class="o">,</span> <span class="n">ax</span> <span class="o">((</span><span class="n">h.left</span> <span class="n">y</span> <span class="n">hy</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">yx</span><span class="o">),</span> <span class="o">},</span> <span class="o">},</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">list.drop_while_subtype</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="o">(</span><span class="n">subtype</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">y</span><span class="bp">≤</span><span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l.drop_while</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">attach.map</span> <span class="bp">$</span> <span class="n">subtype.map</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">l.pairwise_le_drop_while_le_not_le</span> <span class="n">x</span> <span class="n">h</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">list.drop_while_subtype_ge</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">list</span> <span class="o">(</span><span class="n">subtype</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">≤</span><span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">l.drop_while_subtype</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">$</span> <span class="n">subtype.map</span> <span class="n">id</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">h'</span><span class="o">,</span> <span class="bp">@</span><span class="n">le_of_not_le</span> <span class="n">α</span> <span class="n">_</span> <span class="n">y</span> <span class="n">x</span> <span class="n">h'</span>

<span class="kd">lemma</span> <span class="n">list.drop_while_subtype_ge_map_coe</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.drop_while_subtype_ge</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">coe</span> <span class="bp">=</span> <span class="n">l.drop_while</span> <span class="o">(</span><span class="bp">≤</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.drop_while_subtype_ge</span><span class="o">,</span> <span class="n">list.drop_while_subtype</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.map_map</span><span class="o">,</span> <span class="n">subtype.map_id_comp_id</span><span class="o">,</span> <span class="n">subtype.coe_comp_map_id</span><span class="o">,</span> <span class="n">list.attach_map_coe</span><span class="o">],</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="317112972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317112972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317112972">(Dec 21 2022 at 09:17)</a>:</h4>
<p>Oh, I know, it's because of my use of <code>open_locale classical</code> and <code>noncomputable theory</code>. If I correct that and have the right instances as parameters, then the <code>simp</code> does the job.</p>



<a name="317113042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113042">(Dec 21 2022 at 09:17)</a>:</h4>
<p>Wow, and the profiler tells we I gain a lot of time. I guess classical mathematics is not efficient :(</p>



<a name="317113115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113115">(Dec 21 2022 at 09:18)</a>:</h4>
<p>Why do you open_locale classical at all? I no longer know of any situation where this is the correct approach.</p>



<a name="317113271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113271">(Dec 21 2022 at 09:19)</a>:</h4>
<p>If the statement doesn't compile, add decidable hypotheses. If the statement compiles but you need classical arguments in the proofs, use the <code>classical</code> tactic.</p>



<a name="317113429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113429">(Dec 21 2022 at 09:20)</a>:</h4>
<p>I'm not sure, to be honest: it's one of those brute-force things I learned to do to get stuff to compile when I started, and it lingered there because it didn't seem to hurt.</p>



<a name="317113520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113520">(Dec 21 2022 at 09:20)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/linear_order">docs#linear_order</a></p>



<a name="317113528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113528">(Dec 21 2022 at 09:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60list.2Etake_while_coe.60.3F/near/317113115">said</a>:</p>
<blockquote>
<p>Why do you open_locale classical at all? I no longer know of any situation where this is the correct approach.</p>
</blockquote>
<p>Is there any easy replacement for it here?<br>
<a href="https://github.com/madvorak/grammars/blob/8b76863a14b453be88570dd19a41eb2f57e3c853/src/written_by_others/list_take_join.lean">https://github.com/madvorak/grammars/blob/8b76863a14b453be88570dd19a41eb2f57e3c853/src/written_by_others/list_take_join.lean</a></p>



<a name="317113598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113598">(Dec 21 2022 at 09:21)</a>:</h4>
<p><code>linear_order</code> has decidable hypotheses in it so you might get diamonds with this approach</p>



<a name="317113794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113794">(Dec 21 2022 at 09:22)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> what happens if you remove it and do what I suggest instead?</p>



<a name="317113903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113903">(Dec 21 2022 at 09:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60list.2Etake_while_coe.60.3F/near/317113598">said</a>:</p>
<blockquote>
<p><code>linear_order</code> has decidable hypotheses in it so you might get diamonds with this approach</p>
</blockquote>
<p>I think that's exactly why <code>refl</code> didn't work there, and it will surely explain all the rest of my troubles.</p>



<a name="317113995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317113995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317113995">(Dec 21 2022 at 09:24)</a>:</h4>
<p>but <code>noncomputable theory</code> is just a way to not have to write <code>noncomputable def</code> everywhere, right?</p>



<a name="317114040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317114040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317114040">(Dec 21 2022 at 09:24)</a>:</h4>
<p>Yes that's usually not a problem</p>



<a name="317114139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317114139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317114139">(Dec 21 2022 at 09:25)</a>:</h4>
<p>Although with decidable hypotheses you might find that more things become computable I guess (I'm not entirely sure, I don't understand computability)</p>



<a name="317114751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317114751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317114751">(Dec 21 2022 at 09:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60list.2Etake_while_coe.60.3F/near/317113794">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> what happens if you remove it and do what I suggest instead?</p>
</blockquote>
<p>I just removed it without replacement and the file still builds, lol.</p>



<a name="317114879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317114879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317114879">(Dec 21 2022 at 09:29)</a>:</h4>
<div class="codehilite" data-code-language="import"><pre><span></span><code>import topology.metric_space.emetric_space

open emetric nnreal set

--noncomputable theory

namespace function


variables {α β : Type*} [pseudo_emetric_space α]
variables (f : β → α)

@[simp] def dist_head : β → list β → ennreal
| _ [] := 0
| x (a :: _) := edist (f x) (f a)

lemma dist_head_le_append :
  ∀ (l : list β) (b : β) (l' : list β), f.dist_head b l ≤ f.dist_head b (l ++ l')
| [] _ _ := zero_le'
| (_::_) _ _ := le_refl _

lemma dist_head_triangle :
  ∀ (a b : β) (l : list β), f.dist_head a l ≤ edist (f a) (f b) + f.dist_head b l
| _ _ [] := zero_le'
| _ _ (_::_) := edist_triangle _ _ _


@[simp] def length_on : list β → ennreal
| list.nil := 0
| (a :: l) := f.dist_head a l + length_on l

end function
</code></pre></div>
<p>Strangely, <code>length_on</code> requires <code>noncomputable</code></p>



<a name="317114911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/%60list.take_while_coe%60%3F/near/317114911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/.60list.2Etake_while_coe.60.3F.html#317114911">(Dec 21 2022 at 09:29)</a>:</h4>
<p>It probably makes sense to also remove <code>noncomputable theory</code> because only one declaration needs <code>noncomputable def</code> if I'm not mistaken.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
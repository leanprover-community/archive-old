---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html">induction on an index type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="269460754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269460754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269460754">(Jan 26 2022 at 18:42)</a>:</h4>
<p>I am trying to show <code>[is_domain (mv_power_series I R)]</code>, generalizing from <code>[is_domain (power_series R)]</code>. I am hoping to "induct" on the index type, proving the <code>R[X]</code> case first, using the proof we have already. Do we have code that helps facilitate this? I was thinking of something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.power_series.basic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="kd">noncomputable theory</span>

<span class="kn">namespace</span> <span class="n">mv_power_series</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="sd">/-- The contravariant map between multivariate formal power series</span>
<span class="sd">induced by a map on the indeterminates. -/</span>
<span class="kd">def</span> <span class="n">map_indeterminate</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">τ</span> <span class="bp">→</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">mv_power_series</span> <span class="n">τ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x.map_domain</span> <span class="n">φ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">indeterminate_induction</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">σ</span><span class="o">,</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_empty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">subsingleton</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">E</span> <span class="n">R</span><span class="o">),</span> <span class="n">P</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_sum</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">σₗ</span> <span class="n">σ</span><span class="bp">ᵣ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σₗ</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span><span class="bp">ᵣ</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span> <span class="n">_</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">fg</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="o">(</span><span class="n">σₗ</span> <span class="bp">⊕</span> <span class="n">σ</span><span class="bp">ᵣ</span><span class="o">)</span> <span class="n">R</span><span class="o">),</span> <span class="n">P</span> <span class="n">_</span> <span class="n">fg</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_iso</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">≃</span> <span class="n">τ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">τ</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">P</span> <span class="n">_</span> <span class="n">f</span><span class="o">),</span>
    <span class="n">P</span> <span class="n">σ</span> <span class="o">(</span><span class="n">f.map_indeterminate</span> <span class="n">e</span><span class="o">))</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">_</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">mv_power_series</span>
</code></pre></div>



<a name="269463528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269463528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269463528">(Jan 26 2022 at 19:01)</a>:</h4>
<p>You already showed this fact for hahn_series right? So it seems a bit of a shame to have to give a separate proof here, I couldn't find the equivalence between hahn series on <code>\sigma \to \N</code> and <code>mv_power_series \sigma</code> (hopefully I'm not mathematically wrong and it doesnt exist xD) but there is the single variable case already <a href="https://leanprover-community.github.io/mathlib_docs/find/hahn_series.to_power_series">docs#hahn_series.to_power_series</a>. Do you think it'll be easier to just transfer this fact from a ring equivalence to hahn_series?</p>



<a name="269463743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269463743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269463743">(Jan 26 2022 at 19:02)</a>:</h4>
<p>Maybe -- I did want it in <code>ring_theory.power_series.basic</code> so I could generalize <code>inv</code> from field to <code>division_ring</code> though.</p>



<a name="269463993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269463993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269463993">(Jan 26 2022 at 19:03)</a>:</h4>
<p>You could always split the file? Mathematically if a fact about power series is a special case of one about hahn series I'd say there is a dependency there and we shouldn't reprove things</p>



<a name="269491858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269491858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269491858">(Jan 26 2022 at 22:21)</a>:</h4>
<p>Alex, can you clarify something for me please? Do you mean we should prove it via the <code>hahn_series sigma X</code> and a compatible <code>\sigma to nat</code>? (First showing that those are ring isomorphic?)</p>



<a name="269491882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269491882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269491882">(Jan 26 2022 at 22:21)</a>:</h4>
<p>And in general refactor to make <code>power_series/basic</code> import <code>hahn_series</code>?</p>



<a name="269499736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269499736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269499736">(Jan 26 2022 at 23:38)</a>:</h4>
<p>I was thinking of the following def, sans sorries + API</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">to_mv_power_series</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">hahn_series</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≃+*</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.coeff</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span><span class="o">),</span> <span class="gr">sorry</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">mv_power_series.coeff_mul</span><span class="o">,</span> <span class="n">power_series.coeff_mk</span><span class="o">,</span> <span class="n">mul_coeff</span><span class="o">,</span> <span class="n">is_pwo_support</span><span class="o">],</span>
    <span class="n">classical</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">mul_coeff</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">sum_filter_ne_zero.symm.trans</span>
      <span class="o">((</span><span class="n">sum_congr</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="n">sum_filter_ne_zero</span><span class="o">),</span>
    <span class="n">ext</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">nat.mem_antidiagonal</span><span class="o">,</span> <span class="n">and.congr_left_iff</span><span class="o">,</span> <span class="n">mem_add_antidiagonal</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span>
      <span class="n">and_iff_left_iff_imp</span><span class="o">,</span> <span class="n">mem_filter</span><span class="o">,</span> <span class="n">mem_support</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">contrapose</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">decidable.or_iff_not_and_not</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h1</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="269500207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269500207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269500207">(Jan 26 2022 at 23:42)</a>:</h4>
<p>Refactoring power_series/basic completely to depend on hahn_series would be quite a job right now (but might be worth it eventually),  however its almost 2000 lines so it definitely needs a haircut or two. (One obvious thing is that <a href="https://leanprover-community.github.io/mathlib_docs/find/power_series">docs#power_series</a> is only defined on line 800 so could be split off but thats slightly orthogonal).<br>
Domain for <code>power_series</code> is on line ~1300 of that file, so maybe stuff after that is more commutative algebra than just basic facts about power series, that could be a good point to split perhaps and have that part import hahn_series</p>



<a name="269500976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269500976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269500976">(Jan 26 2022 at 23:53)</a>:</h4>
<p>Is this even true though? What if <code>\sigma</code> is <code>complex</code>? It's not ordered, but one can still have a completely valid <code>mv_power_series complex R</code></p>



<a name="269502144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269502144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269502144">(Jan 27 2022 at 00:03)</a>:</h4>
<p>Maybe you need <code>fintype sigma</code> yeah? That certainly was the case for the inductive proof you proposed too I guess</p>



<a name="269502281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269502281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269502281">(Jan 27 2022 at 00:04)</a>:</h4>
<p>If my sigma was <code>nat</code> or even <code>nat \o+ nat</code> I think my proof would still work?</p>



<a name="269502442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269502442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269502442">(Jan 27 2022 at 00:06)</a>:</h4>
<p>The induction you asked about above is summing subsingleton sigmas only so I don't think you can get nat from that</p>



<a name="269502457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269502457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269502457">(Jan 27 2022 at 00:06)</a>:</h4>
<p>Or is it really only true for <code>fintype</code> in general?</p>



<a name="269502527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269502527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269502527">(Jan 27 2022 at 00:07)</a>:</h4>
<p>I thought the summing singletons would be enough for any <code>encodable</code> type</p>



<a name="269504060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269504060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269504060">(Jan 27 2022 at 00:23)</a>:</h4>
<p>I don't think thats possible, your induction principle can prove things about arbitrarily large fintypes but not infinite types. I think the statement that mv_power_series are a domain when R is is true in complete generality, but I cant think of a good way to approach proving it</p>



<a name="269504476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269504476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269504476">(Jan 27 2022 at 00:28)</a>:</h4>
<p>It seems to me that if you have countably many variables <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">X_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, ... then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>X</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">X_1 + X_2 + \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.313em;"></span><span class="minner">⋯</span></span></span></span> is not a Hahn series. (I checked the referenced paper by van der Hoeven and it seems to agree with this.) On the other hand it is an <code>mv_power_series</code>. I'm not sure whether this is a good thing or a bad thing--apparently SGA3 has an opinion about this which I'm trying to look up</p>



<a name="269504761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269504761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269504761">(Jan 27 2022 at 00:30)</a>:</h4>
<p>Yeah my sorry above is unprovable (as they often are <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span>) except in the fintype sigma case</p>



<a name="269510223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269510223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269510223">(Jan 27 2022 at 00:43)</a>:</h4>
<p>I didn't find whatever I was supposed to be looking for in SGA3, but Wikipedia agrees with mathlib's definition of the power series ring at least.</p>



<a name="269510342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/269510342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#269510342">(Jan 27 2022 at 00:44)</a>:</h4>
<p>How about this argument to reduce to the case of finitely many variables. Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ab = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mo stretchy="false">[</mo><mi>S</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[[S]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[[</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">]]</span></span></span></span>. Pick a nonzero monomial of each of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>. Together they contain only finitely many variables. Send the rest of the variables to 0. Then we get nonzero elements of a power series ring in finitely many variables, which multiply to zero</p>



<a name="270598067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/induction%20on%20an%20index%20type/near/270598067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/induction.20on.20an.20index.20type.html#270598067">(Feb 03 2022 at 18:47)</a>:</h4>
<p>I just got back to this and finally proved the fintype version. Some lemmas need breaking out but I'll try and PR it today</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">to_mv_power_series</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">hahn_series</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≃+*</span> <span class="n">mv_power_series</span> <span class="n">σ</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.coeff</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span><span class="o">),</span> <span class="kd">begin</span>
    <span class="n">refine</span> <span class="n">set.partially_well_ordered_on.mono</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">change</span> <span class="n">set.is_pwo</span> <span class="o">(</span><span class="n">set.univ</span><span class="o">),</span> <span class="c1">-- mono for is_pwo?</span>
    <span class="n">rw</span> <span class="n">set.is_pwo_iff_exists_monotone_subseq</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">monotone</span><span class="o">,</span> <span class="n">finsupp.le_def</span><span class="o">],</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">σ</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">set.range</span> <span class="n">f</span> <span class="bp">⊆</span> <span class="n">set.univ</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">↪</span><span class="n">o</span> <span class="n">ℕ</span><span class="o">),</span>
      <span class="bp">∀</span> <span class="o">⦃</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">⦄,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">this</span> <span class="n">univ</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">apply'</span> <span class="n">finset.induction</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">rel_embedding.refl</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span>
      <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">s</span> <span class="n">hx</span> <span class="n">ih</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">is_well_order.wf.is_wf</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">))</span><span class="bp">.</span><span class="n">is_pwo.exists_monotone_subseq</span>
        <span class="o">((</span><span class="bp">λ</span> <span class="n">mo</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→₀</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">mo</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">g'</span><span class="o">,</span> <span class="n">hg'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">set.subset_univ</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">g'.trans</span> <span class="n">g</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_insert</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">,</span> <span class="n">rel_embedding.coe_trans</span><span class="o">],</span>
      <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hg</span> <span class="o">(</span><span class="n">order_hom_class.mono</span> <span class="n">g'</span> <span class="n">hab</span><span class="o">),</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">hg'</span> <span class="n">hab</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">mv_power_series.coeff_mul</span><span class="o">,</span> <span class="n">power_series.coeff_mk</span><span class="o">,</span> <span class="n">mul_coeff</span><span class="o">,</span> <span class="n">is_pwo_support</span><span class="o">],</span>
    <span class="n">classical</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">mul_coeff</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">sum_filter_ne_zero.symm.trans</span>
      <span class="o">((</span><span class="n">sum_congr</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="n">sum_filter_ne_zero</span><span class="o">),</span>
    <span class="n">ext</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">nat.mem_antidiagonal</span><span class="o">,</span> <span class="n">and.congr_left_iff</span><span class="o">,</span> <span class="n">mem_add_antidiagonal</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span>
      <span class="n">and_iff_left_iff_imp</span><span class="o">,</span> <span class="n">mem_filter</span><span class="o">,</span> <span class="n">mem_support</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">contrapose</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">decidable.or_iff_not_and_not</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h1</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
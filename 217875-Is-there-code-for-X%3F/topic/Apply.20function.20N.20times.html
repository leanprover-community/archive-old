---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html">Apply function N times</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="203150033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150033">(Jul 07 2020 at 19:38)</a>:</h4>
<p>Is there a function with the type <code>ℕ → (α → α) → α → α</code> that applied the second argument to the third the amount of times given? Also, why does Lean call the induction principle of a given type <code>rec</code>, e.g. <code>nat.rec</code>, I'd expect <code>rec</code> to refer to the given recursor. Does Lean generate the recursor, if so, under which name?</p>



<a name="203150278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150278">(Jul 07 2020 at 19:40)</a>:</h4>
<p>There is, because I was told about it at Xena last Thursday. We ended up making an int one, which took an int and an equiv :-) I only half remember the name -- was it <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate">docs#nat.iterate</a> ?</p>



<a name="203150320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150320">(Jul 07 2020 at 19:41)</a>:</h4>
<p>Aah, it's function.swap applied to nat.iterate :-)</p>



<a name="203150341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150341">(Jul 07 2020 at 19:41)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
</code></pre></div>



<a name="203150359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150359">(Jul 07 2020 at 19:41)</a>:</h4>
<p>i think this is notation for <code>iterate</code></p>



<a name="203150373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150373">(Jul 07 2020 at 19:41)</a>:</h4>
<p>Yes! There is also <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.repeat">docs#nat.repeat</a>, which is also cool.</p>



<a name="203150497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150497">(Jul 07 2020 at 19:42)</a>:</h4>
<p>I don't understand your question about <code>nat.rec</code> though. <code>nat.rec</code> is exactly what I thought computer scientists called the recursor for nat. Because <code>Prop = Sort 0</code>, the recursor can also be used as the induction principle.</p>



<a name="203150558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150558">(Jul 07 2020 at 19:43)</a>:</h4>
<p>It's interesting that <code>nat.iterate</code> has that argument order.  If it were <span class="user-mention" data-user-id="298376">@Pedro Minicz</span>'s, then it would be the map from Lean's naturals to Church-encoded naturals.</p>



<a name="203150601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150601">(Jul 07 2020 at 19:43)</a>:</h4>
<p>A distinction between the recursor and the induction principle is usually made (at least where I've read), Coq and HoTT book do that distinction at least.</p>



<a name="203150665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150665">(Jul 07 2020 at 19:44)</a>:</h4>
<p>But I think they have more elaborate set-ups with Prop.</p>



<a name="203150699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150699">(Jul 07 2020 at 19:44)</a>:</h4>
<p>In book HoTT the recursor is the non-dependent version of the induction principle (and the induction principle is what Lean calls <code>rec</code>).</p>



<a name="203150821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150821">(Jul 07 2020 at 19:45)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">nat</span><span class="bp">.</span><span class="n">rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">C</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span>
</code></pre></div>


<p>I was taught as a mathematician that one defines things by recursion and proves them by induction. Induction is inherently dependent. <code>Sort u</code> is precisely Lean's way of saying "Type or Prop, I don't care".</p>



<a name="203150845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203150845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203150845">(Jul 07 2020 at 19:45)</a>:</h4>
<p>I believe Coq's Prop is about the same as Lean's. In book HoTT there is no impredicative universe, so the distinction between the induction principle and the recursor does not necessarily have to do with <code>Sort</code>.</p>



<a name="203151037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203151037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203151037">(Jul 07 2020 at 19:47)</a>:</h4>
<p>I'd expect Lean to generate a recursor of with the type <code>ℕ → α → (α → α) → α</code> for <code>nat</code>.</p>



<a name="203151065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203151065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203151065">(Jul 07 2020 at 19:47)</a>:</h4>
<p>Which, of course, is just an specialization of <code>nat.rec</code>.</p>



<a name="203151285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203151285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203151285">(Jul 07 2020 at 19:49)</a>:</h4>
<p>Just checked, I was mistaken, Coq does not make such distinction. I guess book HoTT just left an impression on me.</p>



<a name="203151333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203151333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203151333">(Jul 07 2020 at 19:49)</a>:</h4>
<p>It seems to me that <code>nat.rec</code> is one function which covers everything. It would not surprise me at all if there were specialised versions which cover more specialised use cases.</p>



<a name="203194462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203194462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203194462">(Jul 07 2020 at 19:50)</a>:</h4>
<p>I think that when one makes a new inductive type, Lean generates a constant for the type, a constant for each constructor, and then a constant for the recursor (aka the eliminator). An algorithm then generates a bunch of helper functions, but each of these have definitions which depend on these undefined constants.</p>



<a name="203194732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203194732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203194732">(Jul 07 2020 at 19:53)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">mynat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">mynat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="n">mynat</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">mynat</span> <span class="c1">-- about 20 things</span>

<span class="c1">-- these have no definitions</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">mynat</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">zero</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">succ</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">rec</span>

<span class="c1">-- everything else has a definition</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">rec_on</span>
</code></pre></div>


<p>All you need is <code>mynat.rec</code> and then you can make anything else you need by yourself.</p>



<a name="203198433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203198433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203198433">(Jul 07 2020 at 20:25)</a>:</h4>
<p>Indeed. Coq defines a few recursors because of its universes. I mistook the distinction that book HoTT makes for it.</p>



<a name="203198742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203198742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203198742">(Jul 07 2020 at 20:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="298376">Pedro Minicz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Apply.20function.20N.20times/near/203151065">said</a>:</p>
<blockquote>
<p>Which, of course, is just an specialization of <code>nat.rec</code>.</p>
</blockquote>
<p>Working through this to understand it better, it looks like you get <code>nat.repeat</code> with reordered arguments.  That's interesting.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">nat</span><span class="bp">.</span><span class="n">repeat&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>



<a name="203201048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203201048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203201048">(Jul 07 2020 at 20:50)</a>:</h4>
<p>Indeed. If you want to go deeper into lambda calculus you can also compare it to Church encoded natural numbers.</p>



<a name="203201155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/Apply%20function%20N%20times/near/203201155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/Apply.20function.20N.20times.html#203201155">(Jul 07 2020 at 20:51)</a>:</h4>
<p>What is described as the "recursor" on book HoTT is I believe always (almost) equivalent to the Church encoded version of the type.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
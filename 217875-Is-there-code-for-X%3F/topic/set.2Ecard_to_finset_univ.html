---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html">set.card_to_finset_univ</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266439576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266439576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266439576">(Dec 30 2021 at 16:19)</a>:</h4>
<p>I've found I've wanted this lemma before for direct conversion between <code>fintype.card</code> and <code>set.univ.to_finset.card</code>. Does it already exist somewhere? Any reason for it not to exist?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">set.card_to_finset_univ</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset.card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">set.to_finset_univ</span><span class="o">,</span> <span class="n">finset.card_univ</span><span class="o">]</span>
</code></pre></div>
<p>(I ask because it's currently in <a href="https://github.com/leanprover-community/mathlib/pull/5698">#5698</a>.)</p>



<a name="266468941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266468941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266468941">(Dec 31 2021 at 00:14)</a>:</h4>
<p>Not every pair of lemmas chained together is worthy of its own lemma (otherwise this strategy for adding lemmas recurses forever!). When do you need this combination?</p>



<a name="266470932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266470932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266470932">(Dec 31 2021 at 00:55)</a>:</h4>
<p>Yeah, that's the motivation for asking about this. It would be a counterpart to <a href="https://leanprover-community.github.io/mathlib_docs/find/set.to_finset_card">docs#set.to_finset_card</a> for <code>set.univ</code>, and you can use these two lemmas in reverse to turn all the <code>fintype.card</code>s in an expression into <code>to_finset.card</code>, which then you manipulate using the <code>set.finite</code> module.</p>
<p>It's not essential to have this shortcut lemma, but I usually forget which pair of lemmas are needed to do the transformation.</p>



<a name="266504096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266504096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266504096">(Dec 31 2021 at 13:40)</a>:</h4>
<p>Can this be <code>simp</code>? If so that would be a good reason to have it.</p>



<a name="266504268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266504268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266504268">(Dec 31 2021 at 13:44)</a>:</h4>
<p>I wonder if there's a reason <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_univ">docs#finset.card_univ</a> isn't a <code>simp</code> lemma already.</p>



<a name="266504410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266504410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266504410">(Dec 31 2021 at 13:47)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/7230">#7230</a></p>



<a name="266506762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266506762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266506762">(Dec 31 2021 at 14:38)</a>:</h4>
<p>I think that might be worth reviving</p>



<a name="266508818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266508818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266508818">(Dec 31 2021 at 15:18)</a>:</h4>
<p>Maybe if you're mostly dealing with fintype.card then you want it as a simp lemma and if you're mostly dealing with finset.card then you don't. This sort of thing can happen, right? For example when making an API for the complex numbers you really want <code>complex.ext_iff</code> as a <code>simp</code> lemma because when checking the axioms to show C is a ring you want to prove all equalities by equating real and imaginary parts and then using <code>ring</code> for the corresponding real equations. But in general when working with complex numbers as more conceptual objects e.g. when doing complex analysis you probably don't want this.</p>



<a name="266524332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266524332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266524332">(Dec 31 2021 at 21:16)</a>:</h4>
<p>It's still running through CI, but I've made a PR (<a href="https://github.com/leanprover-community/mathlib/pull/11174">#11174</a>) that addresses what is probably the underlying issue that made we want <code>set.card_to_finset_univ</code>, which is that <code>set.to_finset_univ</code> does not have fully general <code>fintype</code> arguments.</p>



<a name="266524344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266524344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266524344">(Dec 31 2021 at 21:17)</a>:</h4>
<p>(A way I've used things like <code>set.card_to_finset_univ</code> in the past is to close goals by <code>convert</code>.)</p>



<a name="266524511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266524511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266524511">(Dec 31 2021 at 21:22)</a>:</h4>
<p>It still doesn't seem like it's properly general -- it would be nice if a lemma could take implicit arguments that are elaborated as typeclass arguments if they don't end up being solved for via unification.</p>
<p>To do things "right" without that, it seems like we need variants of each lemma where instances for the left-hand side of an expression come from implicit arguments, and instances on the right-hand side come from typeclasses. That way when rewriting the left-hand side has greater freedom to match, but the right-hand side still is able to use typeclass search to fill in instances that the implicit argument system can't determine.</p>



<a name="266595410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266595410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266595410">(Jan 02 2022 at 05:17)</a>:</h4>
<p>To illustrate the issue that <a href="https://github.com/leanprover-community/mathlib/pull/11174">#11174</a> is solving more clearly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">[</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="c1">-- fails</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span> <span class="n">set.to_finset_univ</span> <span class="c1">--fails</span>
<span class="c1">-- `set.univ.to_finset = finset.univ` and `set.univ.to_finset = finset.univ` have different types</span>
<span class="c1">-- due to different instance arguments.</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">convert</span> <span class="n">set.to_finset_univ</span> <span class="c1">-- OK</span>

<span class="c1">-- New lemma:</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.to_finset_univ'</span> <span class="o">{</span><span class="n">hu</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">hu</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">set.mem_to_finset</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="c1">-- OK</span>
</code></pre></div>



<a name="266595519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266595519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266595519">(Jan 02 2022 at 05:20)</a>:</h4>
<p>The PR leaves the original version of <a href="https://leanprover-community.github.io/mathlib_docs/find/set.to_finset_univ">docs#set.to_finset_univ</a> because it's still useful if you want to <code>rw ← set.to_finset_univ</code>, since it will synthesize the <code>fintype set.univ</code> instance.</p>



<a name="266604999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266604999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266604999">(Jan 02 2022 at 09:37)</a>:</h4>
<p>What's the conflicting pair of instances?</p>



<a name="266614654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266614654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266614654">(Jan 02 2022 at 13:37)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> <code>subtype.fintype</code> and <code>set.fintype_univ</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">set.to_finset_univ</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="bp">?</span><span class="n">m_1</span> <span class="n">a</span><span class="o">)</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span> <span class="bp">=</span>
    <span class="bp">@</span><span class="n">finset.univ</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">?</span><span class="n">m_2</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.fintype_univ</span> <span class="n">α</span> <span class="n">hα</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">finset.univ</span> <span class="n">α</span> <span class="n">hα</span>
</code></pre></div>



<a name="266614918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266614918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266614918">(Jan 02 2022 at 13:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/set.fintype_univ/src">src#set.fintype_univ</a></p>



<a name="266614985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266614985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266614985">(Jan 02 2022 at 13:46)</a>:</h4>
<p>That instance seems pointless if the other one matches it</p>



<a name="266615276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266615276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266615276">(Jan 02 2022 at 13:54)</a>:</h4>
<p>Also, I believe I've misunderstood how <code>simp</code> interacts with instance arguments. It seems to already treat them as implicit arguments first? Otherwise, these examples wouldn't all work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.to_finset_univ'</span> <span class="o">[</span><span class="n">hu</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">hu</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">set.mem_to_finset</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">subtype.fintype</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">set.fintype_univ</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">)</span>  <span class="o">:</span>
  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">hu</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">finset.univ</span> <span class="n">_</span> <span class="n">hα</span><span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">subtype.fintype</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">finset.univ.card</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">set.fintype_univ</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">finset.univ.card</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">)</span>  <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="n">hu</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset.univ</span> <span class="n">_</span> <span class="n">hα</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</code></pre></div>



<a name="266670695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266670695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266670695">(Jan 03 2022 at 10:22)</a>:</h4>
<p>Indeed, after matching with the goal, <code>simp</code> processes arguments to its lemmas left-to-right, if the value of the argument derives from the unification it uses that, otherwise it will use typeclass inference, or if it's a <code>Prop</code>, recursively call <code>simp</code> on that argument. (Notably, this means <code>out_param</code>s of instances do not get inferred correctly by <code>simp</code>.)</p>



<a name="266671043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266671043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266671043">(Jan 03 2022 at 10:26)</a>:</h4>
<p>Does any of the interesting discussion above deserve being added to this page: <a href="https://leanprover-community.github.io/extras/simp.html">https://leanprover-community.github.io/extras/simp.html</a> ?</p>



<a name="266672053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266672053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266672053">(Jan 03 2022 at 10:38)</a>:</h4>
<p>I'm hoping to fix the <code>out_param</code> issue soon, so let's wait a bit before we do so :)</p>



<a name="266836489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266836489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266836489">(Jan 04 2022 at 17:14)</a>:</h4>
<p>There seems to be an elaboration bug with this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.to_finset_univ</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">mem_univ</span><span class="o">,</span> <span class="n">set.mem_to_finset</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>
<p>Here's the full error using <code>set_option pp.implicit true</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">1303</span><span class="o">:</span><span class="mi">35</span><span class="o">:</span> <span class="n">kernel</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">type</span> <span class="n">check</span> <span class="n">declaration</span> <span class="bp">'</span><span class="n">set.to_finset_univ'</span> <span class="n">this</span> <span class="n">is</span> <span class="n">usually</span> <span class="n">due</span> <span class="n">to</span> <span class="n">a</span> <span class="n">buggy</span> <span class="n">tactic</span> <span class="n">or</span> <span class="n">a</span> <span class="n">bug</span> <span class="k">in</span> <span class="n">the</span> <span class="n">builtin</span> <span class="n">elaborator</span>
<span class="n">elaborated</span> <span class="n">type</span><span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">],</span>
    <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="n">α</span> <span class="n">a</span><span class="o">)</span> <span class="n">_inst_2</span><span class="o">)</span> <span class="bp">=</span>
      <span class="bp">@</span><span class="n">univ</span> <span class="n">α</span> <span class="n">_inst_2</span>
<span class="n">elaborated</span> <span class="n">value</span><span class="o">:</span>
  <span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">],</span>
    <span class="bp">@</span><span class="n">ext</span> <span class="n">α</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
         <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="n">α</span> <span class="n">a</span><span class="o">)</span> <span class="n">_inst_2</span><span class="o">))</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">univ</span> <span class="n">α</span> <span class="n">_inst_2</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
         <span class="o">(</span><span class="bp">@</span><span class="n">id</span>
            <span class="o">((</span><span class="n">a</span> <span class="bp">∈</span>
                    <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
                      <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="n">α</span> <span class="n">a</span><span class="o">)</span>
                         <span class="n">_inst_2</span><span class="o">)</span> <span class="bp">↔</span>
                  <span class="n">a</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">univ</span> <span class="n">α</span> <span class="n">_inst_2</span><span class="o">)</span> <span class="bp">=</span>
               <span class="o">(</span><span class="n">true</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">))</span>
            <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a_1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">b_1</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">e_2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b_1</span><span class="o">),</span>
                <span class="bp">@</span><span class="n">congr</span> <span class="kt">Prop</span> <span class="kt">Prop</span> <span class="o">(</span><span class="n">iff</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">iff</span> <span class="n">a_1</span><span class="o">)</span> <span class="n">b</span> <span class="n">b_1</span> <span class="o">(</span><span class="bp">@</span><span class="n">congr_arg</span> <span class="kt">Prop</span> <span class="o">(</span><span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">a</span> <span class="n">a_1</span> <span class="n">iff</span> <span class="n">e_1</span><span class="o">)</span> <span class="n">e_2</span><span class="o">)</span>
               <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span>
                  <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="n">α</span> <span class="n">a</span><span class="o">)</span>
                       <span class="n">_inst_2</span><span class="o">))</span>
               <span class="n">true</span>
               <span class="o">((</span><span class="bp">@</span><span class="n">propext</span>
                   <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span>
                      <span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
                        <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="n">α</span> <span class="n">a</span><span class="o">)</span>
                           <span class="n">_inst_2</span><span class="o">))</span>
                   <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
                   <span class="o">(</span><span class="bp">@</span><span class="n">set.mem_to_finset</span> <span class="n">α</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
                      <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">set.univ_decidable</span> <span class="n">α</span> <span class="n">a</span><span class="o">)</span>
                         <span class="n">_inst_2</span><span class="o">)</span>
                      <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span>
                  <span class="o">(</span><span class="bp">@</span><span class="n">propext</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="n">true</span>
                     <span class="o">(</span><span class="bp">@</span><span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">@</span><span class="n">iff_true_intro</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.mem_univ</span> <span class="n">α</span> <span class="n">x</span><span class="o">))</span> <span class="n">α</span> <span class="n">a</span><span class="o">)))</span>
               <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">univ</span> <span class="n">α</span> <span class="n">_inst_2</span><span class="o">)</span>
               <span class="n">true</span>
               <span class="o">(</span><span class="bp">@</span><span class="n">propext</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">univ</span> <span class="n">α</span> <span class="n">_inst_2</span><span class="o">)</span> <span class="n">true</span>
                  <span class="o">(</span><span class="bp">@</span><span class="o">(</span><span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span>
                      <span class="bp">@</span><span class="n">iff_true_intro</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="bp">@</span><span class="n">univ</span> <span class="n">α</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">mem_univ</span> <span class="n">α</span> <span class="n">_inst_1</span> <span class="n">x</span><span class="o">))</span>
                     <span class="n">α</span>
                     <span class="n">_inst_2</span>
                     <span class="n">a</span><span class="o">))))</span><span class="bp">.</span><span class="n">mpr</span>
           <span class="o">(</span><span class="n">iff.refl</span> <span class="n">true</span><span class="o">))</span>
<span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
<span class="n">term</span>
  <span class="bp">↥</span><span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">α</span><span class="o">)</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u_2</span>
</code></pre></div>



<a name="266836553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266836553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266836553">(Jan 04 2022 at 17:14)</a>:</h4>
<p>I'm not sure whether I'd expect it or not, but it also chooses the <code>subtype.fintype</code> instance for <code>set.to_finset</code> rather than the one given as an argument.</p>



<a name="266845564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266845564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266845564">(Jan 04 2022 at 18:28)</a>:</h4>
<p>You need to add a coe_sort arrow I think</p>



<a name="266850863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266850863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266850863">(Jan 04 2022 at 19:17)</a>:</h4>
<p>That does fix it here, but what's going on exactly? The error message shows that Lean's inserting the <code>coe_sort</code> automatically -- my only guess is that somehow it causes the elaborator to fail to unify some universe (meta)variables, so when metavariables are replaced by variables, once the kernel gets ahold of it they're accidentally different.</p>
<p>I think this explains also why typeclass inference isn't picking up on the instance, since it seems to be <code>fintype.{u_2} (↥(@set.univ α) : Type u_1)</code>.</p>



<a name="266850908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266850908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266850908">(Jan 04 2022 at 19:18)</a>:</h4>
<p>Indeed, explicit universes fixes it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.to_finset_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">[</span><span class="n">fintype.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">((</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">mem_univ</span><span class="o">,</span> <span class="n">set.mem_to_finset</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>
<p><em>Edit:</em> Hmm, even this is enough to get it to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.to_finset_univ</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="o">((</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">mem_univ</span><span class="o">,</span> <span class="n">set.mem_to_finset</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="266854435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266854435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266854435">(Jan 04 2022 at 19:51)</a>:</h4>
<p>But this does fix it, too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">set.to_finset_univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">[</span><span class="n">fintype.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">mem_univ</span><span class="o">,</span> <span class="n">set.mem_to_finset</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="266873447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266873447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266873447">(Jan 04 2022 at 22:30)</a>:</h4>
<p>Anyway, assuming this is a bug, <a href="https://github.com/leanprover-community/mathlib/pull/11247">#11247</a> puts the lemma into this last form while adding a TODO.</p>



<a name="266873513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266873513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266873513">(Jan 04 2022 at 22:31)</a>:</h4>
<p>Does it seem like a bug? Should I submit a lean issue?</p>
<p>Here's a mathlib-free mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}⟩</span>

<span class="c1">-- OK</span>
<span class="kd">lemma</span> <span class="n">ex1</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="c1">-- Not OK</span>
<span class="kd">lemma</span> <span class="n">ex2</span> <span class="o">[</span><span class="n">inhabited</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">kernel failed to type check declaration 'ex2' this is usually due to a buggy tactic or a bug in the builtin elaborator</span>
<span class="cm">elaborated type:</span>
<span class="cm">  ∀ {α : Type u} [_inst_1 : inhabited ↥set.univ], true</span>
<span class="cm">elaborated value:</span>
<span class="cm">  λ {α : Type u} [_inst_1 : inhabited ↥set.univ], trivial</span>
<span class="cm">nested exception message:</span>
<span class="cm">type mismatch at application</span>
<span class="cm">  inhabited ↥set.univ</span>
<span class="cm">term</span>
<span class="cm">  ↥set.univ</span>
<span class="cm">has type</span>
<span class="cm">  Type u</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  Sort u_1</span>
<span class="cm">-/</span>

<span class="c1">-- OK</span>
<span class="kd">lemma</span> <span class="n">ex3</span> <span class="o">[</span><span class="n">inhabited.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="c1">-- OK</span>
<span class="kd">lemma</span> <span class="n">ex4</span> <span class="o">[</span><span class="n">inhabited</span> <span class="bp">↥</span><span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)]</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="c1">-- OK</span>
<span class="kd">lemma</span> <span class="n">ex5</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>
</code></pre></div>



<a name="266874384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266874384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266874384">(Jan 04 2022 at 22:40)</a>:</h4>
<p>This definitely seems like an elaborator bug.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>fails,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>works</p>



<a name="266877746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266877746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266877746">(Jan 04 2022 at 23:17)</a>:</h4>
<p>Definitely open a lean issue, because then you can reference it from a comment.</p>



<a name="266879951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/set.card_to_finset_univ/near/266879951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/set.2Ecard_to_finset_univ.html#266879951">(Jan 04 2022 at 23:43)</a>:</h4>
<p>I wonder if it's the same underlying issue as <a href="https://github.com/leanprover-community/lean/pull/474">lean#474</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
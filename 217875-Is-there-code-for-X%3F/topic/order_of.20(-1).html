---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html">order_of (-1)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262529841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262529841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262529841">(Nov 23 2021 at 23:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">one_eq_neg_iff</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">not_iff_not</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">hr</span> <span class="n">h1</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h1</span> <span class="n">hr</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">sub_eq_zero</span><span class="o">,</span> <span class="n">sub_neg_eq_add</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">ring_char</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">eq_zero_or_pos</span> <span class="k">with</span> <span class="n">hrc</span> <span class="n">hrc</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">ring_char.eq_iff.mp</span> <span class="n">hrc</span><span class="o">,</span>
      <span class="n">haveI</span> <span class="o">:=</span> <span class="n">char_p.char_p_to_char_zero</span> <span class="n">R</span><span class="o">,</span>
      <span class="n">apply</span> <span class="bp">@</span><span class="n">two_ne_zero'</span> <span class="n">R</span><span class="o">,</span>
      <span class="n">exact_mod_cast</span> <span class="n">h1</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="k">show</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="kd">by</span> <span class="n">norm_cast</span><span class="o">,</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">nat.le_of_dvd</span> <span class="n">zero_lt_two</span> <span class="o">(</span><span class="n">ring_char.dvd</span> <span class="n">h1</span><span class="o">),</span>
    <span class="n">interval_cases</span> <span class="o">(</span><span class="n">ring_char</span> <span class="n">R</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">char_p.ring_char_ne_one</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hr</span> <span class="n">h</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">sub_eq_zero</span><span class="o">,</span> <span class="n">sub_neg_eq_add</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="kd">by</span> <span class="n">norm_cast</span><span class="o">]</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ring_char.spec</span> <span class="n">R</span><span class="o">,</span> <span class="n">hr</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">fact_prime_two</span> <span class="o">:=</span> <span class="n">fact.mk</span> <span class="n">nat.prime_two</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">order_of_neg_one</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">order_of</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">ring_char</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">one_eq_neg_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">order_of_eq_prime</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">one_eq_neg_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span>
<span class="kd">end</span>
</code></pre></div>
<p>this cannot be the best way of doing this?!? do we have any of these results somewhere?</p>



<a name="262532112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262532112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262532112">(Nov 24 2021 at 00:11)</a>:</h4>
<p>I think that first lemma is much easier than you have</p>



<a name="262532117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262532117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262532117">(Nov 24 2021 at 00:11)</a>:</h4>
<p>I think Eric Wieser had the first lemma over arbitrary x, for the mp direction</p>



<a name="262532121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262532121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262532121">(Nov 24 2021 at 00:11)</a>:</h4>
<p>I have a bunch of lemmas about characteristic 2 I should PR</p>



<a name="262532130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262532130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262532130">(Nov 24 2021 at 00:11)</a>:</h4>
<p>Ah didn't even tag him!</p>



<a name="262532191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262532191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262532191">(Nov 24 2021 at 00:12)</a>:</h4>
<p>From <a href="https://github.com/pygae/lean-ga/blob/68f3e4214dc0e13519170aad7c9aa691589149e3/src/geometric_algebra/from_mathlib/mathoverflow.lean#L167">https://github.com/pygae/lean-ga/blob/68f3e4214dc0e13519170aad7c9aa691589149e3/src/geometric_algebra/from_mathlib/mathoverflow.lean#L167</a> there are a handful</p>



<a name="262532440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262532440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262532440">(Nov 24 2021 at 00:16)</a>:</h4>
<p>Sorry, I meant <a href="https://github.com/eric-wieser/lean-ga/blob/bab185bad6c35b350678a58cb9ee55339a4927f7/src/geometric_algebra/from_mathlib/mathoverflow.lean#L165">https://github.com/eric-wieser/lean-ga/blob/bab185bad6c35b350678a58cb9ee55339a4927f7/src/geometric_algebra/from_mathlib/mathoverflow.lean#L165</a></p>



<a name="262533178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262533178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262533178">(Nov 24 2021 at 00:29)</a>:</h4>
<p>mind if I PR them at some point? it was honestly a painful hour working with charp...</p>



<a name="262535504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262535504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262535504">(Nov 24 2021 at 01:05)</a>:</h4>
<p><del>#60852</del> <a href="https://github.com/leanprover-community/mathlib/issues/10441">#10441</a></p>



<a name="262536078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262536078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262536078">(Nov 24 2021 at 01:14)</a>:</h4>
<p>When you PR the <code>iff</code> versions later, you can use them to clean up <a href="https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.neg_one">docs#is_primitive_root.neg_one</a></p>



<a name="262536092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262536092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262536092">(Nov 24 2021 at 01:14)</a>:</h4>
<p>Which seems to be the only lemma that mentions characteristic two</p>



<a name="262572293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262572293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262572293">(Nov 24 2021 at 10:51)</a>:</h4>
<p>I added some machinery that makes <code>order_of</code> basically equivalent to <code>is_primitive_root</code>, so it should be super easy actually</p>



<a name="262572305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262572305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262572305">(Nov 24 2021 at 10:51)</a>:</h4>
<p>I'm somewhat confused why they weren't unified earlier</p>



<a name="262574211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262574211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262574211">(Nov 24 2021 at 11:08)</a>:</h4>
<p>It's probably only a psychological thing: even if I know that <code>z : C</code> is a primitive <code>n</code>-th root of unity if and only if its multiplicative order is <code>n</code>, in my mental image primitive roots is a ring related notion</p>



<a name="262574399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262574399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262574399">(Nov 24 2021 at 11:10)</a>:</h4>
<p>Because we want to be able to say that <code>r : R</code> is a (primitive) root of unity, without knowing a priori that <code>r</code> is a unit</p>



<a name="262673415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262673415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262673415">(Nov 25 2021 at 07:23)</a>:</h4>
<p>But can't you say that? Since a refactor some months ago, <code>order_of</code> doesn't require to be in a group, so you can just express it as <code>order_of r</code> in the multiplicative group of <code>R</code> being positive without talking about <code>units R</code>.</p>



<a name="262674996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/order_of%20%28-1%29/near/262674996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/order_of.20(-1).html#262674996">(Nov 25 2021 at 07:51)</a>:</h4>
<p>Yes, this does currently work just fine</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>